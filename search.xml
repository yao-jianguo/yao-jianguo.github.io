<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>详解动态规划, 此一篇足以！</title>
    <url>/posts/5faf7bc2/</url>
    <content><![CDATA[<img src="/images/b046fbe0f5ceead771b5ceeeaf5f7eed1.jpg" width="50%" height="50%">

<p><em>六个案例由浅入深把动态规划说明白！！！</em></p>
<a id="more"></a>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，先大致列下这篇文章会讲到什么</span><br><span class="line">    1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</span><br><span class="line">    2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</span><br><span class="line">一、动态规划带给我们的优势</span><br><span class="line">传统递归 vs. DP</span><br><span class="line">    1. 先 递归解决</span><br><span class="line">    2. 后 动态规划解决</span><br><span class="line">    3. 动态规划 + 优化</span><br><span class="line">二、动态规划四大解题步骤处理问题</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：定义状态转移方程</span><br><span class="line">    步骤三：初始化过程转移的初始值</span><br><span class="line">    步骤四：可优化点(可选)</span><br><span class="line">案例一：打家劫舍I 「来自leetcode198」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例二：不同路径「来自leetcode62」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例三：不同路径II 「来自leetcode63」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例四：打家劫舍II 「来自leetcode213」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例五：打家劫舍III 「来自leetcode337」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划 - 超详细系列</p>
<p>该文章较长，比较详细的阐述了动态规划思想，请耐心跟着思路走下去</p>
</blockquote>
<h2 id="动态规划-超详细系列"><a href="#动态规划-超详细系列" class="headerlink" title="动态规划 - 超详细系列"></a>动态规划 - 超详细系列</h2><p><strong>动态规划</strong>，一直以来听着就是一种很高深莫测的算法思想。尤其是上学时候算法的第一堂课，老师巴拉巴拉列了一大堆的算法核心思想，<strong>贪心、回溯、动态规划</strong>… …，开始感觉要在算法世界里游刃有余的进行解决各种各样牛B问题了，没想到的还是稀里糊涂学过了之后还就真的是学过了（大学的课程还真是一个样子）。再后来才明白，大学的课程一般来说就是入门级讲解，用来开拓眼界的，真正想要有一番自己的见解，必须要在背后下一番辛苦，形成自己的<strong>思考逻辑</strong>。</p>
<p>再后来返回头来看，<strong>动态规划</strong>理解起来还是比较困难，什么<strong>重叠子问题、动态转移方程，优化点</strong>等等等等，稀里糊涂，最后痛定思痛，好好看着其他人的分享理解了一部分，疯狂刷题几十道。算是基本可以佛挡杀佛了.</p>
<p>在我的这些学习积累过程中，总结出来希望可以给到大家一点小小的帮助，相信在读完这篇文章的时候，你会感觉到<strong>动态规划</strong>给你带来的奇妙之处。也一定对<strong>动态规划</strong>形成自己的<strong>思考方式</strong>.     很🐂的DP！！！</p>
<h2 id="首先，先大致列下这篇文章会讲到什么"><a href="#首先，先大致列下这篇文章会讲到什么" class="headerlink" title="首先，先大致列下这篇文章会讲到什么"></a>首先，先大致列下这篇文章会讲到什么</h2><h4 id="1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的"><a href="#1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的" class="headerlink" title="1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?"></a>1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</h4><h4 id="2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次"><a href="#2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次" class="headerlink" title="2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次."></a>2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</h4><p>看完本篇文章后，相信大家会对DP问题会有一个初步的思考，一定会入门。后面大家可以继续练习相关问题，熟能生巧，思考的多了就会形成自己的思维逻辑.</p>
<p>好了，话不多说，开搞…</p>
<h2 id="一、动态规划带给我们的优势"><a href="#一、动态规划带给我们的优势" class="headerlink" title="一、动态规划带给我们的优势"></a>一、动态规划带给我们的优势</h2><p><strong>很有趣，一定要看完，必定有收获，加油！💪💪💪</strong></p>
<p>平时在我们算法设计的过程中，一般讲求的是算法的执行效率和空间效率的利用情况</p>
<p>也就是我们熟知的<strong>时间复杂度</strong>（执行时耗费时间的长度）和<strong>空间复杂度</strong>（执行时占用存储单元的长度）</p>
<p>那下面用<strong>时间复杂度和空间复杂度</strong>来评估下<strong>传统算法设计</strong>和用<strong>动态规划思想</strong>解决下的效率情况</p>
<h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p>
<p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p>
<p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p>
<p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p>
<p>接下来咱们先来看题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure>


<p>比较一下传统递归解法和动态规划思想下的解决对比</p>
<h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_recur</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;F(&quot;</span>,self.i,<span class="string">&quot;) = &quot;</span>, N   <span class="comment"># 此处仅仅来看递归输出的N</span></span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">return</span> self.fib_recur(N-<span class="number">1</span>) + self.fib_recur(N-<span class="number">2</span>)  <span class="comment"># 递归输出</span></span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F( <span class="number">0</span> ) =  <span class="number">4</span></span><br><span class="line">F( <span class="number">1</span> ) =  <span class="number">3</span></span><br><span class="line">F( <span class="number">2</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">3</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">4</span> ) =  <span class="number">0</span></span><br><span class="line">F( <span class="number">5</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">6</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">7</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">8</span> ) =  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>重复计算</strong></p>
<p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p>
<p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p>
<p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p>
<blockquote>
<p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p>
<p>注意：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p>
</blockquote>
<img src="/images/20521cf21f76b9359a5c9dbbeda106361.jpg" width="50%" height="50%">

<p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗. </p>
<p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p>
<p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效. </p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106362.jpg" width="50%" height="50%">

<blockquote>
<p>时间复杂度：$O(2^N)$   —&gt; 指数级</p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p>
<p><strong>动态规划：</strong>我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用<strong>过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p>
<p><strong>规划：</strong>在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的<strong>一维表格</strong>还是复杂一点的<strong>二维表格</strong>，都是以<strong>开辟空间换时间</strong>的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p>
<p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p>
<p>因此，动态规划可以避免重复计算，达到了时间上的最优，从$O(2^N)$指数级变为$O(N)$常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p>
<p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p>
<p>依据题中的规则：</p>
<p>F(0) = 0, F(1) = 1</p>
<p>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</p>
<p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1<br>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   –&gt;  保存 F(2)<br>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   –&gt;  保存 F(3)<br>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   –&gt;  保存 F(4)</p>
<p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106363.jpg" width="50%" height="50%">

<p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p>
<p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p>
<p>​    a. <strong>定义一个一维数组</strong>   —&gt;  一般用dp来命名</p>
<p>​    b. <strong>动态方程的设定</strong>   —&gt;  题中的F(N) = F(N - 1) + F(N - 2)</p>
<p>​    c. <strong>初始化数值</strong>   —&gt;  F(0) = 0和F(1) = 1</p>
<p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p>
<p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 1定义dp[i]保存第i个计算得到的数值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>       <span class="comment"># 2初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>            <span class="comment"># 2初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):    <span class="comment"># 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span> dp         <span class="comment"># 记录计算过程中的次数，与上述递归形成对比</span></span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p>
<blockquote>
<p>时间复杂度：$O(N)$ </p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong> </p>
<hr>
<p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p>
<h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106364.jpg" width="50%" height="50%">

<p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106365.jpg" width="50%" height="50%">
b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   -->  保存 F(2)

<p>​    顺带将F(1)赋值给dp1， f(2)赋值给dp2</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106366.jpg" width="50%" height="50%">

<p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   –&gt;  保存 F(3)</p>
<p>​    顺带将F(2)赋值给dp1， F(3)赋值给dp2</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106367.jpg" width="50%" height="50%">

<p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   –&gt;  保存 F(4)</p>
<p>​    顺带将F(3)赋值给dp1， F(4)赋值给dp2</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda106368.jpg" width="50%" height="50%">

<p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p>
<p>咱们把代码也贴一下吧，供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_dp1</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<p>看起来是不是更加简洁了。</p>
<p>洋洋洒洒不知不觉写了这么多了。</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<p>大家感觉这个例子怎么样，三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p>
<p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p>
<p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜<br><img src="/images/20521cf21f76b9359a5c9dbbeda106369.jpg" width="50%" height="50%"></p>
<blockquote>
<p>到这里有没有一种对动态规划的感觉了</p>
<p>文章较长，可以先关注或者收藏，也可以关注「计算广告生态」，回复“DP”获取本文pdf文件哦</p>
</blockquote>
<h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p>
<p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p>
<blockquote>
<p>步骤一：定义dp数组的含义</p>
<p>步骤二：定义状态转移方程</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>步骤四：可优化点(可选)</p>
</blockquote>
<h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p>
<p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p>
<h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p>
<p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p>
<h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p>
<p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p>
<p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p>
<h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p>
<p>在例子中，我们会进行不同的优化. </p>
<p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了. </p>
<h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>


<p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p>
<p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。  然后严格按照四步骤进行解题. </p>
<h5 id="步骤一：-定义dp数组的含义"><a href="#步骤一：-定义dp数组的含义" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p>
<p>​    <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p>
<p>​    也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p>
<p>​    该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p>
<p>​    a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] =  nums[i-1] + dp[i-2]</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063610.jpg" width="50%" height="50%">

<p>​    b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] =  dp[i-1]</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063611.jpg" width="50%" height="50%">

<p>​    最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p>
<p>​    <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p>
<h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        1 当size=0时，没有房子，dp[0]=0；<br>​        2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p>
<p>那么，按照这个思路来整理一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">      <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">      <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span></span><br><span class="line">      <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">      <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">      <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line">      size = <span class="built_in">len</span>(nums)</span><br><span class="line">      <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
</blockquote>
<p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p>
<h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p>
<p>​    所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob_o</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span></span><br><span class="line">        <span class="comment"># 因此，我们可以使用两个变量来存放前两个状态值</span></span><br><span class="line">        <span class="comment"># 空间使用由O(N) -&gt; O(1)</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        dp2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p>
<p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063612.jpg" width="50%" height="50%">

<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><em>提示：</em></p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>下面依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>​    当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p>
<p>​    <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p>
<p>​    即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p>
<h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p>
<p>​    那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p>
<p>​    <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p>
<h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p>
<p>​    因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p>
<p>​    因此初始值如下：</p>
<p>​    <strong>dp[0] [0….n-1] = 1;</strong>  // 机器人一直向右走，第 0 列统统为 1</p>
<p>​    <strong>dp[0…m-1] [0] = 1;</strong>  // 机器人一直向下走，第 0 列统统为 1</p>
<p>​    现在，按照这个思路来整理一下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths1</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码中由于dp[0..m][1] 或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p>
<p>然后从位置(1, 1)开始计算每个位置的总路径数</p>
<blockquote>
<p>时间复杂度：O(M*N)</p>
<p>空间复杂度：O(M*N)</p>
</blockquote>
<p>既然到这里了，下面再想想看有没有可优化的地方</p>
<h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p>
<p>​    参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p>
<p>​    现在这个例子中的动态方程是*<em>dp[i][j] = dp[i-1][j] + dp[i][j-1]**，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3</em>4 来举例）：</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063613.jpg" width="50%" height="50%">

<p>​    这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p>
<p>​    因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p>
<p>​    看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p>
<p>​    <strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。 其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p>
<p>​    <strong>这块大家一定多想想，多理解，多画图</strong></p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063614.jpg" width="50%" height="50%">



<p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063615.jpg" width="50%" height="50%">

<p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p>
<p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths2</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(min(m ,n))</p>
</blockquote>
<p>是不是从思维方面简单干净了许多</p>
<p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p>
<p>来看:</p>
<h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063616.jpg" width="50%" height="50%">

<blockquote>
<p>说明：m 和 n 的值均不超过 100。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>


<p><strong>咱们先看一下题中的两个关键点：</strong><br>关键点1：只能向右或者向下<br>关键点2：有障碍物为1， 无障碍物为0</p>
<p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>  这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间<br>  那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p>
<h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>  参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]<br>  由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件<br>  a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程<br>  b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p>
<p>  所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p>
<h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法<br>​    但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063617.jpg" width="50%" height="50%">

<p>​    所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p>
<p>​    <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p>
<p>​    只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 行初始化表达式: </span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0 列初始化表达式: </span></span><br><span class="line">obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<p>  这些都准备就绪之后，按照相关思路进行编码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles1</span>(<span class="params">self, obstacleGrid</span>):</span></span><br><span class="line">          <span class="comment"># 行列长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果在位置(0, 0)，哪里都去不了，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，位置(0, 0)可以到达</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 列</span></span><br><span class="line">        <span class="keyword">for</span> clo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从位置(1, 1)根据动态方程开始计算</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度: O(mxn)</p>
<p>空间复杂度: O(1)</p>
</blockquote>
<h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p>
<p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p>
<p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p>
<h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>


<p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p>
<p>a. 不偷首偷尾</p>
<p>b. 偷首不偷尾</p>
<p>c. 首位都不偷<br>显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。<br>那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p>
<p>下面依然按照之前的四个步骤来进行分析</p>
<h5 id="步骤一：-定义dp数组的含义-1"><a href="#步骤一：-定义dp数组的含义-1" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p>
<p>​    所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p>
<p>#####步骤二：找出关系元素间的动态方程</p>
<p>​    动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p>
<p>​    <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p>
<h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；<br>​        b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p>
<img src="/images/20521cf21f76b9359a5c9dbbeda1063618.jpg" width="50%" height="50%">

<p>​    由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p>
<p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p>
<h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p>
<p>​    代码中有详细的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 点睛：与打家劫舍I的区别是屋子围成了一个环</span></span><br><span class="line">        <span class="comment">#   那么，很明显可以分为三种情况：</span></span><br><span class="line">        <span class="comment">#   1. 首位都不偷</span></span><br><span class="line">        <span class="comment">#   2. 偷首不偷尾</span></span><br><span class="line">        <span class="comment">#   3. 不偷首偷尾</span></span><br><span class="line">        <span class="comment"># 显然，第1种方式损失太大，选取2、3。</span></span><br><span class="line">        <span class="comment"># 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">        <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])</span></span><br><span class="line">        <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">        <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">        <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依照《打家劫舍I》的优化方案进行计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># nums处理，分别切割出去首和去尾的子串</span></span><br><span class="line">        nums1 = nums[<span class="number">1</span>:]</span><br><span class="line">        nums2 = nums[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">size, nums</span>):</span></span><br><span class="line">            dp1 = <span class="number">0</span></span><br><span class="line">            dp2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">                dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">                dp1, dp2 = dp2, dp1</span><br><span class="line">            <span class="keyword">return</span> dp2</span><br><span class="line"></span><br><span class="line">        res1 = handle(size-<span class="number">1</span>, nums1)</span><br><span class="line">        res2 = handle(size-<span class="number">1</span>, nums2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p>
<h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9.</span></span><br></pre></td></tr></table></figure>
<p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p>
<p>言归正传，咱们先来说说题目本身</p>
<p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p>
<p>来整理几点思路，再来按照四步走：</p>
<p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)<br>2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历<br>3.得到每一节点的最优值，最后选取最优的结果</p>
<p>依然按照三个步骤来进行分析（无优化点）</p>
<h5 id="步骤一：-定义dp数组的含义-2"><a href="#步骤一：-定义dp数组的含义-2" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p>
<h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 **不偷(0)**。我们分开来讨论：</p>
<p>​    a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p>
<p>​        所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p>
<p>​    b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p>
<p>​        所以：<strong>dp[1] = value + left[0] + right[0]</strong>  (value代表该节点的价值)</p>
<p>​    有看不懂的地方吗？再紧接着解释一下：</p>
<p>​        left[0]代表不偷取左孩子拿到最高的金额</p>
<p>​        left[1]代表偷取左孩子拿到最高的金额</p>
<p>​        right[0]代表不偷取右孩子拿到最高的金额</p>
<p>​        right[1]代表偷取右孩子拿到最高的金额</p>
<p>​    <em>如果还有不太懂的话，留言或者私信我联系我，随时骚扰我哈</em></p>
<h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p>
<p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 说明：</span></span><br><span class="line">        <span class="comment"># 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span></span><br><span class="line">        <span class="comment"># 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span></span><br><span class="line">        <span class="comment"># 3.得到每一节点的最优值，最后选取最优的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i]代表该节点及以下拿到的最多的钱</span></span><br><span class="line">        <span class="comment"># 2.动态方程：</span></span><br><span class="line">        <span class="comment">#   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span></span><br><span class="line">        <span class="comment">#   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span></span><br><span class="line">        <span class="comment"># 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postTrasval</span>(<span class="params">root</span>):</span></span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dp</span><br><span class="line"></span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># initial tree structure</span></span><br><span class="line">    T = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    T.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.right.right = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The solution to the Question</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.rob(T))</span><br></pre></td></tr></table></figure>




<p>至此为止，想要讲解的全部完毕了</p>
<p>洋洋洒洒过万字，自己都没想到写了这么多</p>
<p>在强调一点吧，这些题目全部理解 外加 自己另外练习，一定能够cover<strong>关于动态规划80%以上的题目</strong>，基本上都是dp为一维数组，二维数组的题目，很少有很奇怪的题型出现。所以，本文将《打家劫舍》经典案例详细讲解了一次，还有不同路径的问题，也是很经典的题目，而经典题目一定很具有代表性。优化方向很多，本文也只介绍了关于空间方面的优化，因为这个是最最常见的。</p>
<p>最后，大家一定多画图，多思考，题解百边其义自见（百边有点多哈哈哈）</p>
<p>还有，多理解四步骤， 加油！</p>
<p>后面有机会再细致的分享其他常见算法思想的文章</p>
<p>如果感觉对大家有帮助，不妨关注、点赞、转发起来哦！！！</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>百本互联网图书PDF分享</title>
    <url>/posts/77172009/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<p><strong>【电子书籍】坚持书籍分享 … 完善中 …</strong></p>
<p><strong>【要善用Command/Ctrl+F查找资料哦】</strong></p>
<p>零、互联网面试书籍集合</p>
<p>一、计算机技术语言类</p>
<p>二、数据结构和算法</p>
<p>三、Python技术</p>
<p>四、大数据技术</p>
<p>五、机器学习和人工智能AI</p>
<p>六、其他书籍</p>
<p><strong>按需寻找哦！ 链接如果失效，随时随地联系作者 (^o^)/~</strong></p>
<hr>
<h4 id="零、互联网面试书籍集合"><a href="#零、互联网面试书籍集合" class="headerlink" title="零、互联网面试书籍集合"></a>零、互联网面试书籍集合</h4><h6 id="1-《labuladong的算法小抄官方完整版》"><a href="#1-《labuladong的算法小抄官方完整版》" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> </p>
<p>密码: 密码:KfGM</p>
<h6 id="3-《剑指offer名企面试官精讲典型编程题》"><a href="#3-《剑指offer名企面试官精讲典型编程题》" class="headerlink" title="3.《剑指offer名企面试官精讲典型编程题》"></a>3.《剑指offer名企面试官精讲典型编程题》</h6><p>链接: <a href="https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw">https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw</a>  </p>
<p>密码: jnnl</p>
<h6 id="4-《阿里Java面试问题大全》"><a href="#4-《阿里Java面试问题大全》" class="headerlink" title="4.《阿里Java面试问题大全》"></a>4.《阿里Java面试问题大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ">https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ</a> </p>
<p>提取码: es6v</p>
<h6 id="5-《程序员面试宝典》"><a href="#5-《程序员面试宝典》" class="headerlink" title="5.《程序员面试宝典》"></a>5.《程序员面试宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ">https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ</a> </p>
<p>提取码: aske</p>
<h4 id="一、计算机技术语言类"><a href="#一、计算机技术语言类" class="headerlink" title="一、计算机技术语言类"></a>一、计算机技术语言类</h4><h5 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h5><h6 id="1-《C和指针》-C语言经典书籍"><a href="#1-《C和指针》-C语言经典书籍" class="headerlink" title="1. 《C和指针》 C语言经典书籍"></a>1. 《C和指针》 C语言经典书籍</h6><p>PDF链接:<a href="https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ">https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ</a>  </p>
<p>密码:dr1q</p>
<h6 id="2-《啊哈c语言》"><a href="#2-《啊哈c语言》" class="headerlink" title="2. 《啊哈c语言》"></a>2. 《啊哈c语言》</h6><p>链接:<a href="https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA">https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA</a>  </p>
<p>密码:gi21</p>
<h6 id="3-《c-primerplus6》-C-经典书籍"><a href="#3-《c-primerplus6》-C-经典书籍" class="headerlink" title="3. 《c++primerplus6》 C++经典书籍"></a>3. 《c++primerplus6》 C++经典书籍</h6><p>链接:<a href="https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw">https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw</a>  </p>
<p>密码:0kat</p>
<h6 id="4-《深入探索C-对象模型》"><a href="#4-《深入探索C-对象模型》" class="headerlink" title="4. 《深入探索C++对象模型》"></a>4. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ">https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ</a> </p>
<p>提取码: k98m</p>
<h6 id="5-《C-编程规范-101条规则准则与最佳实践》"><a href="#5-《C-编程规范-101条规则准则与最佳实践》" class="headerlink" title="5. 《C++编程规范-101条规则准则与最佳实践》"></a>5. 《C++编程规范-101条规则准则与最佳实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="6-《C-编程思想两卷合订本》"><a href="#6-《C-编程思想两卷合订本》" class="headerlink" title="6. 《C++编程思想两卷合订本》"></a>6. 《C++编程思想两卷合订本》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="7-《C-沉思录中文第2版》"><a href="#7-《C-沉思录中文第2版》" class="headerlink" title="7. 《C++沉思录中文第2版》"></a>7. 《C++沉思录中文第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA">https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA</a> </p>
<p>提取码: 4rk1</p>
<h6 id="8-《C-大学教程》"><a href="#8-《C-大学教程》" class="headerlink" title="8. 《C++大学教程》"></a>8. 《C++大学教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g">https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g</a> </p>
<p>提取码: 1ine</p>
<h6 id="9-《深入探索C-对象模型》"><a href="#9-《深入探索C-对象模型》" class="headerlink" title="9. 《深入探索C++对象模型》"></a>9. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw">https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw</a> </p>
<p>提取码: s4ht</p>
<h6 id="10-《C-设计新思维-泛型编程与设计之应用》"><a href="#10-《C-设计新思维-泛型编程与设计之应用》" class="headerlink" title="10. 《C++设计新思维-泛型编程与设计之应用》"></a>10. 《C++设计新思维-泛型编程与设计之应用》</h6><p>链接: <a href="https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw">https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw</a> </p>
<p>提取码: a73e</p>
<h6 id="11-《C-primer5th》"><a href="#11-《C-primer5th》" class="headerlink" title="11. 《C++primer5th》"></a>11. 《C++primer5th》</h6><p>链接: <a href="https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g">https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g</a> </p>
<p>提取码: f66t</p>
<h6 id="12-《C-Templates》"><a href="#12-《C-Templates》" class="headerlink" title="12. 《C++ Templates》"></a>12. 《C++ Templates》</h6><p>链接: <a href="https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ">https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ</a> </p>
<p>提取码: bhmc</p>
<h6 id="13-《C语言编程精粹》"><a href="#13-《C语言编程精粹》" class="headerlink" title="13. 《C语言编程精粹》"></a>13. 《C语言编程精粹》</h6><p>链接: <a href="https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw">https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw</a> </p>
<p>提取码: xvas</p>
<h6 id="14-《C语言参考手册第五版》"><a href="#14-《C语言参考手册第五版》" class="headerlink" title="14. 《C语言参考手册第五版》"></a>14. 《C语言参考手册第五版》</h6><p>链接: <a href="https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg">https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg</a> </p>
<p>提取码: x3ns</p>
<h6 id="15-《C语言解析教程》"><a href="#15-《C语言解析教程》" class="headerlink" title="15. 《C语言解析教程》"></a>15. 《C语言解析教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg">https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg</a> </p>
<p>提取码: hn2i</p>
<h6 id="16-《C语言深度解剖》"><a href="#16-《C语言深度解剖》" class="headerlink" title="16. 《C语言深度解剖》"></a>16. 《C语言深度解剖》</h6><p>链接: <a href="https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww">https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww</a> </p>
<p>提取码: ggfh</p>
<h6 id="17-《C专家编程》"><a href="#17-《C专家编程》" class="headerlink" title="17. 《C专家编程》"></a>17. 《C专家编程》</h6><p>链接: <a href="https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw">https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw</a> </p>
<p>提取码: c8fu</p>
<h6 id="18-《EffectiveSTL中文版》"><a href="#18-《EffectiveSTL中文版》" class="headerlink" title="18. 《EffectiveSTL中文版》"></a>18. 《EffectiveSTL中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA">https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA</a> </p>
<p>提取码: arzc</p>
<h6 id="19-《MoreEffectiveC-中文版》"><a href="#19-《MoreEffectiveC-中文版》" class="headerlink" title="19. 《MoreEffectiveC++中文版》"></a>19. 《MoreEffectiveC++中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g">https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g</a> </p>
<p>提取码: qdd3</p>
<h6 id="20-《STL源码剖析》"><a href="#20-《STL源码剖析》" class="headerlink" title="20. 《STL源码剖析》"></a>20. 《STL源码剖析》</h6><p>链接: <a href="https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ">https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ</a> </p>
<p>提取码: w9x8</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><h6 id="1-《Java核心技术-卷1-基础知识-原书第9版》"><a href="#1-《Java核心技术-卷1-基础知识-原书第9版》" class="headerlink" title="1. 《Java核心技术 卷1 基础知识 原书第9版》"></a>1. 《Java核心技术 卷1 基础知识 原书第9版》</h6><p>链接:<a href="https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw">https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw</a>  </p>
<p>密码:x1x3</p>
<h6 id="2-《阿里巴巴Java开发手册》"><a href="#2-《阿里巴巴Java开发手册》" class="headerlink" title="2. 《阿里巴巴Java开发手册》"></a>2. 《阿里巴巴Java开发手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ">https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ</a> </p>
<p>提取码: w6gc</p>
<h6 id="3-《码出高效》Java开发手册"><a href="#3-《码出高效》Java开发手册" class="headerlink" title="3. 《码出高效》Java开发手册"></a>3. 《码出高效》Java开发手册</h6><p>链接: <a href="https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg">https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg</a> </p>
<p>提取码: sqhe</p>
<h6 id="3-《轻量级JavaEE企业应用实战》"><a href="#3-《轻量级JavaEE企业应用实战》" class="headerlink" title="3. 《轻量级JavaEE企业应用实战》"></a>3. 《轻量级JavaEE企业应用实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ">https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ</a> </p>
<p>提取码: rtzw</p>
<h6 id="4-《深入分析JavaWeb技术内幕》"><a href="#4-《深入分析JavaWeb技术内幕》" class="headerlink" title="4. 《深入分析JavaWeb技术内幕》"></a>4. 《深入分析JavaWeb技术内幕》</h6><p>链接: <a href="https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ">https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ</a> </p>
<p>提取码: vivd</p>
<h6 id="5-《深入理解Java虚拟机第二版》"><a href="#5-《深入理解Java虚拟机第二版》" class="headerlink" title="5. 《深入理解Java虚拟机第二版》"></a>5. 《深入理解Java虚拟机第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA">https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA</a> </p>
<p>提取码: jj6z</p>
<h6 id="6-《深入剖析Tomcat》"><a href="#6-《深入剖析Tomcat》" class="headerlink" title="6. 《深入剖析Tomcat》"></a>6. 《深入剖析Tomcat》</h6><p>链接: <a href="https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg">https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg</a> </p>
<p>提取码: p42w</p>
<h6 id="7-《Java8实战》"><a href="#7-《Java8实战》" class="headerlink" title="7. 《Java8实战》"></a>7. 《Java8实战》</h6><p>链接: <a href="https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ">https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ</a> </p>
<p>提取码: hh1e</p>
<h6 id="8-《JAVA并发编程实践》"><a href="#8-《JAVA并发编程实践》" class="headerlink" title="8. 《JAVA并发编程实践》"></a>8. 《JAVA并发编程实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw">https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw</a> </p>
<p>提取码: tcvd</p>
<h6 id="9-《EffectiveJava中文第二版》"><a href="#9-《EffectiveJava中文第二版》" class="headerlink" title="9. 《EffectiveJava中文第二版》"></a>9. 《EffectiveJava中文第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA">https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA</a> </p>
<p>提取码: ankv</p>
<h6 id="10-《HeadFirstJava第二版涵盖java5-0》"><a href="#10-《HeadFirstJava第二版涵盖java5-0》" class="headerlink" title="10. 《HeadFirstJava第二版涵盖java5.0》"></a>10. 《HeadFirstJava第二版涵盖java5.0》</h6><p>链接: <a href="https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng">https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng</a> </p>
<p>提取码: bmkj</p>
<h6 id="11-《HeadFirstServletandJSP》-高清中文版"><a href="#11-《HeadFirstServletandJSP》-高清中文版" class="headerlink" title="11. 《HeadFirstServletandJSP》(高清中文版)"></a>11. 《HeadFirstServletandJSP》(高清中文版)</h6><p>链接: <a href="https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA">https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA</a> </p>
<p>提取码: vkmk</p>
<h6 id="12-《Java从小白到大牛精简版》"><a href="#12-《Java从小白到大牛精简版》" class="headerlink" title="12. 《Java从小白到大牛精简版》"></a>12. 《Java从小白到大牛精简版》</h6><p>链接: <a href="https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw">https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw</a> </p>
<p>提取码: mz9r</p>
<h6 id="13-《Java核心技术卷1第8版》"><a href="#13-《Java核心技术卷1第8版》" class="headerlink" title="13. 《Java核心技术卷1第8版》"></a>13. 《Java核心技术卷1第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA">https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA</a> </p>
<p>提取码: 9i6e</p>
<h6 id="14-《Java核心技术卷2第8版》"><a href="#14-《Java核心技术卷2第8版》" class="headerlink" title="14. 《Java核心技术卷2第8版》"></a>14. 《Java核心技术卷2第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg">https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg</a> </p>
<p>提取码: x58i</p>
<h6 id="15-《Java性能优化权威指南》"><a href="#15-《Java性能优化权威指南》" class="headerlink" title="15. 《Java性能优化权威指南》"></a>15. 《Java性能优化权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw">https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw</a> </p>
<p>提取码: 8emi</p>
<h6 id="16-《Spring-实战-中文版第4版》"><a href="#16-《Spring-实战-中文版第4版》" class="headerlink" title="16. 《Spring 实战 中文版第4版》"></a>16. 《Spring 实战 中文版第4版》</h6><p>链接: <a href="https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w">https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w</a> </p>
<p>提取码: gea5</p>
<h4 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="1-《大话数据结构》"><a href="#1-《大话数据结构》" class="headerlink" title="1. 《大话数据结构》"></a>1. 《大话数据结构》</h6><p>链接: <a href="https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA">https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA</a> </p>
<p>提取码: 8i5k</p>
<h6 id="2-《Java数据结构和算法》-第二版"><a href="#2-《Java数据结构和算法》-第二版" class="headerlink" title="2. 《Java数据结构和算法》 第二版"></a>2. 《Java数据结构和算法》 第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw">https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw</a> </p>
<p>提取码: f6y5</p>
<h5 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h5><h6 id="1-《labuladong的算法小抄官方完整版》-1"><a href="#1-《labuladong的算法小抄官方完整版》-1" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a><br>提取码：KfGM</p>
<h6 id="2-动态规划总结文档"><a href="#2-动态规划总结文档" class="headerlink" title="2. 动态规划总结文档"></a>2. 动态规划总结文档</h6><p>对动态规划的理解还是差那么一点？这一篇帮你安排的明明白白！</p>
<h6 id="3-《算法导论》"><a href="#3-《算法导论》" class="headerlink" title="3. 《算法导论》"></a>3. 《算法导论》</h6><p>链接: <a href="https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw">https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw</a>  </p>
<p>密码: s3sh</p>
<h6 id="4-《啊哈算法》"><a href="#4-《啊哈算法》" class="headerlink" title="4. 《啊哈算法》"></a>4. 《啊哈算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="5-《编程珠玑第二版》"><a href="#5-《编程珠玑第二版》" class="headerlink" title="5. 《编程珠玑第二版》"></a>5. 《编程珠玑第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="6-《算法图解》"><a href="#6-《算法图解》" class="headerlink" title="6. 《算法图解》"></a>6. 《算法图解》</h6><p>链接: <a href="https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ">https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ</a> </p>
<p>提取码: r7wa</p>
<h5 id="周边算法思想"><a href="#周边算法思想" class="headerlink" title="周边算法思想"></a>周边算法思想</h5><h4 id="三、Python技术"><a href="#三、Python技术" class="headerlink" title="三、Python技术"></a>三、Python技术</h4><h5 id="Python-语言"><a href="#Python-语言" class="headerlink" title="Python 语言"></a>Python 语言</h5><h6 id="1-《Python进阶》"><a href="#1-《Python进阶》" class="headerlink" title="1. 《Python进阶》"></a>1. 《Python进阶》</h6><p>链接:<a href="https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg">https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg</a>  </p>
<p>密码:u9u0</p>
<h6 id="2-《Python基础教程（第二版）》"><a href="#2-《Python基础教程（第二版）》" class="headerlink" title="2. 《Python基础教程（第二版）》"></a>2. 《Python基础教程（第二版）》</h6><p>链接: <a href="https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw">https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw</a>  </p>
<p>密码: lam6</p>
<h6 id="3-《Python核心编程第二版中文》"><a href="#3-《Python核心编程第二版中文》" class="headerlink" title="3. 《Python核心编程第二版中文》"></a>3. 《Python核心编程第二版中文》</h6><p>链接: <a href="https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ">https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ</a>  </p>
<p>密码: hq9b</p>
<h6 id="4-《Python开发实战》"><a href="#4-《Python开发实战》" class="headerlink" title="4. 《Python开发实战》"></a>4. 《Python开发实战》</h6><p>链接: <a href="https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA">https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA</a> </p>
<p>提取码: 2bnj</p>
<h6 id="5-《Python开发技术详解》"><a href="#5-《Python开发技术详解》" class="headerlink" title="5. 《Python开发技术详解》"></a>5. 《Python开发技术详解》</h6><p>链接: <a href="https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw">https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw</a> </p>
<p>提取码: 3kjn</p>
<h6 id="6-《Python灰帽子黑客与逆向工程师的Python编程之道》"><a href="#6-《Python灰帽子黑客与逆向工程师的Python编程之道》" class="headerlink" title="6. 《Python灰帽子黑客与逆向工程师的Python编程之道》"></a>6. 《Python灰帽子黑客与逆向工程师的Python编程之道》</h6><p>链接: <a href="https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA">https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA</a> </p>
<p>提取码: ev5v</p>
<h6 id="7-《Python高级编程第2版》"><a href="#7-《Python高级编程第2版》" class="headerlink" title="7. 《Python高级编程第2版》"></a>7. 《Python高级编程第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw">https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw</a> </p>
<p>提取码: 62qy</p>
<h6 id="8-《Python编程入门经典》"><a href="#8-《Python编程入门经典》" class="headerlink" title="8. 《Python编程入门经典》"></a>8. 《Python编程入门经典》</h6><p>链接: <a href="https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ">https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ</a> </p>
<p>提取码: g4pr</p>
<h6 id="9-《Python编程初学者指南》"><a href="#9-《Python编程初学者指南》" class="headerlink" title="9. 《Python编程初学者指南》"></a>9. 《Python编程初学者指南》</h6><p>链接: <a href="https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw">https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw</a> </p>
<p>提取码: k86q</p>
<h6 id="10-《Python网络编程基础》"><a href="#10-《Python网络编程基础》" class="headerlink" title="10. 《Python网络编程基础》"></a>10. 《Python网络编程基础》</h6><p>链接: <a href="https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA">https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA</a> </p>
<p>提取码: vy2t</p>
<h6 id="11-《Python学习手册》"><a href="#11-《Python学习手册》" class="headerlink" title="11. 《Python学习手册》"></a>11. 《Python学习手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ">https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ</a> </p>
<p>提取码: nikm</p>
<h6 id="12-《Python学习手册》-第4版"><a href="#12-《Python学习手册》-第4版" class="headerlink" title="12. 《Python学习手册》 第4版"></a>12. 《Python学习手册》 第4版</h6><p>链接: <a href="https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg">https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg</a> </p>
<p>提取码: arcd</p>
<h6 id="13-《用Python写网络爬虫》"><a href="#13-《用Python写网络爬虫》" class="headerlink" title="13. 《用Python写网络爬虫》"></a>13. 《用Python写网络爬虫》</h6><p>链接: <a href="https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA">https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA</a> </p>
<p>提取码: wm92</p>
<h5 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h5><h6 id="1-《利用Python进行数据分析》"><a href="#1-《利用Python进行数据分析》" class="headerlink" title="1. 《利用Python进行数据分析》"></a>1. 《利用Python进行数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g">https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g</a>  </p>
<p>密码: qune</p>
<h6 id="2-《NumPy学习指南（第2版）》"><a href="#2-《NumPy学习指南（第2版）》" class="headerlink" title="2. 《NumPy学习指南（第2版）》"></a>2. 《NumPy学习指南（第2版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw">https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw</a>  </p>
<p>密码:3nwc</p>
<h6 id="3-《常用的数据分析方法》"><a href="#3-《常用的数据分析方法》" class="headerlink" title="3. 《常用的数据分析方法》"></a>3. 《常用的数据分析方法》</h6><p>链接: <a href="https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g">https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g</a> </p>
<p>提取码: u8p6</p>
<h6 id="4-《Python数据处理》"><a href="#4-《Python数据处理》" class="headerlink" title="4. 《Python数据处理》"></a>4. 《Python数据处理》</h6><p>链接: <a href="https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g">https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g</a> </p>
<p>提取码: m42q</p>
<h6 id="5-《Python金融大数据分析》"><a href="#5-《Python金融大数据分析》" class="headerlink" title="5. 《Python金融大数据分析》"></a>5. 《Python金融大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ">https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ</a> </p>
<p>提取码: rpqw</p>
<h6 id="6-《Python数据分析与挖掘实战》"><a href="#6-《Python数据分析与挖掘实战》" class="headerlink" title="6. 《Python数据分析与挖掘实战》"></a>6. 《Python数据分析与挖掘实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg">https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg</a> </p>
<p>提取码: evbm</p>
<h6 id="7-《Python数据科学手册》"><a href="#7-《Python数据科学手册》" class="headerlink" title="7. 《Python数据科学手册》"></a>7. 《Python数据科学手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw">https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw</a> </p>
<p>提取码: qyqh</p>
<h6 id="8-《Python数据可视化编程实战》"><a href="#8-《Python数据可视化编程实战》" class="headerlink" title="8. 《Python数据可视化编程实战》"></a>8. 《Python数据可视化编程实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw">https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw</a> </p>
<p>提取码: b3sb</p>
<h6 id="9-《PYTHON自然语言处理中文版》"><a href="#9-《PYTHON自然语言处理中文版》" class="headerlink" title="9. 《PYTHON自然语言处理中文版》"></a>9. 《PYTHON自然语言处理中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA">https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA</a> </p>
<p>提取码: k8bs</p>
<h4 id="四、大数据技术"><a href="#四、大数据技术" class="headerlink" title="四、大数据技术"></a>四、大数据技术</h4><h5 id="大数据技术基础"><a href="#大数据技术基础" class="headerlink" title="大数据技术基础"></a>大数据技术基础</h5><h6 id="1-《Hadoop全权威指南第三版（原版）》"><a href="#1-《Hadoop全权威指南第三版（原版）》" class="headerlink" title="1.《Hadoop全权威指南第三版（原版）》"></a>1.《Hadoop全权威指南第三版（原版）》</h6><p>链接: <a href="https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww">https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww</a>  </p>
<p>密码: 29li</p>
<h6 id="2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"><a href="#2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理" class="headerlink" title="2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"></a>2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ">https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ</a> </p>
<p>提取码: c3gx</p>
<h6 id="3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理"><a href="#3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理" class="headerlink" title="3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理"></a>3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg">https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg</a> </p>
<p>提取码: bdje</p>
<h6 id="4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"><a href="#4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理" class="headerlink" title="4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"></a>4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w">https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w</a> </p>
<p>提取码: wfks</p>
<h6 id="5-《Spark快速大数据分析》"><a href="#5-《Spark快速大数据分析》" class="headerlink" title="5.《Spark快速大数据分析》"></a>5.《Spark快速大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA">https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA</a> </p>
<p>提取码: i6av</p>
<h5 id="大数据平台开源工具"><a href="#大数据平台开源工具" class="headerlink" title="大数据平台开源工具"></a>大数据平台开源工具</h5><h5 id="大数据集群"><a href="#大数据集群" class="headerlink" title="大数据集群"></a>大数据集群</h5><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA">https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA</a> </p>
<p>提取码: c276</p>
<h6 id="2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg">https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg</a> </p>
<p>提取码: x4ej</p>
<h6 id="3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列"><a href="#3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列" class="headerlink" title="3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)"></a>3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)</h6><p>链接: <a href="https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg">https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg</a> </p>
<p>提取码: ktff</p>
<h6 id="4-《Linux宝典》"><a href="#4-《Linux宝典》" class="headerlink" title="4. 《Linux宝典》"></a>4. 《Linux宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w">https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w</a> </p>
<p>提取码: 6rxa</p>
<h6 id="5-《linux常用命令大全》"><a href="#5-《linux常用命令大全》" class="headerlink" title="5. 《linux常用命令大全》"></a>5. 《linux常用命令大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww">https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww</a> </p>
<p>提取码: bsce</p>
<h6 id="6-《LINUX防火墙原书第3版》"><a href="#6-《LINUX防火墙原书第3版》" class="headerlink" title="6. 《LINUX防火墙原书第3版》"></a>6. 《LINUX防火墙原书第3版》</h6><p>链接: <a href="https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g">https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g</a> </p>
<p>提取码: wi4c</p>
<h6 id="7-《Linux高级程序设计中文第三版》"><a href="#7-《Linux高级程序设计中文第三版》" class="headerlink" title="7. 《Linux高级程序设计中文第三版》"></a>7. 《Linux高级程序设计中文第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg">https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg</a> </p>
<p>提取码: 26ek</p>
<h6 id="8-《Linux环境编程从应用到内核》"><a href="#8-《Linux环境编程从应用到内核》" class="headerlink" title="8. 《Linux环境编程从应用到内核》"></a>8. 《Linux环境编程从应用到内核》</h6><p>链接: <a href="https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ">https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ</a> </p>
<p>提取码: fwi2</p>
<h6 id="9-《Linux命令详解词典施威铭研究室》"><a href="#9-《Linux命令详解词典施威铭研究室》" class="headerlink" title="9. 《Linux命令详解词典施威铭研究室》"></a>9. 《Linux命令详解词典施威铭研究室》</h6><p>链接: <a href="https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw">https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw</a> </p>
<p>提取码: rhpb</p>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><h6 id="1-《深入浅出MySQL-数据库开发优化与管理维护》"><a href="#1-《深入浅出MySQL-数据库开发优化与管理维护》" class="headerlink" title="1. 《深入浅出MySQL++数据库开发优化与管理维护》"></a>1. 《深入浅出MySQL++数据库开发优化与管理维护》</h6><p>链接: <a href="https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A">https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A</a> 提取码: 5eez</p>
<h6 id="2-《高性能mysql第三版》"><a href="#2-《高性能mysql第三版》" class="headerlink" title="2. 《高性能mysql第三版》"></a>2. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="3-《MySQL必知必会》"><a href="#3-《MySQL必知必会》" class="headerlink" title="3. 《MySQL必知必会》"></a>3. 《MySQL必知必会》</h6><p>链接: <a href="https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA">https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA</a> </p>
<p>提取码: 7xds</p>
<h4 id="五、机器学习和人工智能AI"><a href="#五、机器学习和人工智能AI" class="headerlink" title="五、机器学习和人工智能AI"></a>五、机器学习和人工智能AI</h4><h5 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h5><h6 id="1-《高等数学（同济）第六版-第七版课后习题答案》完整答案"><a href="#1-《高等数学（同济）第六版-第七版课后习题答案》完整答案" class="headerlink" title="1.《高等数学（同济）第六版/第七版课后习题答案》完整答案"></a>1.《高等数学（同济）第六版/第七版课后习题答案》完整答案</h6><p>链接:<a href="https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw">https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw</a>  </p>
<p>密码:xlij</p>
<h6 id="2-《浙江大学概率论与数理统计-第四版-》"><a href="#2-《浙江大学概率论与数理统计-第四版-》" class="headerlink" title="2.《浙江大学概率论与数理统计(第四版)》"></a>2.《浙江大学概率论与数理统计(第四版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g">https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g</a> </p>
<p>提取码: zeda</p>
<h6 id="3-《数学之美》完整版"><a href="#3-《数学之美》完整版" class="headerlink" title="3.《数学之美》完整版"></a>3.《数学之美》完整版</h6><p>链接: <a href="https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA">https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA</a> </p>
<p>提取码: a95d</p>
<h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><h6 id="1-《Machine-Learning-Yearning》完整中文版"><a href="#1-《Machine-Learning-Yearning》完整中文版" class="headerlink" title="1.《Machine Learning Yearning》完整中文版"></a>1.《Machine Learning Yearning》完整中文版</h6><p>链接:<a href="https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw">https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw</a> </p>
<p>提取码:wxoj </p>
<h6 id="2-《百面机器学习》"><a href="#2-《百面机器学习》" class="headerlink" title="2.《百面机器学习》"></a>2.《百面机器学习》</h6><p>链接:<a href="https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ">https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ</a>  </p>
<p>密码:xbhr</p>
<h6 id="3-《统计学习方法》"><a href="#3-《统计学习方法》" class="headerlink" title="3.《统计学习方法》"></a>3.《统计学习方法》</h6><p>链接:<a href="https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA">https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA</a>  </p>
<p>密码:m5qp</p>
<h6 id="4-《机器学习》周志华-西瓜书"><a href="#4-《机器学习》周志华-西瓜书" class="headerlink" title="4.《机器学习》周志华-西瓜书"></a>4.《机器学习》周志华-西瓜书</h6><p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a>  </p>
<p>密码:odp0</p>
<h6 id="5-《Artificial-Intelligence-A-Modern》"><a href="#5-《Artificial-Intelligence-A-Modern》" class="headerlink" title="5.《Artificial Intelligence_ A Modern》"></a>5.《Artificial Intelligence_ A Modern》</h6><p>链接:<a href="https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ">https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ</a>  </p>
<p>密码:2t6s</p>
<h6 id="6-《贝叶斯思维统计建模的PYTHON学习法》"><a href="#6-《贝叶斯思维统计建模的PYTHON学习法》" class="headerlink" title="6.《贝叶斯思维统计建模的PYTHON学习法》"></a>6.《贝叶斯思维统计建模的PYTHON学习法》</h6><p>链接: <a href="https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g">https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g</a> </p>
<p>提取码: 7t7x</p>
<h6 id="7-《机器学习实战》"><a href="#7-《机器学习实战》" class="headerlink" title="7.《机器学习实战》"></a>7.《机器学习实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA">https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA</a> </p>
<p>提取码: b9hw</p>
<h6 id="8-《机器学习与数据挖掘方法和应用》"><a href="#8-《机器学习与数据挖掘方法和应用》" class="headerlink" title="8.《机器学习与数据挖掘方法和应用》"></a>8.《机器学习与数据挖掘方法和应用》</h6><p>链接: <a href="https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw">https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw</a> </p>
<p>提取码: rw5q</p>
<h6 id="9-《机器学习》中文版"><a href="#9-《机器学习》中文版" class="headerlink" title="9.《机器学习》中文版"></a>9.《机器学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw">https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw</a> </p>
<p>提取码: 387b</p>
<h6 id="10-《人工智能》复杂问题求解的结构和策略"><a href="#10-《人工智能》复杂问题求解的结构和策略" class="headerlink" title="10.《人工智能》复杂问题求解的结构和策略"></a>10.《人工智能》复杂问题求解的结构和策略</h6><p>链接: <a href="https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng">https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng</a> </p>
<p>提取码: 5ji1</p>
<h6 id="11-《数据挖掘-实用机器学习技术》中文第二版"><a href="#11-《数据挖掘-实用机器学习技术》中文第二版" class="headerlink" title="11.《数据挖掘-实用机器学习技术》中文第二版"></a>11.《数据挖掘-实用机器学习技术》中文第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g">https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g</a> </p>
<p>提取码: ek29</p>
<h6 id="12-《数据挖掘-数据-模型-算法》"><a href="#12-《数据挖掘-数据-模型-算法》" class="headerlink" title="12.《数据挖掘-数据-模型-算法》"></a>12.《数据挖掘-数据-模型-算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg">https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg</a> </p>
<p>提取码: iwde</p>
<h6 id="13-《数据挖掘概念与技术-中文版-》"><a href="#13-《数据挖掘概念与技术-中文版-》" class="headerlink" title="13.《数据挖掘概念与技术(中文版)》"></a>13.《数据挖掘概念与技术(中文版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ">https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ</a> </p>
<p>提取码: 44c4</p>
<h6 id="14-《数据挖掘实用案例分析》"><a href="#14-《数据挖掘实用案例分析》" class="headerlink" title="14.《数据挖掘实用案例分析》"></a>14.《数据挖掘实用案例分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ">https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ</a> </p>
<p>提取码: d6fx</p>
<h6 id="15-《Web数据挖掘》"><a href="#15-《Web数据挖掘》" class="headerlink" title="15.《Web数据挖掘》"></a>15.《Web数据挖掘》</h6><p>链接: <a href="https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw">https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw</a> </p>
<p>提取码: tmy4</p>
<h5 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h5><h6 id="1-《推荐算法在业界的应用实践合集》"><a href="#1-《推荐算法在业界的应用实践合集》" class="headerlink" title="1.《推荐算法在业界的应用实践合集》"></a>1.《推荐算法在业界的应用实践合集》</h6><p>链接:<a href="https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ">https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ</a>  </p>
<p>密码:3qbx</p>
<h6 id="2-《推荐系统实践》"><a href="#2-《推荐系统实践》" class="headerlink" title="2.《推荐系统实践》"></a>2.《推荐系统实践》</h6><p>链接:<a href="https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig">https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig</a>  </p>
<p>密码:w1qj</p>
<h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><h6 id="1-2020最新版《神经网络与深度学习》中文版"><a href="#1-2020最新版《神经网络与深度学习》中文版" class="headerlink" title="1. 2020最新版《神经网络与深度学习》中文版"></a>1. 2020最新版《神经网络与深度学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg">https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg</a>  </p>
<p>密码: 7cor</p>
<h6 id="2-《神经网络与机器学习》"><a href="#2-《神经网络与机器学习》" class="headerlink" title="2. 《神经网络与机器学习》"></a>2. 《神经网络与机器学习》</h6><p>链接: <a href="https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg">https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg</a> </p>
<p>提取码: 5py4</p>
<h6 id="3-《TensorFlow实践与智能系统》"><a href="#3-《TensorFlow实践与智能系统》" class="headerlink" title="3. 《TensorFlow实践与智能系统》"></a>3. 《TensorFlow实践与智能系统》</h6><p>链接: <a href="https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg">https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg</a> </p>
<p>提取码: 9iq7</p>
<h6 id="4-《Tensorflow实战Google深度学习框架》"><a href="#4-《Tensorflow实战Google深度学习框架》" class="headerlink" title="4. 《Tensorflow实战Google深度学习框架》"></a>4. 《Tensorflow实战Google深度学习框架》</h6><p>链接: <a href="https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA">https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA</a> </p>
<p>提取码: ybr9</p>
<h4 id="六、其他书籍"><a href="#六、其他书籍" class="headerlink" title="六、其他书籍"></a>六、其他书籍</h4><h6 id="1-《计算广告：互联网商业变现的市场与技术-刘鹏》"><a href="#1-《计算广告：互联网商业变现的市场与技术-刘鹏》" class="headerlink" title="1. 《计算广告：互联网商业变现的市场与技术-刘鹏》"></a>1. 《计算广告：互联网商业变现的市场与技术-刘鹏》</h6><p>链接:<a href="https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg">https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg</a>  </p>
<p>密码:uj8o</p>
<h6 id="2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】"><a href="#2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】" class="headerlink" title="2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】"></a>2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】</h6><p>链接:<a href="https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ">https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ</a>  </p>
<p>密码:46s7</p>
<h6 id="3-《Go语言实战》"><a href="#3-《Go语言实战》" class="headerlink" title="3. 《Go语言实战》"></a>3. 《Go语言实战》</h6><p>链接:<a href="https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw">https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw</a>  密码:277h</p>
<h6 id="4-《第一行代码-Android》"><a href="#4-《第一行代码-Android》" class="headerlink" title="4. 《第一行代码-Android》"></a>4. 《第一行代码-Android》</h6><p>链接:<a href="https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g">https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g</a>  </p>
<p>密码:bvqp</p>
<h6 id="5-《数据库原理（第5版）》"><a href="#5-《数据库原理（第5版）》" class="headerlink" title="5. 《数据库原理（第5版）》"></a>5. 《数据库原理（第5版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q">https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q</a>  </p>
<p>密码:kfi2</p>
<h6 id="5-《VIM-思维导图》"><a href="#5-《VIM-思维导图》" class="headerlink" title="5. 《VIM 思维导图》"></a>5. 《VIM 思维导图》</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="6-《编程之美》完整版"><a href="#6-《编程之美》完整版" class="headerlink" title="6. 《编程之美》完整版"></a>6. 《编程之美》完整版</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="7-《代码大全2中文版》"><a href="#7-《代码大全2中文版》" class="headerlink" title="7. 《代码大全2中文版》"></a>7. 《代码大全2中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg">https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg</a> </p>
<p>提取码: ag4d</p>
<h6 id="8-《代码整洁之道》"><a href="#8-《代码整洁之道》" class="headerlink" title="8. 《代码整洁之道》"></a>8. 《代码整洁之道》</h6><p>链接: <a href="https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ">https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ</a> </p>
<p>提取码: 5d2v</p>
<h6 id="9-《高性能mysql第三版》"><a href="#9-《高性能mysql第三版》" class="headerlink" title="9. 《高性能mysql第三版》"></a>9. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="10-《黑客与画家》"><a href="#10-《黑客与画家》" class="headerlink" title="10. 《黑客与画家》"></a>10. 《黑客与画家》</h6><p>链接: <a href="https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg">https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg</a> </p>
<p>提取码: rqem</p>
<h6 id="11-《汇编语言》-第3版-王爽著"><a href="#11-《汇编语言》-第3版-王爽著" class="headerlink" title="11. 《汇编语言》(第3版)王爽著"></a>11. 《汇编语言》(第3版)王爽著</h6><p>链接: <a href="https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg">https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg</a> </p>
<p>提取码: 9au5</p>
<h6 id="12-《计算机程序设计艺术-第一卷-》"><a href="#12-《计算机程序设计艺术-第一卷-》" class="headerlink" title="12. 《计算机程序设计艺术(第一卷)》"></a>12. 《计算机程序设计艺术(第一卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw">https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw</a> </p>
<p>提取码: 5qgb</p>
<h6 id="13-《计算机程序设计艺术-第二卷-》"><a href="#13-《计算机程序设计艺术-第二卷-》" class="headerlink" title="13. 《计算机程序设计艺术(第二卷)》"></a>13. 《计算机程序设计艺术(第二卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ">https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ</a> </p>
<p>提取码: 8rsz</p>
<h6 id="14-《计算机程序设计艺术-第三卷-》"><a href="#14-《计算机程序设计艺术-第三卷-》" class="headerlink" title="14. 《计算机程序设计艺术(第三卷)》"></a>14. 《计算机程序设计艺术(第三卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w">https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w</a> </p>
<p>提取码: dtwr </p>
<h6 id="15-《精通正则表达式》"><a href="#15-《精通正则表达式》" class="headerlink" title="15. 《精通正则表达式》"></a>15. 《精通正则表达式》</h6><p>链接: <a href="https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw">https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw</a> </p>
<p>提取码: d762</p>
<h6 id="16-《浪潮之巅》-完整版"><a href="#16-《浪潮之巅》-完整版" class="headerlink" title="16. 《浪潮之巅》(完整版)"></a>16. 《浪潮之巅》(完整版)</h6><p>链接: <a href="https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA">https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA</a> </p>
<p>提取码: r5y2</p>
<h6 id="17-《图解设计模式》"><a href="#17-《图解设计模式》" class="headerlink" title="17. 《图解设计模式》"></a>17. 《图解设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog">https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog</a> </p>
<p>提取码: p3wn</p>
<h6 id="18-《学习Go语言-Golang-》"><a href="#18-《学习Go语言-Golang-》" class="headerlink" title="18. 《学习Go语言(Golang)》"></a>18. 《学习Go语言(Golang)》</h6><p>链接: <a href="https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ">https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ</a> </p>
<p>提取码: vw22</p>
<h6 id="19-《研磨设计模式》"><a href="#19-《研磨设计模式》" class="headerlink" title="19. 《研磨设计模式》"></a>19. 《研磨设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg">https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg</a> </p>
<p>提取码: nmyf</p>
<h6 id="20-《HeadFirst设计模式》"><a href="#20-《HeadFirst设计模式》" class="headerlink" title="20. 《HeadFirst设计模式》"></a>20. 《HeadFirst设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg">https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg</a> </p>
<p>提取码: 33ff</p>
<h6 id="21-《Maven实战》"><a href="#21-《Maven实战》" class="headerlink" title="21. 《Maven实战》"></a>21. 《Maven实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A">https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A</a> </p>
<p>提取码: x5xv</p>
<h6 id="22-《MongoDB权威指南》"><a href="#22-《MongoDB权威指南》" class="headerlink" title="22. 《MongoDB权威指南》"></a>22. 《MongoDB权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ">https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ</a> </p>
<p>提取码: sj6a</p>
<h6 id="21-《Pro-Git中文版》"><a href="#21-《Pro-Git中文版》" class="headerlink" title="21. 《Pro Git中文版》"></a>21. 《Pro Git中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw">https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw</a> </p>
<p>提取码: eeg1</p>
<h6 id="22-《SQL查询的艺术》"><a href="#22-《SQL查询的艺术》" class="headerlink" title="22. 《SQL查询的艺术》"></a>22. 《SQL查询的艺术》</h6><p>链接: <a href="https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q">https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q</a> </p>
<p>提取码: khvi</p>
<h6 id="23-《SQLite权威指南》"><a href="#23-《SQLite权威指南》" class="headerlink" title="23. 《SQLite权威指南》"></a>23. 《SQLite权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw">https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw</a> </p>
<p>提取码: 9dqe</p>
<hr>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：<a href="mailto:&#121;&#x61;&#x6f;&#106;&#105;&#x61;&#110;&#103;&#x75;&#111;&#108;&#113;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#121;&#x61;&#x6f;&#106;&#105;&#x61;&#110;&#103;&#x75;&#111;&#108;&#113;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>《机器学习》周志华-西瓜书PDF</title>
    <url>/posts/d92a0946/</url>
    <content><![CDATA[<h4 id="书籍名称"><a href="#书籍名称" class="headerlink" title="书籍名称"></a>书籍名称</h4><p><strong>《机器学习》周志华-西瓜书 PDF</strong></p>
<p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a> 提取码:odp0</p>
<img src="/images/c04ff56125cfc9f61fe032af1498c7dd1.jpg" width="50%" height="50%">




<a id="more"></a>


<p>机器学习是计算机科学与人工智能的重要分支领域. 本书作为该领域的入门教材，在内容上尽可能涵盖机器学习基础知识的各方面. 全书共16 章，大致分为3 个部分：第1 部分（第1～3 章）介绍机器学习的基础知识；第2 部分（第4～10 章）讨论一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11～16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习等. 每章都附有习题并介绍了相关阅读材料，以便有兴趣的读者进一步钻研探索。</p>
<p>本书可作为高等院校计算机、自动化及相关专业的本科生或研究生教材，也可供对机器学习感兴趣的研究人员和工程技术人员阅读参考。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 1</span><br><span class="line"></span><br><span class="line">1.1 引言 1</span><br><span class="line"></span><br><span class="line">1.2 基本术 2</span><br><span class="line"></span><br><span class="line">1.3 假设空间 4</span><br><span class="line"></span><br><span class="line">1.4 归纳偏好 6</span><br><span class="line"></span><br><span class="line">1.5 发展历程 10</span><br><span class="line"></span><br><span class="line">1.6 应用现状 13</span><br><span class="line"></span><br><span class="line">1.7 阅读材料 16</span><br><span class="line"></span><br><span class="line">习题 19</span><br><span class="line"></span><br><span class="line">参考文献 20</span><br><span class="line"></span><br><span class="line">休息一会儿 22</span><br><span class="line"></span><br><span class="line">第2章 模型评估与选择 23</span><br><span class="line"></span><br><span class="line">2.1 经验误差与过拟合 23</span><br><span class="line"></span><br><span class="line">2.2 评估方法 24</span><br><span class="line"></span><br><span class="line">2.2.1 留出法 25</span><br><span class="line"></span><br><span class="line">2.2.2 交叉验证法 26</span><br><span class="line"></span><br><span class="line">2.2.3 自助法 27</span><br><span class="line"></span><br><span class="line">2.2.4 调参与最终模型 28</span><br><span class="line"></span><br><span class="line">2.3 性能度量 28</span><br><span class="line"></span><br><span class="line">2.3.1 错误率与精度 29</span><br><span class="line"></span><br><span class="line">2.3.2 查准率、查全率与F1 30</span><br><span class="line"></span><br><span class="line">2.3.3 ROC与AUC 33</span><br><span class="line"></span><br><span class="line">2.3.4 代价敏感错误率与代价曲线 35</span><br><span class="line"></span><br><span class="line">2.4 比较检验 37</span><br><span class="line"></span><br><span class="line">2.4.1 假设检验 37</span><br><span class="line"></span><br><span class="line">2.4.2 交叉验证t检验 40</span><br><span class="line"></span><br><span class="line">2.4.3 McNemar检验 41</span><br><span class="line"></span><br><span class="line">2.4.4 Friedman检验与后续检验 42</span><br><span class="line"></span><br><span class="line">2.5 偏差与方差 44</span><br><span class="line"></span><br><span class="line">2.6 阅读材料 46</span><br><span class="line"></span><br><span class="line">习题 48</span><br><span class="line"></span><br><span class="line">参考文献 49</span><br><span class="line"></span><br><span class="line">休息一会儿 51</span><br><span class="line"></span><br><span class="line">第3章 线性模型 53</span><br><span class="line"></span><br><span class="line">3.1 基本形式 53</span><br><span class="line"></span><br><span class="line">3.2 线性回归 53</span><br><span class="line"></span><br><span class="line">3.3 对数几率回归 57</span><br><span class="line"></span><br><span class="line">3.4 线性判别分析 60</span><br><span class="line"></span><br><span class="line">3.5 多分类学习 63</span><br><span class="line"></span><br><span class="line">3.6 类别不平衡问题 66</span><br><span class="line"></span><br><span class="line">3.7 阅读材料 67</span><br><span class="line"></span><br><span class="line">习题 69</span><br><span class="line"></span><br><span class="line">参考文献 70</span><br><span class="line"></span><br><span class="line">休息一会儿 72</span><br><span class="line"></span><br><span class="line">第4章 决策树 73</span><br><span class="line"></span><br><span class="line">4.1 基本流程 73</span><br><span class="line"></span><br><span class="line">4.2 划分选择 75</span><br><span class="line"></span><br><span class="line">4.2.1 信息增益 75</span><br><span class="line"></span><br><span class="line">4.2.2 增益率 77</span><br><span class="line"></span><br><span class="line">4.2.3 基尼指数 79</span><br><span class="line"></span><br><span class="line">4.3 剪枝处理 79</span><br><span class="line"></span><br><span class="line">4.3.1 预剪枝 80</span><br><span class="line"></span><br><span class="line">4.3.2 后剪枝 82</span><br><span class="line"></span><br><span class="line">4.4 连续与缺失值 83</span><br><span class="line"></span><br><span class="line">4.4.1 连续值处理 83</span><br><span class="line"></span><br><span class="line">4.4.2 缺失值处理 85</span><br><span class="line"></span><br><span class="line">4.5 多变量决策树 88</span><br><span class="line"></span><br><span class="line">4.6 阅读材料 92</span><br><span class="line"></span><br><span class="line">习题 93</span><br><span class="line"></span><br><span class="line">参考文献 94</span><br><span class="line"></span><br><span class="line">休息一会儿 95</span><br><span class="line"></span><br><span class="line">第5章 神经网络 97</span><br><span class="line"></span><br><span class="line">5.1 神经元模型 97</span><br><span class="line"></span><br><span class="line">5.2 感知机与多层网络 98</span><br><span class="line"></span><br><span class="line">5.3 误差逆传播算法 101</span><br><span class="line"></span><br><span class="line">5.4 全局最小与局部极小 106</span><br><span class="line"></span><br><span class="line">5.5 其他常见神经网络 108</span><br><span class="line"></span><br><span class="line">5.5.1 RBF网络 108</span><br><span class="line"></span><br><span class="line">5.5.2 ART网络 108</span><br><span class="line"></span><br><span class="line">5.5.3 SOM网络 109</span><br><span class="line"></span><br><span class="line">5.5.4 级联相关网络 110</span><br><span class="line"></span><br><span class="line">5.5.5 Elman网络 111</span><br><span class="line"></span><br><span class="line">5.5.6 Boltzmann机 111</span><br><span class="line"></span><br><span class="line">5.6 深度学习 113</span><br><span class="line"></span><br><span class="line">5.7 阅读材料 115</span><br><span class="line"></span><br><span class="line">习题 116</span><br><span class="line"></span><br><span class="line">参考文献 117</span><br><span class="line"></span><br><span class="line">休息一会儿 120</span><br><span class="line"></span><br><span class="line">第6章 支持向量机 121</span><br><span class="line"></span><br><span class="line">6.1 间隔与支持向量 121</span><br><span class="line"></span><br><span class="line">6.2 对偶问题 123</span><br><span class="line"></span><br><span class="line">6.3 核函数 126</span><br><span class="line"></span><br><span class="line">6.4 软间隔与正则化 129</span><br><span class="line"></span><br><span class="line">6.5 支持向量回归 133</span><br><span class="line"></span><br><span class="line">6.6 核方法 137</span><br><span class="line"></span><br><span class="line">6.7 阅读材料 139</span><br><span class="line"></span><br><span class="line">习题 141</span><br><span class="line"></span><br><span class="line">参考文献 142</span><br><span class="line"></span><br><span class="line">休息一会儿 145</span><br><span class="line"></span><br><span class="line">第7章 贝叶斯分类器 147</span><br><span class="line"></span><br><span class="line">7.1 贝叶斯决策论 147</span><br><span class="line"></span><br><span class="line">7.2 极大似然估计 149</span><br><span class="line"></span><br><span class="line">7.3 朴素贝叶斯分类器 150</span><br><span class="line"></span><br><span class="line">7.4 半朴素贝叶斯分类器 154</span><br><span class="line"></span><br><span class="line">7.5 贝叶斯网 156</span><br><span class="line"></span><br><span class="line">7.5.1 结构 157</span><br><span class="line"></span><br><span class="line">7.5.2 学习 159</span><br><span class="line"></span><br><span class="line">7.5.3 推断 161</span><br><span class="line"></span><br><span class="line">7.6 EM算法 162</span><br><span class="line"></span><br><span class="line">7.7 阅读材料 164</span><br><span class="line"></span><br><span class="line">习题 166</span><br><span class="line"></span><br><span class="line">参考文献 167</span><br><span class="line"></span><br><span class="line">休息一会儿 169</span><br><span class="line"></span><br><span class="line">第8章 集成学习 171</span><br><span class="line"></span><br><span class="line">8.1 个体与集成 171</span><br><span class="line"></span><br><span class="line">8.2 Boosting 173</span><br><span class="line"></span><br><span class="line">8.3 Bagging与随机森林 178</span><br><span class="line"></span><br><span class="line">8.3.1 Bagging 178</span><br><span class="line"></span><br><span class="line">8.3.2 随机森林 179</span><br><span class="line"></span><br><span class="line">8.4 结合策略 181</span><br><span class="line"></span><br><span class="line">8.4.1 平均法 181</span><br><span class="line"></span><br><span class="line">8.4.2 投票法 182</span><br><span class="line"></span><br><span class="line">8.4.3 学习法 183</span><br><span class="line"></span><br><span class="line">8.5 多样性 185</span><br><span class="line"></span><br><span class="line">8.5.1 误差--分歧分解 185</span><br><span class="line"></span><br><span class="line">8.5.2 多样性度量 186</span><br><span class="line"></span><br><span class="line">8.5.3 多样性增强 188</span><br><span class="line"></span><br><span class="line">8.6 阅读材料 190</span><br><span class="line"></span><br><span class="line">习题 192</span><br><span class="line"></span><br><span class="line">参考文献 193</span><br><span class="line"></span><br><span class="line">休息一会儿 196</span><br><span class="line"></span><br><span class="line">第9章 聚类 197</span><br><span class="line"></span><br><span class="line">9.1 聚类任务 197</span><br><span class="line"></span><br><span class="line">9.2 性能度量 197</span><br><span class="line"></span><br><span class="line">9.3 距离计算 199</span><br><span class="line"></span><br><span class="line">9.4 原型聚类 202</span><br><span class="line"></span><br><span class="line">9.4.1 k均值算法 202</span><br><span class="line"></span><br><span class="line">9.4.2 学习向量量化 204</span><br><span class="line"></span><br><span class="line">9.4.3 高斯混合聚类 206</span><br><span class="line"></span><br><span class="line">9.5 密度聚类 211</span><br><span class="line"></span><br><span class="line">9.6 层次聚类 214</span><br><span class="line"></span><br><span class="line">9.7 阅读材料 217</span><br><span class="line"></span><br><span class="line">习题 220</span><br><span class="line"></span><br><span class="line">参考文献 221</span><br><span class="line"></span><br><span class="line">休息一会儿 224</span><br><span class="line"></span><br><span class="line">第10章 降维与度量学习 225</span><br><span class="line"></span><br><span class="line">10.1 k近邻学习 225</span><br><span class="line"></span><br><span class="line">10.2 低维嵌入 226</span><br><span class="line"></span><br><span class="line">10.3 主成分分析 229</span><br><span class="line"></span><br><span class="line">10.4 核化线性降维 232</span><br><span class="line"></span><br><span class="line">10.5 流形学习 234</span><br><span class="line"></span><br><span class="line">10.5.1 等度量映射 234</span><br><span class="line"></span><br><span class="line">10.5.2 局部线性嵌入 235</span><br><span class="line"></span><br><span class="line">10.6 度量学习 237</span><br><span class="line"></span><br><span class="line">10.7 阅读材料 240</span><br><span class="line"></span><br><span class="line">习题 242</span><br><span class="line"></span><br><span class="line">参考文献 243</span><br><span class="line"></span><br><span class="line">休息一会儿 246</span><br><span class="line"></span><br><span class="line">第11章 特征选择与稀疏学习 247</span><br><span class="line"></span><br><span class="line">11.1 子集搜索与评价 247</span><br><span class="line"></span><br><span class="line">11.2 过滤式选择 249</span><br><span class="line"></span><br><span class="line">11.3 包裹式选择 250</span><br><span class="line"></span><br><span class="line">11.4 嵌入式选择与L$_1$正则化 252</span><br><span class="line"></span><br><span class="line">11.5 稀疏表示与字典学习 254</span><br><span class="line"></span><br><span class="line">11.6 压缩感知 257</span><br><span class="line"></span><br><span class="line">11.7 阅读材料 260</span><br><span class="line"></span><br><span class="line">习题 262</span><br><span class="line"></span><br><span class="line">参考文献 263</span><br><span class="line"></span><br><span class="line">休息一会儿 266</span><br><span class="line"></span><br><span class="line">第12章 计算学习理论 267</span><br><span class="line"></span><br><span class="line">12.1 基础知识 267</span><br><span class="line"></span><br><span class="line">12.2 PAC学习 268</span><br><span class="line"></span><br><span class="line">12.3 有限假设空间 270</span><br><span class="line"></span><br><span class="line">12.3.1 可分情形 270</span><br><span class="line"></span><br><span class="line">12.3.2 不可分情形 272</span><br><span class="line"></span><br><span class="line">12.4 VC维 273</span><br><span class="line"></span><br><span class="line">12.5 Rademacher复杂度 279</span><br><span class="line"></span><br><span class="line">12.6 稳定性 284</span><br><span class="line"></span><br><span class="line">12.7 阅读材料 287</span><br><span class="line"></span><br><span class="line">习题 289</span><br><span class="line"></span><br><span class="line">参考文献 290</span><br><span class="line"></span><br><span class="line">休息一会儿 292</span><br><span class="line"></span><br><span class="line">第13章 半监督学习 293</span><br><span class="line"></span><br><span class="line">13.1 未标记样本 293</span><br><span class="line"></span><br><span class="line">13.2 生成式方法 295</span><br><span class="line"></span><br><span class="line">13.3 半监督SVM 298</span><br><span class="line"></span><br><span class="line">13.4 图半监督学习 300</span><br><span class="line"></span><br><span class="line">13.5 基于分歧的方法 304</span><br><span class="line"></span><br><span class="line">13.6 半监督聚类 307</span><br><span class="line"></span><br><span class="line">13.7 阅读材料 311</span><br><span class="line"></span><br><span class="line">习题 313</span><br><span class="line"></span><br><span class="line">参考文献 314</span><br><span class="line"></span><br><span class="line">休息一会儿 317</span><br><span class="line"></span><br><span class="line">第14章 概率图模型 319</span><br><span class="line"></span><br><span class="line">14.1 隐马尔可夫模型 319</span><br><span class="line"></span><br><span class="line">14.2 马尔可夫随机场 322</span><br><span class="line"></span><br><span class="line">14.3 条件随机场 325</span><br><span class="line"></span><br><span class="line">14.4 学习与推断 328</span><br><span class="line"></span><br><span class="line">14.4.1 变量消去 328</span><br><span class="line"></span><br><span class="line">14.4.2 信念传播 330</span><br><span class="line"></span><br><span class="line">14.5 近似推断 331</span><br><span class="line"></span><br><span class="line">14.5.1 MCMC采样 331</span><br><span class="line"></span><br><span class="line">14.5.2 变分推断 334</span><br><span class="line"></span><br><span class="line">14.6 话题模型 337</span><br><span class="line"></span><br><span class="line">14.7 阅读材料 339</span><br><span class="line"></span><br><span class="line">习题 341</span><br><span class="line"></span><br><span class="line">参考文献 342</span><br><span class="line"></span><br><span class="line">休息一会儿 345</span><br><span class="line"></span><br><span class="line">第15章 规则学习 347</span><br><span class="line"></span><br><span class="line">15.1 基本概念 347</span><br><span class="line"></span><br><span class="line">15.2 序贯覆盖 349</span><br><span class="line"></span><br><span class="line">15.3 剪枝优化 352</span><br><span class="line"></span><br><span class="line">15.4 一阶规则学习 354</span><br><span class="line"></span><br><span class="line">15.5 归纳逻辑程序设计 357</span><br><span class="line"></span><br><span class="line">15.5.1 最小一般泛化 358</span><br><span class="line"></span><br><span class="line">15.5.2 逆归结 359</span><br><span class="line"></span><br><span class="line">15.6 阅读材料 363</span><br><span class="line"></span><br><span class="line">习题 365</span><br><span class="line"></span><br><span class="line">参考文献 366</span><br><span class="line"></span><br><span class="line">休息一会儿 369</span><br><span class="line"></span><br><span class="line">第16章 强化学习 371</span><br><span class="line"></span><br><span class="line">16.1 任务与奖赏 371</span><br><span class="line"></span><br><span class="line">16.2 $K$-摇臂赌博机 373</span><br><span class="line"></span><br><span class="line">16.2.1 探索与利用 373</span><br><span class="line"></span><br><span class="line">16.2.2 $\epsilon $-贪心 374</span><br><span class="line"></span><br><span class="line">16.2.3 Softmax 375</span><br><span class="line"></span><br><span class="line">16.3 有模型学习 377</span><br><span class="line"></span><br><span class="line">16.3.1 策略评估 377</span><br><span class="line"></span><br><span class="line">16.3.2 策略改进 379</span><br><span class="line"></span><br><span class="line">16.3.3 策略迭代与值迭代 381</span><br><span class="line"></span><br><span class="line">16.4 免模型学习 382</span><br><span class="line"></span><br><span class="line">16.4.1 蒙特卡罗强化学习 383</span><br><span class="line"></span><br><span class="line">16.4.2 时序差分学习 386</span><br><span class="line"></span><br><span class="line">16.5 值函数近似 388</span><br><span class="line"></span><br><span class="line">16.6 模仿学习 390</span><br><span class="line"></span><br><span class="line">16.6.1 直接模仿学习 391</span><br><span class="line"></span><br><span class="line">16.6.2 逆强化学习 391</span><br><span class="line"></span><br><span class="line">16.7 阅读材料 393</span><br><span class="line"></span><br><span class="line">习题 394</span><br><span class="line"></span><br><span class="line">参考文献 395</span><br><span class="line"></span><br><span class="line">休息一会儿 397</span><br><span class="line"></span><br><span class="line">附录 399</span><br><span class="line"></span><br><span class="line">A 矩阵 399</span><br><span class="line"></span><br><span class="line">B 优化 403</span><br><span class="line"></span><br><span class="line">C 概率分布 409</span><br><span class="line"></span><br><span class="line">后记 417</span><br><span class="line"></span><br><span class="line">索引 419</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：<a href="mailto:&#x79;&#x61;&#x6f;&#106;&#105;&#x61;&#110;&#x67;&#x75;&#111;&#108;&#113;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;">&#x79;&#x61;&#x6f;&#106;&#105;&#x61;&#110;&#x67;&#x75;&#111;&#108;&#113;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#111;&#109;</a></em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
</search>
