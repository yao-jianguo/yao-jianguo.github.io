<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>详解动态规划, 此一篇足矣！</title>
    <url>/posts/5faf7bc2/</url>
    <content><![CDATA[<p><img src="/images/b046fbe0f5ceead771b5ceeeaf5f7eed1.jpg" width="50%" height="50%"></p>
<p><em>六个案例由浅入深把动态规划说明白！！！</em><br><a id="more"></a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，先大致列下这篇文章会讲到什么</span><br><span class="line">    1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</span><br><span class="line">    2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</span><br><span class="line">一、动态规划带给我们的优势</span><br><span class="line">传统递归 vs. DP</span><br><span class="line">    1. 先 递归解决</span><br><span class="line">    2. 后 动态规划解决</span><br><span class="line">    3. 动态规划 + 优化</span><br><span class="line">二、动态规划四大解题步骤处理问题</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：定义状态转移方程</span><br><span class="line">    步骤三：初始化过程转移的初始值</span><br><span class="line">    步骤四：可优化点(可选)</span><br><span class="line">案例一：打家劫舍I 「来自leetcode198」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例二：不同路径「来自leetcode62」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例三：不同路径II 「来自leetcode63」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例四：打家劫舍II 「来自leetcode213」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例五：打家劫舍III 「来自leetcode337」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划 - 超详细系列</p>
<p>该文章较长，比较详细的阐述了动态规划思想，请耐心跟着思路走下去</p>
</blockquote>
<h2 id="动态规划-超详细系列"><a href="#动态规划-超详细系列" class="headerlink" title="动态规划 - 超详细系列"></a>动态规划 - 超详细系列</h2><p><strong>动态规划</strong>，一直以来听着就是一种很高深莫测的算法思想。尤其是上学时候算法的第一堂课，老师巴拉巴拉列了一大堆的算法核心思想，<strong>贪心、回溯、动态规划</strong>… …，开始感觉要在算法世界里游刃有余的进行解决各种各样牛B问题了，没想到的还是稀里糊涂学过了之后还就真的是学过了（大学的课程还真是一个样子）。再后来才明白，大学的课程一般来说就是入门级讲解，用来开拓眼界的，真正想要有一番自己的见解，必须要在背后下一番辛苦，形成自己的<strong>思考逻辑</strong>。</p>
<p>再后来返回头来看，<strong>动态规划</strong>理解起来还是比较困难，什么<strong>重叠子问题、动态转移方程，优化点</strong>等等等等，稀里糊涂，最后痛定思痛，好好看着其他人的分享理解了一部分，疯狂刷题几十道。算是基本可以佛挡杀佛了.</p>
<p>在我的这些学习积累过程中，总结出来希望可以给到大家一点小小的帮助，相信在读完这篇文章的时候，你会感觉到<strong>动态规划</strong>给你带来的奇妙之处。也一定对<strong>动态规划</strong>形成自己的<strong>思考方式</strong>.     很🐂的DP！！！</p>
<h2 id="首先，先大致列下这篇文章会讲到什么"><a href="#首先，先大致列下这篇文章会讲到什么" class="headerlink" title="首先，先大致列下这篇文章会讲到什么"></a>首先，先大致列下这篇文章会讲到什么</h2><h4 id="1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的"><a href="#1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的" class="headerlink" title="1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?"></a>1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</h4><h4 id="2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次"><a href="#2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次" class="headerlink" title="2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次."></a>2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</h4><p>看完本篇文章后，相信大家会对DP问题会有一个初步的思考，一定会入门。后面大家可以继续练习相关问题，熟能生巧，思考的多了就会形成自己的思维逻辑.</p>
<p>好了，话不多说，开搞…</p>
<h2 id="一、动态规划带给我们的优势"><a href="#一、动态规划带给我们的优势" class="headerlink" title="一、动态规划带给我们的优势"></a>一、动态规划带给我们的优势</h2><p><strong>很有趣，一定要看完，必定有收获，加油！💪💪💪</strong></p>
<p>平时在我们算法设计的过程中，一般讲求的是算法的执行效率和空间效率的利用情况</p>
<p>也就是我们熟知的<strong>时间复杂度</strong>（执行时耗费时间的长度）和<strong>空间复杂度</strong>（执行时占用存储单元的长度）</p>
<p>那下面用<strong>时间复杂度和空间复杂度</strong>来评估下<strong>传统算法设计</strong>和用<strong>动态规划思想</strong>解决下的效率情况</p>
<h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p>
<p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p>
<p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p>
<p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p>
<p>接下来咱们先来看题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure>
<p>比较一下传统递归解法和动态规划思想下的解决对比</p>
<h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_recur</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;F(&quot;</span>,self.i,<span class="string">&quot;) = &quot;</span>, N   <span class="comment"># 此处仅仅来看递归输出的N</span></span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">return</span> self.fib_recur(N-<span class="number">1</span>) + self.fib_recur(N-<span class="number">2</span>)  <span class="comment"># 递归输出</span></span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F( <span class="number">0</span> ) =  <span class="number">4</span></span><br><span class="line">F( <span class="number">1</span> ) =  <span class="number">3</span></span><br><span class="line">F( <span class="number">2</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">3</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">4</span> ) =  <span class="number">0</span></span><br><span class="line">F( <span class="number">5</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">6</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">7</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">8</span> ) =  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>重复计算</strong></p>
<p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p>
<p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p>
<p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p>
<blockquote>
<p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p>
<p>注意：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p>
</blockquote>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106361.jpg" width="50%" height="50%"></p>
<p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗. </p>
<p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p>
<p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效. </p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106362.jpg" width="50%" height="50%"></p>
<blockquote>
<p>时间复杂度：$O(2^N)$   —-&gt; 指数级</p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p>
<p><strong>动态规划：</strong>我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用<strong>过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p>
<p><strong>规划：</strong>在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的<strong>一维表格</strong>还是复杂一点的<strong>二维表格</strong>，都是以<strong>开辟空间换时间</strong>的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p>
<p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p>
<p>因此，动态规划可以避免重复计算，达到了时间上的最优，从$O(2^N)$指数级变为$O(N)$常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p>
<p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p>
<p>依据题中的规则：</p>
<p>F(0) = 0, F(1) = 1</p>
<p>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</p>
<p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1<br>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   —&gt;  保存 F(2)<br>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   —&gt;  保存 F(3)<br>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   —&gt;  保存 F(4)</p>
<p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106363.jpg" width="50%" height="50%"></p>
<p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p>
<p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p>
<p>​    a. <strong>定义一个一维数组</strong>   —-&gt;  一般用dp来命名</p>
<p>​    b. <strong>动态方程的设定</strong>   —-&gt;  题中的F(N) = F(N - 1) + F(N - 2)</p>
<p>​    c. <strong>初始化数值</strong>   —-&gt;  F(0) = 0和F(1) = 1</p>
<p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p>
<p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 1定义dp[i]保存第i个计算得到的数值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>       <span class="comment"># 2初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>            <span class="comment"># 2初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):    <span class="comment"># 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span> dp         <span class="comment"># 记录计算过程中的次数，与上述递归形成对比</span></span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p>
<blockquote>
<p>时间复杂度：$O(N)$ </p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong> </p>
<hr>
<p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p>
<h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106364.jpg" width="50%" height="50%"></p>
<p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106365.jpg" width="50%" height="50%"><br>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   —&gt;  保存 F(2)</p>
<p>​    顺带将F(1)赋值给dp1， f(2)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106366.jpg" width="50%" height="50%"></p>
<p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   —&gt;  保存 F(3)</p>
<p>​    顺带将F(2)赋值给dp1， F(3)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106367.jpg" width="50%" height="50%"></p>
<p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   —&gt;  保存 F(4)</p>
<p>​    顺带将F(3)赋值给dp1， F(4)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106368.jpg" width="50%" height="50%"></p>
<p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p>
<p>咱们把代码也贴一下吧，供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_dp1</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<p>看起来是不是更加简洁了。</p>
<p>洋洋洒洒不知不觉写了这么多了。</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<p>大家感觉这个例子怎么样，三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p>
<p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p>
<p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜<br><img src="/images/20521cf21f76b9359a5c9dbbeda106369.jpg" width="50%" height="50%"></p>
<blockquote>
<p>到这里有没有一种对动态规划的感觉了</p>
<p>文章较长，可以先关注或者收藏，也可以关注「计算广告生态」，回复“DP”获取本文pdf文件哦</p>
</blockquote>
<h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p>
<p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p>
<blockquote>
<p>步骤一：定义dp数组的含义</p>
<p>步骤二：定义状态转移方程</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>步骤四：可优化点(可选)</p>
</blockquote>
<h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p>
<p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p>
<h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p>
<p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p>
<h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p>
<p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p>
<p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p>
<h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p>
<p>在例子中，我们会进行不同的优化. </p>
<p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了. </p>
<h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>
<p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p>
<p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。  然后严格按照四步骤进行解题. </p>
<h5 id="步骤一：-定义dp数组的含义"><a href="#步骤一：-定义dp数组的含义" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p>
<p>​    <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p>
<p>​    也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p>
<p>​    该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p>
<p>​    a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] =  nums[i-1] + dp[i-2]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063610.jpg" width="50%" height="50%"></p>
<p>​    b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] =  dp[i-1]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063611.jpg" width="50%" height="50%"></p>
<p>​    最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p>
<p>​    <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p>
<h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        1 当size=0时，没有房子，dp[0]=0；<br>​        2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p>
<p>那么，按照这个思路来整理一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">      <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">      <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span></span><br><span class="line">      <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">      <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">      <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line">      size = <span class="built_in">len</span>(nums)</span><br><span class="line">      <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
</blockquote>
<p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p>
<h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p>
<p>​    所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob_o</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span></span><br><span class="line">        <span class="comment"># 因此，我们可以使用两个变量来存放前两个状态值</span></span><br><span class="line">        <span class="comment"># 空间使用由O(N) -&gt; O(1)</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        dp2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p>
<p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063612.jpg" width="50%" height="50%"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><em>提示：</em></p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>下面依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>​    当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p>
<p>​    <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p>
<p>​    即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p>
<h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p>
<p>​    那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p>
<p>​    <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p>
<h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p>
<p>​    因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p>
<p>​    因此初始值如下：</p>
<p>​    <strong>dp[0] [0….n-1] = 1;</strong>  // 机器人一直向右走，第 0 列统统为 1</p>
<p>​    <strong>dp[0…m-1] [0] = 1;</strong>  // 机器人一直向下走，第 0 列统统为 1</p>
<p>​    现在，按照这个思路来整理一下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths1</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码中由于dp[0..m][1] 或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p>
<p>然后从位置(1, 1)开始计算每个位置的总路径数</p>
<blockquote>
<p>时间复杂度：O(M*N)</p>
<p>空间复杂度：O(M*N)</p>
</blockquote>
<p>既然到这里了，下面再想想看有没有可优化的地方</p>
<h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p>
<p>​    参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p>
<p>​    现在这个例子中的动态方程是<strong>dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong>，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3*4 来举例）：</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063613.jpg" width="50%" height="50%"></p>
<p>​    这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p>
<p>​    因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p>
<p>​    看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p>
<p>​    <strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。 其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p>
<p>​    <strong>这块大家一定多想想，多理解，多画图</strong></p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063614.jpg" width="50%" height="50%"></p>
<p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063615.jpg" width="50%" height="50%"></p>
<p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p>
<p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths2</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(min(m ,n))</p>
</blockquote>
<p>是不是从思维方面简单干净了许多</p>
<p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p>
<p>来看:</p>
<h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063616.jpg" width="50%" height="50%"></p>
<blockquote>
<p>说明：m 和 n 的值均不超过 100。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>咱们先看一下题中的两个关键点：</strong><br>关键点1：只能向右或者向下<br>关键点2：有障碍物为1， 无障碍物为0</p>
<p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>  这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间<br>  那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p>
<h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>  参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]<br>  由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件<br>  a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程<br>  b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p>
<p>  所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p>
<h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法<br>​    但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063617.jpg" width="50%" height="50%"></p>
<p>​    所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p>
<p>​    <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p>
<p>​    只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 行初始化表达式: </span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0 列初始化表达式: </span></span><br><span class="line">obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>  这些都准备就绪之后，按照相关思路进行编码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles1</span>(<span class="params">self, obstacleGrid</span>):</span></span><br><span class="line">          <span class="comment"># 行列长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果在位置(0, 0)，哪里都去不了，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，位置(0, 0)可以到达</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 列</span></span><br><span class="line">        <span class="keyword">for</span> clo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从位置(1, 1)根据动态方程开始计算</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>时间复杂度: O(mxn)</p>
<p>空间复杂度: O(1)</p>
</blockquote>
<h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p>
<p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p>
<p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p>
<h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p>
<p>a. 不偷首偷尾</p>
<p>b. 偷首不偷尾</p>
<p>c. 首位都不偷<br>显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。<br>那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p>
<p>下面依然按照之前的四个步骤来进行分析</p>
<h5 id="步骤一：-定义dp数组的含义-1"><a href="#步骤一：-定义dp数组的含义-1" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p>
<p>​    所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p>
<p>​    <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p>
<h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；<br>​        b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063618.jpg" width="50%" height="50%"></p>
<p>​    由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p>
<p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p>
<h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p>
<p>​    代码中有详细的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 点睛：与打家劫舍I的区别是屋子围成了一个环</span></span><br><span class="line">        <span class="comment">#   那么，很明显可以分为三种情况：</span></span><br><span class="line">        <span class="comment">#   1. 首位都不偷</span></span><br><span class="line">        <span class="comment">#   2. 偷首不偷尾</span></span><br><span class="line">        <span class="comment">#   3. 不偷首偷尾</span></span><br><span class="line">        <span class="comment"># 显然，第1种方式损失太大，选取2、3。</span></span><br><span class="line">        <span class="comment"># 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">        <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])</span></span><br><span class="line">        <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">        <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">        <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依照《打家劫舍I》的优化方案进行计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># nums处理，分别切割出去首和去尾的子串</span></span><br><span class="line">        nums1 = nums[<span class="number">1</span>:]</span><br><span class="line">        nums2 = nums[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">size, nums</span>):</span></span><br><span class="line">            dp1 = <span class="number">0</span></span><br><span class="line">            dp2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">                dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">                dp1, dp2 = dp2, dp1</span><br><span class="line">            <span class="keyword">return</span> dp2</span><br><span class="line"></span><br><span class="line">        res1 = handle(size-<span class="number">1</span>, nums1)</span><br><span class="line">        res2 = handle(size-<span class="number">1</span>, nums2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p>
<h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9.</span></span><br></pre></td></tr></table></figure>
<p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p>
<p>言归正传，咱们先来说说题目本身</p>
<p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p>
<p>来整理几点思路，再来按照四步走：</p>
<p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)<br>2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历<br>3.得到每一节点的最优值，最后选取最优的结果</p>
<p>依然按照三个步骤来进行分析（无优化点）</p>
<h5 id="步骤一：-定义dp数组的含义-2"><a href="#步骤一：-定义dp数组的含义-2" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p>
<h5 id="步骤二：找出关系元素间的动态方程-4"><a href="#步骤二：找出关系元素间的动态方程-4" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 <strong>不偷(0)</strong>。我们分开来讨论：</p>
<p>​    a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p>
<p>​        所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p>
<p>​    b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p>
<p>​        所以：<strong>dp[1] = value + left[0] + right[0]</strong>  (value代表该节点的价值)</p>
<p>​    有看不懂的地方吗？再紧接着解释一下：</p>
<p>​        left[0]代表不偷取左孩子拿到最高的金额</p>
<p>​        left[1]代表偷取左孩子拿到最高的金额</p>
<p>​        right[0]代表不偷取右孩子拿到最高的金额</p>
<p>​        right[1]代表偷取右孩子拿到最高的金额</p>
<p>​    <em>如果还有不太懂的话，留言或者私信我联系我，随时骚扰我哈</em></p>
<h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p>
<p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 说明：</span></span><br><span class="line">        <span class="comment"># 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span></span><br><span class="line">        <span class="comment"># 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span></span><br><span class="line">        <span class="comment"># 3.得到每一节点的最优值，最后选取最优的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i]代表该节点及以下拿到的最多的钱</span></span><br><span class="line">        <span class="comment"># 2.动态方程：</span></span><br><span class="line">        <span class="comment">#   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span></span><br><span class="line">        <span class="comment">#   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span></span><br><span class="line">        <span class="comment"># 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postTrasval</span>(<span class="params">root</span>):</span></span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dp</span><br><span class="line"></span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># initial tree structure</span></span><br><span class="line">    T = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    T.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.right.right = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The solution to the Question</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.rob(T))</span><br></pre></td></tr></table></figure>
<p>至此为止，想要讲解的全部完毕了</p>
<p>洋洋洒洒过万字，自己都没想到写了这么多</p>
<p>在强调一点吧，这些题目全部理解 外加 自己另外练习，一定能够cover<strong>关于动态规划80%以上的题目</strong>，基本上都是dp为一维数组，二维数组的题目，很少有很奇怪的题型出现。所以，本文将《打家劫舍》经典案例详细讲解了一次，还有不同路径的问题，也是很经典的题目，而经典题目一定很具有代表性。优化方向很多，本文也只介绍了关于空间方面的优化，因为这个是最最常见的。</p>
<p>最后，大家一定多画图，多思考，题解百边其义自见（百边有点多哈哈哈）</p>
<p>还有，多理解四步骤， 加油！</p>
<p>后面有机会再细致的分享其他常见算法思想的文章</p>
<p>如果感觉对大家有帮助，不妨关注、点赞、转发起来哦！！！</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>几百本互联网图书PDF全部放出</title>
    <url>/posts/77172009/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<p><strong>【电子书籍】坚持书籍分享 … 完善中 …</strong></p>
<p><strong>【要善用Command/Ctrl+F查找资料哦】</strong></p>
<p>零、互联网面试书籍集合</p>
<p>一、计算机技术语言类</p>
<p>二、数据结构和算法</p>
<p>三、Python技术</p>
<p>四、大数据技术</p>
<p>五、机器学习和人工智能AI</p>
<p>六、其他书籍</p>
<p><strong>按需寻找哦！ 链接如果失效，随时随地联系作者 (^o^)/~</strong></p>
<hr>
<h4 id="零、互联网面试书籍集合"><a href="#零、互联网面试书籍集合" class="headerlink" title="零、互联网面试书籍集合"></a>零、互联网面试书籍集合</h4><h6 id="1-《labuladong的算法小抄官方完整版》"><a href="#1-《labuladong的算法小抄官方完整版》" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> </p>
<p>密码: 密码:KfGM</p>
<h6 id="3-《剑指offer名企面试官精讲典型编程题》"><a href="#3-《剑指offer名企面试官精讲典型编程题》" class="headerlink" title="3.《剑指offer名企面试官精讲典型编程题》"></a>3.《剑指offer名企面试官精讲典型编程题》</h6><p>链接: <a href="https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw">https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw</a>  </p>
<p>密码: jnnl</p>
<h6 id="4-《阿里Java面试问题大全》"><a href="#4-《阿里Java面试问题大全》" class="headerlink" title="4.《阿里Java面试问题大全》"></a>4.《阿里Java面试问题大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ">https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ</a> </p>
<p>提取码: es6v</p>
<h6 id="5-《程序员面试宝典》"><a href="#5-《程序员面试宝典》" class="headerlink" title="5.《程序员面试宝典》"></a>5.《程序员面试宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ">https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ</a> </p>
<p>提取码: aske</p>
<h4 id="一、计算机技术语言类"><a href="#一、计算机技术语言类" class="headerlink" title="一、计算机技术语言类"></a>一、计算机技术语言类</h4><h5 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h5><h6 id="1-《C和指针》-C语言经典书籍"><a href="#1-《C和指针》-C语言经典书籍" class="headerlink" title="1. 《C和指针》 C语言经典书籍"></a>1. 《C和指针》 C语言经典书籍</h6><p>PDF链接:<a href="https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ">https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ</a>  </p>
<p>密码:dr1q</p>
<h6 id="2-《啊哈c语言》"><a href="#2-《啊哈c语言》" class="headerlink" title="2. 《啊哈c语言》"></a>2. 《啊哈c语言》</h6><p>链接:<a href="https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA">https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA</a>  </p>
<p>密码:gi21</p>
<h6 id="3-《c-primerplus6》-C-经典书籍"><a href="#3-《c-primerplus6》-C-经典书籍" class="headerlink" title="3. 《c++primerplus6》 C++经典书籍"></a>3. 《c++primerplus6》 C++经典书籍</h6><p>链接:<a href="https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw">https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw</a>  </p>
<p>密码:0kat</p>
<h6 id="4-《深入探索C-对象模型》"><a href="#4-《深入探索C-对象模型》" class="headerlink" title="4. 《深入探索C++对象模型》"></a>4. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ">https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ</a> </p>
<p>提取码: k98m</p>
<h6 id="5-《C-编程规范-101条规则准则与最佳实践》"><a href="#5-《C-编程规范-101条规则准则与最佳实践》" class="headerlink" title="5. 《C++编程规范-101条规则准则与最佳实践》"></a>5. 《C++编程规范-101条规则准则与最佳实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="6-《C-编程思想两卷合订本》"><a href="#6-《C-编程思想两卷合订本》" class="headerlink" title="6. 《C++编程思想两卷合订本》"></a>6. 《C++编程思想两卷合订本》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="7-《C-沉思录中文第2版》"><a href="#7-《C-沉思录中文第2版》" class="headerlink" title="7. 《C++沉思录中文第2版》"></a>7. 《C++沉思录中文第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA">https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA</a> </p>
<p>提取码: 4rk1</p>
<h6 id="8-《C-大学教程》"><a href="#8-《C-大学教程》" class="headerlink" title="8. 《C++大学教程》"></a>8. 《C++大学教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g">https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g</a> </p>
<p>提取码: 1ine</p>
<h6 id="9-《深入探索C-对象模型》"><a href="#9-《深入探索C-对象模型》" class="headerlink" title="9. 《深入探索C++对象模型》"></a>9. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw">https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw</a> </p>
<p>提取码: s4ht</p>
<h6 id="10-《C-设计新思维-泛型编程与设计之应用》"><a href="#10-《C-设计新思维-泛型编程与设计之应用》" class="headerlink" title="10. 《C++设计新思维-泛型编程与设计之应用》"></a>10. 《C++设计新思维-泛型编程与设计之应用》</h6><p>链接: <a href="https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw">https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw</a> </p>
<p>提取码: a73e</p>
<h6 id="11-《C-primer5th》"><a href="#11-《C-primer5th》" class="headerlink" title="11. 《C++primer5th》"></a>11. 《C++primer5th》</h6><p>链接: <a href="https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g">https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g</a> </p>
<p>提取码: f66t</p>
<h6 id="12-《C-Templates》"><a href="#12-《C-Templates》" class="headerlink" title="12. 《C++ Templates》"></a>12. 《C++ Templates》</h6><p>链接: <a href="https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ">https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ</a> </p>
<p>提取码: bhmc</p>
<h6 id="13-《C语言编程精粹》"><a href="#13-《C语言编程精粹》" class="headerlink" title="13. 《C语言编程精粹》"></a>13. 《C语言编程精粹》</h6><p>链接: <a href="https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw">https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw</a> </p>
<p>提取码: xvas</p>
<h6 id="14-《C语言参考手册第五版》"><a href="#14-《C语言参考手册第五版》" class="headerlink" title="14. 《C语言参考手册第五版》"></a>14. 《C语言参考手册第五版》</h6><p>链接: <a href="https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg">https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg</a> </p>
<p>提取码: x3ns</p>
<h6 id="15-《C语言解析教程》"><a href="#15-《C语言解析教程》" class="headerlink" title="15. 《C语言解析教程》"></a>15. 《C语言解析教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg">https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg</a> </p>
<p>提取码: hn2i</p>
<h6 id="16-《C语言深度解剖》"><a href="#16-《C语言深度解剖》" class="headerlink" title="16. 《C语言深度解剖》"></a>16. 《C语言深度解剖》</h6><p>链接: <a href="https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww">https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww</a> </p>
<p>提取码: ggfh</p>
<h6 id="17-《C专家编程》"><a href="#17-《C专家编程》" class="headerlink" title="17. 《C专家编程》"></a>17. 《C专家编程》</h6><p>链接: <a href="https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw">https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw</a> </p>
<p>提取码: c8fu</p>
<h6 id="18-《EffectiveSTL中文版》"><a href="#18-《EffectiveSTL中文版》" class="headerlink" title="18. 《EffectiveSTL中文版》"></a>18. 《EffectiveSTL中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA">https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA</a> </p>
<p>提取码: arzc</p>
<h6 id="19-《MoreEffectiveC-中文版》"><a href="#19-《MoreEffectiveC-中文版》" class="headerlink" title="19. 《MoreEffectiveC++中文版》"></a>19. 《MoreEffectiveC++中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g">https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g</a> </p>
<p>提取码: qdd3</p>
<h6 id="20-《STL源码剖析》"><a href="#20-《STL源码剖析》" class="headerlink" title="20. 《STL源码剖析》"></a>20. 《STL源码剖析》</h6><p>链接: <a href="https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ">https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ</a> </p>
<p>提取码: w9x8</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><h6 id="1-《Java核心技术-卷1-基础知识-原书第9版》"><a href="#1-《Java核心技术-卷1-基础知识-原书第9版》" class="headerlink" title="1. 《Java核心技术 卷1 基础知识 原书第9版》"></a>1. 《Java核心技术 卷1 基础知识 原书第9版》</h6><p>链接:<a href="https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw">https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw</a>  </p>
<p>密码:x1x3</p>
<h6 id="2-《阿里巴巴Java开发手册》"><a href="#2-《阿里巴巴Java开发手册》" class="headerlink" title="2. 《阿里巴巴Java开发手册》"></a>2. 《阿里巴巴Java开发手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ">https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ</a> </p>
<p>提取码: w6gc</p>
<h6 id="3-《码出高效》Java开发手册"><a href="#3-《码出高效》Java开发手册" class="headerlink" title="3. 《码出高效》Java开发手册"></a>3. 《码出高效》Java开发手册</h6><p>链接: <a href="https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg">https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg</a> </p>
<p>提取码: sqhe</p>
<h6 id="3-《轻量级JavaEE企业应用实战》"><a href="#3-《轻量级JavaEE企业应用实战》" class="headerlink" title="3. 《轻量级JavaEE企业应用实战》"></a>3. 《轻量级JavaEE企业应用实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ">https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ</a> </p>
<p>提取码: rtzw</p>
<h6 id="4-《深入分析JavaWeb技术内幕》"><a href="#4-《深入分析JavaWeb技术内幕》" class="headerlink" title="4. 《深入分析JavaWeb技术内幕》"></a>4. 《深入分析JavaWeb技术内幕》</h6><p>链接: <a href="https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ">https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ</a> </p>
<p>提取码: vivd</p>
<h6 id="5-《深入理解Java虚拟机第二版》"><a href="#5-《深入理解Java虚拟机第二版》" class="headerlink" title="5. 《深入理解Java虚拟机第二版》"></a>5. 《深入理解Java虚拟机第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA">https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA</a> </p>
<p>提取码: jj6z</p>
<h6 id="6-《深入剖析Tomcat》"><a href="#6-《深入剖析Tomcat》" class="headerlink" title="6. 《深入剖析Tomcat》"></a>6. 《深入剖析Tomcat》</h6><p>链接: <a href="https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg">https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg</a> </p>
<p>提取码: p42w</p>
<h6 id="7-《Java8实战》"><a href="#7-《Java8实战》" class="headerlink" title="7. 《Java8实战》"></a>7. 《Java8实战》</h6><p>链接: <a href="https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ">https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ</a> </p>
<p>提取码: hh1e</p>
<h6 id="8-《JAVA并发编程实践》"><a href="#8-《JAVA并发编程实践》" class="headerlink" title="8. 《JAVA并发编程实践》"></a>8. 《JAVA并发编程实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw">https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw</a> </p>
<p>提取码: tcvd</p>
<h6 id="9-《EffectiveJava中文第二版》"><a href="#9-《EffectiveJava中文第二版》" class="headerlink" title="9. 《EffectiveJava中文第二版》"></a>9. 《EffectiveJava中文第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA">https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA</a> </p>
<p>提取码: ankv</p>
<h6 id="10-《HeadFirstJava第二版涵盖java5-0》"><a href="#10-《HeadFirstJava第二版涵盖java5-0》" class="headerlink" title="10. 《HeadFirstJava第二版涵盖java5.0》"></a>10. 《HeadFirstJava第二版涵盖java5.0》</h6><p>链接: <a href="https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng">https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng</a> </p>
<p>提取码: bmkj</p>
<h6 id="11-《HeadFirstServletandJSP》-高清中文版"><a href="#11-《HeadFirstServletandJSP》-高清中文版" class="headerlink" title="11. 《HeadFirstServletandJSP》(高清中文版)"></a>11. 《HeadFirstServletandJSP》(高清中文版)</h6><p>链接: <a href="https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA">https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA</a> </p>
<p>提取码: vkmk</p>
<h6 id="12-《Java从小白到大牛精简版》"><a href="#12-《Java从小白到大牛精简版》" class="headerlink" title="12. 《Java从小白到大牛精简版》"></a>12. 《Java从小白到大牛精简版》</h6><p>链接: <a href="https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw">https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw</a> </p>
<p>提取码: mz9r</p>
<h6 id="13-《Java核心技术卷1第8版》"><a href="#13-《Java核心技术卷1第8版》" class="headerlink" title="13. 《Java核心技术卷1第8版》"></a>13. 《Java核心技术卷1第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA">https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA</a> </p>
<p>提取码: 9i6e</p>
<h6 id="14-《Java核心技术卷2第8版》"><a href="#14-《Java核心技术卷2第8版》" class="headerlink" title="14. 《Java核心技术卷2第8版》"></a>14. 《Java核心技术卷2第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg">https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg</a> </p>
<p>提取码: x58i</p>
<h6 id="15-《Java性能优化权威指南》"><a href="#15-《Java性能优化权威指南》" class="headerlink" title="15. 《Java性能优化权威指南》"></a>15. 《Java性能优化权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw">https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw</a> </p>
<p>提取码: 8emi</p>
<h6 id="16-《Spring-实战-中文版第4版》"><a href="#16-《Spring-实战-中文版第4版》" class="headerlink" title="16. 《Spring 实战 中文版第4版》"></a>16. 《Spring 实战 中文版第4版》</h6><p>链接: <a href="https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w">https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w</a> </p>
<p>提取码: gea5</p>
<h4 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="1-《大话数据结构》"><a href="#1-《大话数据结构》" class="headerlink" title="1. 《大话数据结构》"></a>1. 《大话数据结构》</h6><p>链接: <a href="https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA">https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA</a> </p>
<p>提取码: 8i5k</p>
<h6 id="2-《Java数据结构和算法》-第二版"><a href="#2-《Java数据结构和算法》-第二版" class="headerlink" title="2. 《Java数据结构和算法》 第二版"></a>2. 《Java数据结构和算法》 第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw">https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw</a> </p>
<p>提取码: f6y5</p>
<h5 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h5><h6 id="1-《labuladong的算法小抄官方完整版》-1"><a href="#1-《labuladong的算法小抄官方完整版》-1" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a><br>提取码：KfGM</p>
<h6 id="2-动态规划总结文档"><a href="#2-动态规划总结文档" class="headerlink" title="2. 动态规划总结文档"></a>2. 动态规划总结文档</h6><p>对动态规划的理解还是差那么一点？这一篇帮你安排的明明白白！</p>
<h6 id="3-《算法导论》"><a href="#3-《算法导论》" class="headerlink" title="3. 《算法导论》"></a>3. 《算法导论》</h6><p>链接: <a href="https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw">https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw</a>  </p>
<p>密码: s3sh</p>
<h6 id="4-《啊哈算法》"><a href="#4-《啊哈算法》" class="headerlink" title="4. 《啊哈算法》"></a>4. 《啊哈算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="5-《编程珠玑第二版》"><a href="#5-《编程珠玑第二版》" class="headerlink" title="5. 《编程珠玑第二版》"></a>5. 《编程珠玑第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="6-《算法图解》"><a href="#6-《算法图解》" class="headerlink" title="6. 《算法图解》"></a>6. 《算法图解》</h6><p>链接: <a href="https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ">https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ</a> </p>
<p>提取码: r7wa</p>
<h5 id="周边算法思想"><a href="#周边算法思想" class="headerlink" title="周边算法思想"></a>周边算法思想</h5><h4 id="三、Python技术"><a href="#三、Python技术" class="headerlink" title="三、Python技术"></a>三、Python技术</h4><h5 id="Python-语言"><a href="#Python-语言" class="headerlink" title="Python 语言"></a>Python 语言</h5><h6 id="1-《Python进阶》"><a href="#1-《Python进阶》" class="headerlink" title="1. 《Python进阶》"></a>1. 《Python进阶》</h6><p>链接:<a href="https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg">https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg</a>  </p>
<p>密码:u9u0</p>
<h6 id="2-《Python基础教程（第二版）》"><a href="#2-《Python基础教程（第二版）》" class="headerlink" title="2. 《Python基础教程（第二版）》"></a>2. 《Python基础教程（第二版）》</h6><p>链接: <a href="https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw">https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw</a>  </p>
<p>密码: lam6</p>
<h6 id="3-《Python核心编程第二版中文》"><a href="#3-《Python核心编程第二版中文》" class="headerlink" title="3. 《Python核心编程第二版中文》"></a>3. 《Python核心编程第二版中文》</h6><p>链接: <a href="https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ">https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ</a>  </p>
<p>密码: hq9b</p>
<h6 id="4-《Python开发实战》"><a href="#4-《Python开发实战》" class="headerlink" title="4. 《Python开发实战》"></a>4. 《Python开发实战》</h6><p>链接: <a href="https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA">https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA</a> </p>
<p>提取码: 2bnj</p>
<h6 id="5-《Python开发技术详解》"><a href="#5-《Python开发技术详解》" class="headerlink" title="5. 《Python开发技术详解》"></a>5. 《Python开发技术详解》</h6><p>链接: <a href="https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw">https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw</a> </p>
<p>提取码: 3kjn</p>
<h6 id="6-《Python灰帽子黑客与逆向工程师的Python编程之道》"><a href="#6-《Python灰帽子黑客与逆向工程师的Python编程之道》" class="headerlink" title="6. 《Python灰帽子黑客与逆向工程师的Python编程之道》"></a>6. 《Python灰帽子黑客与逆向工程师的Python编程之道》</h6><p>链接: <a href="https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA">https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA</a> </p>
<p>提取码: ev5v</p>
<h6 id="7-《Python高级编程第2版》"><a href="#7-《Python高级编程第2版》" class="headerlink" title="7. 《Python高级编程第2版》"></a>7. 《Python高级编程第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw">https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw</a> </p>
<p>提取码: 62qy</p>
<h6 id="8-《Python编程入门经典》"><a href="#8-《Python编程入门经典》" class="headerlink" title="8. 《Python编程入门经典》"></a>8. 《Python编程入门经典》</h6><p>链接: <a href="https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ">https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ</a> </p>
<p>提取码: g4pr</p>
<h6 id="9-《Python编程初学者指南》"><a href="#9-《Python编程初学者指南》" class="headerlink" title="9. 《Python编程初学者指南》"></a>9. 《Python编程初学者指南》</h6><p>链接: <a href="https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw">https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw</a> </p>
<p>提取码: k86q</p>
<h6 id="10-《Python网络编程基础》"><a href="#10-《Python网络编程基础》" class="headerlink" title="10. 《Python网络编程基础》"></a>10. 《Python网络编程基础》</h6><p>链接: <a href="https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA">https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA</a> </p>
<p>提取码: vy2t</p>
<h6 id="11-《Python学习手册》"><a href="#11-《Python学习手册》" class="headerlink" title="11. 《Python学习手册》"></a>11. 《Python学习手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ">https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ</a> </p>
<p>提取码: nikm</p>
<h6 id="12-《Python学习手册》-第4版"><a href="#12-《Python学习手册》-第4版" class="headerlink" title="12. 《Python学习手册》 第4版"></a>12. 《Python学习手册》 第4版</h6><p>链接: <a href="https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg">https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg</a> </p>
<p>提取码: arcd</p>
<h6 id="13-《用Python写网络爬虫》"><a href="#13-《用Python写网络爬虫》" class="headerlink" title="13. 《用Python写网络爬虫》"></a>13. 《用Python写网络爬虫》</h6><p>链接: <a href="https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA">https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA</a> </p>
<p>提取码: wm92</p>
<h5 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h5><h6 id="1-《利用Python进行数据分析》"><a href="#1-《利用Python进行数据分析》" class="headerlink" title="1. 《利用Python进行数据分析》"></a>1. 《利用Python进行数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g">https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g</a>  </p>
<p>密码: qune</p>
<h6 id="2-《NumPy学习指南（第2版）》"><a href="#2-《NumPy学习指南（第2版）》" class="headerlink" title="2. 《NumPy学习指南（第2版）》"></a>2. 《NumPy学习指南（第2版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw">https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw</a>  </p>
<p>密码:3nwc</p>
<h6 id="3-《常用的数据分析方法》"><a href="#3-《常用的数据分析方法》" class="headerlink" title="3. 《常用的数据分析方法》"></a>3. 《常用的数据分析方法》</h6><p>链接: <a href="https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g">https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g</a> </p>
<p>提取码: u8p6</p>
<h6 id="4-《Python数据处理》"><a href="#4-《Python数据处理》" class="headerlink" title="4. 《Python数据处理》"></a>4. 《Python数据处理》</h6><p>链接: <a href="https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g">https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g</a> </p>
<p>提取码: m42q</p>
<h6 id="5-《Python金融大数据分析》"><a href="#5-《Python金融大数据分析》" class="headerlink" title="5. 《Python金融大数据分析》"></a>5. 《Python金融大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ">https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ</a> </p>
<p>提取码: rpqw</p>
<h6 id="6-《Python数据分析与挖掘实战》"><a href="#6-《Python数据分析与挖掘实战》" class="headerlink" title="6. 《Python数据分析与挖掘实战》"></a>6. 《Python数据分析与挖掘实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg">https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg</a> </p>
<p>提取码: evbm</p>
<h6 id="7-《Python数据科学手册》"><a href="#7-《Python数据科学手册》" class="headerlink" title="7. 《Python数据科学手册》"></a>7. 《Python数据科学手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw">https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw</a> </p>
<p>提取码: qyqh</p>
<h6 id="8-《Python数据可视化编程实战》"><a href="#8-《Python数据可视化编程实战》" class="headerlink" title="8. 《Python数据可视化编程实战》"></a>8. 《Python数据可视化编程实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw">https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw</a> </p>
<p>提取码: b3sb</p>
<h6 id="9-《PYTHON自然语言处理中文版》"><a href="#9-《PYTHON自然语言处理中文版》" class="headerlink" title="9. 《PYTHON自然语言处理中文版》"></a>9. 《PYTHON自然语言处理中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA">https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA</a> </p>
<p>提取码: k8bs</p>
<h4 id="四、大数据技术"><a href="#四、大数据技术" class="headerlink" title="四、大数据技术"></a>四、大数据技术</h4><h5 id="大数据技术基础"><a href="#大数据技术基础" class="headerlink" title="大数据技术基础"></a>大数据技术基础</h5><h6 id="1-《Hadoop全权威指南第三版（原版）》"><a href="#1-《Hadoop全权威指南第三版（原版）》" class="headerlink" title="1.《Hadoop全权威指南第三版（原版）》"></a>1.《Hadoop全权威指南第三版（原版）》</h6><p>链接: <a href="https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww">https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww</a>  </p>
<p>密码: 29li</p>
<h6 id="2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"><a href="#2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理" class="headerlink" title="2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"></a>2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ">https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ</a> </p>
<p>提取码: c3gx</p>
<h6 id="3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理"><a href="#3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理" class="headerlink" title="3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理"></a>3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg">https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg</a> </p>
<p>提取码: bdje</p>
<h6 id="4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"><a href="#4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理" class="headerlink" title="4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"></a>4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w">https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w</a> </p>
<p>提取码: wfks</p>
<h6 id="5-《Spark快速大数据分析》"><a href="#5-《Spark快速大数据分析》" class="headerlink" title="5.《Spark快速大数据分析》"></a>5.《Spark快速大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA">https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA</a> </p>
<p>提取码: i6av</p>
<h5 id="大数据平台开源工具"><a href="#大数据平台开源工具" class="headerlink" title="大数据平台开源工具"></a>大数据平台开源工具</h5><h5 id="大数据集群"><a href="#大数据集群" class="headerlink" title="大数据集群"></a>大数据集群</h5><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA">https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA</a> </p>
<p>提取码: c276</p>
<h6 id="2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg">https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg</a> </p>
<p>提取码: x4ej</p>
<h6 id="3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列"><a href="#3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列" class="headerlink" title="3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)"></a>3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)</h6><p>链接: <a href="https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg">https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg</a> </p>
<p>提取码: ktff</p>
<h6 id="4-《Linux宝典》"><a href="#4-《Linux宝典》" class="headerlink" title="4. 《Linux宝典》"></a>4. 《Linux宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w">https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w</a> </p>
<p>提取码: 6rxa</p>
<h6 id="5-《linux常用命令大全》"><a href="#5-《linux常用命令大全》" class="headerlink" title="5. 《linux常用命令大全》"></a>5. 《linux常用命令大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww">https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww</a> </p>
<p>提取码: bsce</p>
<h6 id="6-《LINUX防火墙原书第3版》"><a href="#6-《LINUX防火墙原书第3版》" class="headerlink" title="6. 《LINUX防火墙原书第3版》"></a>6. 《LINUX防火墙原书第3版》</h6><p>链接: <a href="https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g">https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g</a> </p>
<p>提取码: wi4c</p>
<h6 id="7-《Linux高级程序设计中文第三版》"><a href="#7-《Linux高级程序设计中文第三版》" class="headerlink" title="7. 《Linux高级程序设计中文第三版》"></a>7. 《Linux高级程序设计中文第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg">https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg</a> </p>
<p>提取码: 26ek</p>
<h6 id="8-《Linux环境编程从应用到内核》"><a href="#8-《Linux环境编程从应用到内核》" class="headerlink" title="8. 《Linux环境编程从应用到内核》"></a>8. 《Linux环境编程从应用到内核》</h6><p>链接: <a href="https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ">https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ</a> </p>
<p>提取码: fwi2</p>
<h6 id="9-《Linux命令详解词典施威铭研究室》"><a href="#9-《Linux命令详解词典施威铭研究室》" class="headerlink" title="9. 《Linux命令详解词典施威铭研究室》"></a>9. 《Linux命令详解词典施威铭研究室》</h6><p>链接: <a href="https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw">https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw</a> </p>
<p>提取码: rhpb</p>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><h6 id="1-《深入浅出MySQL-数据库开发优化与管理维护》"><a href="#1-《深入浅出MySQL-数据库开发优化与管理维护》" class="headerlink" title="1. 《深入浅出MySQL++数据库开发优化与管理维护》"></a>1. 《深入浅出MySQL++数据库开发优化与管理维护》</h6><p>链接: <a href="https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A">https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A</a> 提取码: 5eez</p>
<h6 id="2-《高性能mysql第三版》"><a href="#2-《高性能mysql第三版》" class="headerlink" title="2. 《高性能mysql第三版》"></a>2. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="3-《MySQL必知必会》"><a href="#3-《MySQL必知必会》" class="headerlink" title="3. 《MySQL必知必会》"></a>3. 《MySQL必知必会》</h6><p>链接: <a href="https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA">https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA</a> </p>
<p>提取码: 7xds</p>
<h4 id="五、机器学习和人工智能AI"><a href="#五、机器学习和人工智能AI" class="headerlink" title="五、机器学习和人工智能AI"></a>五、机器学习和人工智能AI</h4><h5 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h5><h6 id="1-《高等数学（同济）第六版-第七版课后习题答案》完整答案"><a href="#1-《高等数学（同济）第六版-第七版课后习题答案》完整答案" class="headerlink" title="1.《高等数学（同济）第六版/第七版课后习题答案》完整答案"></a>1.《高等数学（同济）第六版/第七版课后习题答案》完整答案</h6><p>链接:<a href="https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw">https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw</a>  </p>
<p>密码:xlij</p>
<h6 id="2-《浙江大学概率论与数理统计-第四版-》"><a href="#2-《浙江大学概率论与数理统计-第四版-》" class="headerlink" title="2.《浙江大学概率论与数理统计(第四版)》"></a>2.《浙江大学概率论与数理统计(第四版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g">https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g</a> </p>
<p>提取码: zeda</p>
<h6 id="3-《数学之美》完整版"><a href="#3-《数学之美》完整版" class="headerlink" title="3.《数学之美》完整版"></a>3.《数学之美》完整版</h6><p>链接: <a href="https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA">https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA</a> </p>
<p>提取码: a95d</p>
<h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><h6 id="1-《Machine-Learning-Yearning》完整中文版"><a href="#1-《Machine-Learning-Yearning》完整中文版" class="headerlink" title="1.《Machine Learning Yearning》完整中文版"></a>1.《Machine Learning Yearning》完整中文版</h6><p>链接:<a href="https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw">https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw</a> </p>
<p>提取码:wxoj </p>
<h6 id="2-《百面机器学习》"><a href="#2-《百面机器学习》" class="headerlink" title="2.《百面机器学习》"></a>2.《百面机器学习》</h6><p>链接:<a href="https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ">https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ</a>  </p>
<p>密码:xbhr</p>
<h6 id="3-《统计学习方法》"><a href="#3-《统计学习方法》" class="headerlink" title="3.《统计学习方法》"></a>3.《统计学习方法》</h6><p>链接:<a href="https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA">https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA</a>  </p>
<p>密码:m5qp</p>
<h6 id="4-《机器学习》周志华-西瓜书"><a href="#4-《机器学习》周志华-西瓜书" class="headerlink" title="4.《机器学习》周志华-西瓜书"></a>4.《机器学习》周志华-西瓜书</h6><p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a>  </p>
<p>密码:odp0</p>
<h6 id="5-《Artificial-Intelligence-A-Modern》"><a href="#5-《Artificial-Intelligence-A-Modern》" class="headerlink" title="5.《Artificial Intelligence_ A Modern》"></a>5.《Artificial Intelligence_ A Modern》</h6><p>链接:<a href="https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ">https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ</a>  </p>
<p>密码:2t6s</p>
<h6 id="6-《贝叶斯思维统计建模的PYTHON学习法》"><a href="#6-《贝叶斯思维统计建模的PYTHON学习法》" class="headerlink" title="6.《贝叶斯思维统计建模的PYTHON学习法》"></a>6.《贝叶斯思维统计建模的PYTHON学习法》</h6><p>链接: <a href="https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g">https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g</a> </p>
<p>提取码: 7t7x</p>
<h6 id="7-《机器学习实战》"><a href="#7-《机器学习实战》" class="headerlink" title="7.《机器学习实战》"></a>7.《机器学习实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA">https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA</a> </p>
<p>提取码: b9hw</p>
<h6 id="8-《机器学习与数据挖掘方法和应用》"><a href="#8-《机器学习与数据挖掘方法和应用》" class="headerlink" title="8.《机器学习与数据挖掘方法和应用》"></a>8.《机器学习与数据挖掘方法和应用》</h6><p>链接: <a href="https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw">https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw</a> </p>
<p>提取码: rw5q</p>
<h6 id="9-《机器学习》中文版"><a href="#9-《机器学习》中文版" class="headerlink" title="9.《机器学习》中文版"></a>9.《机器学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw">https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw</a> </p>
<p>提取码: 387b</p>
<h6 id="10-《人工智能》复杂问题求解的结构和策略"><a href="#10-《人工智能》复杂问题求解的结构和策略" class="headerlink" title="10.《人工智能》复杂问题求解的结构和策略"></a>10.《人工智能》复杂问题求解的结构和策略</h6><p>链接: <a href="https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng">https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng</a> </p>
<p>提取码: 5ji1</p>
<h6 id="11-《数据挖掘-实用机器学习技术》中文第二版"><a href="#11-《数据挖掘-实用机器学习技术》中文第二版" class="headerlink" title="11.《数据挖掘-实用机器学习技术》中文第二版"></a>11.《数据挖掘-实用机器学习技术》中文第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g">https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g</a> </p>
<p>提取码: ek29</p>
<h6 id="12-《数据挖掘-数据-模型-算法》"><a href="#12-《数据挖掘-数据-模型-算法》" class="headerlink" title="12.《数据挖掘-数据-模型-算法》"></a>12.《数据挖掘-数据-模型-算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg">https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg</a> </p>
<p>提取码: iwde</p>
<h6 id="13-《数据挖掘概念与技术-中文版-》"><a href="#13-《数据挖掘概念与技术-中文版-》" class="headerlink" title="13.《数据挖掘概念与技术(中文版)》"></a>13.《数据挖掘概念与技术(中文版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ">https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ</a> </p>
<p>提取码: 44c4</p>
<h6 id="14-《数据挖掘实用案例分析》"><a href="#14-《数据挖掘实用案例分析》" class="headerlink" title="14.《数据挖掘实用案例分析》"></a>14.《数据挖掘实用案例分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ">https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ</a> </p>
<p>提取码: d6fx</p>
<h6 id="15-《Web数据挖掘》"><a href="#15-《Web数据挖掘》" class="headerlink" title="15.《Web数据挖掘》"></a>15.《Web数据挖掘》</h6><p>链接: <a href="https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw">https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw</a> </p>
<p>提取码: tmy4</p>
<h5 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h5><h6 id="1-《推荐算法在业界的应用实践合集》"><a href="#1-《推荐算法在业界的应用实践合集》" class="headerlink" title="1.《推荐算法在业界的应用实践合集》"></a>1.《推荐算法在业界的应用实践合集》</h6><p>链接:<a href="https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ">https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ</a>  </p>
<p>密码:3qbx</p>
<h6 id="2-《推荐系统实践》"><a href="#2-《推荐系统实践》" class="headerlink" title="2.《推荐系统实践》"></a>2.《推荐系统实践》</h6><p>链接:<a href="https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig">https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig</a>  </p>
<p>密码:w1qj</p>
<h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><h6 id="1-2020最新版《神经网络与深度学习》中文版"><a href="#1-2020最新版《神经网络与深度学习》中文版" class="headerlink" title="1. 2020最新版《神经网络与深度学习》中文版"></a>1. 2020最新版《神经网络与深度学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg">https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg</a>  </p>
<p>密码: 7cor</p>
<h6 id="2-《神经网络与机器学习》"><a href="#2-《神经网络与机器学习》" class="headerlink" title="2. 《神经网络与机器学习》"></a>2. 《神经网络与机器学习》</h6><p>链接: <a href="https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg">https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg</a> </p>
<p>提取码: 5py4</p>
<h6 id="3-《TensorFlow实践与智能系统》"><a href="#3-《TensorFlow实践与智能系统》" class="headerlink" title="3. 《TensorFlow实践与智能系统》"></a>3. 《TensorFlow实践与智能系统》</h6><p>链接: <a href="https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg">https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg</a> </p>
<p>提取码: 9iq7</p>
<h6 id="4-《Tensorflow实战Google深度学习框架》"><a href="#4-《Tensorflow实战Google深度学习框架》" class="headerlink" title="4. 《Tensorflow实战Google深度学习框架》"></a>4. 《Tensorflow实战Google深度学习框架》</h6><p>链接: <a href="https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA">https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA</a> </p>
<p>提取码: ybr9</p>
<h4 id="六、其他书籍"><a href="#六、其他书籍" class="headerlink" title="六、其他书籍"></a>六、其他书籍</h4><h6 id="1-《计算广告：互联网商业变现的市场与技术-刘鹏》"><a href="#1-《计算广告：互联网商业变现的市场与技术-刘鹏》" class="headerlink" title="1. 《计算广告：互联网商业变现的市场与技术-刘鹏》"></a>1. 《计算广告：互联网商业变现的市场与技术-刘鹏》</h6><p>链接:<a href="https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg">https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg</a>  </p>
<p>密码:uj8o</p>
<h6 id="2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】"><a href="#2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】" class="headerlink" title="2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】"></a>2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】</h6><p>链接:<a href="https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ">https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ</a>  </p>
<p>密码:46s7</p>
<h6 id="3-《Go语言实战》"><a href="#3-《Go语言实战》" class="headerlink" title="3. 《Go语言实战》"></a>3. 《Go语言实战》</h6><p>链接:<a href="https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw">https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw</a>  密码:277h</p>
<h6 id="4-《第一行代码-Android》"><a href="#4-《第一行代码-Android》" class="headerlink" title="4. 《第一行代码-Android》"></a>4. 《第一行代码-Android》</h6><p>链接:<a href="https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g">https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g</a>  </p>
<p>密码:bvqp</p>
<h6 id="5-《数据库原理（第5版）》"><a href="#5-《数据库原理（第5版）》" class="headerlink" title="5. 《数据库原理（第5版）》"></a>5. 《数据库原理（第5版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q">https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q</a>  </p>
<p>密码:kfi2</p>
<h6 id="5-《VIM-思维导图》"><a href="#5-《VIM-思维导图》" class="headerlink" title="5. 《VIM 思维导图》"></a>5. 《VIM 思维导图》</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="6-《编程之美》完整版"><a href="#6-《编程之美》完整版" class="headerlink" title="6. 《编程之美》完整版"></a>6. 《编程之美》完整版</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="7-《代码大全2中文版》"><a href="#7-《代码大全2中文版》" class="headerlink" title="7. 《代码大全2中文版》"></a>7. 《代码大全2中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg">https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg</a> </p>
<p>提取码: ag4d</p>
<h6 id="8-《代码整洁之道》"><a href="#8-《代码整洁之道》" class="headerlink" title="8. 《代码整洁之道》"></a>8. 《代码整洁之道》</h6><p>链接: <a href="https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ">https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ</a> </p>
<p>提取码: 5d2v</p>
<h6 id="9-《高性能mysql第三版》"><a href="#9-《高性能mysql第三版》" class="headerlink" title="9. 《高性能mysql第三版》"></a>9. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="10-《黑客与画家》"><a href="#10-《黑客与画家》" class="headerlink" title="10. 《黑客与画家》"></a>10. 《黑客与画家》</h6><p>链接: <a href="https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg">https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg</a> </p>
<p>提取码: rqem</p>
<h6 id="11-《汇编语言》-第3版-王爽著"><a href="#11-《汇编语言》-第3版-王爽著" class="headerlink" title="11. 《汇编语言》(第3版)王爽著"></a>11. 《汇编语言》(第3版)王爽著</h6><p>链接: <a href="https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg">https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg</a> </p>
<p>提取码: 9au5</p>
<h6 id="12-《计算机程序设计艺术-第一卷-》"><a href="#12-《计算机程序设计艺术-第一卷-》" class="headerlink" title="12. 《计算机程序设计艺术(第一卷)》"></a>12. 《计算机程序设计艺术(第一卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw">https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw</a> </p>
<p>提取码: 5qgb</p>
<h6 id="13-《计算机程序设计艺术-第二卷-》"><a href="#13-《计算机程序设计艺术-第二卷-》" class="headerlink" title="13. 《计算机程序设计艺术(第二卷)》"></a>13. 《计算机程序设计艺术(第二卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ">https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ</a> </p>
<p>提取码: 8rsz</p>
<h6 id="14-《计算机程序设计艺术-第三卷-》"><a href="#14-《计算机程序设计艺术-第三卷-》" class="headerlink" title="14. 《计算机程序设计艺术(第三卷)》"></a>14. 《计算机程序设计艺术(第三卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w">https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w</a> </p>
<p>提取码: dtwr </p>
<h6 id="15-《精通正则表达式》"><a href="#15-《精通正则表达式》" class="headerlink" title="15. 《精通正则表达式》"></a>15. 《精通正则表达式》</h6><p>链接: <a href="https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw">https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw</a> </p>
<p>提取码: d762</p>
<h6 id="16-《浪潮之巅》-完整版"><a href="#16-《浪潮之巅》-完整版" class="headerlink" title="16. 《浪潮之巅》(完整版)"></a>16. 《浪潮之巅》(完整版)</h6><p>链接: <a href="https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA">https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA</a> </p>
<p>提取码: r5y2</p>
<h6 id="17-《图解设计模式》"><a href="#17-《图解设计模式》" class="headerlink" title="17. 《图解设计模式》"></a>17. 《图解设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog">https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog</a> </p>
<p>提取码: p3wn</p>
<h6 id="18-《学习Go语言-Golang-》"><a href="#18-《学习Go语言-Golang-》" class="headerlink" title="18. 《学习Go语言(Golang)》"></a>18. 《学习Go语言(Golang)》</h6><p>链接: <a href="https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ">https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ</a> </p>
<p>提取码: vw22</p>
<h6 id="19-《研磨设计模式》"><a href="#19-《研磨设计模式》" class="headerlink" title="19. 《研磨设计模式》"></a>19. 《研磨设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg">https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg</a> </p>
<p>提取码: nmyf</p>
<h6 id="20-《HeadFirst设计模式》"><a href="#20-《HeadFirst设计模式》" class="headerlink" title="20. 《HeadFirst设计模式》"></a>20. 《HeadFirst设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg">https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg</a> </p>
<p>提取码: 33ff</p>
<h6 id="21-《Maven实战》"><a href="#21-《Maven实战》" class="headerlink" title="21. 《Maven实战》"></a>21. 《Maven实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A">https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A</a> </p>
<p>提取码: x5xv</p>
<h6 id="22-《MongoDB权威指南》"><a href="#22-《MongoDB权威指南》" class="headerlink" title="22. 《MongoDB权威指南》"></a>22. 《MongoDB权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ">https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ</a> </p>
<p>提取码: sj6a</p>
<h6 id="21-《Pro-Git中文版》"><a href="#21-《Pro-Git中文版》" class="headerlink" title="21. 《Pro Git中文版》"></a>21. 《Pro Git中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw">https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw</a> </p>
<p>提取码: eeg1</p>
<h6 id="22-《SQL查询的艺术》"><a href="#22-《SQL查询的艺术》" class="headerlink" title="22. 《SQL查询的艺术》"></a>22. 《SQL查询的艺术》</h6><p>链接: <a href="https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q">https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q</a> </p>
<p>提取码: khvi</p>
<h6 id="23-《SQLite权威指南》"><a href="#23-《SQLite权威指南》" class="headerlink" title="23. 《SQLite权威指南》"></a>23. 《SQLite权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw">https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw</a> </p>
<p>提取码: 9dqe</p>
<hr>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 统计各个年龄阶段的人数</title>
    <url>/posts/c7081fb8/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<p><img src="/images/3.jpg" width="90%" height="90%"></p>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：统计各个年龄阶段的人数</p>
<p>描述：</p>
<p>N个年龄通过调用随机函数获得，并存放在主函数的age中<br>要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</p>
<p>结果在主函数中输出</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>随机使用 rand() 函数，头文件为#include <stdlib.h></stdlib.h></p>
<p>rand()函数是按指定的顺序来产生整数，因此每次执行上面的语句都打印相同的两个值，所以说C语言的随机并不是真正意义上的随机，有时候也叫伪随机数，使用 rand() 生成随机数之前需要用随机发生器的初始化函数 srand(unsigned seed)（也位于 stdlib.h 中） 进行伪随机数序列初始化，seed 又叫随机种子，通俗讲就是，如果每次提供的 seed 是一样的话，最后每一轮生成的几个随机值也都是一样的，因此叫伪随机数，所以需要每次提供不同的 seed 达到完全的随机，我们通常用时间函数 time(NULL) 作为 seed ，因为时间值每秒都不同，但是在此题中使用不到time这个工具</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计各个年龄阶段的人数</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">N个年龄通过调用随机函数获得，并存放在主函数的age中</span></span><br><span class="line"><span class="comment">要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</span></span><br><span class="line"><span class="comment">结果在主函数中输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *age, <span class="keyword">int</span> *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(age+i)&lt;<span class="number">100</span>) &#123;</span><br><span class="line">            d[(*(age+i))/<span class="number">10</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d[M<span class="number">-1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> age[N];        <span class="comment">// 100个用户</span></span><br><span class="line">    <span class="keyword">int</span> d[M]=&#123;<span class="number">0</span>&#125;;         <span class="comment">// 11个年龄段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(age+i) = rand()%<span class="number">121</span>;    <span class="comment">// 设定年龄的范围是0-120</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(age, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;各年龄阶段人数数量：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex004.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">各年龄阶段人数数量：</span><br><span class="line">10 9 8 4 10 8 7 7 6 11 20</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 统计一行字符串单词的个数，作为函数值返回</title>
    <url>/posts/596c8a1b/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：统计一行字符串单词的个数，作为函数值返回</p>
<p>一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>逐个字符进行判断是否为空</p>
<p><em>下面“空开处”指的是一个空格或者若干空格隔开单词的说法</em></p>
<ol>
<li>开头无空格，故需要判断结尾有没有空开出，如果有，直接计算空开出就是单词数，如果没有需要单词数加1</li>
<li>上述1中的空开出需要做处理，由于单词间由若干空格隔开，故判断一个空格的前一个是否为空格，如果不是，数量加1；如果是，不做处理</li>
</ol>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计一行字符串单词的个数，作为函数值返回</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>; 	<span class="comment">// 单词个数</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*(s+i)!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*(s+i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; *(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			cnt += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;	<span class="comment">// 如果单词结尾没有空格，则单词数需要空开数+1</span></span><br><span class="line">		<span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;hello world      i am c language&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;字符串内容：%s\n&quot;</span>, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;单词个数为：%d\n&quot;</span>, fun(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex003.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">字符串内容：hello world      i am c language</span><br><span class="line">单词个数为：6</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>布隆过滤器(BloomFilter)原理 | 亿级数据过滤解决方案</title>
    <url>/posts/ba26fe62/</url>
    <content><![CDATA[<p>读前福利：几百本互联网技术书籍送给大家<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<blockquote>
<p>1970 年，<strong>布隆先生</strong>提出了一种很优秀的过滤器算法，用来判断一个元素是否在集合中</p>
<p>「布隆过滤器算法」</p>
<p><strong>故事开始</strong>→_→</p>
</blockquote>
<p><strong>先看本故事结构</strong></p>
<p><img src="/images/7082216a05225e2828d568baab4754a31.jpg" width="80%" height="80%"></p>
<p>就当前互联网环境来说，头部的互联网生态越来越往高并发、分布式的形态发展。举例来说，各大网页的黑名单系统，爬虫的重复率判断。这些场景越来越多。</p>
<p>举例来说，实时状态下可能会对超过百亿级别的 URL 需要进行判断是否符合规范或者存在于系统中，能否正常使用。</p>
<p>通常情况下，每个 URL 的大小为 64B（字节），那么就按照100亿的 URL 数量来看，大概需要640GB的内存容量【$64 \times 100\text{亿}/1024^3$】，对于当前线上服务器来说，… 这个值依然还是很大的！但如果利用布隆过滤器的优势，在没有失误率的情况下只需要100亿个比特，即：1.2GB，即使为了降低失误率，也不会超过几十GB的空间【失误率后面会谈到】</p>
<p>那么在这种情况下，利用<strong>布隆过滤器</strong>来解决的确是很优秀，优秀到维基百科这样说「<strong>它的优点是空间效率和查询时间都远远超过一般的算法</strong>」，空间复杂度和时间复杂度都远超一般的算法，布隆过滤器存储空间和插入/查询时间都是常数O(1)！<strong>注意：远超！！</strong></p>
<p><strong><em>看着来自各方面这么牛B 的吹嘘，咱们把布隆过滤器安排到方方面面，来具体看看它的原理是怎么样的…</em></strong></p>
<p>维基百科的概念：布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。基于这个解释，下面从  </p>
<p><img src="/images/7082216a05225e2828d568baab4754a32.jpg" width="80%" height="80%"></p>
<p>等方面系统性的说道说道…</p>
<p>【1】</p>
<h4 id="主要作用：判断一个元素是否在集合中"><a href="#主要作用：判断一个元素是否在集合中" class="headerlink" title="主要作用：判断一个元素是否在集合中"></a>主要作用：判断一个元素是否在集合中</h4><p>这样的场景会有很多。会去判断，要查询的元素是否存在于集合当中。【该网站是否允许该用户登录、该网站共是否接受这样的 url 请求】</p>
<p>通常在查询的时候，一般会先从 cache 中进行查询，如果没有的话会直接到磁盘或者数据库查询，这样的方式看起来很合理，但是如果在中间再加一层<strong>布隆顾虑器</strong>，这样就会更加合理了！为什么？</p>
<p>假设要查询的一个元素，而该元素不存在</p>
<p>a. 如果没有 BloomFilter，从cache中查询完就会直接到数据库做查询了，这样带来的现象是“慢”，毕竟从库中查耗时是比较长的，很大程度上对服务的性能产生影响。</p>
<p>b. 中间存在 BloomFilter，从cache中查询完就会首先查询 BloomFilter，就会发现该元素不存在，就可以不往后面进行查询了，而 BloomFilter 的性能是极其优越的。这样，对于机器或者说服务性能避免了很大不必要的消耗。</p>
<p><img src="/images/7082216a05225e2828d568baab4754a33.jpg" width="80%" height="80%"></p>
<p>就上图所示，假设元素不存在，如果没有布隆过滤器，就直接会查询【磁盘/数据库】，这样会带来很大不必要的性能消耗！</p>
<blockquote>
<p>既然效率这么高，那到底是什么原因呢？</p>
</blockquote>
<p>【2】</p>
<h4 id="数据结构：二进制数组-hash算法"><a href="#数据结构：二进制数组-hash算法" class="headerlink" title="数据结构：二进制数组+hash算法"></a>数据结构：二进制数组+hash算法</h4><h5 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h5><p>这个是最关键的一个数据结构，会将每一个元素经过 hash 算法映射到每一个二进制数组中去。</p>
<p>开篇讲到在时间复杂度和空间复杂度方面来说，都是在常数级别，这也归功于一个数据结构就是由比特位构成的数组，所以在空间这块是很有优势的。就拿一个URL 64B来说，对应比特位就是1，大概是 <strong>64*8:1</strong> 这个空间比例。</p>
<h5 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h5><p><img src="/images/7082216a05225e2828d568baab4754a34.jpg" width="80%" height="80%"></p>
<p>对于hash算法来说，应该是比较熟悉了，数据元素经过 hash 函数会映射到不同的数组中，如果发生冲突可以使用一些方法进行解决，比如说是拉链法解决。</p>
<p>hash 函数应用在 BloomFilter 中的时候，与一般的 hash 函数处理有区别的地方是：</p>
<p>a. BloomFilter 将值不会映射到一个地址，而是映射到对应的二进制数组位，然后将该数组为置为 1</p>
<p>b. BloomFilter 不会采用 hash 函数中常用的解决地址冲突的方法，而是会将同一个元素，经过几个 hash function 后，将对应二进制数组位置置为 1，后期如果进行查询的时候，<strong>只有经过hash函数后，几个位置同时为1，才可以判断该元素存在</strong>。</p>
<p>看下图：</p>
<p><img src="/images/7082216a05225e2828d568baab4754a35.jpg" width="80%" height="80%"></p>
<p>按照图例，每个数据元素会经过 3 个不同的 hash function，然后对应到不同的二进制数组位，并且置为 1，这样一方面减小了冲突的概率，另外一方面会减小误差率。</p>
<p>当一个客户端查询过来，对于 URL1、URL2 和 URL3 在BloomFilter 中都是存在的，所以对这三个元素进行查询的时候，一定是可以查到的。</p>
<p>下面咱们试着用 URL1、URL4 和 URL5 进行举例说明：查找成功、查找不存在以及查找失误这三种真实存在的情况。【下图👇】</p>
<p><img src="/images/7082216a05225e2828d568baab4754a36.jpg" width="80%" height="80%"></p>
<p>在 BloomFilter 的二进制数组右边是指的进行客户端查询 URL1、URL4 和 URL5时候的情况，可以看到：</p>
<ul>
<li>URL1：完全可以和存储 URL1 时候的数组位能够对应上并且同时都为1，即位置：1、5、9。查询成功！</li>
<li>URL4：在数组位 2 处为0，其余为 1，导致三个位置不全为1，查找不存在，返回空！</li>
<li>URL5：URL5 的三个二进制数组位都为 1，按原理说结果是URL5元素存在于BloomFilter中，但是可以清楚看到，查询有错误！这个就是查询产生失误的情况。</li>
</ul>
<p>这也就能够说明，BloomFIlter在空间和时间方面是极其优秀的，都达到了 O(1) 的级别，但是缺点是存在误识别率。</p>
<p>在这里注意，误识别率仅仅是存在查找成功的情况下，查询不存在是没有误识别率的。即：</p>
<ul>
<li>查询存在：存在误识别率，就上面图示所示</li>
<li>查询不存在：肯定不会存在都是 1 的情况，所以这方面不会存在误识别率</li>
</ul>
<p>【3】</p>
<h4 id="优势：省空间-高性能"><a href="#优势：省空间-高性能" class="headerlink" title="优势：省空间+高性能"></a>优势：省空间+高性能</h4><h5 id="省空间"><a href="#省空间" class="headerlink" title="省空间"></a>省空间</h5><p>这个在URL长度的案例说到，正是采用了二进制数组，一个元素经过 hash 函数对应着一个数组位（比特位），如果是真实存储一个URL（64B）的话，这就空间比例大约是<strong>64*8:1</strong>，即512:1</p>
<p>比特数组促使 BloomFilter 会省很大的空间，就空间效率来说，是极其高效的。</p>
<h5 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h5><p>BloomFilter 不存在像链表查询一样，需要一个一个去遍历。反而会像数组一样，类似于直接取下标就可以找到所需要的结果。</p>
<p>不同的是，BloomFilter 需要过几个hash function，去查找下标。所以，综合来看，性能是很高的！</p>
<p>综合时间和空间效率，在有很低的误识别率情况下，各方面都是远超其他算法的。</p>
<p>【4】</p>
<h4 id="不足：有误判-不能删除元素"><a href="#不足：有误判-不能删除元素" class="headerlink" title="不足：有误判+不能删除元素"></a>不足：有误判+不能删除元素</h4><h5 id="有误判的情况-hash存在冲突"><a href="#有误判的情况-hash存在冲突" class="headerlink" title="有误判的情况 - hash存在冲突"></a>有误判的情况 - hash存在冲突</h5><p>在前面举例 URL5 的时候，这种情况就会使得查询出现了失误，这也是传统hash冲突的直接表现，同时这也是使用了几个 hash 函数的原因。而这种错误识别，后期可以使用白名单的形式进行标记以补全这方面的不足。</p>
<p>但是在真正工业界的使用来看，这种冲突或者说查询失误也是保持在 0.01% 以下，一方面会考量 hash 函数的使用，另外一方面会增大 BloomFilter 二进制数组的位数来避免这种冲突。</p>
<p>那么，就上面两个考虑的方面，来具体看看：到底需要<strong>多大的二进制数组的长度</strong>以及<strong>多少个hash 函数</strong> 才可以使得上述案例的失误率保持在 0.01% 以下？</p>
<p><strong>二进制bit数组长度的选取</strong></p>
<p>记：$n=100$亿，$p=0.01%$， BloomFilter 的二进制bit数组长度 m 使用以下公式决定的：</p>
<script type="math/tex; mode=display">
m=\frac{n\times ln p}{(ln 2)^2}</script><p>可以求得：m=19.19n，即二进制bit数组长度大概是元素个数 n 的20倍，需要200亿个bit位，相当于大约25GB的空间，对于我们普通工业界的服务器来说，是足够容纳这个数组的</p>
<p><strong>最好需要多少个 hash 函数</strong></p>
<p>业界一般用这个公式来计算需要 k 个 hash 函数：</p>
<script type="math/tex; mode=display">
k=ln2 \times \frac {m}{n} = 0.7 \times \frac {m}{n} = 14</script><p>即：需要 14 个 hash 函数来进行构造</p>
<p>根据上述的计算，可以得到我们要使用 BloomFilter 的最佳方案</p>
<h5 id="不能删除元素"><a href="#不能删除元素" class="headerlink" title="不能删除元素"></a>不能删除元素</h5><p>这个就很好理解了，不同的元素通过 hash 函数使得相应位置都置为了 1，是绝对不能删除该元素，将它对应的位置置为 0 的。</p>
<p>下图中的 URL1 和 URL2，经过 hash 函数后，其中一个hash结果都指向了二进制数组中的3位置【红色箭头】，如果现在想要删除URL1，那么，按理说应该将 URL1 hash后指向的二进制数组对应位置都置为 0 才对，显然，这样做是不行的，会影响到 URL2 的查询。</p>
<p><img src="/images/7082216a05225e2828d568baab4754a37.jpg" width="80%" height="80%"></p>
<p>【5】</p>
<h4 id="业界应用"><a href="#业界应用" class="headerlink" title="业界应用"></a>业界应用</h4><p>工业界会有很多这种场景会使用到，例如：</p>
<ul>
<li><p>博客系统黑名单限制</p>
</li>
<li><p>爬虫重复率的判定</p>
</li>
<li><p>比特币的应用</p>
</li>
<li><p>垃圾邮件过滤</p>
<p>等等…</p>
</li>
</ul>
<p>不过大致都是很通用的一些解决方案，比如下图所示：</p>
<p>在信息写入的时候，会同时写入到缓存、数据库和布隆过滤器。需要查询的时候，先进行对缓存进行查询，如果找不到的话，就会先使用 BloomFilter 进行判断是否存在，如果存在就会继续向数据库查询；如果不存在，就直接返回空了。</p>
<p>这样在很大程度上提升了应用服务的效率！</p>
<p><img src="/images/7082216a05225e2828d568baab4754a38.jpg" width="80%" height="80%"></p>
<hr>
<h4 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</title>
    <url>/posts/2e6bba8d/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>编写：fun()</p>
<p>功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</p>
<p>例如：</p>
<p>二维数组中的数据为：</p>
<p>W W W W</p>
<p>S S S S</p>
<p>H H H H</p>
<p>则字符串中的内容是：WSHWSHWSH</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>第一层循环按照列数进行，第二层循环按照行数</p>
<p>然后依次提出每一列的字符</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><p>为了熟悉二维数组的指针表示，部分代码给出了数组表示和指针表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写：fun()</span></span><br><span class="line"><span class="comment">功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">二维数组中的数据为：</span></span><br><span class="line"><span class="comment">W W W W</span></span><br><span class="line"><span class="comment">S S S S</span></span><br><span class="line"><span class="comment">H H H H</span></span><br><span class="line"><span class="comment">则字符串中的内容是：WSHWSHWSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   0 1 2 3</span></span><br><span class="line"><span class="comment">// 0 W W W W</span></span><br><span class="line"><span class="comment">// 1 S S S S</span></span><br><span class="line"><span class="comment">// 2 H H H H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[M][N], <span class="keyword">char</span> *res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            res[t++] = s[j][i];</span><br><span class="line">      <span class="comment">// res[t++] = *(*(a*i)+i);   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[t] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[M][N] = &#123;<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size_res = M*N;</span><br><span class="line">    <span class="keyword">char</span> res[size_res];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组中元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, a[i][j]);</span><br><span class="line">      <span class="comment">// printf(&quot;%c\t&quot;, *(*(a*i)+j));   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按列的顺序依次:\n%s\n&quot;</span>, fun(a, res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex002.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">二维数组中元素：</span><br><span class="line">M    M    M    M</span><br><span class="line">S    S    S    S</span><br><span class="line">H    H    H    H</span><br><span class="line">按列的顺序依次:</span><br><span class="line">MSHMSHMSHMSH</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 将字符串转换为一个整数</title>
    <url>/posts/b762eb37/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：将字符串转换为一个整数</p>
<p>描述：</p>
<p>【不能使用C语言提供的字符串函数】</p>
<p>输入：字符串”-1234”</p>
<p>输出：整型 -1234</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>思路：将字符串每个位置的字符进行对应的ASCII码转换</p>
<p>例如：字符 ‘0’-‘9’ 对应的十进制整数是48~57，那么，将对应的整数减去48就得到了对应的整数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：将字符串转换为一个整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">【不能使用C语言提供的字符串函数】</span></span><br><span class="line"><span class="comment">输入：字符串&quot;-1234&quot;</span></span><br><span class="line"><span class="comment">输出：整型 -1234</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;		<span class="comment">//数字个数</span></span><br><span class="line">	<span class="keyword">long</span> res = <span class="number">0L</span>;	<span class="comment">// 转化后的数字</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;		<span class="comment">// 位数*10 *100 ...</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">strlen</span>(p); 	<span class="comment">// 字符串长度</span></span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">		r = size - <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从前往后转换的话，需要分情况去计算。即：不是负数的话从p[0] 和 如果是负数的话需要从p[1]开始</span></span><br><span class="line">	<span class="comment">// 所以，可以从后往前计算，循环次数是 r </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">		res += (p[size<span class="number">-1</span>-i]<span class="number">-48</span>)*pos;</span><br><span class="line">		pos *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>?-res:res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">	gets(s);</span><br><span class="line">	<span class="keyword">long</span> res = fun(s);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Convert Result: %ld\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex1.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: -1234</span><br><span class="line">Convert Result: -1234</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: 9089</span><br><span class="line">Convert Result: 9089</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例详解</title>
    <url>/posts/c065dba1/</url>
    <content><![CDATA[<blockquote>
<p>以下88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<h3 id="案例ex01-将字符串转换为一个整数"><a href="#案例ex01-将字符串转换为一个整数" class="headerlink" title="案例ex01: 将字符串转换为一个整数"></a><strong>案例ex01: 将字符串转换为一个整数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：将字符串转换为一个整数<br>描述：</p>
<p>【不能使用C语言提供的字符串函数】</p>
<p>输入：字符串”-1234”</p>
<p>输出：整型 -1234</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>思路：将字符串每个位置的字符进行对应的ASCII码转换</p>
<p>例如：字符 ‘0’-‘9’ 对应的十进制整数是48~57，那么，将对应的整数减去48就得到了对应的整数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：将字符串转换为一个整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">【不能使用C语言提供的字符串函数】</span></span><br><span class="line"><span class="comment">输入：字符串&quot;-1234&quot;</span></span><br><span class="line"><span class="comment">输出：整型 -1234</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;        <span class="comment">//数字个数</span></span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0L</span>;    <span class="comment">// 转化后的数字</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;        <span class="comment">// 位数*10 *100 ...</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(p);     <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        r = size - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前往后转换的话，需要分情况去计算。即：不是负数的话从p[0] 和 如果是负数的话需要从p[1]开始</span></span><br><span class="line">    <span class="comment">// 所以，可以从后往前计算，循环次数是 r</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        res += (p[size<span class="number">-1</span>-i]<span class="number">-48</span>)*pos;</span><br><span class="line">        pos *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">long</span> res = fun(s);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Convert Result: %ld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex1.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: -1234</span><br><span class="line">Convert Result: -1234</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: 9089</span><br><span class="line">Convert Result: 9089</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex02-将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中"><a href="#案例ex02-将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中" class="headerlink" title="案例ex02: 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中"></a><strong>案例ex02: 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>编写：fun()</p>
<p>功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</p>
<p>例如：</p>
<p>二维数组中的数据为：</p>
<p>W W W W</p>
<p>S S S S</p>
<p>H H H H</p>
<p>则字符串中的内容是：WSHWSHWSH</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>第一层循环按照列数进行，第二层循环按照行数</p>
<p>然后依次提出每一列的字符</p>
<p><strong>3 代码</strong></p>
<p>为了熟悉二维数组的指针表示，部分代码给出了数组表示和指针表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写：fun()</span></span><br><span class="line"><span class="comment">功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">二维数组中的数据为：</span></span><br><span class="line"><span class="comment">W W W W</span></span><br><span class="line"><span class="comment">S S S S</span></span><br><span class="line"><span class="comment">H H H H</span></span><br><span class="line"><span class="comment">则字符串中的内容是：WSHWSHWSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   0 1 2 3</span></span><br><span class="line"><span class="comment">// 0 W W W W</span></span><br><span class="line"><span class="comment">// 1 S S S S</span></span><br><span class="line"><span class="comment">// 2 H H H H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[M][N], <span class="keyword">char</span> *res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            res[t++] = s[j][i];</span><br><span class="line">      <span class="comment">// res[t++] = *(*(a*i)+i);   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[t] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[M][N] = &#123;<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size_res = M*N;</span><br><span class="line">    <span class="keyword">char</span> res[size_res];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组中元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, a[i][j]);</span><br><span class="line">      <span class="comment">// printf(&quot;%c\t&quot;, *(*(a*i)+j));   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按列的顺序依次:\n%s\n&quot;</span>, fun(a, res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex002.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">二维数组中元素：</span><br><span class="line">M    M    M    M</span><br><span class="line">S    S    S    S</span><br><span class="line">H    H    H    H</span><br><span class="line">按列的顺序依次:</span><br><span class="line">MSHMSHMSHMSH</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex03-统计一行字符串单词的个数，作为函数值返回"><a href="#案例ex03-统计一行字符串单词的个数，作为函数值返回" class="headerlink" title="案例ex03: 统计一行字符串单词的个数，作为函数值返回"></a><strong>案例ex03: 统计一行字符串单词的个数，作为函数值返回</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：统计一行字符串单词的个数，作为函数值返回</p>
<p>一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>逐个字符进行判断是否为空</p>
<p><em>下面“空开处”指的是一个空格或者若干空格隔开单词的说法</em></p>
<ol>
<li>开头无空格，故需要判断结尾有没有空开出，如果有，直接计算空开出就是单词数，如果没有需要单词数加1</li>
<li>上述1中的空开出需要做处理，由于单词间由若干空格隔开，故判断一个空格的前一个是否为空格，如果不是，数量加1；如果是，不做处理</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计一行字符串单词的个数，作为函数值返回</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;     <span class="comment">// 单词个数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*(s+i)!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(s+i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; *(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;    <span class="comment">// 如果单词结尾没有空格，则单词数需要空开数+1</span></span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;hello world      i am c language&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串内容：%s\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单词个数为：%d\n&quot;</span>, fun(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex003.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">字符串内容：hello world      i am c language</span><br><span class="line">单词个数为：6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex04-统计各个年龄阶段的人数"><a href="#案例ex04-统计各个年龄阶段的人数" class="headerlink" title="案例ex04: 统计各个年龄阶段的人数"></a><strong>案例ex04: 统计各个年龄阶段的人数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：统计各个年龄阶段的人数</p>
<p>描述：</p>
<p>N个年龄通过调用随机函数获得，并存放在主函数的age中<br>要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</p>
<p>结果在主函数中输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>随机使用 rand() 函数，头文件为#include <stdlib.h></stdlib.h></p>
<p>rand()函数是按指定的顺序来产生整数，因此每次执行上面的语句都打印相同的两个值，所以说C语言的随机并不是真正意义上的随机，有时候也叫伪随机数，使用 rand() 生成随机数之前需要用随机发生器的初始化函数 srand(unsigned seed)（也位于 stdlib.h 中） 进行伪随机数序列初始化，seed 又叫随机种子，通俗讲就是，如果每次提供的 seed 是一样的话，最后每一轮生成的几个随机值也都是一样的，因此叫伪随机数，所以需要每次提供不同的 seed 达到完全的随机，我们通常用时间函数 time(NULL) 作为 seed ，因为时间值每秒都不同，但是在此题中使用不到time这个工具</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计各个年龄阶段的人数</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">N个年龄通过调用随机函数获得，并存放在主函数的age中</span></span><br><span class="line"><span class="comment">要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</span></span><br><span class="line"><span class="comment">结果在主函数中输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *age, <span class="keyword">int</span> *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(age+i)&lt;<span class="number">100</span>) &#123;</span><br><span class="line">            d[(*(age+i))/<span class="number">10</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d[M<span class="number">-1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age[N];        <span class="comment">// 100个用户</span></span><br><span class="line">    <span class="keyword">int</span> d[M]=&#123;<span class="number">0</span>&#125;;         <span class="comment">// 11个年龄段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(age+i) = rand()%<span class="number">121</span>;    <span class="comment">// 设定年龄的范围是0-120</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(age, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;各年龄阶段人数数量：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex004.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">各年龄阶段人数数量：</span><br><span class="line">10 9 8 4 10 8 7 7 6 11 20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex05-删除一维数组中所有相同的数，使之只剩一个。"><a href="#案例ex05-删除一维数组中所有相同的数，使之只剩一个。" class="headerlink" title="案例ex05: 删除一维数组中所有相同的数，使之只剩一个。"></a><strong>案例ex05: 删除一维数组中所有相同的数，使之只剩一个。</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：删除一维数组中所有相同的数，使之只剩一个。</p>
<p>描述：数组中的数据已经按照从小到大排列，函数返回删除后数组中元素的个数<br>举例：</p>
<p>一维数组中的数据是：2,2,2,2,3,3,4,4,5,6,6,6,7,7,8,9,9,9,10,10</p>
<p>删除后数组中的内容是：2,3,4,5,6,7,8,9,10</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>初始化没有重复元素最右方的指针 a</p>
<p>当前元素与前一个元素进行比较，如果相同，则调到下一个，否则指针a+1</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：删除一维数组中所有相同的数，使之只剩一个。</span></span><br><span class="line"><span class="comment">描述：数组中的数据已经按照从小到大排列，函数返回删除后数组中元素的个数</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">一维数组中的数据是：2,2,2,2,3,3,4,4,5,6,6,6,7,7,8,9,9,9,10,10</span></span><br><span class="line"><span class="comment">删除后数组中的内容是：2,3,4,5,6,7,8,9,10</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(s+i) != *(s+i<span class="number">-1</span>)) &#123;  <span class="comment">// 当前元素与前一个元素进行比较，如果相同，则调到下一个，否则a+1</span></span><br><span class="line">            *(s+a) = *(s+i);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s[N] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = fun(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后的数组元素个数为：%d\n&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex005.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">删除后的数组元素个数为：9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex06-移动字符串中内容"><a href="#案例ex06-移动字符串中内容" class="headerlink" title="案例ex06: 移动字符串中内容"></a><strong>案例ex06: 移动字符串中内容</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：移动字符串中内容</p>
<p>描述：移动规则如下：把第1到第m个字符，平移到字符串的最后，把m+1到最后的字符移到字符串的前部</p>
<p>举例：字符串原有内容为ABCDEFGHIJK，m的值为3，则移动后，字符串中的内容应该是DEFGHIJKABC</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>为了不产生额外的空间复杂度，本次解决将一位一位移动</p>
<p>将数组第一个位置的元素保存到一个临时变量temp中，从第二位开始集体向左移动，最后将temp元素保存到最后一位</p>
<p>循环 m 次，从而达到最后的效果</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：移动字符串中内容</span></span><br><span class="line"><span class="comment">描述：移动规则如下：把第1到第m个字符，平移到字符串的最后，把m+1到最后的字符移到字符串的前部。</span></span><br><span class="line"><span class="comment">举例：字符串原有内容为ABCDEFGHIJK，m的值为3，则移动后，字符串中的内容应该是DEFGHIJKABC</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        temp = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            s[j<span class="number">-1</span>] = s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        s[N<span class="number">-1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[N] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动前的字符串：%s\n&quot;</span>, s);</span><br><span class="line">    fun(s, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动后的字符串：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex006.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">移动前的字符串：ABCDEFGHIJ</span><br><span class="line">移动后的字符串：DEFGHIJABC</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex07-求数字的低n-1位的数"><a href="#案例ex07-求数字的低n-1位的数" class="headerlink" title="案例ex07: 求数字的低n-1位的数"></a><strong>案例ex07: 求数字的低n-1位的数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：unsigned fun(unsigned w)</p>
<p>功能：求数字的低n-1位的数</p>
<p>描述：w 是一个大于10的无符号整数，若 w 是 n(n&gt;=2)位的整数，函数求出来w的低n-1位的数作为函数值返回</p>
<p>举例：w 值为5923，则函数返回 923</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>两步走：</p>
<ol>
<li>先判断当前无符号整数的位数，记录位数*10。例如：如果有三位，那么记录time=100</li>
<li>根据time计算后 n-1 位，即：w-((w/time)*time)</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：unsigned fun(unsigned w)</span></span><br><span class="line"><span class="comment">功能：求数字的低n-1位的数</span></span><br><span class="line"><span class="comment">描述：w 是一个大于10的无符号整数，若 w 是 n(n&gt;=2)位的整数，函数求出来w的低n-1位的数作为函数值返回</span></span><br><span class="line"><span class="comment">举例：w 值为5923，则函数返回 923</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断数字的位数</span></span><br><span class="line">    <span class="keyword">int</span> temp_w = w;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;   <span class="comment">// 位数10的指数次</span></span><br><span class="line">    <span class="keyword">while</span>(temp_w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        time*=<span class="number">10</span>;</span><br><span class="line">        temp_w = temp_w/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    time = time/<span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 计算返回</span></span><br><span class="line">    <span class="keyword">return</span> w-((w/time)*time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请一个大于10的无符号整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无符号整数低n-1位的数为：%d\n&quot;</span>, fun(w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex007.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请一个大于10的无符号整数：12345</span><br><span class="line">无符号整数低n-1位的数为：2345</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请一个大于10的无符号整数：765432</span><br><span class="line">无符号整数低n-1位的数为：65432</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex08-使数组的左下三角元素中的值乘以n"><a href="#案例ex08-使数组的左下三角元素中的值乘以n" class="headerlink" title="案例ex08: 使数组的左下三角元素中的值乘以n"></a><strong>案例ex08: 使数组的左下三角元素中的值乘以n</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun(int a[][N], int n)</p>
<p>功能：使数组的左下三角元素中的值乘以n</p>
<p>描述：程序定义了 N*N 的二维数组，并在主函数中自动赋值。</p>
<p>举例：<br>若 n 的值为3，a数组中的值为<br>1  9  7<br>3  9  7<br>2  3  8<br>则返回主程序后 a 数组中的值应该为<br>3  9  7<br>9  27 7<br>6  9  24</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用二重循环解决</p>
<p>在第二层需要进行一点注意的地方</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun(int a[][N], int n)</span></span><br><span class="line"><span class="comment">功能：使数组的左下三角元素中的值乘以n</span></span><br><span class="line"><span class="comment">描述：程序定义了 N*N 的二维数组，并在主函数中自动赋值。</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">若 n 的值为3，a数组中的值为</span></span><br><span class="line"><span class="comment">1  9  7</span></span><br><span class="line"><span class="comment">3  9  7</span></span><br><span class="line"><span class="comment">2  3  8</span></span><br><span class="line"><span class="comment">则返回主程序后 a 数组中的值应该为</span></span><br><span class="line"><span class="comment">3  9  7</span></span><br><span class="line"><span class="comment">9  27 7</span></span><br><span class="line"><span class="comment">6  9  24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[][N], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            a[i][j] = a[i][j] * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N][N] = &#123;&#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>&#125;, &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;计算后数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex008.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原数组为：</span><br><span class="line">1    9    7</span><br><span class="line">3    9    7</span><br><span class="line">2    3    8</span><br><span class="line">计算后数组：</span><br><span class="line">3    9    7</span><br><span class="line">9    27    7</span><br><span class="line">6    9    24</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex09-移动一维数组的内容"><a href="#案例ex09-移动一维数组的内容" class="headerlink" title="案例ex09: 移动一维数组的内容"></a><strong>案例ex09: 移动一维数组的内容</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：移动一维数组的内容</p>
<p>描述：若数组中有n个整数，要求把下标从0到p（含p，p&lt;=n-1）的元素平移到数组的最后<br>举例：</p>
<p>一维数组：1,2,3,4,5,6,7,8,9,10，p的值为3</p>
<p>移动后：5,6,7,8,9,10,1,2,3,4</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>循环 p 次：</p>
<p>将下标为0的数字进行临时存放，然后将后面的数字平移到前面，最后将临时存放的数字放到最后一位</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：移动一维数组的内容</span></span><br><span class="line"><span class="comment">描述：若数组中有n个整数，要求把下标从0到p（含p，p&lt;=n-1）的元素平移到数组的最后</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">一维数组：1,2,3,4,5,6,7,8,9,10，p的值为3</span></span><br><span class="line"><span class="comment">移动后：5,6,7,8,9,10,1,2,3,4</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">        temp = a[<span class="number">0</span>];    <span class="comment">// 临时存放第一个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;     <span class="comment">// 循环将后续数字进行平移</span></span><br><span class="line">            a[j<span class="number">-1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[N<span class="number">-1</span>] = temp;    <span class="comment">// 临时数字存放到最后一位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数组内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fun(a, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平移后数组内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex009.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原始数组内容：</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">平移后数组内容：</span><br><span class="line">5 6 7 8 9 10 1 2 3 4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex10-删除字符串中所有的空格"><a href="#案例ex10-删除字符串中所有的空格" class="headerlink" title="案例ex10: 删除字符串中所有的空格"></a><strong>案例ex10: 删除字符串中所有的空格</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：删除字符串中所有的空格</p>
<p>举例：</p>
<p>主函数中输入“fds afadsf adf d  dsf   67d”</p>
<p>则输出：“fdsafadsfadfddsf67d”</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>设置两指针，begin 和 end</p>
<p>begin 和 end 同时从头开始向后移动：</p>
<ul>
<li>当遇到空格的时候，end 向后移动，begin不变</li>
<li>当 end 位置不为空格的时候，将 end 位置的字符填充到 begin 的位置</li>
</ul>
<p>最后，在完成去除空格的操作后，在最后添加 ‘\0’</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：删除字符串中所有的空格</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">主函数中输入“fds afadsf adf d  dsf   67d”</span></span><br><span class="line"><span class="comment">则输出：“fdsafadsfadfddsf67d”</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[end]!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[end] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[begin] = s[end];</span><br><span class="line">            begin++;</span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[begin] = <span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 去除空格后，在最后一位加 &#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[N] = <span class="string">&quot;fds afadsf adf d  dsf   67d&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始字符串：%s\n&quot;</span>, s);</span><br><span class="line">    fun(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;去空格后字符串：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex010.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原始字符串：fds afadsf adf d  dsf   67d</span><br><span class="line">去空格后字符串：fdsafadsfadfddsf67d</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex11-使用指针实现整数逆序排序"><a href="#案例ex11-使用指针实现整数逆序排序" class="headerlink" title="案例ex11: 使用指针实现整数逆序排序"></a><strong>案例ex11: 使用指针实现整数逆序排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：使用指针实现整数逆序排序</p>
<p>描述：在main函数中实现，输入三个数字，使用指针实现三个数字的逆序排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针实现数字的操作</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指针实现整数逆序排序</span></span><br><span class="line"><span class="comment">描述：在main函数中实现，输入三个数字，使用指针实现三个数字的逆序排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">int</span> *p3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*p1 &lt; *p2)</span><br><span class="line">        swap(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (*p1 &lt; *p3)</span><br><span class="line">        swap(p1, p3);</span><br><span class="line">    <span class="keyword">if</span> (*p2 &lt; *p3)</span><br><span class="line">        swap(p2, p3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">int</span> *q1, *q2, *q3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    q1 = &amp;a;</span><br><span class="line">    q2 = &amp;b;</span><br><span class="line">    q3 = &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆序前的数字：%d, %d, %d\n&quot;</span>, *q1, *q2, *q3);</span><br><span class="line">    fun(q1, q2, q3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆序后的数字：%d, %d, %d\n&quot;</span>, *q1, *q2, *q3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex011.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入三个数字：3,9,1</span><br><span class="line">逆序前的数字：3, 9, 1</span><br><span class="line">逆序后的数字：9, 3, 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入三个数字：1,2,3</span><br><span class="line">逆序前的数字：1, 2, 3</span><br><span class="line">逆序后的数字：3, 2, 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex12-指向结构体变量的指针"><a href="#案例ex12-指向结构体变量的指针" class="headerlink" title="案例ex12: 指向结构体变量的指针"></a><strong>案例ex12: 指向结构体变量的指针</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：指向结构体变量的指针</p>
<p>描述：通过结构体指针变量实现显示学生信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>熟悉结构体的使用</p>
<p>熟悉指针和结构体的混合使用</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：指向结构体变量的指针</span></span><br><span class="line"><span class="comment">描述：通过结构体指针变量实现显示学生信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">        <span class="number">1001</span>, <span class="string">&quot;计算广告生态&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">28</span>, <span class="number">98.5</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> =</span> &amp;stu;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No.\t%d\n&quot;</span>, s-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name.\t%s\n&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sex.\t%c\n&quot;</span>, s-&gt;sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age.\t%d\n&quot;</span>, s-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Score.\t%d\n&quot;</span>, s-&gt;score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex012.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">No.    1001</span><br><span class="line">Name.    计算广告生态</span><br><span class="line">Sex.    M</span><br><span class="line">Age.    28</span><br><span class="line">Score.    73896</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex13-使用指针输出数组元素"><a href="#案例ex13-使用指针输出数组元素" class="headerlink" title="案例ex13: 使用指针输出数组元素"></a><strong>案例ex13: 使用指针输出数组元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>目标：熟悉指针和数组的底层逻辑</p>
<p>功能：使用指针输出数组元素</p>
<p>描述：通过指针将数组中你那个各个元素值进行打印输出</p>
</blockquote>
<p><strong>2 要点</strong></p>
<p>a. 指向数组的指针实现输出数组元素，定义一个指向数组的指针用来灵活操作数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="comment">// 指针 p 指向数组的方法，下面两种都是可以的.</span></span><br><span class="line"><span class="comment">// a 本身就是数组的其实地址，&amp;a[0] 也是数组的起始地址</span></span><br><span class="line">p = a;                 </span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>b. 指针既是指向变量地址的又是决定指向变量地址的位数的。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>既是指向数组a的首地址 又是说明了每次指向都int类型的数据，即 4 个字节。</p>
<p>所以，在指定 p 的<strong>基类型</strong>后，通过指针指向数组，每次 p++ 都是会跳动4个字节，到达下一个位置a[1]。</p>
<p>即：*(p+1) 即取得 a[1] 的数据</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：熟悉指针和数组的底层逻辑</span></span><br><span class="line"><span class="comment">功能：使用指针输出数组元素</span></span><br><span class="line"><span class="comment">描述：通过指针将数组中你那个各个元素值进行打印输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 10 个数字: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = a; p &lt; a+<span class="number">10</span>; ++p)    &#123;    <span class="comment">// 指针指向进行数组内容打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组中的内容：\n%d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex013.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 10 个数字:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">数组中的内容：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex14-找出数列中的最大值和最小值"><a href="#案例ex14-找出数列中的最大值和最小值" class="headerlink" title="案例ex14: 找出数列中的最大值和最小值"></a><strong>案例ex14: 找出数列中的最大值和最小值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：max_min()</p>
<p>功能：找出数列中的最大值和最小值</p>
<p>描述：使用指针查找数列中的最大值和最小值（使用指针从而避免使用返回值）</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针从而避免使用返回值</p>
<p>在主函数中定义最大值 max 和最小值 min，将 max 和 min 的地址传递给函数处理，计算结果直接放到主函数中定义的 max 和 min 的地址中</p>
<p>这样做代码执行高效并且思路清晰</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：max_min()</span></span><br><span class="line"><span class="comment">功能：找出数列中的最大值和最小值</span></span><br><span class="line"><span class="comment">描述：使用指针查找数列中的最大值和最小值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span> </span>&#123;</span><br><span class="line">    *max = *a;        <span class="comment">// 将数组下标为 0 的数字初始化给max</span></span><br><span class="line">    *min = *a;        <span class="comment">// 将数组下标为 0 的数字初始化给min</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*max &lt; *(a+i))        <span class="comment">// 将大于max的值赋值给max</span></span><br><span class="line">            *max = *(a+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*min &gt; *(a+i))        <span class="comment">// 将小于min的值赋值给min</span></span><br><span class="line">            *min = *(a+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, a[N];</span><br><span class="line">    <span class="keyword">int</span> max, min;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 10 个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">        <span class="comment">// scanf(&quot;%d&quot;, &amp;a[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    max_min(a, &amp;max, &amp;min);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的 10 个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n最大值为：%d\n&quot;</span>, max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n最小值为：%d\n&quot;</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex014.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 10 个数字：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">输入的 10 个数字为： 3 2 1 10 9 8 7 6 5 4</span><br><span class="line">最大值为：10</span><br><span class="line"></span><br><span class="line">最小值为：1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex15-使用指针的指针输出字符串"><a href="#案例ex15-使用指针的指针输出字符串" class="headerlink" title="案例ex15: 使用指针的指针输出字符串"></a><strong>案例ex15: 使用指针的指针输出字符串</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用指针的指针输出字符串</p>
<p>描述：</p>
<p>使用指针的指针输出字符串。</p>
<p>首先要使用指针数组创建一个字符串数组，然后定义指向指针的指针，使其指向字符串数组，并使用其输出数组的字符串</p>
</blockquote>
<p><strong>2 思路</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> **p;</span><br></pre></td></tr></table></figure>
<p>这里指向指针的指针，表示指针变量 p 是指向一个指针变量。*p 就表示 p 指向另外一个指针变量，即一个地址。</p>
<p><em>*p 表示 p 指向指针变量指向的对象的值。 例如：\</em> (p+1) 表示 accounts[1] 的内容，指向 accounts[1] 的首地址</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指针的指针输出字符串</span></span><br><span class="line"><span class="comment">描述：使用指针的指针输出字符串。</span></span><br><span class="line"><span class="comment">首先要使用指针数组创建一个字符串数组，然后定义指向指针的指针，使其指向字符串数组，并使用其输出数组的字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *accounts[] = &#123;</span><br><span class="line">        <span class="string">&quot;你好 C语言 1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 5&quot;</span></span><br><span class="line">    &#125;;                                                                        <span class="comment">// 指针数组创建字符串数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    p = accounts;                                                    <span class="comment">// 注意这里一定是二重指针来指向accounts</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(p+i));                            <span class="comment">// 使用指针将字符串数组中的字符串打印出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex015.c -o demo</span></span><br><span class="line">yaojianguodeMacBook-Pro:ex100 yaojianguo$ ./demo</span><br><span class="line">欢迎关注公众号, 计算广告生态1</span><br><span class="line">欢迎关注公众号, 计算广告生态2</span><br><span class="line">欢迎关注公众号, 计算广告生态3</span><br><span class="line">欢迎关注公众号, 计算广告生态4</span><br><span class="line">欢迎关注公众号, 计算广告生态5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex16-使用指向指针的指针对字符串排序"><a href="#案例ex16-使用指向指针的指针对字符串排序" class="headerlink" title="案例ex16: 使用指向指针的指针对字符串排序"></a><strong>案例ex16: 使用指向指针的指针对字符串排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：sort()</p>
<p>功能：使用指向指针的指针对字符串排序</p>
<p>描述：</p>
<p>使用指向指针的指针对字符串排序，输出是按照字母顺序进行排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>a. 熟悉指向指针的指针的使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *nums[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> **p;</span><br><span class="line">p = nums;</span><br></pre></td></tr></table></figure>
<p>熟悉 *p 指向的是 nums[0] 的首地址</p>
<p><strong>b. 引用模块#include <string.h></string.h></strong></p>
<p>使用函数 int strcmp(const char <em>str1, const char </em>str2) 进行字符串的比较</p>
<p>该函数返回值如下：</p>
<ul>
<li>如果返回值小于 0，则表示 str1 小于 str2。</li>
<li>如果返回值大于 0，则表示 str1 大于 str2。</li>
<li>如果返回值等于 0，则表示 str1 等于 str2。</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指向指针的指针对字符串排序</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">使用指向指针的指针对字符串排序，输出是按照字母顺序进行排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;     <span class="comment">// 排序交换时的临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(*(p+i), *(p+j)) &gt; <span class="number">0</span>) &#123;     <span class="comment">// 使用strcmp进行字符串的比较</span></span><br><span class="line">                temp = *(p+i);</span><br><span class="line">                *(p+i) = *(p+j);</span><br><span class="line">                *(p+j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">char</span> *nums[] = &#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    p = nums;            <span class="comment">// 使用指向指针的指针指向字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前的数组内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex016.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">排序前的数组内容为：</span><br><span class="line">one two three four five six seven eight nine ten</span><br><span class="line">排序后的数组内容为：</span><br><span class="line">eight five four nine one seven six ten three two</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex17-使用指针连接两个字符串"><a href="#案例ex17-使用指针连接两个字符串" class="headerlink" title="案例ex17: 使用指针连接两个字符串"></a><strong>案例ex17: 使用指针连接两个字符串</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：connect()</p>
<p>功能：使用指针连接两个字符串</p>
<p>描述：</p>
<p>实现两个已知字符串的连接，放到另外一个字符串数组中，然后将连接好的字符串进行打印显示</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用<strong>字符型指针变量</strong>和<strong>指向字符串的指针</strong>做函数的参数来实现字符串的连接</p>
<p>注意初始化 char *conn来存储新字符串的时候，必须先分配存储空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *conn = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(conn, <span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 可选，初始化填充内存空间</span></span><br></pre></td></tr></table></figure>
<p>另外，使用指针的特性，使得 conn 不断被赋值， str1 和 str2 指向的存储地址，达到字符串的连接</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：connect()</span></span><br><span class="line"><span class="comment">功能：使用指针连接两个字符串</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">实现两个已知字符串的连接，放到另外一个字符串数组中，然后将连接好的字符串进行打印显示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2, <span class="keyword">char</span> *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str1 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *conn = *str1;</span><br><span class="line">        conn++;</span><br><span class="line">        str1++;</span><br><span class="line">    &#125;</span><br><span class="line">    *conn = <span class="string">&#x27;,&#x27;</span>;     <span class="comment">// 两个字符串直接添加逗号</span></span><br><span class="line">    conn++;</span><br><span class="line">    <span class="keyword">while</span>(*str2 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *conn = *str2;</span><br><span class="line">        conn++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    *conn = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;技术分享园子&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *conn = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>);      <span class="comment">// 为 conn 分配空间，否则是无效地址</span></span><br><span class="line">    <span class="built_in">memset</span>(conn, <span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>, <span class="number">0</span>);               <span class="comment">// 初始化 conn 指向的存储地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个字符串：%s\n&quot;</span>, str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个字符串：%s\n&quot;</span>, str2);</span><br><span class="line">    connect(str1, str2, conn);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连接后的字符串是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex017.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">第一个字符串：技术分享园子</span><br><span class="line">第二个字符串：计算广告生态</span><br><span class="line">连接后的字符串是：</span><br><span class="line">技术分享园子,计算广告生态</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex18-用指针实现逆序存放数组元素的值"><a href="#案例ex18-用指针实现逆序存放数组元素的值" class="headerlink" title="案例ex18: 用指针实现逆序存放数组元素的值"></a><strong>案例ex18: 用指针实现逆序存放数组元素的值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：invert()</p>
<p>功能：用指针实现逆序存放数组元素的值</p>
<p>描述：使用指针将数组中的元素值逆序放置，并且将结果打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>1. 程序变量中两个数字进行交换的三种方法</strong></p>
<p> 第一种：引入一个中间量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br></pre></td></tr></table></figure>
<p> 第二种：要注意的是a+b可能会超过int的范围，这个是该方法的缺点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure>
<p>第三种：这种方法效率最高，推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure>
<p><strong>2. 指针的使用</strong></p>
<p>使用指针对数组内容进行操作，数组 a， a 指向数组首位置，a+N-1 指向最后一位。从而利用循环对数组的首尾数字逐个替换</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：invert()</span></span><br><span class="line"><span class="comment">功能：用指针实现逆序存放数组元素的值</span></span><br><span class="line"><span class="comment">描述：使用指针将数组中的元素值逆序放置，并且将结果打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *begin, *end, mid;   <span class="comment">// 定义首尾指针</span></span><br><span class="line">    begin = a;</span><br><span class="line">    end = a+N<span class="number">-1</span>;</span><br><span class="line">    mid = (N<span class="number">-1</span>)/<span class="number">2</span>;             <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid; ++i)&#123;    <span class="comment">// 循环，首尾指针内容变换</span></span><br><span class="line">        <span class="comment">// temp = *begin;</span></span><br><span class="line">        <span class="comment">// *begin = *end;</span></span><br><span class="line">        <span class="comment">// *end = temp;</span></span><br><span class="line">        *begin = *begin ^ *end;</span><br><span class="line">        *end = *begin ^ *end;</span><br><span class="line">        *begin = *begin ^ *end;</span><br><span class="line"></span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前数组中的值为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    invert(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用指针逆序后数组中的值为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex018.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">当前数组中的值为：1 2 3 4 5 6 7 8 9 10</span><br><span class="line">使用指针逆序后数组中的值为：10 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex19-用指针数组构造字符串数组"><a href="#案例ex19-用指针数组构造字符串数组" class="headerlink" title="案例ex19: 用指针数组构造字符串数组"></a><strong>案例ex19: 用指针数组构造字符串数组</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用<strong>指针数组</strong>构造字符串数组</p>
<p>描述：实现输入一个星期中对应的第几天，可以显示其英文名</p>
<p>目标：熟悉对字符串数组对应的指针的使用</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p>要点：通过构造一个字符串数组来指定数组中元素的元素值。</p>
</li>
<li><p>指针数组：即数组中都是指针类型的数据，指针数组中的每个元素都是一个指针</p>
<p>定义：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型名 *数组名[数组长度];</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>​        其中 p 是一个指针数组，该数组是由 5 个数据元素组成，每个元素相当于一个指针变量，都可以指向一个字符串变量</p>
<ul>
<li>注意点：<em>p[4] 与 (\</em>p)[4] 的区别要知道， <strong>(*p)[4] 中的 p 是一个指向一维数组的指针变量</strong></li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：用指针数组构造字符串数组</span></span><br><span class="line"><span class="comment">描述：实现输入一个星期中对应的第几天，可以显示其英文名</span></span><br><span class="line"><span class="comment">目标：熟悉对字符串数组对应的指针的使用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *week[] = &#123;</span><br><span class="line">        <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> w;    <span class="comment">// 用来记录周几</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入星期几(输入阿拉伯数字)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today is %s.\n&quot;</span>, *(week+w<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex019.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入星期几(输入阿拉伯数字)：5</span><br><span class="line">Today is Friday</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex20-用指针函数输出学生成绩"><a href="#案例ex20-用指针函数输出学生成绩" class="headerlink" title="案例ex20: 用指针函数输出学生成绩"></a><strong>案例ex20: 用指针函数输出学生成绩</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：search()</p>
<p>功能：用指针函数输出学生成绩</p>
<p>描述：指针函数的使用，输入学生的序号，将在窗口输出该序号对应的学生的成绩</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p>指向函数的指针变量的形式如下：</p>
<p>数据类型 (*指针变量名)()</p>
<p>例如;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>*(p)() 表示定义一个指向函数的指针变量，用来存放函数入口地址。在程序设计过程中，将一个函数地址赋值给它，它就指向那个函数。函数指针变量赋值写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = min;</span><br></pre></td></tr></table></figure>
<p>在赋值的时候，只给出函数名即可<strong>，函数名即地址</strong></p>
<p>在使用函数指针调用函数的时候，要写出函数的参数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m = (*p)(a,b);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：search()</span></span><br><span class="line"><span class="comment">功能：用指针函数输出学生成绩</span></span><br><span class="line"><span class="comment">描述：指针函数的使用，输入学生的序号，将在窗口输出该序号对应的学生的成绩</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pt = *(p+n);</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">98</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">87</span>&#125;,</span><br><span class="line">        &#123;<span class="number">88</span>,<span class="number">56</span>,<span class="number">87</span>,<span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">92</span>,<span class="number">56</span>,<span class="number">84</span>,<span class="number">82</span>&#125;,</span><br><span class="line">        &#123;<span class="number">78</span>,<span class="number">56</span>,<span class="number">90</span>,<span class="number">67</span>&#125;</span><br><span class="line">    &#125;;                    <span class="comment">// 声明数组，对应四个学生的各科成绩</span></span><br><span class="line">    <span class="keyword">int</span> no;                <span class="comment">// 保存学生编号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入学生编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;no);</span><br><span class="line">    <span class="keyword">int</span> *p = search(score, no);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生编号为 %d 的学生成绩为：\n&quot;</span>, no);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex020.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入学生编号：3</span><br><span class="line">学生编号为3的学生成绩为：</span><br><span class="line">78    56    90    67</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex21-寻找相同元素的指针"><a href="#案例ex21-寻找相同元素的指针" class="headerlink" title="案例ex21: 寻找相同元素的指针"></a><strong>案例ex21: 寻找相同元素的指针</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：find()</p>
<p>功能：寻找相同元素的指针</p>
<p>描述：比较两个有序数组的元素，输出两个数组中第一个相同的值</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用有序数组有序的特点</p>
<p>建立一个指针函数，这个函数返回值为指针类型，即一个地址。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在程序中调用该函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = find(a, b, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>返回一个指向整型变量的指针</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：find()</span></span><br><span class="line"><span class="comment">功能：寻找相同元素的指针</span></span><br><span class="line"><span class="comment">描述：比较两个有序数组的元素，输出两个数组中第一个相同的值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pa = a;</span><br><span class="line">    <span class="keyword">int</span> *pb = b;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt; a+m &amp;&amp; pb &lt; b+n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt; *pb) &#123;</span><br><span class="line">            pa++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pa &gt; *pb) &#123;</span><br><span class="line">            pb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">34</span>,<span class="number">56</span>&#125;;        <span class="comment">// 声明两个数组</span></span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">59</span>&#125;;    <span class="comment">// 声明两个数组    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两个数组的内容分别是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); ++i) &#123;     <span class="comment">// 打印数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]); ++j) &#123;     <span class="comment">// 打印数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line">    p = find(a, b, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n相同的数字是：%d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex021.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">两个数组的内容分别是：</span><br><span class="line">2 5 7 9 11 34 56</span><br><span class="line">3 6 8 10 12 34 59</span><br><span class="line">相同的数字是：34</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex22-查找成绩不及格的学生"><a href="#案例ex22-查找成绩不及格的学生" class="headerlink" title="案例ex22: 查找成绩不及格的学生"></a><strong>案例ex22: 查找成绩不及格的学生</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：search()</p>
<p>功能：查找成绩不及格的学生</p>
<p>描述：有 4 名学生的成绩，找出至少有一科不及格的学生，并将成绩列表输出（规定60以下为不及格）</p>
<p>目标：重点理解 int (*p)[N] 的使用方法</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>int*p[5] 和 int(*p)[5] 的区别</strong></p>
<ul>
<li><p>int *p[5],首先它是一个数组，它的大小是5，p里面存放的数据都是类型是int *,也就是整型指针。 所以它叫指针数组。</p>
</li>
<li><p>int (*p)[5]，首先p是一个指针，<strong>指向大小为5的数组</strong>，因此这叫数组指针。通常用在二维数组的操作上</p>
<ul>
<li>注意指针的类型，从 int(*p)[5] 可以看到， p 的类型不是int *， 而是 int(*)[5]，p 被定义为指向一维数组的指针变量，里面有 5 个元素，因此，p 的基类型是一维数组，长度为 20 字节。</li>
<li>*(p+2)+3， 括号中的 2 是指的以 p 的基类型（一维整型数组）的长度为单位的，即，p 每增加 1，地址就增加 20 个字节（5 个元素，每个元素4个字节）。而 *(p+2)+3 括号外的数字 3，不是以 p 的基类型的长度为单位的，而是一维数组的下一个位置</li>
</ul>
</li>
<li><p>先看一个简单的引例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">float</span> (*p)[<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;序号为 %d 的学生的成绩：\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2f &quot;</span>, *(*(p+n)+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">60</span>,<span class="number">75</span>,<span class="number">82</span>,<span class="number">91</span>&#125;,&#123;<span class="number">75</span>,<span class="number">81</span>,<span class="number">91</span>,<span class="number">90</span>&#125;,&#123;<span class="number">51</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">84</span>&#125;&#125;;</span><br><span class="line">    search(score, <span class="number">2</span>);  <span class="comment">// 计算得出序号为 2 的学生的成绩</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~操作结果~~~~~~~~~~~~</span><br><span class="line">$ gcc ex022<span class="number">-1.</span>c -o demo</span><br><span class="line">./yaojianguodeMacBook-Pro:C语言<span class="number">100</span>题集合代码 yaojianguo$ ./demo</span><br><span class="line">序号为 <span class="number">2</span> 的学生的成绩：</span><br><span class="line"><span class="number">51.00</span> <span class="number">65.00</span> <span class="number">78.00</span> <span class="number">84.00</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：search()</span></span><br><span class="line"><span class="comment">功能：查找成绩不及格的学生</span></span><br><span class="line"><span class="comment">描述：有 4 名学生的成绩，找出至少有一科不及格的学生，并将成绩列表输出（规定60以下为不及格）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> (*p)[N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * pt = *(p+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(*(p+<span class="number">0</span>)+i) &lt; <span class="number">60</span>) &#123;   <span class="comment">// 这块可以写成*(*p+i) &lt; 60，也就是平常看到了*(*(p+m)+n）)来取到二维数组中列向的值</span></span><br><span class="line">            pt = *p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p;</span><br><span class="line">    <span class="keyword">int</span> score[][N]=&#123;&#123;<span class="number">60</span>,<span class="number">75</span>,<span class="number">82</span>,<span class="number">91</span>&#125;,&#123;<span class="number">75</span>,<span class="number">81</span>,<span class="number">91</span>,<span class="number">90</span>&#125;,&#123;<span class="number">51</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">84</span>&#125;,&#123;<span class="number">65</span>,<span class="number">72</span>,<span class="number">78</span>,<span class="number">72</span>&#125;,&#123;<span class="number">75</span>,<span class="number">70</span>,<span class="number">98</span>,<span class="number">92</span>&#125;&#125;;     <span class="comment">// 四个学生的成绩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        p = search(score+i);</span><br><span class="line">        <span class="keyword">if</span> (p==*(score+i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成绩不及格学生的成绩分别是:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+j));</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex022.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">成绩不及格学生的成绩分别是:</span><br><span class="line">51 65 78 84</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex23-使用指针实现冒泡排序"><a href="#案例ex23-使用指针实现冒泡排序" class="headerlink" title="案例ex23: 使用指针实现冒泡排序"></a><strong>案例ex23: 使用指针实现冒泡排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：bubble_order()</p>
<p>功能：使用指针实现冒泡排序</p>
<p>描述：实现C语言经典的冒泡排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>冒泡排序的基本思路:</strong></p>
<p>如果对 n 个数进行冒泡排序，则需要进行 n-1 躺比较，在第 1 趟比较中要进行 n-1 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：bubble_order()</span></span><br><span class="line"><span class="comment">功能：使用指针实现冒泡排序</span></span><br><span class="line"><span class="comment">描述：实现C语言经典的冒泡排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_order</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(a+j) &gt; *(a+j+<span class="number">1</span>)) &#123;</span><br><span class="line">                *(a+j) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">                *(a+j+<span class="number">1</span>) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">                *(a+j) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>], n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要排序元素的个数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入各个元素\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前元素的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+j));</span><br><span class="line">    &#125;</span><br><span class="line">    bubble_order(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n排序后元素的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex023.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入要排序元素的个数：</span><br><span class="line">5</span><br><span class="line">请输入各个元素</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">9</span><br><span class="line">4</span><br><span class="line">排序前元素的内容为：</span><br><span class="line">3 7 1 9 4</span><br><span class="line">排序后元素的内容为：</span><br><span class="line">1 3 4 7 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex24-输入月份号并输出英文月份名"><a href="#案例ex24-输入月份号并输出英文月份名" class="headerlink" title="案例ex24: 输入月份号并输出英文月份名"></a><strong>案例ex24: 输入月份号并输出英文月份名</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输入月份号并输出英文月份名</p>
<p>描述：</p>
<p>使用指针数组创建一个含有月份英文名的字符串数组</p>
<p>并使用指向指针的指针指向这个字符串数组，实现输出数组中的指定字符串</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针的指针实现对字符串数组中的字符串的输出</p>
<p>*month[] 属于指针数组，*month本身就是指针，数组中都是存放着指针。那么 month是指针数组的首地址，**p=month 指向数组中的每个元素</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输入月份号并输出英文月份名</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">使用指针数组创建一个含有月份英文名的字符串数组</span></span><br><span class="line"><span class="comment">并使用指向指针的指针指向这个字符串数组，实现输出数组中的指定字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *month[] = &#123;</span><br><span class="line">        <span class="string">&quot;January&quot;</span>,</span><br><span class="line">        <span class="string">&quot;February&quot;</span>,</span><br><span class="line">        <span class="string">&quot;March&quot;</span>,</span><br><span class="line">        <span class="string">&quot;April&quot;</span>,</span><br><span class="line">        <span class="string">&quot;May&quot;</span>,</span><br><span class="line">        <span class="string">&quot;June&quot;</span>,</span><br><span class="line">        <span class="string">&quot;July&quot;</span>,</span><br><span class="line">        <span class="string">&quot;August&quot;</span>,</span><br><span class="line">        <span class="string">&quot;September&quot;</span>,</span><br><span class="line">        <span class="string">&quot;October&quot;</span>,</span><br><span class="line">        <span class="string">&quot;November&quot;</span>,</span><br><span class="line">        <span class="string">&quot;December&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">char</span> **p;           <span class="comment">// 指向指针的指针变量</span></span><br><span class="line">    p = month;        <span class="comment">// 数组首地址赋值给指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个月份号(阿拉伯数组)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本月是：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(p+m<span class="number">-1</span>));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex024.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入一个月份号(阿拉伯数组)：3</span><br><span class="line">本月是：March</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入一个月份号(阿拉伯数组)：9</span><br><span class="line">本月是：September</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex25-使用指针插入元素"><a href="#案例ex25-使用指针插入元素" class="headerlink" title="案例ex25: 使用指针插入元素"></a><strong>案例ex25: 使用指针插入元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：insert()</p>
<p>功能：使用指针插入元素</p>
<p>描述：在有序（升序)的数组中插入一个数，使得插入的数组仍然有序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>参数传递，使用指针变量</li>
<li>插入数字，找到插入点，<strong>从数组的末端逐个向后移动</strong>，最后将要插入的数字放到插入点</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：insert()</span></span><br><span class="line"><span class="comment">功能：使用指针插入元素</span></span><br><span class="line"><span class="comment">描述：在有序（升序)的数组中插入一个数，使得插入的数组仍然有序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; *(a+i))</span><br><span class="line">            <span class="keyword">break</span>;            <span class="comment">// 插入的数据记录大于数组中数据的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( ; j &gt; i; --j) &#123;</span><br><span class="line">        *(a+j) = *(a+j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *(a+i) = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N+<span class="number">1</span>], add_num;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入十个数字:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要插入的数字: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;add_num);</span><br><span class="line"></span><br><span class="line">    insert(a, add_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入后的数组为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex025.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入十个数字:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">输入要插入的数字: 6</span><br><span class="line">6</span><br><span class="line">插入后的数组为： 1 2 3 4 5 6 7 8 9 10 11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex26-使用指针交换两个数组中的最大值"><a href="#案例ex26-使用指针交换两个数组中的最大值" class="headerlink" title="案例ex26: 使用指针交换两个数组中的最大值"></a><strong>案例ex26: 使用指针交换两个数组中的最大值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：max()、swap()</p>
<p>功能：使用指针交换两个数组中的最大值</p>
<p>描述：</p>
<p>输入两个五个元素的数组，使用指针将两个数组中的最大值进行交换</p>
<p>并输出最大值交换之后的两个数组</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>以下都使用指针来进行实现</p>
<ol>
<li>找到最大值<br> 创建 int <em>max(int </em>a) 函数，指针指向找出的最大值</li>
<li>交换最大值<br> 创建 void swap(int <em>p1, int </em>p2) 找到的两个最大值进行交换，即进行指针指向的内容进行交换</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：max()、swap()</span></span><br><span class="line"><span class="comment">功能：使用指针交换两个数组中的最大值</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">输入两个五个元素的数组，使用指针将两个数组中的最大值进行交换</span></span><br><span class="line"><span class="comment">并输出最大值交换之后的两个数组</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(a+i) &gt; *p)</span><br><span class="line">            p = a+i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    *p1 = *p1 ^ *p2;</span><br><span class="line">    *p2 = *p1 ^ *p2;</span><br><span class="line">    *p1 = *p1 ^ *p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> * max_a, * max_b;</span><br><span class="line">    <span class="comment">// 1. 初始化两个数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数组 a 的5个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数组 b 的5个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (b+j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 a 的5个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 b 的5个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 找出各数组中的最大值</span></span><br><span class="line">    max_a = max(a);</span><br><span class="line">    max_b = max(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 a 的最大值：%d&quot;</span>, *max_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 b 的最大值：%d&quot;</span>, *max_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对两个最大值进行交换</span></span><br><span class="line">    swap(max_a, max_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n交换最大值之后的数组 a 的5个数字为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n交换最大值之后的数组 b 的5个数字为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex026.c -o demo</span></span><br><span class="line">yaojianguodeMacBook-Pro:C语言100题集合代码 yaojianguo$ ./demo</span><br><span class="line">输入数组 a 的5个数字：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">输入数组 b 的5个数字：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">数组 a 的5个数字为： 1 3 5 7 9</span><br><span class="line">数组 b 的5个数字为： 2 4 6 8 10</span><br><span class="line">数组 a 的最大值：9</span><br><span class="line">数组 b 的最大值：10</span><br><span class="line">交换最大值之后的数组 a 的5个数字为：1 3 5 7 10</span><br><span class="line">交换最大值之后的数组 b 的5个数字为：2 4 6 8 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex27-输出二维数组有关值-二维数组的经典案例-非常重要"><a href="#案例ex27-输出二维数组有关值-二维数组的经典案例-非常重要" class="headerlink" title="案例ex27: 输出二维数组有关值(二维数组的经典案例,非常重要)"></a><strong>案例ex27: 输出二维数组有关值(二维数组的经典案例,非常重要)</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输出二维数组有关值(二维数组的经典案例,非常重要)</p>
<p>描述：输出二维数组中的有关值，以及指向二维数组的指针变量的应用</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>非常重要！非常重要！非常重要！</strong></p>
<p>a+1 是二维数组 a 中序号为 1 的行的首地址（序号从0起算），而*(a+1) 并不是 a+1 单元的内容(值)，因为 a+1 并不是一个变量的存储单元，也就谈不上他的内容了。*(a+1) 就是 a[1]，而 a[1] 是一维数组名，所以也是地址，它指向 a[1][0]。a[1] 和 *(a+1) 都是二维数组中地址的不同表现形式</p>
<p><img src="/images/54dca58dd5321010bbf45b00a98173971.jpg" width="50%" height="50%"></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输出二维数组有关值(二维数组的经典案例,非常重要)</span></span><br><span class="line"><span class="comment">描述：输出二维数组中的有关值，以及指向二维数组的指针变量的应用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,  <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a, *a);                                 <span class="comment">// 0 行的首地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">0</span>], *(a+<span class="number">0</span>));                    <span class="comment">// 0 行 0 列元素地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>][<span class="number">0</span>]);            <span class="comment">// 0 行的首地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">1</span>], a+<span class="number">1</span>);                        <span class="comment">// 1 行 0 列的元素地址, 1 行首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, &amp;a[<span class="number">1</span>][<span class="number">0</span>], *(a+<span class="number">1</span>)+<span class="number">0</span>);        <span class="comment">// 1 行 0 列的元素地址, 1 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">1</span>][<span class="number">1</span>], *(*(a+<span class="number">1</span>)+<span class="number">1</span>));    <span class="comment">// 1 行 1 列的值，1 行 1 列的值</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex027.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746688,-302746688</span><br><span class="line">-302746688,-302746688</span><br><span class="line">6,6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex28-输出二维数组任一行任一列值"><a href="#案例ex28-输出二维数组任一行任一列值" class="headerlink" title="案例ex28: 输出二维数组任一行任一列值"></a><strong>案例ex28: 输出二维数组任一行任一列值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输出二维数组任一行任一列值</p>
<p>描述：一个 3 行 4 列的数组，输入要显示数组元素的所在行数和列数，将在终端显示该数组元素的值</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>熟悉ex027的案例，对上一个案例的简单应用</p>
<p>要彻底理解指针和二维数组的操作以及其内在的联系</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输出二维数组任一行任一列值</span></span><br><span class="line"><span class="comment">描述：一个 3 行 4 列的数组，输入要显示数组元素的所在行数和列数，将在终端显示该数组元素的值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p, (*pt)[<span class="number">4</span>], i, j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组内容为:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (p = a[<span class="number">0</span>]; p &lt; a[<span class="number">0</span>] + <span class="number">12</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p - a[<span class="number">0</span>]) % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,  *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入想要获取的数字的位置: i=, j= \n&quot;</span>);</span><br><span class="line">    pt = a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;i=%d, j=%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d行%d列的值为；\na[%d, %d]=%d\n&quot;</span>, i, j, i, j, *(*(pt + i) + j));</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex028.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">数组内容为:</span><br><span class="line">   1   2   3   4</span><br><span class="line">   5   6   7   8</span><br><span class="line">   9  10  11  12</span><br><span class="line">请输入想要获取的数字的位置: i=, j=</span><br><span class="line"> i=1, j=2</span><br><span class="line">1行2列的值为；</span><br><span class="line">a[1, 2]=7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex29-将若干字符串按照字母顺序输出"><a href="#案例ex29-将若干字符串按照字母顺序输出" class="headerlink" title="案例ex29: 将若干字符串按照字母顺序输出"></a><strong>案例ex29: 将若干字符串按照字母顺序输出</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：sort()</p>
<p>功能：将若干字符串按照字母顺序输出</p>
<p>描述：实现对程序中几个字符串按照从小到大的顺序进行排序，并打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>运用字符串数组的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * week[] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>将 week 传递到 sort() 函数，然后利用 C 语言提供的 strcmp() 进行字符类的比较</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：sort()</span></span><br><span class="line"><span class="comment">功能：将若干字符串按照字母顺序输出</span></span><br><span class="line"><span class="comment">描述：实现对程序中几个字符串按照从小到大的顺序进行排序，并打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *p[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(*(p+i), *(p+j)) &gt; <span class="number">0</span>) &#123;    <span class="comment">// 比较大小，交换位置</span></span><br><span class="line">                temp = *(p+i);</span><br><span class="line">                *(p+i) = *(p+j);</span><br><span class="line">                *(p+j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * week[] = &#123;</span><br><span class="line">        <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    sort(week);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的周为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(week+i));</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex029.c -o de</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">排序后的周为：</span><br><span class="line">Friday Monday Saturday Sunday Thursday Tuesday Wednesday</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex30-用指向函数的指针比较大小"><a href="#案例ex30-用指向函数的指针比较大小" class="headerlink" title="案例ex30: 用指向函数的指针比较大小"></a><strong>案例ex30: 用指向函数的指针比较大小</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：min() / max()</p>
<p>功能：用指向函数的指针比较大小</p>
<p>描述：实现输入两个整数后，打印较小和较大的那个数字（规定使用指向函数的指针实现）</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>函数指针</strong></p>
<ul>
<li><p>函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。一个函数的地址是该函数的进入点，也是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。</p>
</li>
<li><p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p>
</li>
<li><p>定义形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型 (*指针变量名)(参数列表)；</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> i,<span class="keyword">int</span> j);</span><br></pre></td></tr></table></figure></li>
<li>p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。p首先和*结合，表明p是一个指针。然后再与()结合，表明它指向的是一个函数。指向函数的指针也称为函数指针。</li>
</ul>
<p><strong>本案例中，利用指向函数的指针，在不同情况同一个指针指向不同的函数实现不同的功能</strong></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：min() / max()</span></span><br><span class="line"><span class="comment">功能：用指向函数的指针比较大小</span></span><br><span class="line"><span class="comment">描述：实现输入两个整数后，打印较小的那个数字（规定使用指向函数的指针实现）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>(*p)();</span><br><span class="line">    <span class="keyword">int</span> a, b, max_v, min_v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请你输入两个数字(如：a, b): \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="comment">// 取小值</span></span><br><span class="line">    p = min;</span><br><span class="line">    min_v = (*p)(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d\n&quot;</span>, min_v);</span><br><span class="line">    <span class="comment">// 取大值</span></span><br><span class="line">    p = max;</span><br><span class="line">    max_v = (*p)(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max_v);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex030.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请你输入两个数字(如：a, b):</span><br><span class="line">1,5</span><br><span class="line">min=1</span><br><span class="line">max=5</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请你输入两个数字(如：a, b):</span><br><span class="line">10,50</span><br><span class="line">min=1</span><br><span class="line">max=50</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex31-字符串的匹配"><a href="#案例ex31-字符串的匹配" class="headerlink" title="案例ex31: 字符串的匹配"></a><strong>案例ex31: 字符串的匹配</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：match()</p>
<p>功能：字符串的匹配</p>
<p>描述：</p>
<p>本例实现两个字符串的匹配操作，即在第一个字符串中查找是否存在第二个字符串。</p>
<p>如果字符串完全匹配，则提示”匹配“，并显示第二个字符串在第一个字符串中的开始位置。</p>
<p>否则：提示”不匹配“</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本案例自定义 match(char <em>B, char </em>A) 函数进行匹配，使用循环进行每个字符进行比较，从而找出是否包含子串</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：match()</span></span><br><span class="line"><span class="comment">功能：字符串的匹配    </span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">本例实现两个字符串的匹配操作，即在第一个字符串中查找是否存在第二个字符串。</span></span><br><span class="line"><span class="comment">如果字符串完全匹配，则提示”匹配“，并显示第二个字符串在第一个字符串中的开始位置。</span></span><br><span class="line"><span class="comment">否则：提示”不匹配“</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> *B, <span class="keyword">char</span> *A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastB = <span class="built_in">strlen</span>(B) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lastA = <span class="built_in">strlen</span>(A) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endmatch = lastA;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; endmatch &lt;= lastB; endmatch++, start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[endmatch] == A[lastA])</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>, i = start; j &lt; lastA &amp;&amp; B[i] == A[j];)</span><br><span class="line">                i++, j++;</span><br><span class="line">        <span class="keyword">if</span> (j == lastA)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (start + <span class="number">1</span>); <span class="comment">/*成功  */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endmatch &gt; lastB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不匹配!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;Computational advertising ecology&quot;</span>; <span class="comment">// 计算广告生态</span></span><br><span class="line">    <span class="keyword">char</span> t[] = <span class="string">&quot;advertising&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> p = match(s, t);</span><br><span class="line">    <span class="keyword">if</span> (p !=  - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配的开始位置在: %d&quot;</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex031.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">匹配!</span><br><span class="line">匹配的开始位置在: 15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex32-使用malloc-函数分配内存"><a href="#案例ex32-使用malloc-函数分配内存" class="headerlink" title="案例ex32: 使用malloc()函数分配内存"></a><strong>案例ex32: 使用malloc()函数分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用malloc()函数分配内存</p>
<p>描述：</p>
<p>要求创建一个结构体类型的指针，其中包含两个成员，一个是整型，另外一个是结构体指针</p>
<p>使用 malloc() 函数分配一个结构体的内存空间，然后给这两个成员赋值并显示</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>malloc() 函数的语法格式如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><br>该函数的作用是在内存中的动态存储区域动态分配指定长度的存储空间。该函数返回一个指针，然后指向所分配存储空间的起始地址。<br>如果返回值 0，那么表示没有成功申请到内存空间。函数类型为 void * ，表示返回的指针不指向任何类型。</p>
<p>本例中，使用 malloc() 函数申请返回指向结构体的指针，利用该指针可以进行结构体成员的赋值和取值操作<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">st s = (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用malloc()函数分配内存</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">要求创建一个结构体类型的指针，其中包含两个成员，一个是整型，另外一个是结构体指针。</span></span><br><span class="line"><span class="comment">使用 malloc() 函数分配一个结构体的内存空间，然后给这两个成员赋值并显示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span>    <span class="comment">// 结构体成员，指针类型</span></span><br><span class="line">&#125;*st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    st s = (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));     <span class="comment">// 开辟存储空间</span></span><br><span class="line">    s-&gt;n = <span class="number">1</span>;                 <span class="comment">// 成员 n 赋值</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;            <span class="comment">// 成员 next 赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成员的 n = %d, 成员 next = %d\n&quot;</span>, s-&gt;n, s-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex032.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">成员的 n = 1, 成员 next = 0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex33-调用calloc-函数动态分配内存存放若干数据"><a href="#案例ex33-调用calloc-函数动态分配内存存放若干数据" class="headerlink" title="案例ex33: 调用calloc()函数动态分配内存存放若干数据"></a><strong>案例ex33: 调用calloc()函数动态分配内存存放若干数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：调用calloc()函数动态分配内存存放若干数据</p>
<p>返回值分配域的起始地址吗，如果分配失败返回 0</p>
<hr>
<p>理解<strong>malloc() 和 calloc() 异同点</strong></p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p><strong>calloc() 函数</strong><br>的语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">calloc</span><span class="params">(<span class="keyword">unsigned</span> n, <span class="keyword">unsigned</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在内存中动态分配 n 个长度为 size 的连续内存空间数组，calloc() 函数会返回一个指针<br>该指针指向动态分配的连续内存空间地址。<br>当分配错误的时候，会返回 0</p>
</li>
</ul>
<ul>
<li><p><strong>malloc() 和 calloc() 异同点</strong></p>
<ul>
<li><p><strong>共同点：</strong><br>都为了分配存储空间，<br>它们返回的是 void <em> 类型，也就是说如果我们要为int或者其他类型的数据分配空间<em>*必须显式强制转换</em></em>；</p>
</li>
<li><p><strong>不同点：</strong><br>malloc() 1个形参，因此如果是数组，必须由我们计算需要的字节总数作为形参传递<br>用malloc只分配空间不初始化，也就是依然保留着这段内存里的数据，<br>calloc() 2个形参，因此如果是数组，需要传递个数和数据类型<br>而calloc则进行了初始化，<strong>calloc分配的空间全部初始化为0</strong>，这样就避免了可能的一些数据错误</p>
</li>
</ul>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：调用calloc()函数动态分配内存存放若干数据</span></span><br><span class="line"><span class="comment">返回值分配域的起始地址吗，如果分配失败返回 0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *p, *q;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数据的个数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 分配内存空间，并且会进行初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;为 %d 个数据分配内存空间 \n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (q = p; q &lt; p+n; ++q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给 p 指向的一段内存空间存储的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex033.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入数据的个数：</span><br><span class="line">5</span><br><span class="line">为 5 个数据分配内存空间</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">给 p 指向的一段内存空间存储的内容是：</span><br><span class="line">1 5 6 8 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex34-为具有-5-个数组元素的数组分配内存"><a href="#案例ex34-为具有-5-个数组元素的数组分配内存" class="headerlink" title="案例ex34: 为具有 5 个数组元素的数组分配内存"></a><strong>案例ex34: 为具有 5 个数组元素的数组分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：为具有 5 个数组元素的数组分配内存</p>
<p>描述：为具有 5 个元素的数组动态分配内存，并赋值输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用 calloc() 函数为数组的 5 个元素进行分配存储空间，然后进行赋值</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：为具有 5 个数组元素的数组分配内存</span></span><br><span class="line"><span class="comment">描述：为具有 5 个元素的数组动态分配内存，并赋值输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(N, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;看使用 calloc() 函数后，初始化的内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(p+i) = i*<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化后的数组的内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex034.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">看使用 calloc() 函数后，初始化的内容：</span><br><span class="line">0 0 0 0 0</span><br><span class="line">初始化后的数组的内容：</span><br><span class="line">0 3 6 9 12</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex35-为二维数组动态分配内存"><a href="#案例ex35-为二维数组动态分配内存" class="headerlink" title="案例ex35: 为二维数组动态分配内存"></a><strong>案例ex35: 为二维数组动态分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：为二维数组动态分配内存</p>
<p>描述：为二维数组动态分配内存，然后输出并释放内存</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li>在C语言中，一维数组是通过 malloc() 函数动态分配空间来实现的，动态的二维数组也能够通过malloc()函数动态分配空间来实现。实际上，C语言中没有二维数组，至少对二维数组没有直接的支持，取而代之的是“数组的数组”，二维数组能够看成是由指向数组的指针构成的数组。</li>
<li>对于一个二维数组p[i][j]，编译器通过公式 *(*(p+i)+j) 求出数组元素的值，其中，p+i表示计算行指针；*(p+i)表示具体的行，是指针，指向该行首元素地址 *(*(p+i)+j 表示得到具体元素的地址；*(*(p+i)+j)表示得到元素的值。基于这个原理，通过分配一个指针数组，再对指针数组的每一个元素分配空间实现动态的分配二维数组</li>
</ul>
<p>案例中实现的步骤<br>1.定义二维指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **p;         <span class="comment">// 二维数组指针</span></span><br></pre></td></tr></table></figure>
<p>2.分配行动态空间<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *[M]));     <span class="comment">// 指向指针的指针</span></span><br></pre></td></tr></table></figure><br>3.再为每一行的每一列进行动态分配<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(p+i) = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>[N]));</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：为二维数组动态分配内存</span></span><br><span class="line"><span class="comment">描述：为二维数组动态分配内存，然后输出并释放内存</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **p;         <span class="comment">// 二维数组指针</span></span><br><span class="line">    p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *[M]));     <span class="comment">// 指向指针的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        *(p+i) = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>[N]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            *(*(p+i)+j) = i + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给二维数组分配空间后，内存的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>, *(*(p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex035.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">给二维数组分配空间后，内存的内容是：</span><br><span class="line">0     1     2     3     4</span><br><span class="line">1     2     3     4     5</span><br><span class="line">2     3     4     5     6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex36-商品信息的动态存放"><a href="#案例ex36-商品信息的动态存放" class="headerlink" title="案例ex36: 商品信息的动态存放"></a><strong>案例ex36: 商品信息的动态存放</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：商品信息的动态存放</p>
<p>描述：</p>
<p>创建一个商品的结构体</p>
<p>动态分配一块内存区域，存放一个商品信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li>定义一个商品信息的结构体类型，同时声明一个结构体类型的指针COMM</li>
<li>调用 malloc() 函数分配空间，地址存放在指针变量 commodity 中</li>
<li>利用指针变量访问该地址空间中的每个成员数据，并为成员赋值，主要要使用 “-&gt;” 去访问，例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COMM commodity = (struct commodity *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct commodity));</span><br><span class="line">commodity-&gt;num = <span class="number">1011</span>;</span><br><span class="line">commodity-&gt;name = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">commodity-&gt;count = <span class="number">10001</span>;</span><br><span class="line">commodity-&gt;price = <span class="number">15000.1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：商品信息的动态存放</span></span><br><span class="line"><span class="comment">描述：创建一个商品的结构体， 动态分配一块内存区域，存放一个商品信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">commodity</span> &#123;</span>    <span class="comment">// 结构体定义</span></span><br><span class="line">    <span class="keyword">int</span> num;                                     <span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">char</span> *name;                             <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">int</span> count;                              <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">double</span> price;                         <span class="comment">// 商品单价</span></span><br><span class="line">&#125;*COMM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    COMM commodity = (struct commodity *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct commodity));</span><br><span class="line">    commodity-&gt;num = <span class="number">1011</span>;</span><br><span class="line">    commodity-&gt;name = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">    commodity-&gt;count = <span class="number">10001</span>;</span><br><span class="line">    commodity-&gt;price = <span class="number">15000.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编号：%d\n商品名称：%s\n商品数量：%d\n商品单价：%f\n&quot;</span>,    </span><br><span class="line">        commodity-&gt;num, commodity-&gt;name, commodity-&gt;count, commodity-&gt;price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex036.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">编号：1011</span><br><span class="line">商品名称：计算广告生态</span><br><span class="line">商品数量：10001</span><br><span class="line">商品单价：15000.100000</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex37-用不带参数的宏定义求平行四边形面积"><a href="#案例ex37-用不带参数的宏定义求平行四边形面积" class="headerlink" title="案例ex37: 用不带参数的宏定义求平行四边形面积"></a><strong>案例ex37: 用不带参数的宏定义求平行四边形面积</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用不带参数的宏定义求平行四边形面积</p>
<p>描述：利用不带参数的宏的形式(一般宏大写字母，以便与其他的操作符进行区别)</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>不带参数的宏名定义如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></table></figure><br>一般情况下 “#” 表示这是一条预处理命令，宏名是一个标识符，必须符合 C 语言规定<br>字符串可以是常数、表达式、格式字符串等<br>后面几节分别就这几种进行讲解</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A  8  <span class="comment">// 定义宏，设置底边的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H  6  <span class="comment">// 定义宏，设置高的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：用不带参数的宏定义求平行四边形面积</span></span><br><span class="line"><span class="comment">描述：利用不带参数的宏的形式(一般宏大写字母，以便与其他的操作符进行区别)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area;                                                <span class="comment">// 存储平行四边形面积</span></span><br><span class="line">    area = A * H;                                        <span class="comment">// 计算平行四边形面积</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 = %d\n&quot;</span>, area);         <span class="comment">// 输出面积值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex037.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">面积 = 48</span><br></pre></td></tr></table></figure>
<p>&gt;</p>
<hr>
<h3 id="案例ex38-使用宏定义实现数组值的互换"><a href="#案例ex38-使用宏定义实现数组值的互换" class="headerlink" title="案例ex38: 使用宏定义实现数组值的互换"></a><strong>案例ex38: 使用宏定义实现数组值的互换</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用宏定义实现数组值的互换</p>
<p>描述：定义一个宏 swap(a, b)，以实现两个整数的交换，并利用它将一维数组 a 和 b 进行交换</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>宏关于函数的运用<br>一般形式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(参数表) 字符串函数定义</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>对带参数的宏的展开只是将语句中的宏名后面括号内的实参字符串代替 #define 命令行中的形参</li>
<li>在宏定义时，在宏名与带参数的括号之间不可以加空格，否则将空格以后的字符都作为替代字符串的一部分</li>
<li><strong>在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义</strong></li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;int temp; temp=a;a=b;b=temp;&#125; <span class="comment">// 宏swap(a,b)进行两个整数的交换</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用宏定义实现数组值的互换</span></span><br><span class="line"><span class="comment">描述：定义一个宏 swap(a, b)，以实现两个整数的交换，并利用它将一维数组 a 和 b 进行交换</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数组a：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数组b：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组a的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组b的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组a 和 数组b的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        swap(*(a+i), *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后数组a的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后数组b的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex038.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个数组a：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">15</span><br><span class="line">17</span><br><span class="line">19</span><br><span class="line">请输入一个数组b：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">数组a的内容是：</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br><span class="line">数组b的内容是：</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br><span class="line">交换后数组a的内容是：</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br><span class="line">交换后数组b的内容是：</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex39-编写头文件包含圆面积的计算公式"><a href="#案例ex39-编写头文件包含圆面积的计算公式" class="headerlink" title="案例ex39: 编写头文件包含圆面积的计算公式"></a><strong>案例ex39: 编写头文件包含圆面积的计算公式</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：编写头文件包含圆面积的计算公式</p>
<p>描述：</p>
<p>计算圆的面积，宏定义存储在一个头文件中</p>
<p>输入半径就可以得到面积</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用不同的文件需要包含不同的 #include 指令，包含两种格式<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;文件名&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>需要注意的是，这两种格式的区别是</p>
<ul>
<li>用尖括号时，系统到存放C库函数头文件所在的目录中寻找要包含的文件，这种称为标准方式</li>
<li>用双引号时，系统先在用户当前目录中寻找要包含的文件，若找不到，再到存放C库函数头文件所在的目录中寻找要包含的文件</li>
</ul>
</li>
<li><p>如果为调用库函数用 #include 命令来包含相关的头文件，则用尖括号，可以节省査找的时间</p>
</li>
<li>如果要包含的是用户自己编写的文件，一般用双引号，用户自己编写的文件通常是在当前目录中</li>
</ul>
<p><strong>如果文件不在当前目录中，双引号可给出文件路径</strong></p>
<p><strong>3 代码</strong></p>
<p>主函数代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ex039_area.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：编写头文件包含圆面积的计算公式</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">计算圆的面积，宏定义存储在一个头文件中</span></span><br><span class="line"><span class="comment">输入半径就可以得到面积</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r;                            <span class="comment">// 定义园的半径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入半径:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 =%.2f \n&quot;</span>,area(r));    <span class="comment">// 调用 ex039_area.h 中的 area函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ex039_area.h：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> area(r) PI*(r)*(r)</span></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex039.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入半径:</span><br><span class="line">3</span><br><span class="line">面积 =28.26</span><br><span class="line">~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入半径:</span><br><span class="line">10</span><br><span class="line">面积 =314.00</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex40-利用宏定义求偶数和"><a href="#案例ex40-利用宏定义求偶数和" class="headerlink" title="案例ex40: 利用宏定义求偶数和"></a><strong>案例ex40: 利用宏定义求偶数和</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：利用宏定义求偶数和</p>
<p>描述：</p>
<p>定义一个宏实现求 1~100 的偶数和</p>
<p>定义一个宏判断一个数是否为偶数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>1、先熟悉带参数的宏已经参数宏利用其它的宏定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVEN(x) (((x)%2==0)?TRUE:FALSE)</span></span><br></pre></td></tr></table></figure>
<p><strong>2、要点</strong><br>在累加求和过程中需要不断判断数据是否为偶数，因此要创建带参数的宏<br>把判断偶数的过程定义为常量，由于C语言中不提供逻辑常量，因此自定义宏 TRUE 和 FALSE,表示1和0<br>因此，判断偶数的宏又可以演变为下面的形式：</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVEN(x) (((x)%2==0)?TRUE:FALSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：利用宏定义求偶数和</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">定义一个宏实现求 1~100 的偶数和</span></span><br><span class="line"><span class="comment">定义一个宏判断一个数是否为偶数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(EVEN(i))    </span><br><span class="line">            sum+=i;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SUM = %d\n&quot;</span>,sum);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex040.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">SUM = 2550</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex41-利用文件包含设计输出模式"><a href="#案例ex41-利用文件包含设计输出模式" class="headerlink" title="案例ex41: 利用文件包含设计输出模式"></a><strong>案例ex41: 利用文件包含设计输出模式</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：利用文件包含设计输出模式</p>
<p>描述：</p>
<p>在程序设计时需要很多输出格式，如整型、实型及字符型等，在编写稈序时会经常使用这些输出格式<br>如果经常书写这些格式会很繁琐，要求设计一个头文件，将经常使用的<br>输出模式都写进头文件中，方便编写代码</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本稈序中仅举一个简单的例子，将整型数据的输出写入到头文件中，并将这个头文件<br>命名为 ex041_format.h 声明整型数据并输出的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTEGER(d) printf(<span class="meta-string">&quot;%4d\n&quot;</span>,d)</span></span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<p>主函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ex041_format.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：利用文件包含设计输出模式</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">在程序设计时需要很多输出格式，如整型、实型及字符型等，在编写稈序时会经常使用这些输出格式</span></span><br><span class="line"><span class="comment">如果经常书写这些格式会很繁琐，要求设计一个头文件，将经常使用的</span></span><br><span class="line"><span class="comment">输出模式都写进头文件中，方便编写代码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;                    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);        </span><br><span class="line">    INTEGER(d);        <span class="comment">// 使用宏定义的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ex041_format.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTEGER(d) printf(<span class="meta-string">&quot;计算结果: %4d\n&quot;</span>,d)</span></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex041.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个整数:10</span><br><span class="line">计算结果:   10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex42-使用条件编译隐藏密码"><a href="#案例ex42-使用条件编译隐藏密码" class="headerlink" title="案例ex42: 使用条件编译隐藏密码"></a><strong>案例ex42: 使用条件编译隐藏密码</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用条件编译隐藏密码</p>
<p>描述：一般输入密码时都会用拿号来替代，用以增强安全性。要求设置一个宏，规定宏体为<br>1,在正常情况下密码显示为审号的形式，在某些特殊的时候，显示为字符串。运行结果</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>C 语言预编译命令 <strong>#if··· #else··· #endif</strong></p>
<p>这个方法一般可以用来调试的时候用，也可以作为控制语句进行使用。有时候串口打印信息太多，一条条注释就很麻烦，于是就用这种方法，定义个宏变量，判断宏变量的条件，来达到改变宏变量的值控制那些代码编译</p>
<p>指令格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span></span></span><br><span class="line">    语句段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    语句段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对于一个字符串要求有两种输出形式<br>一种是原样输出<br>另一种是用相同数目输出<br>可以通过选择语句来实现，但是使用条件编译指令可以在编译阶段就决定要怎样操作</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWD 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用条件编译隐藏密码</span></span><br><span class="line"><span class="comment">描述：一般输入密码时都会用拿号来替代，用以增强安全性。要求设置一个宏，规定宏体为</span></span><br><span class="line"><span class="comment">1,在正常情况下密码显示为审号的形式，在某些特殊的时候，显示为字符串。运行结果</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s=<span class="string">&quot;mrsoft&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PWD    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex042.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">******</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex43-关闭所有打开的文件"><a href="#案例ex43-关闭所有打开的文件" class="headerlink" title="案例ex43: 关闭所有打开的文件"></a><strong>案例ex43: 关闭所有打开的文件</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用fgetc函数从键盘逐个输入字符，然后用fputc函数写到磁盘文件中</p>
<p>描述：</p>
<p>用 fgetc 函数从键盘逐个输入字符，然后用 fputc函数写到磁盘文件即可</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>用来存储数据的文件名可以在fopen函数中直接写成字符串常量形式(如指定”1”)，也可以在程序运行时由用户临时指定。本程序采取的方法是由键盘输入文件名。为此设立一个字符数组filename,用来存放文件名。运行时，从键盘输入磁盘文件名”ex043_file.dat”, 操作系统就新建立一个磁盘文件ex043_file.dat,用来接收程序输出的数据</li>
<li>用fopen函数打开一个”只写”的文件(“w”表示只能写入不能从中读数据)，如果打开文件成功，函数的返回值是该文件所建立的信息区的起始地址，把它赋给指针变量fp(fp已定义为指向文件的指针变量)。如果不能成功地打开文件，则在显示器的屏幕上显示”无法打开此文件”,然后用exit函数终止程序运行</li>
<li>exit是标准C的库函数，作用是使程序终止，用此函数时在程序的开头应包含 <stdlib.h> 头文件</stdlib.h></li>
<li>用getchar函数接收用户从键盘输入的字符。注意每次只能接收一个字符。今输入字符串”公众号：计算广告生态”是用来向程序表示：输入的字符串到此结束。用什么字符作为结束标志是人为的，由程序指定的，也可以用别的字符(如或其他字符)作为结束标志。但应注意：如果字符串中包含”#”,就不能用”# “作结束标志</li>
<li>执行过程是：先从键盘读入一个字符，检查它是否如果是，表示字符串已结束，不执行循环体。如果不是’#’,则执行一次循环体，将该字符输出到磁盘文件filel.datₒ然后在屏幕上显示出该字符，接着再从键盘读入一个字符。如此反复，直到读入’#’字符为止。这时,程序已将”公众号：计算广告生态”写到以”filel. dat”命名的磁盘文件中了，同时在屏幕上也显示出了这些字符，以便核对。</li>
<li>ex043_file.dat 中是否确实存储了这些内容，可以在资源管理器中，按记事本的打开方式打开文件,或者在其他系统有其他查看方式</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：关闭所有打开的文件</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">用 fgetc 函数从键盘逐个输入字符，然后用 fputc函数写到磁盘文件即可</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> ch, filename[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要操作的文件名：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) &#123;     <span class="comment">// 打开输入文件并使 fp 指向此文件    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开此文件！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                                         <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch = getchar();                                <span class="comment">// 用来接收最后输入的回车符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个准备存储到磁盘的字符串（以&#x27;#&#x27;结束）\n&quot;</span>);</span><br><span class="line">    ch = getchar();                                <span class="comment">// 用来接收从键盘输入的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span>) &#123;                        <span class="comment">// 当输入&quot;#&quot;时结束循环</span></span><br><span class="line">        fputc(ch, fp);                            <span class="comment">// 用来向磁盘输出第一个字符</span></span><br><span class="line">        <span class="built_in">putchar</span>(ch);                                <span class="comment">// 将输出的字符显示在屏幕上</span></span><br><span class="line">        ch = getchar();                            <span class="comment">// 接收从键盘输入的一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);                                        <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                                    <span class="comment">// 向屏幕输出一个换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex043.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入要操作的文件名：</span><br><span class="line">ex043_file.dat</span><br><span class="line">请输入一个准备存储到磁盘的字符串（以&#x27;#&#x27;结束）</span><br><span class="line">公众号:计算广告生态</span><br><span class="line">公众号:计算广告生态</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><strong>文件中的显示：</strong></p>
<p>ex043_file.dat：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">公众号:计算广告生态</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex44-将文件中的内容从一个文件拷贝到另外一个文件"><a href="#案例ex44-将文件中的内容从一个文件拷贝到另外一个文件" class="headerlink" title="案例ex44: 将文件中的内容从一个文件拷贝到另外一个文件"></a><strong>案例ex44: 将文件中的内容从一个文件拷贝到另外一个文件</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将文件中的内容从一个文件拷贝到另外一个文件</p>
<p>描述：将上一个案例中的ex043_file.dat 赋值内容到 ex044_file.data</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>1、在访问磁盘文件时，是<strong>逐个字符(字节)</strong>进行的，为了知道当前访问到第几个字节，系统用 “<strong>文件读写位置标记</strong>“ 来表示当前所访问的位置。开始时“文件读写位置标记”指向第1个字节, <strong>每访问完一个字节后，当前读写位置就指向下一个字节</strong>，即当前读写位置自动后移。</p>
<p>2、为了知道对文件的访问是否完成，只须看文件读写位置是否移到文件的末尾。用<strong>feof函数</strong>可以检查到”<strong>文件读写位置标记</strong>“是否移到<strong>文件的末尾</strong>，即磁盘文件是否结束。程序第 26 行中的feof(in)是检查in所指向的文件是否结束。如果是，则函数值为1(真)，否则为0(假)，也就是“ !feof(in) ”为真，在while循环中检査“!feof(in)”为真，就执行循环体。</p>
<p>3、运行结果是将file.dat文件中的内容复制到file2.dat中去。打开这两个文件，可以看到<br>filel. dat 和 file2. dat 的内容都是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<p>4、以上程序是按文本文件方式处理的。也可以用此程序来复制一个二进制文件，只须将两个fopen函数中的“r”和“w”分别改为“rb”和“wb”即可。</p>
<p>5、C 系统已把fputc和fgetc函数定义为宏名putc和getc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> putc(ch, fp) fputc(ch, fp)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> getc(fp) fgetc(fp)</span></span><br></pre></td></tr></table></figure>
<p>这是在 <stdio.h> 中定义的。因此，在程序中用putc和fputc作用是一样的，用getc和fgetc<br>作用是一样的。在使用的形式上，可以把它们当作相同的函数对待。</stdio.h></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将文件中的内容从一个文件拷贝到另外一个文件</span></span><br><span class="line"><span class="comment">描述：将上一个案例中的ex043_file.dat 赋值内容到 ex044_file.dat</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *in, *out;                                        <span class="comment">// 指向文件的变量</span></span><br><span class="line">    <span class="keyword">char</span> ch, infile[<span class="number">20</span>], outfile[<span class="number">20</span>];    <span class="comment">// 定义的两个字符数组，分别存放两个数据文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入读入文件的名称(ex043_file.dat)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, infile);                            <span class="comment">// 输入第一个要读取文件的文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入输出文件的名称(ex044_file.dat)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, outfile);                            <span class="comment">// 输入第一个要读取文件的文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((in = fopen(infile, <span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>) &#123;     <span class="comment">// 打卡输入文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输入文件..\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((out = fopen(outfile, <span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>) &#123;     <span class="comment">// 打卡输出文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输出文件..\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(!feof(in)) &#123;                    <span class="comment">// 如果未遇到输入文件的结束标志，每次访问完一个字节后自动指向下一个字节</span></span><br><span class="line">        ch = fgetc(in);                        <span class="comment">// 从输入文件中读取一个</span></span><br><span class="line">        fputc(ch, out);                        <span class="comment">// 将 ch 写到 outfile 中</span></span><br><span class="line">        <span class="built_in">putchar</span>(ch);                             <span class="comment">// 显示到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                                <span class="comment">// 最后进行换行</span></span><br><span class="line">    fclose(in);                                    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    fclose(out);                                <span class="comment">// 关闭输出文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex044.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入读入文件的名称(ex043_file.dat)：ex043_file.dat</span><br><span class="line">输入输出文件的名称(ex044_file.dat)：ex044_file.dat</span><br><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<p>原来文件中的内容：</p>
<blockquote>
<p>This is the first message<br>copy to another file</p>
</blockquote>
<p>赋值过去的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex45-将排好序的字符串保存到磁盘文件中"><a href="#案例ex45-将排好序的字符串保存到磁盘文件中" class="headerlink" title="案例ex45: 将排好序的字符串保存到磁盘文件中"></a><strong>案例ex45: 将排好序的字符串保存到磁盘文件中</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将排好序的字符串保存到磁盘文件中</p>
<p>描述：从键盘读入若干个字符串，对它们按字母大小的顺序排序，然后把排好序的字符串送到磁盘文件中保存</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p><strong>2.1 处理字符串的两个函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>调用形式</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>fgets</td>
<td>fgets(str, n, fp)</td>
<td>从fp指向的文件读入一个长度为 (n-1) 的字符串，存放到字符数组str中</td>
<td>读成功，返回地址str，失败则返回 NULL</td>
</tr>
<tr>
<td>fputs</td>
<td>fputs(str, fp)</td>
<td>把str所指向的字符串写到文件指针变量 fp 所指向的文件中</td>
<td>输出成功，返回0；否则返回非 0 值</td>
</tr>
</tbody>
</table>
</div>
<p>fgets 中最后一个字母 s 表示字符串（string）。fgets 的含义是，从文件读取一个字符串</p>
<p><strong>1. fgets 函数的函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> n, fILE * fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其作用是从文件中读取一个字符串。调用时可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(str, n, fp)</span><br></pre></td></tr></table></figure>
<p>其中 n 是要求得到的字符的个数，<strong>但实际上只从fp所指向的文件中读取 n-1 个字符，然后在最后加 ‘\0’ 字符</strong>，这样得到的字符串共有 n 个字符，把它们放到数组 str 中。如果在读完 n-1 个字符之前遇到了换行符 ‘\n’ 或者结束符EOF，读入即结束，这块遇到换行符 ‘\n’ 也作为一个字符读入。若执行 fgets函数成功，则返回值为 str 数组元素的地址，如果一开始就遇到文件尾或者读取数据出错，则返回 NULL</p>
<p><strong>2.fputs函数的函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> * str, fILE * fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其作用是将str所指向的字符串输出到fp所指向的文件中。调用时可以写成</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;China&quot;</span>, fp);</span><br></pre></td></tr></table></figure>
<p>把字符串“China”输出到fp指向的文件中。fputs函数中第 1 个参数可以是字符串常量、字符数组名或者字符型指针。字符串末尾的 ‘\0’ 不输出，若输出成功，函数值为 0；失败时，函数值为 EOF。</p>
<p>fgets 和 fgets 这两个函数的功能类似于 gets 和 puts 函数，只是 gets 和 puts 以终端为读写对象，而 fgets 和 fputs 函数以指定的文件作为读写对象。</p>
<p><strong>3 思路</strong></p>
<ol>
<li>从键盘读入n个字符串，存放在一个二维字符数组中，每个一维数组存放一个字符串</li>
<li>对字符数组中的n个字符串按字母顺序排序，排好序的字符串仍存放在字符数组中</li>
<li>将字符数组中的字符串顺序输出</li>
</ol>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将排好序的字符串保存到磁盘文件中</span></span><br><span class="line"><span class="comment">描述：从键盘读入若干个字符串，对它们按字母大小的顺序排序，然后把排好序的字符串送到磁盘文件中保存</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">20</span>], temp[<span class="number">10</span>];                <span class="comment">// str保存存放字符串的二维数组，temp 临时数组</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入三个字符串: \n&quot;</span>);                <span class="comment">// 提示输入字符串</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        gets(str[i]);                                         <span class="comment">// 终端输入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;                     <span class="comment">// 用选择法对字符串排序</span></span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str[k], str[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                k=j;</span><br><span class="line">        <span class="keyword">if</span>(k != i) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp, str[i]);</span><br><span class="line">            <span class="built_in">strcpy</span>(str[i], str[k]);</span><br><span class="line">            <span class="built_in">strcpy</span>(str[k], temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;save_string.dat&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) &#123;     <span class="comment">// 打开磁盘文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的语句是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(str[i], fp);</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex045.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入三个字符串:</span><br><span class="line">grasp</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">新的语句是：</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">grasp</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex46-用二进制方式向文件读写一组数据"><a href="#案例ex46-用二进制方式向文件读写一组数据" class="headerlink" title="案例ex46: 用二进制方式向文件读写一组数据"></a><strong>案例ex46: 用二进制方式向文件读写一组数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：save()/read()</p>
<p>功能：用二进制方式向文件读写一组数据</p>
<p>描述：从键盘输入 10 个学生的有关数据，然后把他们转存到磁盘文件中去</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p>在程序中不仅需要一次输入输出一个数据， 而且常常需要一次输入输出一组数据(如数组或结构体变量的值)， C语言允许用fread函数从文件中读一个数据块， 用fwrite函数向文件写一个数据块。在读写时是以二进制形式进行的。向磁盘写数据时， 直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上， 在读入时也是将磁盘文件中若干字节的内容一批读入内存<br>它们的一般调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(buffer， size， count， fp);</span><br><span class="line">fwrite(buffer， size， count， fp);</span><br></pre></td></tr></table></figure>
<p>buffer：是一个地址</p>
<p><em>对fread来说，它是用来存放从文件读入的数据的存储区的地址</em></p>
<p><em>对fwrite来说，是要把此地址开始的存储区中的数据向文件输出(以上指的是起始地址)</em></p>
<p>size：要读写的字节数</p>
<p>count：要读写多少个数据项(每个数据项长度为size)</p>
<p>fp： FILE类型指针</p>
<p>在打开文件时指定用二进制文件， 这样就可以用 fread 和 fwrite 函数读写任何类型的信息， 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(f, <span class="number">4</span>, <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>
<p>其中 f 是一个 float 型数组名(代表数组首元素地址)。这个函数从 fp 所指向的文件读入10个4字节的数据，存储到数组 f 中。</p>
<p><strong>3 思路</strong></p>
<p>定义一个有 10 个元素的结构体数据，用来存放 10 个学生的数据。</p>
<p>从 main() 中输入 10 个数据。</p>
<p>用 save() 函数实现向磁盘输出学生数据。</p>
<p>用 fwrite() 函数一次输出一个学生的数据</p>
<p>用fread() 函数进行数据的读取</p>
<ol>
<li>在main函数中，从终端键盘输入io个学生的数据，然后调用 save 函数，将这些数据输出到以“stu.dat”命名的磁盘文件中。fwrite函数的作用是将一个长度为36节的数据块送到 ex046_stud.dat 文件中（一个struct student_type类型结构体变量的长度为它的成员长度之和，即10 + 4 + 4 + 15 = 33，实际上占36字节，是4的倍数）</li>
<li>在fopen函数中指定读写方式为“wb”，即二进制写方式。在向磁盘文件 ex046_stud.dat 写的时候，将内存中存放stud数组元素stud订的内存单元中的内容原样复制到磁盘文件，所建立的 ex046_stud.dat 文件是一个二进制文件。这个文件可以为其他程序所用。</li>
<li>在本程序中，用fopen函数打开文件时没有指定路径，只写了文件名ex046_stud.dat，系统默认其路径为当前用户所使用的子目录，在此目录下建立一个新文件ex046_stud.dat，输出的数据存放在此文件中。</li>
<li>程序运行时，屏幕上并无输出任何信息，只是将从键盘输入的数据送到磁盘文件上</li>
</ol>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：save()/read()</span></span><br><span class="line"><span class="comment">功能：用二进制方式向文件读写一组数据</span></span><br><span class="line"><span class="comment">描述：从键盘输入 10 个学生的有关数据，然后把他们转存到磁盘文件中去</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;stud[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以二进制格式进行保存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// 打卡输入文件 ex046_stud.dat</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件打开失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fwrite(&amp;stud[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写入失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二进制文件中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取打开文件失败!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        fread(&amp;stud[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp);     <span class="comment">// 从 fp 指向的文件读入一组数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%d\t%s\n&quot;</span>, stud[i].name, stud[i].num, stud[i].age, stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入 %d 个学生的信息：\n&quot;</span>, SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;    <span class="comment">// 注意 scanf 中的地址传递</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%s&quot;</span>,stud[i].name,&amp;stud[i].num,&amp;stud[i].age,&amp;stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    save();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n====== 读取写入的数据 =======\n&quot;</span>);</span><br><span class="line">    read();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex046.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入 10 个学生的信息：</span><br><span class="line">&quot;A&quot; 1 11 &quot;street01&quot;</span><br><span class="line">&quot;B&quot; 2 12 &quot;street02&quot;</span><br><span class="line">&quot;C&quot; 3 13 &quot;street03&quot;</span><br><span class="line">&quot;D&quot; 4 14 &quot;street04&quot;</span><br><span class="line">&quot;E&quot; 5 15 &quot;street05&quot;</span><br><span class="line">&quot;F&quot; 6 16 &quot;street06&quot;</span><br><span class="line">&quot;G&quot; 7 17 &quot;street07&quot;</span><br><span class="line">&quot;H&quot; 8 18 &quot;street08&quot;</span><br><span class="line">&quot;I&quot; 9 19 &quot;street09&quot;</span><br><span class="line">&quot;J&quot; 10 110 &quot;street010&quot;</span><br><span class="line">写入成功！</span><br><span class="line"></span><br><span class="line">====== 读取写入的数据 =======</span><br><span class="line">&quot;A&quot;    1    11    &quot;street01&quot;</span><br><span class="line">&quot;B&quot;    2    12    &quot;street02&quot;</span><br><span class="line">&quot;C&quot;    3    13    &quot;street03&quot;</span><br><span class="line">&quot;D&quot;    4    14    &quot;street04&quot;</span><br><span class="line">&quot;E&quot;    5    15    &quot;street05&quot;</span><br><span class="line">&quot;F&quot;    6    16    &quot;street06&quot;</span><br><span class="line">&quot;G&quot;    7    17    &quot;street07&quot;</span><br><span class="line">&quot;H&quot;    8    18    &quot;street08&quot;</span><br><span class="line">&quot;I&quot;    9    19    &quot;street09&quot;</span><br><span class="line">&quot;J&quot;    10    110    &quot;street010&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex47-对一个文件重复读取"><a href="#案例ex47-对一个文件重复读取" class="headerlink" title="案例ex47: 对一个文件重复读取"></a><strong>案例ex47: 对一个文件重复读取</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p><strong>功能</strong>：对一个文件重复读取（利用rewind()函数）</p>
<p><strong>描述：</strong></p>
<p>将磁盘文件的内容进行读取</p>
<p>第一次将它的内容显示在屏幕上，第二次把他复制到另外一个文件中</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p>对文件需要进行随机读取的原因：<br>对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高，例如文件中有1000个数据，若只査第1000个数据，必须先逐个读入前面999个数据，才能读入第1000个数据。如果文件中存放一个城市几百万人的资料,若按此方法查某一人的情况，等待的时间可能太长了。<br>随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数<br>据进行访问，显然这种方法比顺序访问效率高得多。</p>
<p><strong>rewind() 函数</strong></p>
<p>文件位置标记定位，强制使文件位置标记指向文件开头，此函数没有返回值</p>
<p><strong>3 思路</strong></p>
<p>可以利用 rewind() 函数进行操作，当第一次读取完后，文件位置标记指向了文件尾，那么使用 rewind() 函数将文件位置标记重新返回到文件头部</p>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：对一个文件重复读取</span></span><br><span class="line"><span class="comment">描述：将磁盘文件的内容进行读取，第一次将它的内容显示在屏幕上，第二次把他复制到另外一个文件中</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp1, * fp2;</span><br><span class="line">    fp1 = fopen(<span class="string">&quot;ex047_1.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);     <span class="comment">// 打开输入文件</span></span><br><span class="line">    fp2 = fopen(<span class="string">&quot;ex047_2.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);     <span class="comment">// 打开写入文件</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp1))&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(fgetc(fp1));             <span class="comment">// 输出到屏幕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                         <span class="comment">// 换行</span></span><br><span class="line">    rewind(fp1);                        <span class="comment">// 文件位置标记重新返回文件的开头</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp1)) &#123;</span><br><span class="line">        fputc(fgetc(fp1), fp2);             <span class="comment">// 重头，逐个字符读取写入到ex047_2.dat</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex047.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this is my first use of wind!</span><br></pre></td></tr></table></figure>
<p>ex047_2.dat 文件中内容，与ex047_1.dat一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this is my first use of wind!</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex48-将文件中不同位置的数据打印出来"><a href="#案例ex48-将文件中不同位置的数据打印出来" class="headerlink" title="案例ex48: 将文件中不同位置的数据打印出来"></a><strong>案例ex48: 将文件中不同位置的数据打印出来</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将文件中不同位置的数据打印出来</p>
<p>描述：</p>
<p>在磁盘上也存有10个学生的数据，要求将第 1、3、5、7、9 的学生数据输入到计算机<br>并且在屏幕中显示出来</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<ul>
<li><p>fseek() 函数</p>
<p>fseek() 函数改变文件位置标记<br>fseek() 的调用形式;<br>fseek(文件类型指针, 位移量, 起始点)<br>起始点用0，1或者2来替代。0 代表文件起始位置、1代表当前位置、2代表文件末尾位置</p>
<p>“位移量”指的是一“起始点” 为基点，向前移动的字节数。位移量应是 long 型数据<br>fseek() 函数一般用于二进制文件。看以下例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">100L</span>, <span class="number">0</span>)     <span class="comment">// 将文件位置标记向前移动到离文件开头100个字节处</span></span><br><span class="line">fseek(fp, <span class="number">50L</span>, <span class="number">1</span>)     <span class="comment">// 将文件位置标记向前移动到离当前位置50个字节处</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, <span class="number">2</span>)     <span class="comment">// 将文件位置标记向前移动到离文件末尾10个字节处</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>ftell() 函数<br>测定文件位置标记的当前位置<br>ftell() 的作用是得到流式文件中文件位置标记的当前位置<br>由于文件中的文件位置标记经常移动，人们往往不容易知道其当前的位置，所以常用 ftell() 函数得到当前位置，<strong>用相对于文件开头的位移量来表示</strong>。<br>如果调用函数时出错（例如不存在 fp 指向的文件）， ftell() 返回 -1L。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ftell(fp);     <span class="comment">// i 存放文件当前的位置</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">-1L</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 思路</strong></p>
<ol>
<li>按照2进制只读的方式打开指定文件，准备从文件中读取学生的成绩</li>
<li>将文件位置标记指向文件的开头，然后从磁盘文件读取一个学生的信息，并把它显示在屏幕上</li>
<li>再将文件位置标记指向第 1、3、5、7、9 的学生的数据区的开头，从磁盘中读取相应的学生的信息，显示在屏幕上</li>
<li>关闭文件</li>
</ol>
<p><strong>注意：将【ex046.c 用二进制方式向文件读写一组数据】按照二进制形式写入的学生信息进行读取</strong></p>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将文件中不同位置的数据打印出来</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">在磁盘上也存有10个学生的数据，要求将第 3、5、7、9 的学生数据输入到计算机</span></span><br><span class="line"><span class="comment">并且在屏幕中显示出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_type</span> &#123;</span>     <span class="comment">// 学生数据信息</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;stud[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        fseek(fp, i*<span class="keyword">sizeof</span>(struct student_type), <span class="number">0</span>);             <span class="comment">// 移动文件位置标记</span></span><br><span class="line">        fread(&amp;stud[i], <span class="keyword">sizeof</span>(struct student_type), <span class="number">1</span>, fp);    <span class="comment">// 读取一个数据块到结构体变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %4d %d %s \n&quot;</span>, stud[i].name, stud[i].num, stud[i].age, stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件中的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;    1    11    &quot;street01&quot;</span><br><span class="line">&quot;B&quot;    2    12    &quot;street02&quot;</span><br><span class="line">&quot;C&quot;    3    13    &quot;street03&quot;</span><br><span class="line">&quot;D&quot;    4    14    &quot;street04&quot;</span><br><span class="line">&quot;E&quot;    5    15    &quot;street05&quot;</span><br><span class="line">&quot;F&quot;    6    16    &quot;street06&quot;</span><br><span class="line">&quot;G&quot;    7    17    &quot;street07&quot;</span><br><span class="line">&quot;H&quot;    8    18    &quot;street08&quot;</span><br><span class="line">&quot;I&quot;    9    19    &quot;street09&quot;</span><br><span class="line">&quot;J&quot;    10    110    &quot;street010&quot;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;    1 11 &quot;street01&quot;</span><br><span class="line">&quot;C&quot;    3 13 &quot;street03&quot;</span><br><span class="line">&quot;E&quot;    5 15 &quot;street05&quot;</span><br><span class="line">&quot;G&quot;    7 17 &quot;street07&quot;</span><br><span class="line">&quot;I&quot;    9 19 &quot;street09&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex49-文件加密"><a href="#案例ex49-文件加密" class="headerlink" title="案例ex49: 文件加密"></a><strong>案例ex49: 文件加密</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：encrypt()<br>功能：文件加密<br>描述：C语言实现文件加密，执行参数有<br>【原文件路径及名称 密码 加密后文件路径及名称】</p>
</blockquote>
<p><strong>2 思路</strong></p>
<blockquote>
<p>register 关键字</p>
</blockquote>
<p>C语言中的关键字register代表寄存器存储类型<br>register修饰符暗示编译程序相应dao的变量zhuan将被频繁地使用，如shu果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问以提高效率</p>
<blockquote>
<p>加密</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = ch ^ *(pwd + i);</span><br></pre></td></tr></table></figure>
<p>采用异或方法进行加密，当然不同的情况可以采用不同的方式进行加密</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：文件加密</span></span><br><span class="line"><span class="comment">描述：C语言实现文件加密，执行参数有</span></span><br><span class="line"><span class="comment">【原文件路径及名称 密码 加密后文件路径及名称】</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">char</span> *s_file, <span class="keyword">char</span> *pwd, <span class="keyword">char</span> *c_file)</span></span>;                     <span class="comment">// 文件加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">char</span> *s_file, <span class="keyword">char</span> *pwd, <span class="keyword">char</span> *c_file)</span> </span>&#123;                      <span class="comment">// 自定义函数encrypt用于加密</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp1,  *fp2;                                                     <span class="comment">// 定义fp1和fp2是指向结构体变量的指针</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch;</span><br><span class="line">    fp1 = fopen(s_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开原文件.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                                         <span class="comment">// 如果不能打开要加密的文件,便退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp2 = fopen(c_file, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开被加密的文件.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                                         <span class="comment">// 如果不能建立加密后的文件,便退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp1);</span><br><span class="line">    <span class="keyword">while</span> (!feof(fp1))    &#123;                                                 <span class="comment">// 测试文件是否结束</span></span><br><span class="line"></span><br><span class="line">        ch = ch ^ *(pwd + i);                                            <span class="comment">// 采用异或方法进行加密，也可以采用其他方式方法就行加密</span></span><br><span class="line">        i++;</span><br><span class="line">        fputc(ch, fp2);                                                    <span class="comment">// 异或后写入fp2文件</span></span><br><span class="line">        ch = fgetc(fp1);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">9</span>)</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sourcefile[<span class="number">50</span>];                                                 <span class="comment">// 被加密的文件名称</span></span><br><span class="line">    <span class="keyword">char</span> codefile[<span class="number">50</span>];                         <span class="comment">// 加密后的文件名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">10</span>];                                                         <span class="comment">// 密码存储</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;                                                    <span class="comment">// 容错处理，不满足参数格式，需要自行输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入原文件名称:\n&quot;</span>);</span><br><span class="line">        gets(sourcefile);                                                 <span class="comment">// 得到要加密的文件名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入密码:\n&quot;</span>);</span><br><span class="line">        gets(pwd);                                                         <span class="comment">// 得到密码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入加密后文件名称:\n&quot;</span>);</span><br><span class="line">        gets(codefile);                                                 <span class="comment">// 得到加密后你要的文件名</span></span><br><span class="line">        encrypt(sourcefile, pwd, codefile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(sourcefile, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">strcpy</span>(pwd, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">strcpy</span>(codefile, argv[<span class="number">3</span>]);</span><br><span class="line">        encrypt(sourcefile, pwd, codefile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex049.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入原文件名称:</span><br><span class="line">s_file.txt</span><br><span class="line">请输入密码:</span><br><span class="line">johngo_py</span><br><span class="line">请输入加密后文件名称:</span><br><span class="line">c_file.txt</span><br></pre></td></tr></table></figure>
<p>最后就可以发现有加密后的文件产出</p>
<hr>
<h3 id="案例ex50-使用共用体存放学生和老师的信息"><a href="#案例ex50-使用共用体存放学生和老师的信息" class="headerlink" title="案例ex50: 使用共用体存放学生和老师的信息"></a><strong>案例ex50: 使用共用体存放学生和老师的信息</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用共用体存放学生和老师的信息<br>描述：根据输入职业的标识，区分出是老师还是学生<br>    然后根据输入的标识将对应的信息输出。<br>    如果是学生，则输出班级信息<br>    如果是老师，则输出职位信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<blockquote>
<p>共用体有时也被称为联合或者联合体</p>
<p>这也是 Union 这个单词的本意</p>
</blockquote>
<p><strong>结构体和共用体的区别：</strong></p>
<p>结构体的各个成员会占用不同的内存，互相之间没有影响；</p>
<p>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<p>共用体也是一种自定义类型，可以通过它来创建变量，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>
<p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>
<p>如果不再定义新的变量，也可以将共用体的名字省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union&#123;</span><br><span class="line">    int n;        </span><br><span class="line">    char ch;</span><br><span class="line">    double f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>
<p>另外，看看下面代码中对共用体的使用方法，可以在后面编程中参考使用</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用共用体存放学生和老师的信息</span></span><br><span class="line"><span class="comment">描述：根据输入职业的标识，区分出是老师还是学生</span></span><br><span class="line"><span class="comment">然后根据输入的标识将对应的信息输出。</span></span><br><span class="line"><span class="comment">如果是学生，则输出班级信息</span></span><br><span class="line"><span class="comment">如果是老师，则输出职位信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> tp;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                    <span class="comment">//共用体类型</span></span><br><span class="line">        <span class="keyword">int</span> inclass;</span><br><span class="line">        <span class="keyword">char</span> position[<span class="number">10</span>];</span><br><span class="line">    &#125;job;                                      <span class="comment">//共用体变量</span></span><br><span class="line">&#125;person[N];                                    <span class="comment">//结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 %d 个人信息(编号 姓名 类型(s/t) 班级/职位)：\n&quot;</span>, N);</span><br><span class="line">    <span class="comment">// 信息填写</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个人\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %c&quot;</span>, &amp;person[i].num, person[i].name, &amp;person[i].tp);        <span class="comment">/*输入信息*/</span></span><br><span class="line">        <span class="keyword">if</span>(person[i].tp==<span class="string">&#x27;s&#x27;</span>)                                        <span class="comment">/*根据类型值判断是老师还是学生*/</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;person[i].job.inclass);                    <span class="comment">/*输入工作类型*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(person[i].tp==<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, person[i].job.position);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n编号    姓名    类型    班级/职位\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信息输出</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(person[i].tp == <span class="string">&#x27;s&#x27;</span>)                                        <span class="comment">/*根据工作类型输出结果*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t%s\t%c\t%d&quot;</span>, person[i].num, person[i].name, person[i].tp, person[i].job.inclass);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(person[i].tp == <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t%s\t%c\t%s&quot;</span>, person[i].num, person[i].name, person[i].tp, person[i].job.position);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex050.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 2 个人信息(编号 姓名 类型(s/t) 班级/职位)：</span><br><span class="line">第1个人</span><br><span class="line">1 Johngo1 s 1</span><br><span class="line">第2个人</span><br><span class="line">2 Johngo2 t 数学</span><br><span class="line"></span><br><span class="line">编号    姓名    类型    班级/职位</span><br><span class="line">1    Johngo    s    1</span><br><span class="line">2    Johngo2    t    数学</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex51-使用共用体处理任意类型数据"><a href="#案例ex51-使用共用体处理任意类型数据" class="headerlink" title="案例ex51: 使用共用体处理任意类型数据"></a><strong>案例ex51: 使用共用体处理任意类型数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用共用体处理任意类型数据<br>描述：设计一个共用体类型，使其成员包含多种数据类型，根据不同的类型，输出不同的数据</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>首先设定了各种数据类型的变量，由于这些变量不是全部一次性处理的，所以就采用了共用体类型<br>在下面例子中，通过 TypeFlag 来识别在共用体重的存储类型，执行程序的时候就会按照不同的存储方式进行存储到 union_demo 变量中</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用共用体处理任意类型数据</span></span><br><span class="line"><span class="comment">描述：设计一个共用体类型，使其成员包含多种数据类型，根据不同的类型，输出不同的数据</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span>                                        <span class="comment">// 定义共用体</span></span><br><span class="line">    <span class="keyword">int</span> i;                                    <span class="comment">// 共用体成员</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;union_demo;                                        <span class="comment">// 声明共用体类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> TypeFlag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入成员类型:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;TypeFlag);                                <span class="comment">// 输入类型符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数字:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(TypeFlag) &#123;                                    <span class="comment">// 多分支选择语句判断输入</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;union_demo.i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;union_demo.c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;union_demo.f); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;union_demo.d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(TypeFlag) &#123;                                      <span class="comment">// 多分支选择语句判断输出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,union_demo.i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,union_demo.c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,union_demo.f); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,union_demo.d);</span><br><span class="line">    &#125;                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex051.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入成员类型:</span><br><span class="line">i</span><br><span class="line">输入数字:</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex52-输出今天星期几"><a href="#案例ex52-输出今天星期几" class="headerlink" title="案例ex52: 输出今天星期几"></a><strong>案例ex52: 输出今天星期几</strong></h3><p><strong>1 题目</strong></p>
<p>&gt;</p>
<p><strong>2 思路</strong></p>
<p>举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Monday          1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tuesday          2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Wednesday      3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Thursday      4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Friday          5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Saturday      6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sunday          7</span></span><br></pre></td></tr></table></figure><br>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span>Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday&#125; ;</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：week()</span></span><br><span class="line"><span class="comment">功能：输出今天星期几</span></span><br><span class="line"><span class="comment">描述：枚举类型的使用，利用枚举类型表示一周的每一天，然后通过数据来输出对应周几</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span>Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday&#125; ; <span class="comment">//定义枚举结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> day;                                            <span class="comment">//定义整型变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入星期数(0-6):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);                                    <span class="comment">//输入0-6的值</span></span><br><span class="line">    <span class="keyword">switch</span>(day) &#123;                                        <span class="comment">//根据数值进行判断</span></span><br><span class="line">        <span class="keyword">case</span> Sunday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期天&quot;</span>); <span class="keyword">break</span>;            <span class="comment">//根据枚举类型进行判断</span></span><br><span class="line">        <span class="keyword">case</span> Monday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期一&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tuesday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期二&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Wednesday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期三&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Thursday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期天四&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Friday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期五&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Saturday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期六&quot;</span>); <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex052.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入星期数(0-6):5</span><br><span class="line">今天是星期五</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex53-任意次方后的最后三位"><a href="#案例ex53-任意次方后的最后三位" class="headerlink" title="案例ex53: 任意次方后的最后三位"></a><strong>案例ex53: 任意次方后的最后三位</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：任意次方后的最后三位<br>描述：<br>求一个整数任意次方后的最后三位数，即求 x^y 的最后三位<br>x 和 y 的值由键盘输入</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>注意点：</strong></p>
<p>为了防止计算越界，本例中不能使用直接计算一个数的任意次方。那么如何去计算并且有效防止计算越界，而且不会产生误差。</p>
<p>这里采用了一种方式就是在每次进行次方相乘后，取其后三位，这样就不会出现越界的现象产生。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：任意次方后的最后三位</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">求一个整数任意次方后的最后三位数，即求 x^y 的最后三位</span></span><br><span class="line"><span class="comment">x 和 y 的值由键盘输入</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y, z = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数，x和y(x^y):\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);                                     <span class="comment">// 输入底数和幂数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        z = z * x % <span class="number">1000</span>;                                    <span class="comment">// 计算一个数任意次方的后三位</span></span><br><span class="line">    <span class="keyword">if</span>(z&gt;=<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d^%d的最后三位是:%d\n&quot;</span>, x, y, z);             <span class="comment">// 输出最终结果*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d^%d的最后三位是:0%d\n&quot;</span>, x, y, z);            <span class="comment">// 输出最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex053.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">1 1</span><br><span class="line">1^1的最后三位是:001</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">2 4</span><br><span class="line">2^4的最后三位是:016</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">5 9</span><br><span class="line">5^9的最后三位是:125</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex54-计算某日是该年的第几天"><a href="#案例ex54-计算某日是该年的第几天" class="headerlink" title="案例ex54: 计算某日是该年的第几天"></a><strong>案例ex54: 计算某日是该年的第几天</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：计算某日是该年的第几天<br>描述：计算天数的代码，从键盘输入年、月、日，在屏幕输出此日期是改年的第几天</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>判断年份是闰年还是平年，两点：要么可以直接被 400 整除，要么能被 4 整除，但是不能被 100 整除<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; a % <span class="number">100</span> != <span class="number">0</span> || a % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                                </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br></pre></td></tr></table></figure><br>判断该天是改年的第几天，那么需要知道每个月有多少天。另外，2 月份需要首先判断是平年还是闰年，再来进行后续的计算</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：计算某日是该年的第几天</span></span><br><span class="line"><span class="comment">描述：计算天数的代码，从键盘输入年、月、日，在屏幕输出此日期是改年的第几天</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leap</span><span class="params">(<span class="keyword">int</span> a)</span>    </span>&#123;                                         <span class="comment">// 判断是否为闰年</span></span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; a % <span class="number">100</span> != <span class="number">0</span> || a % <span class="number">400</span> == <span class="number">0</span>)        <span class="comment">// 闰年判定条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                        <span class="comment">// 是闰年返回1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                        <span class="comment">// 不是闰年返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;                    <span class="comment">// 参数 年 月 日，计算是该年的第几天</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">    <span class="comment">// 平年每月的天数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">// 闰年每月的天数</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leap(year) == <span class="number">1</span>)                                <span class="comment">// 判断是否为闰年</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            sum += b[i];                                <span class="comment">// 是闰年，累加数组b前m-1个月份天数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            sum += a[i];                                <span class="comment">// 不是闰年，累加数组a钱m-1个月份天数</span></span><br><span class="line">    sum += d;                                                        <span class="comment">// 将前面累加的结果加上日期，求出总天数</span></span><br><span class="line">    <span class="keyword">return</span> sum;                                                    <span class="comment">// 将计算的天数返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year, month, day, n;                                        <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年月日\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;year, &amp;month, &amp;day);                <span class="comment">// 输入年月日</span></span><br><span class="line">    n = number(year, month, day);                                <span class="comment">// 调用函数number</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d 是 %d 年的第 %d 天\n&quot;</span>, year, month, day, year, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex054.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入年月日</span><br><span class="line">2020 12 31</span><br><span class="line">2020.12.31 是 2020 年的第 366 天</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex55-婚礼上的谎言"><a href="#案例ex55-婚礼上的谎言" class="headerlink" title="案例ex55: 婚礼上的谎言"></a><strong>案例ex55: 婚礼上的谎言</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：婚礼上的谎言</p>
<p>描述：</p>
<p>3 对儿情侣参加婚礼，3 个新浪为A、B、C，3 个新娘为 X、Y、Z</p>
<p>有人想知道究竟谁与谁结婚，X 说他的未婚夫为C，C 说他将和 Z 结婚。这人们时候都知道他们在开玩笑，说全是假的。</p>
<p>那么，究竟谁与谁结婚呢？</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用穷举法进行计算</p>
<p>然后再利用题目中的谎话进行逻辑判断</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：婚礼上的谎言</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">3 对儿情侣参加婚礼，3 个新浪为A、B、C，3 个新娘为 X、Y、Z</span></span><br><span class="line"><span class="comment">有人想知道究竟谁与谁结婚，X 说他的未婚夫为C，C 说他将和 Z 结婚。这人们时候都知道他们在开玩笑，说全是假的。</span></span><br><span class="line"><span class="comment">那么，究竟谁与谁结婚呢？</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (a = <span class="number">1</span>; a &lt;= <span class="number">3</span>; a++)                                <span class="comment">// 穷举a的所有可能</span></span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">1</span>; b &lt;= <span class="number">3</span>; b++)                            <span class="comment">// 穷举b的所有可能</span></span><br><span class="line">            <span class="keyword">for</span> (c = <span class="number">1</span>; c &lt;= <span class="number">3</span>; c++)                        <span class="comment">// 穷举c的所有可能</span></span><br><span class="line">                <span class="keyword">if</span> (a != <span class="number">1</span> &amp;&amp; c != <span class="number">1</span> &amp;&amp; c != <span class="number">3</span> &amp;&amp; a != b &amp;&amp; a != c &amp;&amp; b != c) &#123;</span><br><span class="line">                                                <span class="comment">// 如果表达式为真，则输出结果，否则继续下次循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 A\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + a - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 B\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + b - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 C\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex055.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Z 将嫁给 A</span><br><span class="line">X 将嫁给 B</span><br><span class="line">Y 将嫁给 C</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex56-百元买百鸡"><a href="#案例ex56-百元买百鸡" class="headerlink" title="案例ex56: 百元买百鸡"></a><strong>案例ex56: 百元买百鸡</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：百元买百鸡</p>
<p>描述：</p>
<p>中国占代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡闷题”</p>
<p>鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>要点</strong><br>所买的 3 种鸡的钱数总和是 100<br>所买的 3 种鸡的数量总和是 100<br>所买的小鸡的数量必须是 3 的倍数</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：百元买百鸡</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">中国占代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡闷题”</span></span><br><span class="line"><span class="comment">鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cock, hen, chick;                                        <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    <span class="keyword">for</span> (cock = <span class="number">0</span>; cock &lt;= <span class="number">20</span>; cock++)                                <span class="comment">// 公鸡范围在0到20之间</span></span><br><span class="line">        <span class="keyword">for</span> (hen = <span class="number">0</span>; hen &lt;= <span class="number">33</span>; hen++)                            <span class="comment">// 母鸡范围在0到33之间</span></span><br><span class="line">            <span class="keyword">for</span> (chick = <span class="number">3</span>; chick &lt;= <span class="number">99</span>; chick++)                        <span class="comment">// 小鸡范围在3到99之间</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">5</span> *cock + <span class="number">3</span> * hen + chick / <span class="number">3</span> == <span class="number">100</span>)                 <span class="comment">// 判断钱数是否等于100</span></span><br><span class="line">                    <span class="keyword">if</span> (cock + hen + chick == <span class="number">100</span>)                 <span class="comment">// 判断购买的鸡数是否等于100</span></span><br><span class="line">                        <span class="keyword">if</span> (chick % <span class="number">3</span> == <span class="number">0</span>)                         <span class="comment">// 判断小鸡数是否能被3整除</span></span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;公鸡:%d 母鸡:%d 小鸡:%d\n&quot;</span>, cock, hen,chick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex056.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">公鸡:0 母鸡:25 小鸡:75</span><br><span class="line">公鸡:4 母鸡:18 小鸡:78</span><br><span class="line">公鸡:8 母鸡:11 小鸡:81</span><br><span class="line">公鸡:12 母鸡:4 小鸡:84</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex57-判断三角形的类型"><a href="#案例ex57-判断三角形的类型" class="headerlink" title="案例ex57: 判断三角形的类型"></a><strong>案例ex57: 判断三角形的类型</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：判断三角形的类型<br>描述：根据给定的三条边判断是否能构成三角形，并且输出它对应的面积和三角形类型</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>从键盘中输入三条边后，只需判断这三条边中任意两边之和是否大于第三边</p>
<p>如果满足条件，可以构成三角形</p>
<p>再做进一步判断确定该三角形是什么三角形</p>
<p>若两边相等-则是等腰三角形；若三边相等，则是等边三角形；若三边满足勾股定理，则是直角三角形</p>
<p>另外，注意 &amp;&amp; 和 || 的使用，以及 &amp; 与 &amp;&amp; 的区别和  | 与 || 的区别</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：判断三角形的类型</span></span><br><span class="line"><span class="comment">描述：根据给定的三条边判断是否能构成三角形，并且输出它对应的面积和三角形类型</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, b, c;</span><br><span class="line">    <span class="keyword">float</span> s, area;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入三角形的三条边长（以空格分隔）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 输入三条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %f\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; b) &#123;                    <span class="comment">// 判断两边之和是否大于第三边</span></span><br><span class="line">        s = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">        area = (<span class="keyword">float</span>)<span class="built_in">sqrt</span>(s *(s - a)*(s - b)*(s - c));         <span class="comment">// 计算三角形的面积</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;面积是:%f\n&quot;</span>, area);                             <span class="comment">// 输出三角形的面积</span></span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == c)                                    <span class="comment">// 判断三条边是否相等</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 等边三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出等边三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b || a == c || b == c)</span><br><span class="line">            <span class="comment">// 判断三角形中是否有两边相等</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 等腰三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出等腰三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a *a))</span><br><span class="line">            <span class="comment">// 判断是否有两边的平方和大于第三边的平方</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 直角三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出直角三角形</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 普通三角形&quot;</span>);</span><br><span class="line">            <span class="comment">// 普通三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果两边之和小于第三边不能组成三角形</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该三条边不能构成三角形\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex057.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入三角形的三条边长（以空格分隔）：3 4 5</span><br><span class="line">a = 3.000000</span><br><span class="line">b = 4.000000</span><br><span class="line">c = 5.000000</span><br><span class="line">面积是:6.000000</span><br><span class="line">三条边组成的三角形是: 直角三角形</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex58-直接插入排序"><a href="#案例ex58-直接插入排序" class="headerlink" title="案例ex58: 直接插入排序"></a><strong>案例ex58: 直接插入排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：直接插入排序<br>描述：利用直接插入排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>原始顺序: 34, 12, 45, 3, 8, 23, 89, 52, 24, 10</p>
<p>在代码中将数组 a[0] 置为监视哨</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">趟数</th>
<th style="text-align:center">监视哨</th>
<th style="text-align:center">排序结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">34</td>
<td style="text-align:center">(12,) 34, 45, 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">12</td>
<td style="text-align:center">(12, 34,) 45, 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">45</td>
<td style="text-align:center">(12, 34, 45,) 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">(3, 12, 34, 45,) 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">(3, 8, 12, 34, 45,) 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">23</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45,) 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">89</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45, 89,) 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">52</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45, 52, 89,) 24, 10</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">24</td>
<td style="text-align:center">(3, 8, 12, 23, 24, 34, 45, 52, 89,) 10</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">(3, 8, 10, 12, 23, 24, 34, 45, 52, 89,)</td>
</tr>
</tbody>
</table>
</div>
<p>以上是整个的插入排序算法的过程</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：直接插入排序</span></span><br><span class="line"><span class="comment">描述：利用直接插入排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span>    </span>&#123;                    <span class="comment">// 自定义函数isort</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;                    <span class="comment">// 数组下标从2开始，0 位置做监视哨，1位置一个数据无可比性</span></span><br><span class="line">        s[<span class="number">0</span>] = s[i];                            <span class="comment">// 给监视哨赋值</span></span><br><span class="line">        j = i - <span class="number">1</span>;                                <span class="comment">// 确定要进行比较的元素的最右边位置</span></span><br><span class="line">        <span class="keyword">while</span> (s[<span class="number">0</span>] &lt; s[j]) &#123;</span><br><span class="line">            s[j + <span class="number">1</span>] = s[j];                    <span class="comment">// 数据右移</span></span><br><span class="line">            j--;                                <span class="comment">// 移向左边一个未比较的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        s[j + <span class="number">1</span>] = s[<span class="number">0</span>];                        <span class="comment">// 在确定的位置插入s[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                    <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数据:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                            <span class="comment">// 接收从键盘中输入的10个数据到数组a中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始顺序:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, a[i]);                        <span class="comment">// 将未排序前的顺序输出</span></span><br><span class="line">    insort(a, <span class="number">10</span>);                                    <span class="comment">// 调用自定义函数isort()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n插入数据排序后顺序:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, a[i]);                        <span class="comment">// 将排序后的数组输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex058.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数据:</span><br><span class="line">34</span><br><span class="line">12</span><br><span class="line">45</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">23</span><br><span class="line">89</span><br><span class="line">52</span><br><span class="line">24</span><br><span class="line">10</span><br><span class="line">原始顺序:</span><br><span class="line"> 34 12 45  3  8 23 89 52 24 10</span><br><span class="line">插入数据排序后顺序:</span><br><span class="line">  3  8 10 12 23 24 34 45 52 89</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex59-希尔排序"><a href="#案例ex59-希尔排序" class="headerlink" title="案例ex59: 希尔排序"></a><strong>案例ex59: 希尔排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：希尔排序<br>描述：利用希尔排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>希尔排序是在直接插入排序的基础上做的改进，将要排序的序列按固定增量分成若干组，等距离者在同一组中，然后再程纽内进行直接插入排序。</p>
<p>这里面的固定增量从n/2开始，以后每次缩小到原来的一半.</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：希尔排序</span></span><br><span class="line"><span class="comment">描述：利用希尔排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shsort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span>    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, d;</span><br><span class="line">    d = n / <span class="number">2</span>;                                                    <span class="comment">// 确定固定增量值</span></span><br><span class="line">    <span class="keyword">while</span> (d &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d + <span class="number">1</span>; i &lt;= n; i++) &#123;                            <span class="comment">// 数组下标从d+1开始进行直接插入排序</span></span><br><span class="line">            s[<span class="number">0</span>] = s[i];                                        <span class="comment">// 设置监视哨</span></span><br><span class="line">            j = i - d;                                            <span class="comment">// 确定要进行比较的元素的最右边位置</span></span><br><span class="line">            <span class="keyword">while</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (s[<span class="number">0</span>] &lt; s[j])) &#123;</span><br><span class="line">                s[j + d] = s[j];                                <span class="comment">// 数据右移</span></span><br><span class="line">                j = j - d;                                        <span class="comment">// 向左移d个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            s[j + d] = s[<span class="number">0</span>];                                    <span class="comment">// 在确定的位置插入s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        d = d / <span class="number">2</span>;                                                <span class="comment">// 增量变为原来的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                                <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数据:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                        <span class="comment">// 从键盘中输入10个数据</span></span><br><span class="line">    shsort(a, <span class="number">10</span>);                                                <span class="comment">// 调用shsort()函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                                    <span class="comment">// 将排好序的数组输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex059.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数据:</span><br><span class="line">34</span><br><span class="line">15</span><br><span class="line">56</span><br><span class="line">12</span><br><span class="line">90</span><br><span class="line">43</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">93</span><br><span class="line">100</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    7    9   12   15   34   43   56   90   93  100</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex60-冒泡排序"><a href="#案例ex60-冒泡排序" class="headerlink" title="案例ex60: 冒泡排序"></a><strong>案例ex60: 冒泡排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：冒泡排序<br>描述：利用冒泡排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>冒泡法的基本思路是</p>
<p>如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第1趟比较中要进行 n-1 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较</p>
<p>从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：冒泡排序</span></span><br><span class="line"><span class="comment">描述：利用冒泡排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, t, a[<span class="number">11</span>];                            <span class="comment">// 定义变量及数组为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                        <span class="comment">// 从键盘中输入10个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)                    <span class="comment">// 变量i代表比较的趟数</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">11</span>-i; j++)                <span class="comment">// 变量j代表每趟两两比较的次数</span></span><br><span class="line">    <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        t = a[j];                                <span class="comment">// 利用中间变量实现俩值互换</span></span><br><span class="line">        a[j] = a[j + <span class="number">1</span>];    </span><br><span class="line">        a[j + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                    <span class="comment">// 将冒泡排序后的顺序输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex060.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">16</span><br><span class="line">87</span><br><span class="line">134</span><br><span class="line">14</span><br><span class="line">1</span><br><span class="line">84</span><br><span class="line">55</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    1   14   16   34   55   56   84   87   90  134</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex61-快速排序"><a href="#案例ex61-快速排序" class="headerlink" title="案例ex61: 快速排序"></a><strong>案例ex61: 快速排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：快速排序<br>描述：利用快速排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>在待排序的n个数据中取第 1 个数据作为基准值，将所有记录分为 3 组<br>使笫一组中各数据值均小于或等于基准值，第二组做基准值的数据，第三组中各数据值均人于或等于基准值，这便实现了第一趟分割，然后再对第一组和第三组分别重复上述方法。<br>依次类推；直到每组中只有一个记录为止</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：快速排序</span></span><br><span class="line"><span class="comment">描述：利用快速排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qusort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;                    <span class="comment">// 自定义函数qusort()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;                                                <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    i = start;                                                <span class="comment">// 将每组首个元素赋给i</span></span><br><span class="line">    j = end;                                                <span class="comment">// 将每组末尾元素赋给j</span></span><br><span class="line">    s[<span class="number">0</span>] = s[start];                                        <span class="comment">// 设置基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[<span class="number">0</span>] &lt; s[j])</span><br><span class="line">            j--;                                            <span class="comment">// 位置左移</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            s[i] = s[j];                                    <span class="comment">// 将s[j]放到s[i]的位置上</span></span><br><span class="line">            i++;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt;= s[<span class="number">0</span>])</span><br><span class="line">            i++;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            s[j] = s[i];                                    <span class="comment">// 将大于基准值的s[j]放到s[i]位置</span></span><br><span class="line">            j--;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = s[<span class="number">0</span>];                                                <span class="comment">// 将基准值放入指定位置</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; i)</span><br><span class="line">        qusort(s, start, j - <span class="number">1</span>);                                <span class="comment">// 对分割出的部分递归调用函数qusort()</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; end)</span><br><span class="line">        qusort(s, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                                <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                        <span class="comment">// 从键盘中输入10个要进行排序的数</span></span><br><span class="line">    qusort(a, <span class="number">1</span>, <span class="number">10</span>);                                            <span class="comment">// 调用qusort()函数进行排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                                        <span class="comment">// 输出排好序的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex061.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">45</span><br><span class="line">12</span><br><span class="line">76</span><br><span class="line">2</span><br><span class="line">45</span><br><span class="line">16</span><br><span class="line">34</span><br><span class="line">61</span><br><span class="line">24</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    2   12   16   24   34   45   45   61   76   90</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex62-选择排序"><a href="#案例ex62-选择排序" class="headerlink" title="案例ex62: 选择排序"></a><strong>案例ex62: 选择排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：选择排序<br>描述：利用选择排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>选择排序的基本算法是从待排序的区间中经过选择和交换后选出最小的数值存放到a[0]中，再从剩余的未排序区间中经过选择和交换后选出最小的数值存放到a[1]中，a[1]中的数字仅大于a[0],依此类推，即可实现排序</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：选择排序</span></span><br><span class="line"><span class="comment">描述：利用选择排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, a[<span class="number">11</span>];                        <span class="comment">//定义变量及数组为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                    <span class="comment">//从键盘中输入要排序的10个数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;            <span class="comment">//如果后一个数比前一个数大则利用中间变量t实现俩值互换</span></span><br><span class="line">                t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                <span class="comment">//将排好序的数组输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex062.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">23</span><br><span class="line">51</span><br><span class="line">34</span><br><span class="line">15</span><br><span class="line">45</span><br><span class="line">72</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">33</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    2    5   15   23   33   34   45   51   72   90</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex63-归并排序"><a href="#案例ex63-归并排序" class="headerlink" title="案例ex63: 归并排序"></a><strong>案例ex63: 归并排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：归并排序<br>描述：利用归并排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>归并排序两个或多个有序记录序列合并成一个有序序列<br>一次对两个有序记录序的归并称为二路归并排序，也有三路归并排序及多路归并排序<br>下面代码给出的是二路归并排序，基本方法<br>        (1)将n个记录看成是n介长度为1的有序子表<br>        (2)将两两相邻的有序壬莓4行归并<br>        (3)垂复轨行步骤(2)<br>直至归并成一个长度为 L 的有序表</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：归并排序</span></span><br><span class="line"><span class="comment">描述：利用归并排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> s[], <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3)</span> </span>&#123; <span class="comment">// 实现一次归并排序函数</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    i = x1;                                         <span class="comment">// 第一部分的开始位置</span></span><br><span class="line">    j = x2 + <span class="number">1</span>;                                         <span class="comment">// 第二部分的开始位置</span></span><br><span class="line">    k = x1;</span><br><span class="line">    <span class="keyword">while</span> ((i &lt;= x2) &amp;&amp; (j &lt;= x3))                <span class="comment">// 当i和j都在两个要合并的部分中</span></span><br><span class="line">        <span class="keyword">if</span> (r[i] &lt;= r[j])&#123;                        <span class="comment">// 筛选两部分中较小的元素放到数组s中</span></span><br><span class="line">        s[k] = r[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[k] = r[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= x2)                                <span class="comment">// 将x1~x2范围内的未比较的数顺次加到数组r中</span></span><br><span class="line">        s[k++] = r[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= x3)                                <span class="comment">// 将x2+1~x3范围内的未比较的数顺次加到数组r中</span></span><br><span class="line">        s[k++] = r[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> s[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span> (m == n)</span><br><span class="line">        s[m] = r[m];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = (m + n) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(r, t, m, p);</span><br><span class="line">                                                <span class="comment">// 递归调用merge_sort函数将r[m]~r[p]归并成有序的t[m]~t[p]</span></span><br><span class="line">        merge_sort(r, t, p + <span class="number">1</span>, n);                <span class="comment">// 递归调用merge_sort函数将r[n+1]~r[n]归并成有序的t[p+1]~t[n]*/</span></span><br><span class="line">        merge(t, s, m, p, n);                     <span class="comment">// 调用函数将前两部分归并到s[m]~s[n]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    merge_sort(a, a, <span class="number">1</span>, <span class="number">10</span>);                     <span class="comment">// 调用merge_sort函数进行归并排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex063.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">34</span><br><span class="line">12</span><br><span class="line">64</span><br><span class="line">23</span><br><span class="line">98</span><br><span class="line">45</span><br><span class="line">18</span><br><span class="line">52</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    1    7   12   18   23   34   45   52   64   98</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex64-二分查找"><a href="#案例ex64-二分查找" class="headerlink" title="案例ex64: 二分查找"></a><strong>案例ex64: 二分查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：二分查找<br>描述：<br>    使用二分查找特定关键字元素<br>    用户输入有序数组的关键字后，给定要查找的关键字，看是否存在于有序数组中</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>二分査找就是折半查找<br>其基本思想：首先选取表中间位置的记录，将其关键字与给定关键字key进行比较，若相等，则査找成功；<br>若key值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半査找;<br>若key值比该关键字值小，则要找的元素一定在左子表中，继续对左子表进行折半査找;<br>按照上述递推，直到查找成功或查找失败。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：二分查找</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    使用二分查找特定关键字元素</span></span><br><span class="line"><span class="comment">    用户输入有序数组的关键字后，给定要查找的关键字，看是否存在于有序数组中</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 自定义函数binary_search</span></span><br><span class="line">    <span class="keyword">int</span> low, high, mid, count = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;                            <span class="comment">// 当查找范围不为0时执行循环体语句</span></span><br><span class="line"></span><br><span class="line">        count++;                                <span class="comment">// count记录查找次数</span></span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;                        <span class="comment">// 求出中间位置</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])                            <span class="comment">// 当key小于中间值</span></span><br><span class="line">            high = mid - <span class="number">1</span>;                        <span class="comment">// 确定左子表范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])                        <span class="comment">// 当key大于中间值</span></span><br><span class="line">            low = mid + <span class="number">1</span>;                            <span class="comment">// 确定右子表范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == a[mid]) &#123;                    <span class="comment">// 当key等于中间值证明查找成功</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找成功!\n查找 %d 次!a[%d]=%d&quot;</span>, count, mid, key);</span><br><span class="line">                                            <span class="comment">// 输出查找次数及所查找元素在数组中的位置</span></span><br><span class="line">            count1++;                            <span class="comment">// count1记录查找成功次数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">0</span>)                                <span class="comment">// 判断是否查找失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                            <span class="comment">// 查找失败输出no found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, key, a[<span class="number">100</span>], n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的长度:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                <span class="comment">// 输入数组元素个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                            <span class="comment">// 输入有序数列到数组a中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);                                <span class="comment">// 输入要查找的关键字</span></span><br><span class="line">    binary_search(key, a, n);                        <span class="comment">// 调用自定义函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex064.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入数组的长度:</span><br><span class="line">10</span><br><span class="line">请输入数组元素:</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">46</span><br><span class="line">78</span><br><span class="line">90</span><br><span class="line">102</span><br><span class="line">122</span><br><span class="line">请输入你想查找的元素:</span><br><span class="line">102</span><br><span class="line">查找成功!</span><br><span class="line">查找 3 次!a[8]=102</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex65-分块查找"><a href="#案例ex65-分块查找" class="headerlink" title="案例ex65: 分块查找"></a><strong>案例ex65: 分块查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：分块查找<br>描述：利用分块查找的思想，将指定的数据项查找出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>分块查找是折半查找和顺序查找的一种改进方法, 分块查找由于只要求索引表是有序的, 对块内节点没有排序要求, 因此特别适合于节点动态变化的情况。</p>
<p>要求将待査的元素均匀地分成块, 块间按大小排序, 块内不排序, 所以要建立一个块的最大（或最小）关键字表, 称为索引表。</p>
<p>本例子中将给出的15个数按关键字大小分成了3块, 这15个数的排列是一个有序序列, 也可以给出无序序列, 但必须满足分在第一块中的任意数都小于第二块中的所有数, 第二块中的所有数都小于第三块中的所有数。</p>
<p>当要査找关键字为key的元素时, 先用顺序查找在已建好的索引表中査出key所在的块中, 再在对应的块中顺序查找key, 若key存在, 则输出其相应位置, 否则输出提示信息。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：分块查找</span></span><br><span class="line"><span class="comment">描述：利用分块查找的思想，将指定的数据项查找出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span>                                            <span class="comment">// 定义块的结构</span></span><br><span class="line">    <span class="keyword">int</span> key;                                                <span class="comment">// 存放块内最大值</span></span><br><span class="line">    <span class="keyword">int</span> start;                                            <span class="comment">// 存放块内起始值</span></span><br><span class="line">    <span class="keyword">int</span> end;                                                <span class="comment">// 存放块内结束值</span></span><br><span class="line">&#125; index_table[<span class="number">4</span>];                                     <span class="comment">// 结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">block_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span> </span>&#123;                     <span class="comment">// 自定义分块查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">3</span> &amp;&amp; key &gt; index_table[i].key)            <span class="comment">// 确定在那个块中</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>)                                                                <span class="comment">// 大于分得的块数, 则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    j = index_table[i].start;                                 <span class="comment">// j等于块范围的起始值</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= index_table[i].end &amp;&amp; a[j] != key)        <span class="comment">// 在确定的块内进行查找</span></span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; index_table[i].end)                                    <span class="comment">// 如果大于块范围的结束值, 则说明没有要查找的数,j置0</span></span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>, k, key, a[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入15个数:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 输入由小到大的15个数，由于是测试数据，那么必须要保证在块之间是整体有序的，块内无序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        index_table[i].start = j + <span class="number">1</span>;                     <span class="comment">// 确定每个块范围的起始值</span></span><br><span class="line">        j = j + <span class="number">1</span>;</span><br><span class="line">        index_table[i].end = j + <span class="number">4</span>;                     <span class="comment">// 确定每个块范围的结束值</span></span><br><span class="line">        j = j + <span class="number">4</span>;</span><br><span class="line">        index_table[i].key = a[j];                         <span class="comment">// 确定每个块范围中元素的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);                                     <span class="comment">// 输入要查询的数值</span></span><br><span class="line">    k = block_search(key, a);                             <span class="comment">// 调用函数进行查找</span></span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找成功, 其位置是:%d\n&quot;</span>, k);                <span class="comment">// 如果找到该数, 则输出其位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                                <span class="comment">// 若未找到则输出提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex065.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入15个数:</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">21</span><br><span class="line">25</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">34</span><br><span class="line">40</span><br><span class="line">请输入你想查找的元素:</span><br><span class="line">29</span><br><span class="line">查找成功, 其位置是:11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex66-哈希查找"><a href="#案例ex66-哈希查找" class="headerlink" title="案例ex66: 哈希查找"></a><strong>案例ex66: 哈希查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：哈希查找<br>描述：<br>    哈希表长度 11<br>    哈希函数 (key)=key%11<br>    采用线性探测再散列的方法处理冲突</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>哈希函数简要介绍</strong></p>
<p><strong>哈希函数的构造方法</strong></p>
<p>哈希函数的构造方法常用的有5种，分别是数字分析法、平方取中法、分段叠加、伪随机数法和余数法，其中余数法比较常用。<br>例子中已给出哈希函数，按照给出的哈希函数进行了构造</p>
<p><strong>避免哈希冲突的方法</strong></p>
<p>分别有开放定址法（包括线性探测再散列和二次探测再散列入、链地址法、再哈希法和建立公共溢出区<br>开放定址法中的线性探测再散列比较常用，该方法的特点是在冲突发生时，顺序查看表中的下一单元，直到找出一个空单元或査遍全表。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：哈希查找</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    哈希表长度 11</span></span><br><span class="line"><span class="comment">    哈希函数 (key)=key%11</span></span><br><span class="line"><span class="comment">    采用线性探测再散列的方法处理冲突</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hashtable[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % Max;                             <span class="comment">// 哈希函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;                                 <span class="comment">// 自定义函数实现哈希查询</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos, t;</span><br><span class="line">    pos = func(key);                                 <span class="comment">// 哈希函数确定出的位置</span></span><br><span class="line">    t = pos;                                        <span class="comment">// t存放确定出的位置</span></span><br><span class="line">    <span class="keyword">while</span> (hashtable[t] != key &amp;&amp; hashtable[t] !=  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该位置上不等于要查找的关键字且不为空</span></span><br><span class="line">        t = (t + <span class="number">1</span>) % Max;                             <span class="comment">// 利用线性探测求出下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (pos == t)</span><br><span class="line">            <span class="comment">// 如果经多次探测又回到原来用哈希函数求出的位置则说明要查找的数不存在</span></span><br><span class="line">            <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hashtable[t] ==  - <span class="number">1</span>)                        <span class="comment">// 如果探测的位置是-1则说明要查找的数不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creathash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;                            <span class="comment">// 自定义函数创建哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos, t;</span><br><span class="line">    pos = func(key);                                <span class="comment">// 哈希函数确定元素的位置</span></span><br><span class="line">    t = pos;</span><br><span class="line">    <span class="keyword">while</span> (hashtable[t] !=  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该位置有元素存在则进行线性探测再散列</span></span><br><span class="line">        t = (t + <span class="number">1</span>) % Max;</span><br><span class="line">        <span class="keyword">if</span> (pos == t) &#123;</span><br><span class="line">            <span class="comment">// 如果冲突处理后确定的位置与原位置相同则说明哈希表已满</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;哈希表已满\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hashtable[t] = key;                                <span class="comment">// 将元素放入确定的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++)</span><br><span class="line">        hashtable[i] =  - <span class="number">1</span>;                <span class="comment">// 哈希表中初始位置全置-1</span></span><br><span class="line">                                             </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">                                             <span class="comment">// 50以内所有数未产生时均标志为0</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">long</span>)time(<span class="number">0</span>));             <span class="comment">// 利用系统时间做种子产生随机数</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;建立 Hash 表： \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != N) &#123;</span><br><span class="line">        t = rand() % <span class="number">50</span>;                     <span class="comment">// 产生一个50以内的随机数赋给t</span></span><br><span class="line">        <span class="keyword">if</span> (flag[t] == <span class="number">0</span>) &#123;                        <span class="comment">// 查看t是否产生过</span></span><br><span class="line">            creathash(t);                        <span class="comment">// 调用函数创建哈希表</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d:&quot;</span>, t);                     <span class="comment">// 将该元素输出</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Max; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(%2d) &quot;</span>, hashtable[j]);</span><br><span class="line">                                                 <span class="comment">// 输出哈希表中内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            flag[t] = <span class="number">1</span>;                         <span class="comment">// 将产生的这个数标志为1</span></span><br><span class="line">            i++;                                <span class="comment">// i自加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);                             <span class="comment">// 输入要查找的元素</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span> &amp;&amp; t &lt; <span class="number">50</span>) &#123;</span><br><span class="line">        i = search(t);                            <span class="comment">// 调用search进行哈希查找</span></span><br><span class="line">        <span class="keyword">if</span> (i !=  - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找成功！其位置是:%d\n&quot;</span>, i);    <span class="comment">// 若查找到该元素则输出其位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                    <span class="comment">// 未找到输出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入有误!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex066.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">建立 Hash 表：</span><br><span class="line"> 7:(-1) (-1) (-1) (-1) (-1) (-1) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">22:(22) (-1) (-1) (-1) (-1) (-1) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">16:(22) (-1) (-1) (-1) (-1) (16) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">29:(22) (-1) (-1) (-1) (-1) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line">44:(22) (44) (-1) (-1) (-1) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line">37:(22) (44) (-1) (-1) (37) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line"> 3:(22) (44) (-1) ( 3) (37) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line"> 9:(22) (44) (-1) ( 3) (37) (16) (-1) ( 7) (29) ( 9) (-1)</span><br><span class="line">请输入你想查找的元素:9</span><br><span class="line">查找成功！其位置是:9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex67-斐波那契数列"><a href="#案例ex67-斐波那契数列" class="headerlink" title="案例ex67: 斐波那契数列"></a><strong>案例ex67: 斐波那契数列</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：斐波那契数列<br>描述：实现一个斐波那契数列，并且打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列<br>斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）<br>即这样的一个序列：这样一个数列：0、1、1、2、3、5、8、13、21、34</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：斐波那契数列</span></span><br><span class="line"><span class="comment">描述：实现一个斐波那契数列，并且打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;                                                <span class="comment">// 定义整型变量i</span></span><br><span class="line">    <span class="keyword">long</span> f[<span class="number">51</span>];                                            <span class="comment">// 意义数组为长整形</span></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">1</span>;                                    <span class="comment">// 数组中的f[1]、f[2]赋初值为1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];                        <span class="comment">// 数列中从第3项开始每一项等于前两项之和</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%12ld&quot;</span>, f[i]);                            <span class="comment">// 输出数组中的 30 个元素</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                                <span class="comment">// 每 5 个元素进行一次换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex067.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">           1           1           2           3           5</span><br><span class="line">           8          13          21          34          55</span><br><span class="line">          89         144         233         377         610</span><br><span class="line">         987        1597        2584        4181        6765</span><br><span class="line">       10946       17711       28657       46368       75025</span><br><span class="line">      121393      196418      317811      514229      832040</span><br><span class="line">     1346269     2178309     3524578     5702887     9227465</span><br><span class="line">    14930352    24157817    39088169    63245986   102334155</span><br><span class="line">   165580141   267914296   433494437   701408733  1134903170</span><br><span class="line">  1836311903  2971215073  4807526976  7778742049 12586269025</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex68-哥德巴赫猜想"><a href="#案例ex68-哥德巴赫猜想" class="headerlink" title="案例ex68: 哥德巴赫猜想"></a><strong>案例ex68: 哥德巴赫猜想</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：哥德巴赫猜想<br>描述：<br>    任一大于2的整数都可写成两个质数之和<br>    验证从 3 到 50 之间所有数都是否可以写成两个素数之和</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>创建判断是否为素数的函数</li>
<li>从 3 到 50 循环判断是否可以有 2 个素数加和</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：哥德巴赫猜想</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    任一大于2的整数都可写成两个质数之和</span></span><br><span class="line"><span class="comment">    验证从 3 到 50 之间所有数都是否可以写成两个素数之和</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ss</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;                                                     <span class="comment">// 素数的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)                                                 <span class="comment">// 小于1的数不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>)                                                 <span class="comment">// 2是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)    &#123;                        <span class="comment">// 对大于2的数进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k, flag1, flag2, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= <span class="number">50</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">2</span>; k &lt;= i / <span class="number">2</span>; k++) &#123;</span><br><span class="line">            j = i - k;</span><br><span class="line">            flag1 = ss(k);                                        <span class="comment">// 判断拆分出的数是否是素数</span></span><br><span class="line">            <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line">                flag2 = ss(j);</span><br><span class="line">                <span class="keyword">if</span> (flag2) &#123;                                     <span class="comment">// 如果拆分出的两个数均是素数则输出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d = %d+%d,\t&quot;</span>, i, k, j);</span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex068.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">4 = 2+2,    5 = 2+3,    6 = 3+3,    7 = 2+5,    8 = 3+5,</span><br><span class="line">9 = 2+7,    10 = 3+7,    10 = 5+5,    12 = 5+7,    13 = 2+11,</span><br><span class="line">14 = 3+11,    14 = 7+7,    15 = 2+13,    16 = 3+13,    16 = 5+11,</span><br><span class="line">18 = 5+13,    18 = 7+11,    19 = 2+17,    20 = 3+17,    20 = 7+13,</span><br><span class="line">21 = 2+19,    22 = 3+19,    22 = 5+17,    22 = 11+11,    24 = 5+19,</span><br><span class="line">24 = 7+17,    24 = 11+13,    25 = 2+23,    26 = 3+23,    26 = 7+19,</span><br><span class="line">26 = 13+13,    28 = 5+23,    28 = 11+17,    30 = 7+23,    30 = 11+19,</span><br><span class="line">30 = 13+17,    31 = 2+29,    32 = 3+29,    32 = 13+19,    33 = 2+31,</span><br><span class="line">34 = 3+31,    34 = 5+29,    34 = 11+23,    34 = 17+17,    36 = 5+31,</span><br><span class="line">36 = 7+29,    36 = 13+23,    36 = 17+19,    38 = 7+31,    38 = 19+19,</span><br><span class="line">39 = 2+37,    40 = 3+37,    40 = 11+29,    40 = 17+23,    42 = 5+37,</span><br><span class="line">42 = 11+31,    42 = 13+29,    42 = 19+23,    43 = 2+41,    44 = 3+41,</span><br><span class="line">44 = 7+37,    44 = 13+31,    45 = 2+43,    46 = 3+43,    46 = 5+41,</span><br><span class="line">46 = 17+29,    46 = 23+23,    48 = 5+43,    48 = 7+41,    48 = 11+37,</span><br><span class="line">48 = 17+31,    48 = 19+29,    49 = 2+47,    50 = 3+47,    50 = 7+43,</span><br><span class="line">50 = 13+37,    50 = 19+31,</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex69-尼科彻斯定理"><a href="#案例ex69-尼科彻斯定理" class="headerlink" title="案例ex69: 尼科彻斯定理"></a><strong>案例ex69: 尼科彻斯定理</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：尼科彻斯定理</p>
<p>描述：<br>    验证尼科彻斯定理。即：任何一个整数 m 的立方都可以写成 m 个连续奇数之和。m属于[1,100]，超出范围则报错。<br>    例如：<br>    1^3=1<br>    2^3=3+5<br>    3^3=7+9+11<br>    4^3=13+15+17+19</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>循环判断实现尼科彻斯定理</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：尼科彻斯定理</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    验证尼科彻斯定理。即：任何一个整数 m 的立方都可以写成 m 个连续奇数之和。m属于[1,100]，超出范围则报错。</span></span><br><span class="line"><span class="comment">    例如：</span></span><br><span class="line"><span class="comment">    1^3=1</span></span><br><span class="line"><span class="comment">    2^3=3+5</span></span><br><span class="line"><span class="comment">    3^3=7+9+11</span></span><br><span class="line"><span class="comment">    4^3=13+15+17+19</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l, n, m, sum, flag=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                    <span class="comment">// 从键盘中任意输入一个数</span></span><br><span class="line">    m = n * n * n;                                        <span class="comment">// 计算出该数的立方</span></span><br><span class="line">    i = m / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)                                        <span class="comment">// 当i为偶数时i值加1</span></span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span> &amp;&amp; i &gt;= <span class="number">1</span>) &#123;                        <span class="comment">// 当i大于等于1且flag=1时执行循环体语句</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sum += (i - <span class="number">2</span> * k);                            <span class="comment">// 奇数累加求和</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;                                    <span class="comment">// 如果sum与m相等，则输出累加过程</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d*%d*%d=%d=&quot;</span>, n, n, n, m);</span><br><span class="line">                <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; k - <span class="number">1</span>; l++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d+&quot;</span>, i - l * <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - (k - <span class="number">1</span>) *<span class="number">2</span>);             <span class="comment">// 输出累加求和的最后一个数</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i -= <span class="number">2</span>;                                            <span class="comment">// i等于下一个奇数继续上面过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex069.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个数:</span><br><span class="line">12</span><br><span class="line">12*12*12=1728=865+863</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex70-创建单向链表"><a href="#案例ex70-创建单向链表" class="headerlink" title="案例ex70: 创建单向链表"></a><strong>案例ex70: 创建单向链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建单向链表</p>
<p>描述：创建Node结构体，构造一个单链表</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>创建结点的结构体，分布由结点值和指针组成</li>
<li>循环创建每个结点，使得上一个结点指向下一个结点</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建单向链表</span></span><br><span class="line"><span class="comment">描述：创建Node结构体，构造一个单链表</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct LNode *<span class="title">create_listnode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">head</span>, *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入结点内容:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p1 = (struct LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)); <span class="comment">// 分配空间</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); <span class="comment">// 输入数据</span></span><br><span class="line">        p1-&gt;data = a; <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 指定头结点</span></span><br><span class="line">            head = p1;</span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1; <span class="comment">// 指定后继指针</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">lnode</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要创建单链表的结点个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入链表结点个数</span></span><br><span class="line">    lnode = create_listnode(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是:\nhead-&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (lnode) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, lnode-&gt;data); <span class="comment">// 输出链表</span></span><br><span class="line">        lnode = lnode-&gt;next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入要创建单链表的结点个数:5</span><br><span class="line">输入结点内容:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">结果是:</span><br><span class="line"><span class="meta">head-&gt;</span><span class="bash">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex71-创建双向链表"><a href="#案例ex71-创建双向链表" class="headerlink" title="案例ex71: 创建双向链表"></a><strong>案例ex71: 创建双向链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建双向链表<br>描述：<br>    a. 创建一个双链表，实现输入链表中的数据，并且可以将链表中的数据进行输出<br>    b. 输入一个结点内容，把这个结点从链表中删除，随后输出链表内容</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>单链表</strong>，存储形式只有一个指向直接后继的指针域，所以只能是从头结点顺着指针域指向的下一个结点进行不断的查找<br><strong>双向链表</strong>，一个结点既可以指向前驱也可以指向后继，对于数据查找来说更加的便捷</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建双向链表</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    a. 创建一个双链表，实现输入链表中的数据，并且可以将链表中的数据进行输出</span></span><br><span class="line"><span class="comment">    b. 输入一个结点内容，把这个结点从链表中删除，随后输出链表内容</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prior</span>,  *<span class="title">next</span>;</span></span><br><span class="line">&#125; stud;                                 <span class="comment">// 双链表的结构定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">stud *<span class="title">creat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    stud *p,  *h,  *s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    h = (stud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stud));    <span class="comment">// 申请结点空间</span></span><br><span class="line">    h-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    h-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = h;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = (stud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stud));</span><br><span class="line">        p-&gt;next = s;                    <span class="comment">// 指定后继结点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d个学生的姓名: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s-&gt;name);</span><br><span class="line">        s-&gt;prior = p;                    <span class="comment">// 指定前驱结点</span></span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function">stud *<span class="title">search</span><span class="params">(stud *h, <span class="keyword">char</span> *x)</span> </span>&#123;</span><br><span class="line">    stud *p;                            <span class="comment">// 指向结构体类型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *y;</span><br><span class="line">    p = h-&gt;next;        </span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        y = p-&gt;name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(y, x) == <span class="number">0</span>)            <span class="comment">// 如果是要删除的节点，则返回地址</span></span><br><span class="line">            <span class="keyword">return</span> (p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有找到数据!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(stud *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;            <span class="comment">// p的下一个结点的前驱指针指向p的前驱结点</span></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;            <span class="comment">// p的前驱结点的后继指针指向p的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> sname[<span class="number">20</span>];</span><br><span class="line">    stud *head,  *sp;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;请输入链表的大小:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);                <span class="comment">// 输入链表结点数</span></span><br><span class="line">    head = creat(number);                <span class="comment">// 创建链表</span></span><br><span class="line">    sp = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n现在这个双链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (sp) &#123;                        <span class="comment">// 输出链表中数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, &amp;*(sp-&gt;name));</span><br><span class="line">        sp = sp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入你想查找的姓名:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, sname);</span><br><span class="line">    sp = search(head, sname);            <span class="comment">// 查找指定结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你想查找的姓名是:%s\n&quot;</span>,  * &amp;sp-&gt;name);</span><br><span class="line">    del(sp);                            <span class="comment">// 删除结点</span></span><br><span class="line">    sp = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n现在这个双链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (sp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, &amp;*(sp-&gt;name));    <span class="comment">// 输出当前链表中数据</span></span><br><span class="line">        sp = sp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex071.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表的大小:</span><br><span class="line">5</span><br><span class="line">输入第1个学生的姓名: a</span><br><span class="line">输入第2个学生的姓名: b</span><br><span class="line">输入第3个学生的姓名: c</span><br><span class="line">输入第4个学生的姓名: d</span><br><span class="line">输入第5个学生的姓名: e</span><br><span class="line"></span><br><span class="line">现在这个双链表是:</span><br><span class="line">a b c d e</span><br><span class="line">请输入你想查找的姓名:</span><br><span class="line">d</span><br><span class="line">你想查找的姓名是:d</span><br><span class="line"></span><br><span class="line">现在这个双链表是:</span><br><span class="line">a b c e</span><br><span class="line"></span><br><span class="line"> 按任意键退出...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex72-创建一个单循环链表"><a href="#案例ex72-创建一个单循环链表" class="headerlink" title="案例ex72: 创建一个单循环链表"></a><strong>案例ex72: 创建一个单循环链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建一个单循环链表<br>描述：输入链表中各个结点中的值，然后进行进行整合成单循环链表进行输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>一个循环链表是从简单的链表中发展而来，简单链表带来的弊端是，必须要保存头结点才能不断的遍历链表，否则当遍历到<br>结点尾部的时候，便没办法进行后续的工作。<br>简单循环链表带来的优势是，当遍历到链表尾部的时候，由于尾部的next指针指向头部，所以是要比简单的单链表灵活一些的</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建一个单循环链表</span></span><br><span class="line"><span class="comment">描述：输入链表中各个结点中的值，然后进行进行整合成单循环链表进行输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1,  *p2;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                 <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = head;                 <span class="comment">// 尾节点指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1, head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入循环链表:(以 # 结束)\n&quot;</span>);</span><br><span class="line">    L1 = create();                    <span class="comment">// 创建循环链表</span></span><br><span class="line">    head = L1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;形成的循环链表是:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, L1-&gt;num);</span><br><span class="line">    L1 = L1-&gt;next;                    <span class="comment">// 指向下一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (L1 != head) &#123;             <span class="comment">// 判断条件为循环到头结点结束</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex072.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入循环链表:(以 # 结束)</span><br><span class="line"><span class="meta">apple#</span></span><br><span class="line"><span class="bash">形成的循环链表是:</span></span><br><span class="line">a -&gt; p -&gt; p -&gt; l -&gt; e -&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex73-头插入法建立单链表"><a href="#案例ex73-头插入法建立单链表" class="headerlink" title="案例ex73: 头插入法建立单链表"></a><strong>案例ex73: 头插入法建立单链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：头插入法建立单链表<br>描述：输入链表中各个结点中的值，然后利用头插入法整合成单循环链表进行输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>头插法的基本思路是：<br>  a. 首先创将一个空的单链表<br>  b. 生成新的结点插入到头部，然后一直循环直到所有的元素结点都插入到链表中<br>最后，由于是循环向头部插入，那么导致的一个现象就是，从头部开始遍历的时候，一定与形成时元素结点相反</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：头插入法建立单链表</span></span><br><span class="line"><span class="comment">描述：输入链表中各个结点中的值，然后利用头插入法整合成单循环链表进行输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,  *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表元素(字符采集，不需要分隔符):\n&quot;</span>);</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));         <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                                 <span class="comment">// 数据域赋值</span></span><br><span class="line">        p1-&gt;next = head;</span><br><span class="line">        head = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;                                    <span class="comment">// 返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1;</span><br><span class="line">    L1 = create();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这个链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (L1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表元素(字符采集，不需要分隔符):</span><br><span class="line">apple</span><br><span class="line">这个链表是:</span><br><span class="line">e l p p a</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex74-约瑟夫环"><a href="#案例ex74-约瑟夫环" class="headerlink" title="案例ex74: 约瑟夫环"></a><strong>案例ex74: 约瑟夫环</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：约瑟夫环<br>描述：使用循环链表实现约瑟夫环，给定一组结点数据 {1,2,3,4,5,6,7,8,9,10}，然后从报数开始，进行打印</p>
</blockquote>
<p><strong>2 科普-什么是约瑟夫环</strong></p>
<p><strong>约瑟夫环 </strong></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719?fromtitle=%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF&amp;fromid=348830&amp;fr=aladdin">百度百科 - 约瑟夫环</a></p>
<p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。</p>
<p>具体例子：</p>
<p>比如说有一个圈中的数字为 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}，第 3 个被杀掉，即从头开始数到 3 的被杀掉</p>
<p>第 1 轮 3 被杀掉，剩余 {1, 2, 【3】, 4, 5, 6, 7, 8, 9, 10}</p>
<p>第 2 轮 6 被杀掉，剩余 {1, 2, 【3】, 4, 5, 【6】, 7, 8, 9, 10}</p>
<p>第 3 轮 9 被杀掉，剩余 {1, 2, 【3】, 4, 5, 【6】, 7, 8, 【9】, 10}</p>
<p>第 4 轮 2 被杀掉，剩余 {1, 【2】, 【3】, 4, 5, 【6】, 7, 8, 【9】, 10}</p>
<p>第 5 轮 7 被杀掉，剩余 {1, 【2】, 【3】, 4, 5, 【6】, 【7】, 8, 【9】, 10}</p>
<p>第 6 轮 1 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 5, 【6】, 【7】, 8, 【9】, 10}</p>
<p>第 7 轮 8 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 5, 【6】, 【7】, 【8】, 【9】, 10}</p>
<p>第 8 轮 5 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 【5】, 【6】, 【7】, 【8】, 【9】, 10}</p>
<p>第 9 轮 10 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 【5】, 【6】, 【7】, 【8】, 【9】, 【10】}</p>
<p>第 10 轮 4 被杀掉，剩余 {【1】, 【2】, 【3】, 【4】, 【5】, 【6】, 【7】, 【8】, 【9】, 【10】}</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="keyword">int</span> KeyW[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：约瑟夫环</span></span><br><span class="line"><span class="comment">描述：使用循环链表实现约瑟夫环，给定一组结点数据 &#123;1,2,3,4,5,6,7,8,9,10&#125;，然后从报数开始，进行打印</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> keyword;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Joseph</span><span class="params">(LinkList p,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LinkList q;                                            <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    q = p;</span><br><span class="line">    m%= x;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) m = x;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)&#123;                                <span class="comment">// 找到下一个结点</span></span><br><span class="line">        p = q;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    i = q-&gt;keyword;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n出队元素: %d \t&quot;</span>,q-&gt;keyword);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;剩余元素: &quot;</span>);</span><br><span class="line">    LinkList tmp =  p;</span><br><span class="line">    <span class="keyword">int</span> tmp_x = x;</span><br><span class="line">    <span class="keyword">while</span>(tmp &amp;&amp; tmp_x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, tmp-&gt;keyword);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        tmp_x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    Joseph(p, i, x<span class="number">-1</span>);                                    <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,m;</span><br><span class="line">    LinkList Lhead,p,q;</span><br><span class="line">    Lhead = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));            <span class="comment">// 申请结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Lhead) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    Lhead-&gt;keyword = KeyW[<span class="number">0</span>];                            <span class="comment">// 数据域赋值</span></span><br><span class="line">    Lhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = Lhead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;                                <span class="comment">// 创建循环链表</span></span><br><span class="line">        <span class="keyword">if</span>(!(q = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))))<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">        q-&gt;keyword = KeyW[i];</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = Lhead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第一次计数值m: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输出的队列结点是:\n&quot;</span>);</span><br><span class="line">    Joseph(p, m, N);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex074.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入第一次计数值m:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输出的队列结点是:</span><br><span class="line"></span><br><span class="line">出队元素: 3     剩余元素: 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt;</span><br><span class="line">出队元素: 6     剩余元素: 5 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt; 2 -&gt; 4 -&gt;</span><br><span class="line">出队元素: 2     剩余元素: 1 -&gt; 4 -&gt; 5 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt;</span><br><span class="line">出队元素: 5     剩余元素: 4 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt;</span><br><span class="line">出队元素: 1     剩余元素: 10 -&gt; 4 -&gt; 7 -&gt; 8 -&gt; 9 -&gt;</span><br><span class="line">出队元素: 4     剩余元素: 10 -&gt; 7 -&gt; 8 -&gt; 9 -&gt;</span><br><span class="line">出队元素: 10     剩余元素: 9 -&gt; 7 -&gt; 8 -&gt;</span><br><span class="line">出队元素: 7     剩余元素: 9 -&gt; 8 -&gt;</span><br><span class="line">出队元素: 8     剩余元素: 9 -&gt;</span><br><span class="line">出队元素: 9     剩余元素:</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex75-创建顺序表并插入元素"><a href="#案例ex75-创建顺序表并插入元素" class="headerlink" title="案例ex75: 创建顺序表并插入元素"></a><strong>案例ex75: 创建顺序表并插入元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建顺序表并插入元素<br>描述：创建一个顺序表，插入元素，并且打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>创建一个链表的结构体，规定了元素最大长度，循环将要插入的元素进行往链表中插入</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Listsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建顺序表并插入元素</span></span><br><span class="line"><span class="comment">描述：创建一个顺序表，插入元素，并且打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqlist</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[Listsize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(struct sqlist *l, <span class="keyword">int</span> t, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; l-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置错误&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l-&gt;length &gt;= Listsize) &#123;                        <span class="comment">// 如果超出顺序表范围，则溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;溢出&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = l-&gt;length - <span class="number">1</span>; j &gt;= i; j--)                <span class="comment">// 插入元素</span></span><br><span class="line">        l-&gt;data[j + <span class="number">1</span>] = l-&gt;data[j];</span><br><span class="line">    l-&gt;data[i] = t;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sqlist</span> *<span class="title">sq</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, n, t;</span><br><span class="line">    sq = (struct sqlist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct sqlist));    <span class="comment">// 分配空间</span></span><br><span class="line">    sq-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表大小:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表的元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        InsertList(sq, t, i);                            <span class="comment">// 插入元素</span></span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">&quot;这个链表现在是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sq-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sq-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex075.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表大小:10</span><br><span class="line">请输入链表的元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">这个链表现在是:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 %</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex76-合并两个链表"><a href="#案例ex76-合并两个链表" class="headerlink" title="案例ex76: 合并两个链表"></a><strong>案例ex76: 合并两个链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：合并两个链表<br>描述：两个链表进行合并，将第二个单链表连接在第一个单链表的尾部</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>通过不断的遍历第一个链表，知道链表尾部，即 L1-&gt;next = NULL，之后将 L1-&gt;next 指向 L2 的头结点</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：合并两个链表</span></span><br><span class="line"><span class="comment">描述：两个链表进行合并，将第二个单链表连接在第一个单链表的尾部</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1,  *p2;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                        <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">coalition</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LNode *temp;</span><br><span class="line">    <span class="keyword">if</span> (L1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L2;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (temp = L1; temp-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next);</span><br><span class="line">            temp-&gt;next = L2;                 <span class="comment">// 遍历L1中节点直到尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个链表:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个链表是:\n&quot;</span>);</span><br><span class="line">    L1 = create();                            <span class="comment">// 创建一个链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个链表是:\n&quot;</span>);</span><br><span class="line">    L2 = create();                            <span class="comment">// 创建第二个链表</span></span><br><span class="line">    coalition(L1, L2);                        <span class="comment">// 连接两个链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;合并后的链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (L1)&#123;                                <span class="comment">// 输出合并后的链表*</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex076.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个链表:</span><br><span class="line">第一个链表是:</span><br><span class="line">apple and</span><br><span class="line">第二个链表是:</span><br><span class="line">orage</span><br><span class="line">合并后的链表是:</span><br><span class="line">apple and orage</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex77-单链表节点逆置"><a href="#案例ex77-单链表节点逆置" class="headerlink" title="案例ex77: 单链表节点逆置"></a><strong>案例ex77: 单链表节点逆置</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：单链表节点逆置<br>描述：创建一个单链表，实现将创建好的单链表进行逆置</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>创建两个指向结点的临时指针，一个指向 NULL，另外一个执行头结点，然后不断向后遍历，进行原地链表反转</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：单链表节点逆置</span></span><br><span class="line"><span class="comment">描述：创建一个单链表，实现将创建好的单链表进行逆置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node *<span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>,  *<span class="title">p1</span>,  *<span class="title">p2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        p1 = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));     <span class="comment">// 分配空间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        p1-&gt;num = a;                                        <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = p1;</span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1;                                     <span class="comment">// 指定后继指针</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;                                            <span class="comment">// 返回头结点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node *<span class="title">reverse</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>,  *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;next) &#123;</span><br><span class="line">        p = head;                                <span class="comment">// 获取头结点地址</span></span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (r) &#123;</span><br><span class="line">            p = r;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">        &#125; <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;                                <span class="comment">// 返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入你想创建的结点个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    q = create(n);                                <span class="comment">// 创建单链表</span></span><br><span class="line">    q = reverse(q);                                <span class="comment">// 单链表逆置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆置后的单链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;                                    <span class="comment">// 输出逆置后的单链表</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;num);</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex077.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入你想创建的结点个数:5</span><br><span class="line">链表元素:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">逆置后的单链表是:</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex78-明码序列号保护"><a href="#案例ex78-明码序列号保护" class="headerlink" title="案例ex78: 明码序列号保护"></a><strong>案例ex78: 明码序列号保护</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：明码序列号保护<br>描述：使用明码序列号保护</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>采用明码序列号保护是通过使用序列号对应用程序进行保护的最初级的方法<br>通过使用序列号对程序进行注册，获取使用程序某些功能的权限<br>采用明码序列号保护的方式是通过对用户输入的序列号与程序自动生成的合法序列号或内置序列号进行比较，采用这种方式并不是很安全，容易被截获到合法的序列号。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：明码序列号保护</span></span><br><span class="line"><span class="comment">描述：使用明码序列号保护</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ysn;                                                    <span class="comment">// 声明字符指针</span></span><br><span class="line">    <span class="keyword">char</span> *sn;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input the serial number：\n&quot;</span>);            <span class="comment">// 指定合法序列号</span></span><br><span class="line">    sn=<span class="string">&quot;1001-1618-2903&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ysn);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(ysn,sn))                                <span class="comment">// 进行序列号比较</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;register succeed&quot;</span>);            <span class="comment">// 注册成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;register lose&quot;</span>);                 <span class="comment">// 注册失败</span></span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex078.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">Please input the serial number：</span><br><span class="line">123</span><br><span class="line">register lose</span><br><span class="line"></span><br><span class="line">Please input the serial number：</span><br><span class="line">1001-1618-2903</span><br><span class="line">register succeed</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex79-非明码序列号保护"><a href="#案例ex79-非明码序列号保护" class="headerlink" title="案例ex79: 非明码序列号保护"></a><strong>案例ex79: 非明码序列号保护</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：非明码序列号保护<br>描述：<br>    本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>采用菲明码序列号保护的方式验证序列号比采用明码序列号保护的方式安全。因为，非明码序列号保护是通过将输入的序列号进行算法验证实现的，而明码序列号保护是通过将输入的序列号与计算生成的合法序列号进行字符串比较实现的。采用明码序列号保护的程序在注册时会生成合法的序列号，该序列号可以通过内存设断的方式获取。一而采用非明码序列号保护的方式无法通过内在设断的方式获取。</p>
<p>本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：非明码序列号保护</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn1</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn2</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">6</span>;i&lt;<span class="number">11</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn3</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">12</span>;i&lt;<span class="number">17</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn4</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">18</span>;i&lt;<span class="number">23</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nplease input the serial number:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str)==<span class="number">23</span> &amp;&amp; str[<span class="number">5</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; str[<span class="number">11</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; str[<span class="number">17</span>]==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(getsn1(str)%<span class="number">6</span>==<span class="number">1</span> &amp;&amp; getsn2(str)%<span class="number">8</span>==<span class="number">1</span> &amp;&amp; getsn3(str)%<span class="number">9</span>==<span class="number">2</span> &amp;&amp; getsn4(str)%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register succeed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register Lose&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register Lose&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">please input the serial number:</span><br><span class="line">11113-22221-33332-11112</span><br><span class="line">register succeed</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">please input the serial number:</span><br><span class="line">11113-22221-33332-11111</span><br><span class="line"></span><br><span class="line">register Lose</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex80-恺撒加密"><a href="#案例ex80-恺撒加密" class="headerlink" title="案例ex80: 恺撒加密"></a><strong>案例ex80: 恺撒加密</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：恺撒加密<br>描述：利用凯撒密码进行加密</p>
</blockquote>
<p><strong>2 凯撒密码</strong></p>
<p>维基百科对凯撒密码的解释：<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC">https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC</a></p>
<p>凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推</p>
<p>例如，当偏移量是左移3的时候（解密时的密钥就是3）：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：恺撒加密</span></span><br><span class="line"><span class="comment">描述：利用凯撒密码进行加密</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (c + n % <span class="number">26</span> &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(c + n % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + ((n - (<span class="string">&#x27;z&#x27;</span> - c) - <span class="number">1</span>) % <span class="number">26</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (c + n % <span class="number">26</span> &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(c + n % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span> + ((n - (<span class="string">&#x27;Z&#x27;</span> - c) - <span class="number">1</span>) % <span class="number">26</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (c - n % <span class="number">26</span> &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(c - n % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;z&#x27;</span> - (n - (c - <span class="string">&#x27;a&#x27;</span>) - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (c - n % <span class="number">26</span> &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(c - n % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;Z&#x27;</span> - (n - (c - <span class="string">&#x27;A&#x27;</span>) - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">//char str[]=&quot;abcdef&quot;;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, n = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input strings:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1:Encryption&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2:Decryption&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3:Violent Crack&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease choose:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n%d&quot;</span>, &amp;n);</span><br><span class="line">        encode(str, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        decode(str, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            decode(str, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex080.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">Please input strings:python</span><br><span class="line"></span><br><span class="line">1:Encryption</span><br><span class="line">2:Decryption</span><br><span class="line">3:Violent Crack</span><br><span class="line">Please choose:1</span><br><span class="line"></span><br><span class="line">Please input number:1</span><br><span class="line"></span><br><span class="line">out:qzuipo</span><br></pre></td></tr></table></figure>
<p>该例子中有以下三种选择，结合上述对于凯撒密码的原理，试着进行理解</p>
<ul>
<li>Encryption</li>
<li>Decryption</li>
<li>Violent Crack</li>
</ul>
<hr>
<h3 id="案例ex81-编写循环移位函数"><a href="#案例ex81-编写循环移位函数" class="headerlink" title="案例ex81: 编写循环移位函数"></a><strong>案例ex81: 编写循环移位函数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：编写循环移位函数<br>描述：编写个移位函数，使移位函数既能循环左移又能循环右移。参数 n 大于 0 时表示左移，参数 n 小于 0 时表示右移。例如 n=-4, 表示要右移四位</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用 &lt;&lt; 或者 &gt;&gt; 进行移位计算</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：编写循环移位函数</span></span><br><span class="line"><span class="comment">描述：编写个移位函数，使移位函数既能循环左移又能循环右移。参数 n 大于 0 时表示左移，参数 n 小于 0 时表示右移。例如 n=-4, 表示要右移四位</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">move</span><span class="params">(<span class="keyword">unsigned</span> value, <span class="keyword">int</span> n)</span>    </span>&#123;                                <span class="comment">// 自定义移位函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> z;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        z = (value &gt;&gt; (<span class="number">32</span>-n)) | (value &lt;&lt; n);                <span class="comment">// 循环左移的实现过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n=-n;</span><br><span class="line">        z = (value &lt;&lt; (<span class="number">32</span>-n)) | (value &gt;&gt; n);                <span class="comment">// 循环右移的实现过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%o&quot;</span>, &amp;a);                                                                <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要移位的位数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                                                    <span class="comment">// 输入要移位的位数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移位后的结果是:%o\n&quot;</span>, move(a, n));                        <span class="comment">// 将移位后的结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入一个八进制数:</span><br><span class="line">12</span><br><span class="line">请输入要移位的位数:</span><br><span class="line">1</span><br><span class="line">移位后的结果是:24</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex82-取出给定-16-位二进制数的奇数位"><a href="#案例ex82-取出给定-16-位二进制数的奇数位" class="headerlink" title="案例ex82: 取出给定 16 位二进制数的奇数位"></a><strong>案例ex82: 取出给定 16 位二进制数的奇数位</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：取出给定 16 位二进制数的奇数位<br>描述：取出给定的 16 位二进制数的奇数位，计算后打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本例的解题关键在于如何将给定的 16 位二进制数的奇数位取出。首先定义个可以借助的中间变量 m，为其赋值，使箕成为最高位是1、其余 15 位为 0 的 16 位进制数</p>
<p>将给定的数 a 的值左移一位，让其原来值的第 15 位成为最高位，将 a 和 m 进行与运算进行判断，若运算结果是 1, 则将此位取出转换为对应的十进制数：若运算结果是 0, 则将 a 的值左移两位，使其原来值的第 13 位成为最高位，再进行判断，直到将 8 位奇数位全部取出</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：取出给定 16 位二进制数的奇数位</span></span><br><span class="line"><span class="comment">描述：取出给定的 16 位二进制数的奇数位，计算后打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a,s=<span class="number">0</span>,q;</span><br><span class="line">    <span class="keyword">int</span> i,j,n=<span class="number">7</span>,m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ho&quot;</span>, &amp;a);                                <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    m=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;                                        <span class="comment">// m 的最高位为 1，其他位为 0</span></span><br><span class="line">    a&lt;&lt;=<span class="number">1</span>;                                            <span class="comment">// 左移一位，使第15位成为最高位</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++) &#123;                                <span class="comment">// 得到 8 位数</span></span><br><span class="line">        </span><br><span class="line">        q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &amp; a) &#123;                                    <span class="comment">// 如果本位上值为1则进行计算</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                q*=<span class="number">2</span>;                                <span class="comment">// 得到权值</span></span><br><span class="line">            s+=q;                                    <span class="comment">// 累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        a&lt;&lt;=<span class="number">2</span>;                                        <span class="comment">// 向左移位</span></span><br><span class="line">        n--;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是:%o\n&quot;</span>, s);                        <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex082.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入一个八进制数:</span><br><span class="line">013</span><br><span class="line">结果是:1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex83-求一个数的补码"><a href="#案例ex83-求一个数的补码" class="headerlink" title="案例ex83: 求一个数的补码"></a><strong>案例ex83: 求一个数的补码</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：求一个数的补码<br>描述：输入一个八进制数，然后输出它的补码</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>一个正数的补码等于该数原码，一个负数的补码等于该数的反码加 1。<br>本例的关键是如何判断一个数是正数还是负数。当最高位为 1 时，则该数是负数；当最高位为 0 时，则该数是正数。<br>因此，数据 a 和八进制数据 010000 进行与运算，保留最高位得到数据的正负</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：求一个数的补码</span></span><br><span class="line"><span class="comment">描述：输入一个八进制数，然后输出它的补码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  a,z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ho&quot;</span>, &amp;a);                            <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    z=a &amp; <span class="number">0100000</span>;                                    <span class="comment">// 0100000的二进制形式为最高位为1，其余为0</span></span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">0100000</span>)                                    <span class="comment">// 如果a小于0</span></span><br><span class="line">        z=~a+<span class="number">1</span>;                                                <span class="comment">// 取反加1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z=a;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是: %o\n&quot;</span>, z);            <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex083.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入一个八进制数:</span><br><span class="line">115333</span><br><span class="line">结果是: 62445</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex84-普通的位运算"><a href="#案例ex84-普通的位运算" class="headerlink" title="案例ex84: 普通的位运算"></a><strong>案例ex84: 普通的位运算</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：普通的位运算<br>描述：<br>    求下面各个位运算的值<br>    a&amp;c<br>    b|d<br>    a^d<br>    ~a</p>
</blockquote>
<p><strong>2 思路</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>位AND</td>
<td>x&amp;y</td>
<td>如果x和y都为1，则得到1；如果x或y任何一个为0，或都为0，则得到0</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>位OR</td>
<td>x\</td>
<td>y</td>
<td>如果x或y为1，或都为1，则得到1；如果x和y都为0，则得到0</td>
</tr>
<tr>
<td>^</td>
<td>位XOR</td>
<td>x^y</td>
<td>如果x或y的值不同，则得到1；如果两个值相同，则得到0</td>
</tr>
<tr>
<td>~</td>
<td>位NOT（I的补码）</td>
<td>~x</td>
<td>如果x为0，则得到1，如果x是1，则得到0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：普通的位运算</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    求下面各个位运算的值</span></span><br><span class="line"><span class="comment">    a&amp;c</span></span><br><span class="line"><span class="comment">    b|d</span></span><br><span class="line"><span class="comment">    a^d</span></span><br><span class="line"><span class="comment">    ~a</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> result;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    c = <span class="number">6</span>;</span><br><span class="line">    d = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d,d=%d&quot;</span>, a, b, c, d);                <span class="comment">// 输出变量a、b、c、d四个数的值</span></span><br><span class="line">    result = a &amp;c;                                            <span class="comment">// a与c的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\na&amp;c=%u\n&quot;</span>, result);                            <span class="comment">// 将结果输出</span></span><br><span class="line">    result = b | d;                                         <span class="comment">// b|d的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b|d=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">    result = a ^ d;                                            <span class="comment">// a^d的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a^d=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">    result = ~a;                                            <span class="comment">// ~a的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~a=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex084.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">a=2,b=4,c=6,d=8</span><br><span class="line">a&amp;c=2</span><br><span class="line">b|d=12</span><br><span class="line">a^d=10</span><br><span class="line">~a=4294967293</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex85-整数与-0-异或"><a href="#案例ex85-整数与-0-异或" class="headerlink" title="案例ex85: 整数与 0 异或"></a><strong>案例ex85: 整数与 0 异或</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：整数与 0 异或</p>
<p>描述：计算输入整数与 0 异或</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>异或：相同为 1，不同为 0</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>位 XOR</td>
<td>x^y</td>
<td>如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：整数与 0 异或</span></span><br><span class="line"><span class="comment">描述：计算输入整数与 0 异或</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> result;                                 <span class="comment">// 定义无符号数</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入a:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    b=<span class="number">0</span>;                                            <span class="comment">// 与0异或</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>, a, b);</span><br><span class="line">    result = a^b;                                     <span class="comment">// 求整数与0异或的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\na^b=%u\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex085.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入a:10</span><br><span class="line">a=10,b=0</span><br><span class="line">a^b=10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex86-打印杨辉三角"><a href="#案例ex86-打印杨辉三角" class="headerlink" title="案例ex86: 打印杨辉三角"></a><strong>案例ex86: 打印杨辉三角</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：打印杨辉三角</p>
<p>描述：打印给定行数的杨辉三角</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>杨辉三角形</strong></p>
<p>又称帕斯卡三角形、贾宪三角形、海亚姆三角形、巴斯卡三角形，是二项式系数的一种写法，形似三角形，在中国首现于南宋杨辉的《详解九章算法》得名，书中杨辉说明是引自贾宪的《释锁算书》，故又名贾宪三角形。</p>
<p><strong>最基本的几个性质</strong><br>每个数等于它上方两数之和<br>每行数字左右对称，由1开始逐渐变大<br>第n行的数字有n项<br>前n行共[(1+n)n]/2 个数</p>
<p><strong>举例</strong></p>
<p>打印出前 9 行的数字</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                        1</span><br><span class="line">                     1     1</span><br><span class="line">                  1     2     1</span><br><span class="line">               1     3     3     1</span><br><span class="line">            1     4     6     4     1</span><br><span class="line">         1     5    10    10     5     1</span><br><span class="line">      1     6    15    20    15     6     1</span><br><span class="line">   1     7    21    35    35    21     7     1</span><br><span class="line">1     8    28    56    70    56    28     8     1</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：打印杨辉三角</span></span><br><span class="line"><span class="comment">描述：打印给定行数的杨辉三角</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k, n, a[N][N];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要打印的行数[范围在1~15之间]：&quot;</span>); <span class="comment">// 控制在 15 行之内</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">1</span> &amp;&amp; n&lt;=<span class="number">15</span>)&#123;                  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入的行数不在规定范围内！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d行杨辉三角打印如下：\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        a[i][<span class="number">1</span>] = a[i][i] = <span class="number">1</span>;               </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>; j&lt;=i<span class="number">-1</span>; j++)</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=n-i; k++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);                   </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i; j++)                  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入要打印的行数[范围在1~15之间]：20</span><br><span class="line">输入的行数不在规定范围内！</span><br><span class="line">请输入要打印的行数[范围在1~15之间]：30</span><br><span class="line">输入的行数不在规定范围内！</span><br><span class="line">请输入要打印的行数[范围在1~15之间]：10</span><br><span class="line">10行杨辉三角打印如下：</span><br><span class="line">                                1</span><br><span class="line">                             1     1</span><br><span class="line">                          1     2     1</span><br><span class="line">                       1     3     3     1</span><br><span class="line">                    1     4     6     4     1</span><br><span class="line">                 1     5    10    10     5     1</span><br><span class="line">              1     6    15    20    15     6     1</span><br><span class="line">           1     7    21    35    35    21     7     1</span><br><span class="line">        1     8    28    56    70    56    28     8     1</span><br><span class="line">     1     9    36    84   126   126    84    36     9     1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex87-循环显示随机数"><a href="#案例ex87-循环显示随机数" class="headerlink" title="案例ex87: 循环显示随机数"></a><strong>案例ex87: 循环显示随机数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：循环显示随机数<br>描述：随机产出 10 个随机数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>在产出随机数的时候，需要将设置随机发生的种子 srand(n);<br>随后才能进行产出不同的随机数</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：循环显示随机数</span></span><br><span class="line"><span class="comment">描述：随机产出 10 个随机数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> rd; <span class="comment">// 随机发生数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 随机发生数的种子</span></span><br><span class="line">        srand(i+<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 产出随机发生数</span></span><br><span class="line">        rd = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;种子 %d 产出的随机数为%d\n&quot;</span>, i+<span class="number">5</span>, rd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex087.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">种子 5 产出的随机数为84035</span><br><span class="line">种子 6 产出的随机数为100842</span><br><span class="line">种子 7 产出的随机数为117649</span><br><span class="line">种子 8 产出的随机数为134456</span><br><span class="line">种子 9 产出的随机数为151263</span><br><span class="line">种子 10 产出的随机数为168070</span><br><span class="line">种子 11 产出的随机数为184877</span><br><span class="line">种子 12 产出的随机数为201684</span><br><span class="line">种子 13 产出的随机数为218491</span><br><span class="line">种子 14 产出的随机数为235298</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex88-阿姆斯特朗数"><a href="#案例ex88-阿姆斯特朗数" class="headerlink" title="案例ex88: 阿姆斯特朗数"></a><strong>案例ex88: 阿姆斯特朗数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：阿姆斯特朗数</p>
<p>描述：打印从100到999之间所有的阿姆斯特朗数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>阿姆斯特朗数</strong></p>
<p>如果一个n位正整数等于其各位数字的n次方之和,则称该数为阿姆斯特朗数。<br>例如1^3 + 5^3 + 3^3 = 153</p>
<p><strong>水仙花数</strong></p>
<p>当n=3时，又称水仙花数，特指一种三位数，其各个数之立方和等于该数。<br>水仙花数共有4个，分别为：153、370、371、407</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：阿姆斯特朗数</span></span><br><span class="line"><span class="comment">描述：打印从1到10000之间所有的阿姆斯特朗数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123; <span class="comment">// 遍历从 1 到 10000 的阿姆斯特朗数</span></span><br><span class="line"></span><br><span class="line">        j = i % <span class="number">10</span>;                 <span class="comment">// 分离出个位上的数</span></span><br><span class="line">        k = i / <span class="number">10</span> % <span class="number">10</span>;             <span class="comment">// 分离出十位上的数</span></span><br><span class="line">        n = i / <span class="number">100</span>;                 <span class="comment">// 分离出百位上的数</span></span><br><span class="line">        <span class="keyword">if</span> (j *j * j + k * k * k + n * n * n == i)     <span class="comment">// 进行判断各位上的立方和是否等于遍历数本身</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex088.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">1^3 + 5^3 + 3^3 = 153</span><br><span class="line">3^3 + 7^3 + 0^3 = 370</span><br><span class="line">3^3 + 7^3 + 1^3 = 371</span><br><span class="line">4^3 + 0^3 + 7^3 = 407</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>互联网技术类书籍集合下载</title>
    <url>/posts/cab6e6f6/</url>
    <content><![CDATA[<p>需要打包下载的，留言区留下邮箱，邮箱发送过去<br>【电子书籍】坚持书籍分享 … 完善中 …<br>【要善用Command/Ctrl+F查找资料哦】<br>资料馆分类：<br>零、互联网面试书籍集合<br>一、计算机技术语言类<br>C / C++<br>Java<br>Python<br>其他<br>二、数据结构和算法<br>数据结构<br>基本算法<br>周边算法思想<br>三、Python技术<br>Python 语言<br>Python 数据分析<br>Python 技巧<br>四、大数据技术<br>大数据技术基础<br>大数据平台开源工具<br>大数据集群<br>Linux<br>数据库<br>五、机器学习和人工智能AI<br>数学相关<br>机器学习<br>推荐算法<br>深度学习<br>其他<br>六、其他书籍<br>按需寻找哦！ 链接如果失效，随时随地联系作者 (^o^)/~<br><strong>需要打包下载的，留言区留下邮箱，邮箱发送过去</strong></p>
<h2 id="零、互联网面试书籍集合"><a href="#零、互联网面试书籍集合" class="headerlink" title="零、互联网面试书籍集合"></a>零、互联网面试书籍集合</h2><p>《labuladong的算法小抄官方完整版<br>《剑指offer名企面试官精讲典型编程题》<br>《阿里Java面试问题大全》<br>《程序员面试宝典》</p>
<h2 id="一、计算机技术语言类"><a href="#一、计算机技术语言类" class="headerlink" title="一、计算机技术语言类"></a>一、计算机技术语言类</h2><h4 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h4><p>《C和指针》 C语言经典书籍<br>《啊哈c语言》<br>《c++primerplus6》 C++经典书籍<br>《深入探索C++对象模型》<br>《C++编程规范-101条规则准则与最佳实践》<br>《C++编程思想两卷合订本》<br>《C++沉思录中文第2版》<br>《C++大学教程》<br>《深入探索C++对象模型》<br>《C++设计新思维-泛型编程与设计之应用》<br>《C++primer5th》<br>《C++ Templates》<br>《C语言编程精粹》<br>《C语言参考手册第五版》<br>《C语言解析教程》<br>《C语言深度解剖》<br>《C专家编程》<br>《EffectiveSTL中文版》<br>《MoreEffectiveC++中文版》<br>《STL源码剖析》</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>《Java核心技术 卷1 基础知识 原书第9版》<br>《阿里巴巴Java开发手册》<br>《码出高效》Java开发手册<br>《轻量级JavaEE企业应用实战》<br>《深入分析JavaWeb技术内幕》<br>《深入理解Java虚拟机第二版》<br>《深入剖析Tomcat》<br>《Java8实战》<br>《JAVA并发编程实践》<br>《EffectiveJava中文第二版》<br>《HeadFirstJava第二版涵盖java0》<br>《HeadFirstServletandJSP》(高清中文版)<br>《Java从小白到大牛精简版》<br>《Java核心技术卷1第8版》<br>《Java核心技术卷2第8版》<br>《Java性能优化权威指南》<br>《Spring 实战 中文版第4版》</p>
<h2 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h2><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>《大话数据结构》<br>《Java数据结构和算法》 第二版<br>《算法导论》<br>《啊哈算法》<br>《编程珠玑第二版》<br>《算法图解》</p>
<h2 id="三、Python技术"><a href="#三、Python技术" class="headerlink" title="三、Python技术"></a>三、Python技术</h2><h4 id="Python-语言"><a href="#Python-语言" class="headerlink" title="Python 语言"></a>Python 语言</h4><p>《Python进阶》<br>《Python基础教程（第二版）》<br>《Python核心编程第二版中文》<br>《Python开发实战》<br>《Python开发技术详解》<br>《Python灰帽子黑客与逆向工程师的Python编程之道》<br>《Python高级编程第2版》<br>《Python编程入门经典》<br>《Python编程初学者指南》<br>《Python网络编程基础》<br>《Python学习手册》<br>《Python学习手册》 第4版<br>《用Python写网络爬虫》</p>
<h4 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h4><p>《利用Python进行数据分析》<br>《NumPy学习指南（第2版）》<br>《常用的数据分析方法》<br>《Python数据处理》<br>《Python金融大数据分析》<br>《Python数据分析与挖掘实战》<br>《Python数据科学手册》<br>《Python数据可视化编程实战》<br>《PYTHON自然语言处理中文版》</p>
<h2 id="四、大数据技术"><a href="#四、大数据技术" class="headerlink" title="四、大数据技术"></a>四、大数据技术</h2><h4 id="大数据技术基础"><a href="#大数据技术基础" class="headerlink" title="大数据技术基础"></a>大数据技术基础</h4><p>《Hadoop全权威指南第三版（原版）》<br>《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理<br>《Hadoop技术内幕》深入解析YARN架构设计与实现原理<br>《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理<br>《Spark快速大数据分析》</p>
<h4 id="大数据平台开源工具"><a href="#大数据平台开源工具" class="headerlink" title="大数据平台开源工具"></a>大数据平台开源工具</h4><h4 id="大数据集群"><a href="#大数据集群" class="headerlink" title="大数据集群"></a>大数据集群</h4><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>《鸟哥的LINUX私房菜_基础学习篇(第三版)》<br>《鸟哥的LINUX私房菜_基础学习篇(第三版)》<br>《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)<br>《Linux宝典》<br>《linux常用命令大全》<br>《LINUX防火墙原书第3版》<br>《Linux高级程序设计中文第三版》<br>《Linux环境编程从应用到内核》<br>《Linux命令详解词典施威铭研究室》</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>《深入浅出MySQL++数据库开发优化与管理维护》<br>《高性能mysql第三版》<br>《MySQL必知必会》</p>
<h2 id="五、机器学习和人工智能AI"><a href="#五、机器学习和人工智能AI" class="headerlink" title="五、机器学习和人工智能AI"></a>五、机器学习和人工智能AI</h2><h4 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h4><p>《高等数学（同济）第六版/第七版课后习题答案》完整答案<br>《浙江大学概率论与数理统计(第四版)》<br>《数学之美》完整版</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《Machine Learning Yearning》完整中文版<br>《百面机器学习》<br>《统计学习方法》<br>《机器学习》周志华-西瓜书<br>《Artificial Intelligence_ A Modern》<br>《贝叶斯思维统计建模的PYTHON学习法》<br>《机器学习实战》<br>《机器学习与数据挖掘方法和应用》<br>《机器学习》中文版<br>《人工智能》复杂问题求解的结构和策略<br>《数据挖掘-实用机器学习技术》中文第二版<br>《数据挖掘-数据-模型-算法》<br>《数据挖掘概念与技术(中文版)》<br>《数据挖掘实用案例分析》<br>《Web数据挖掘》</p>
<h4 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h4><p>《推荐算法在业界的应用实践合集》<br>《推荐系统实践》</p>
<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>2020最新版《神经网络与深度学习》中文版<br>《神经网络与机器学习》<br>《TensorFlow实践与智能系统》<br>《Tensorflow实战Google深度学习框架》</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h2 id="六、其他书籍"><a href="#六、其他书籍" class="headerlink" title="六、其他书籍"></a>六、其他书籍</h2><p>《计算广告：互联网商业变现的市场与技术-刘鹏》<br>Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】<br>《Go语言实战》<br>《第一行代码-Android》<br>《数据库原理（第5版）》<br>《VIM 思维导图》<br>《编程之美》完整版<br>《代码大全2中文版》<br>《代码整洁之道》<br>《高性能mysql第三版》<br>《黑客与画家》<br>《汇编语言》(第3版)王爽著<br>《计算机程序设计艺术(第一卷)》<br>《计算机程序设计艺术(第二卷)》<br>《计算机程序设计艺术(第三卷)》<br>《精通正则表达式》<br>《浪潮之巅》(完整版)<br>《图解设计模式》<br>《学习Go语言(Golang)》<br>《研磨设计模式》<br>《HeadFirst设计模式》<br>《Maven实战》<br>《MongoDB权威指南》<br>《Pro Git中文版》<br>《SQL查询的艺术》<br>《SQLite权威指南》<br><strong>需要打包下载的，留言区留下邮箱，邮箱发送过去</strong></p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本页书籍均来自网络，如有侵权，请联系我立即删除<br>我的邮箱：yaojianguolq@com</p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas系列 | 2.Series基本功能</title>
    <url>/posts/d81231da/</url>
    <content><![CDATA[<h2 id="系列基本功能"><a href="#系列基本功能" class="headerlink" title="系列基本功能"></a>系列基本功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>axes</td>
<td>返回行轴标签列表</td>
</tr>
<tr>
<td>2</td>
<td>dtype</td>
<td>返回对象的数据类型(dtype)</td>
</tr>
<tr>
<td>3</td>
<td>empty</td>
<td>如果系列为空，则返回True</td>
</tr>
<tr>
<td>4</td>
<td>ndim</td>
<td>返回底层数据的维数，默认定义：1</td>
</tr>
<tr>
<td>5</td>
<td>size</td>
<td>返回基础数据中的元素数</td>
</tr>
<tr>
<td>6</td>
<td>values</td>
<td>将系列作为ndarray返回</td>
</tr>
<tr>
<td>7</td>
<td>head()</td>
<td>返回前n行</td>
</tr>
<tr>
<td>8</td>
<td>tail()</td>
<td>返回最后n行</td>
</tr>
</tbody>
</table>
</div>
<p>axes示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a series with 100 random numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.axes  <span class="comment">## 返回行轴标签列表</span></span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.dtype     <span class="comment">## 返回对象的数据类型(dtype)</span></span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.empty    <span class="comment">## 如果系列为空，则返回True    </span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ndim    <span class="comment">## 返回底层数据的维数，默认定义：1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.size    <span class="comment">## 返回基础数据中的元素数</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.values    <span class="comment">## 将系列作为ndarray返回</span></span><br><span class="line">array([-<span class="number">0.56295907</span>,  <span class="number">1.54666615</span>, -<span class="number">0.95013554</span>, -<span class="number">0.06782656</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.head()    <span class="comment">## 返回前n行</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.tail()    <span class="comment">## 返回最后n行</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h2 id="DataFrame基本功能"><a href="#DataFrame基本功能" class="headerlink" title="DataFrame基本功能"></a>DataFrame基本功能</h2><p>列出比较重要的一些方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>T/tranpose()</td>
<td>转置行和列</td>
</tr>
<tr>
<td>2</td>
<td>axes</td>
<td>返回一个列，行轴标签和列轴标签作为唯一的成员</td>
</tr>
<tr>
<td>3</td>
<td>dtypes</td>
<td>返回此对象中的数据类型(dtypes)</td>
</tr>
<tr>
<td>4</td>
<td>empty</td>
<td>如果NDFrame完全为空[无项目]，则返回为True; 如果任何轴的长度为0</td>
</tr>
<tr>
<td>5</td>
<td>ndim</td>
<td>轴/数组维度大小</td>
</tr>
<tr>
<td>6</td>
<td>shape</td>
<td>返回表示DataFrame的维度的元组</td>
</tr>
<tr>
<td>7</td>
<td>size</td>
<td>NDFrame中的元素数</td>
</tr>
<tr>
<td>8</td>
<td>values</td>
<td>NDFrame的Numpy表示</td>
</tr>
<tr>
<td>9</td>
<td>head()</td>
<td>返回开头前n行</td>
</tr>
<tr>
<td>10</td>
<td>tail()</td>
<td>返回最后n行</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据分析专题</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas系列 | 1.基本数据结构</title>
    <url>/posts/411b6060/</url>
    <content><![CDATA[<blockquote>
<p>系列(Series)是能够保存任何类型的数据(整数，字符串，浮点数，Python对象等)的一维标记数组。轴标签统称为索引</p>
</blockquote>
<h2 id="一、pandas-Series"><a href="#一、pandas-Series" class="headerlink" title="一、pandas.Series"></a>一、pandas.Series</h2><p>构造函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series(data, index, dtype, copy)</span><br></pre></td></tr></table></figure><br>| 编号 | 参数  | 描述                                                         |<br>| —— | ——- | —————————————————————————————— |<br>| 1    | data  | 数据采取各种形式，如：ndarray，list，constants               |<br>| 2    | index | 索引值必须是唯一的和散列的，与数据的长度相同  默认np.arange(n)如果没有索引被传递 |<br>| 3    | dtype | dtype用于数据类型 如果没有，将推断数据类型                   |<br>| 4    | copy  | 复制数据，默认为false                                        |</p>
<p>构成一个Series的输入有:</p>
<ul>
<li>数组</li>
<li>字典</li>
<li>标量值</li>
<li>常数</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(data,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100  a</span><br><span class="line">101  b</span><br><span class="line">102  c</span><br><span class="line">103  d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">0.</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">1.</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">2.</span>&#125;</span><br><span class="line">s = pd.Series(data,index=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 1.0</span><br><span class="line">c 2.0</span><br><span class="line">d NaN</span><br><span class="line">a 0.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="标量值-or-常数"><a href="#标量值-or-常数" class="headerlink" title="标量值 or 常数"></a>标量值 or 常数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  5</span><br><span class="line">1  5</span><br><span class="line">2  5</span><br><span class="line">3  5</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、pandas-DataFrame"><a href="#二、pandas-DataFrame" class="headerlink" title="二、pandas.DataFrame"></a>二、pandas.DataFrame</h2><blockquote>
<p>数据帧(DataFrame)是二维数据结构，即数据以行和列的表格方式排列</p>
</blockquote>
<p>数据帧(DataFrame)的功能特点：</p>
<ul>
<li>潜在的列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<p>构造函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame(data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><br>| 编号 | 参数    | 描述                                                         |<br>| —— | ———- | —————————————————————————————— |<br>| 1    | data    | 数据采取各种形式，如:ndarray，series，map，lists，dict，constant和另一个DataFrame。 |<br>| 2    | index   | 对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值。 |<br>| 3    | columns | 对于列标签，可选的默认语法是 - np.arange(n)。 这只有在没有索引传递的情况下才是这样。 |<br>| 4    | dtype   | 每列的数据类型。                                             |<br>| 5    | copy    | 如果默认值为False，则此命令(或任何它)用于复制数据。          |</p>
<h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><p>Pandas数据帧(DataFrame)可以使用各种输入创建 </p>
<ul>
<li>列表</li>
<li>字典</li>
<li>系列（Series）</li>
<li>Numpy ndarrays</li>
<li>另一个数据帧(DataFrame)</li>
</ul>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     0</span><br><span class="line">0    1</span><br><span class="line">1    2</span><br><span class="line">2    3</span><br><span class="line">3    4</span><br><span class="line">4    5</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure><br>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    a    b      c</span><br><span class="line">0   1   2     NaN</span><br><span class="line">1   5   10   20.0</span><br></pre></td></tr></table></figure></p>
<h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;rank1&#x27;</span>,<span class="string">&#x27;rank2&#x27;</span>,<span class="string">&#x27;rank3&#x27;</span>,<span class="string">&#x27;rank4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Age    Name</span><br><span class="line">rank1    28      Tom</span><br><span class="line">rank2    34     Jack</span><br><span class="line">rank3    29    Steve</span><br><span class="line">rank4    42    Ricky</span><br></pre></td></tr></table></figure></p>
<h4 id="系列（Series）"><a href="#系列（Series）" class="headerlink" title="系列（Series）"></a>系列（Series）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      one    two</span><br><span class="line">a     1.0    1</span><br><span class="line">b     2.0    2</span><br><span class="line">c     3.0    3</span><br><span class="line">d     NaN    4</span><br></pre></td></tr></table></figure></p>
<h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df [<span class="string">&#x27;one&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="列添加"><a href="#列添加" class="headerlink" title="列添加"></a>列添加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding a new column to an existing DataFrame object with column label by passing new series</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Adding a new column by passing as Series:&quot;</span>)</span><br><span class="line">df[<span class="string">&#x27;three&#x27;</span>]=pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Adding a new column using the existing columns in DataFrame:&quot;</span>)</span><br><span class="line">df[<span class="string">&#x27;four&#x27;</span>]=df[<span class="string">&#x27;one&#x27;</span>]+df[<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<h3 id="列删除-pop-del"><a href="#列删除-pop-del" class="headerlink" title="列删除 pop/del"></a>列删除 pop/del</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using the previous DataFrame, we will delete a column</span></span><br><span class="line"><span class="comment"># using del function</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;three&#x27;</span> : pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Our dataframe is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># using del function</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Deleting the first column using DEL function:&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># using pop function</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Deleting another column using POP function:&quot;</span>)</span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<h3 id="行选择，添加和删除"><a href="#行选择，添加和删除" class="headerlink" title="行选择，添加和删除"></a>行选择，添加和删除</h3><h4 id="标签选择-loc"><a href="#标签选择-loc" class="headerlink" title="标签选择 loc"></a>标签选择 loc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="按整数位置选择-iloc"><a href="#按整数位置选择-iloc" class="headerlink" title="按整数位置选择 iloc"></a>按整数位置选择 iloc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df.iloc[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="行切片"><a href="#行切片" class="headerlink" title="行切片"></a>行切片</h3><h4 id="附加行-append"><a href="#附加行-append" class="headerlink" title="附加行 append"></a>附加行 append</h4><p>使用append()函数将新行添加到DataFrame<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure></p>
<h4 id="删除行-drop"><a href="#删除行-drop" class="headerlink" title="删除行 drop"></a>删除行 drop</h4><p>使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Drop rows with label 0</span></span><br><span class="line">df = df.drop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="三、pandas-Panel"><a href="#三、pandas-Panel" class="headerlink" title="三、pandas.Panel()"></a>三、pandas.Panel()</h2><blockquote>
<p>面板(Panel)是3D容器的数据</p>
</blockquote>
<p>3轴(axis)这个名称旨在给出描述涉及面板数据的操作的一些语义</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>轴</th>
<th>detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td>axis 0，每个项目对应于内部包含的数据帧(DataFrame)</td>
</tr>
<tr>
<td>major_axis</td>
<td>axis 1，它是每个数据帧(DataFrame)的索引(行)</td>
</tr>
<tr>
<td>minor_axis</td>
<td>axis 2，它是每个数据帧(DataFrame)的列</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br></pre></td></tr></table></figure>
<p>构造函数的参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>数据采取各种形式，如：ndarray，series，map，lists，dict，constant和另一个数据帧(DataFrame)</td>
</tr>
<tr>
<td>items</td>
<td>axis=0</td>
</tr>
<tr>
<td>major_axis</td>
<td>axis=1</td>
</tr>
<tr>
<td>minor_axis</td>
<td>axis=2</td>
</tr>
<tr>
<td>dtype</td>
<td>每列的数据类型</td>
</tr>
<tr>
<td>copy</td>
<td>复制数据，默认 - false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="创建面板"><a href="#创建面板" class="headerlink" title="创建面板"></a>创建面板</h3><p>可以使用多种方式创建面板</p>
<ul>
<li>从ndarrays创建</li>
<li>从DataFrames的dict创建</li>
</ul>
<h4 id="从3D-ndarray创建"><a href="#从3D-ndarray创建" class="headerlink" title="从3D ndarray创建"></a>从3D ndarray创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print data</span><br><span class="line">[[[0.79346549 0.22729079 0.94261176 0.67379434 0.18751374]</span><br><span class="line">  [0.14514546 0.50550601 0.32767807 0.45882726 0.04787695]</span><br><span class="line">  [0.64748544 0.2019516  0.38334503 0.61874107 0.68800838]</span><br><span class="line">  [0.39880845 0.41415895 0.69383131 0.71159435 0.06160828]]</span><br><span class="line"></span><br><span class="line"> [[0.97102379 0.69454937 0.54629548 0.83072134 0.53068539]</span><br><span class="line">  [0.82441684 0.5882186  0.69936055 0.0924247  0.12300041]</span><br><span class="line">  [0.30401452 0.12971053 0.90511636 0.17855185 0.05474733]</span><br><span class="line">  [0.04730471 0.03639553 0.74632198 0.85193736 0.64864719]]]</span><br><span class="line">&gt;&gt;&gt; print p</span><br><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)</span><br><span class="line">Items axis: 0 to 1</span><br><span class="line">Major_axis axis: 0 to 3</span><br><span class="line">Minor_axis axis: 0 to 4</span><br></pre></td></tr></table></figure></p>
<h4 id="从DataFrame对象的dict创建面板"><a href="#从DataFrame对象的dict创建面板" class="headerlink" title="从DataFrame对象的dict创建面板"></a>从DataFrame对象的dict创建面板</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Item1&#x27;</span> : pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>)), </span><br><span class="line">        <span class="string">&#x27;Item2&#x27;</span> : pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">2</span>))&#125;</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;Item2&#39;:           </span><br><span class="line">          0         1</span><br><span class="line">0  0.009730  2.263936</span><br><span class="line">1 -1.008878  1.083319</span><br><span class="line">2  0.288527  0.234344</span><br><span class="line">3 -0.426486  0.286741, </span><br><span class="line">&#39;Item1&#39;:           </span><br><span class="line">      0         1         2</span><br><span class="line">0 -2.149956  1.696135 -0.256530</span><br><span class="line">1 -1.063944 -1.033069  0.653613</span><br><span class="line">2 -0.645782 -0.097129  1.034462</span><br><span class="line">3 -0.041070  0.104719  0.577797&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print p</span><br><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 3 (minor_axis)</span><br><span class="line">Items axis: Item1 to Item2</span><br><span class="line">Major_axis axis: 0 to 3</span><br><span class="line">Minor_axis axis: 0 to 2</span><br></pre></td></tr></table></figure></p>
<h4 id="创建一个空面板"><a href="#创建一个空面板" class="headerlink" title="创建一个空面板"></a>创建一个空面板</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">p = pd.Panel()</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 0 (items) x 0 (major_axis) x 0 (minor_axis)</span><br><span class="line">Items axis: None</span><br><span class="line">Major_axis axis: None</span><br><span class="line">Minor_axis axis: None</span><br></pre></td></tr></table></figure></p>
<h3 id="从面板中选择数据"><a href="#从面板中选择数据" class="headerlink" title="从面板中选择数据"></a>从面板中选择数据</h3><p>要从面板中选择数据，可以使用以下方式</p>
<ul>
<li>Items</li>
<li>Major_axis</li>
<li>Minor_axis</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;Item1&#x27;</span> : pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>, <span class="number">3</span>)), </span><br><span class="line">        <span class="string">&#x27;Item2&#x27;</span> : pd.DataFrame(np.arange(<span class="number">8</span>).reshape(<span class="number">4</span>, <span class="number">2</span>))&#125;</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="comment"># 使用Item</span></span><br><span class="line"><span class="built_in">print</span> p[<span class="string">&#x27;Item1&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用Major_axis</span></span><br><span class="line"><span class="built_in">print</span> p.major_xs(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用Minor_axis</span></span><br><span class="line"><span class="built_in">print</span> p.minor_xs(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data:</span><br><span class="line">&#123;<span class="string">&#x27;Item2&#x27;</span>:    </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>, </span><br><span class="line"><span class="string">&#x27;Item1&#x27;</span>:    </span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Item</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p[<span class="string">&#x27;Item1&#x27;</span>]</span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Major_axis</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p.major_xs(<span class="number">1</span>)</span><br><span class="line">   Item1  Item2</span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">5</span>    NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Minor_axis</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p.minor_xs(<span class="number">1</span>)</span><br><span class="line">   Item1  Item2</span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">7</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">10</span>    <span class="number">7.0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>最后，在这里准备了几百本PDF技术类书籍，<a href="https://www.keketec.club/posts/77172009/">点击来领取吧!!!</a></p>
]]></content>
      <categories>
        <category>数据分析专题</category>
      </categories>
  </entry>
  <entry>
    <title>自己写代码实现邮件发送，再也不用可视化那么麻烦了！</title>
    <url>/posts/a6c96c4e/</url>
    <content><![CDATA[<blockquote>
<p>学而知不足，长按关注，精彩不错过</p>
</blockquote>
<p>Python自动批量发送邮件是一种什么体验？</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b1.jpg" width="50%" height="50%"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们在发送一些邮件信息的时候，在可视化的界面巴拉巴拉操作一顿，其实就是一些很简单的信息，然后可能发送的收信者比较多，带来很多的麻烦，主要是浪费了我们的时间！</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>很重要重要重要的准备工作，带你进入代码发送邮件的氛围！</p>
<blockquote>
<p>看着前面小哥哥把每个订单号都粘贴到邮件里，然后再给一个收件人的联系邮箱，如此熟练的操作，整整做了一个上午，因为需要给每个收件人单独发送，我心里有种说不出来的感觉 …</p>
<p>这就像刚刚工作那会儿看着旁边跟我一样的实习生在重复插入sql一样，他居然不知道列编辑，然而要一行一行一个字一个字的敲进去一样的感受。</p>
<p><em>如果有不知道的同学也可以私信我，几分钟的事情可能对于不知道这个技巧的同学需要几个小时才能完成</em></p>
</blockquote>
<p><strong>进行正题！！！！！</strong></p>
<p>自动化发邮件之前，首先需要用到的两个重要的 Python 模块：smtplib 和 email</p>
<blockquote>
<p>smtplib模块主要用来建立服务器链接、服务器断开的工作； </p>
<p>email模块主要负责邮件的构建，比如收件人、邮件标题、邮件内容等</p>
</blockquote>
<p>我用的是python2.7版本，所以安装这两个库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip2.7 install secure-smtplib</span><br><span class="line">pip2.7 install email</span><br></pre></td></tr></table></figure>
<p>安装准备好需要的包，下面就开始发送邮件的操作，实例化操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br></pre></td></tr></table></figure>
<p>MIMEText 类是 MIMENonMultipart 类的子类，一般用于用于封装文本类型的邮件</p>
<p>实例化邮件服务器信息，可以进行相应的配置，邮件的标题、邮件的收发邮件信息、当然还可以进行抄送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;First Message&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;MyTestTitle&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br></pre></td></tr></table></figure>
<p>在完成了以上的操作之后，然后配置自己的信息就可以进行操作发送了。</p>
<p>当然在我给到的代码中，都是以变量给出的，首先咱们需要初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送者邮箱（改为自己的）</span></span><br><span class="line">sender = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line"><span class="comment"># 接受者邮箱（改为自己的）</span></span><br><span class="line">receiver = <span class="string">&quot;xxx@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 服务器地址</span></span><br><span class="line">smtp_addr = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line"><span class="comment"># 邮件服务器账号和密码，自己的163邮箱的登录账号和密码</span></span><br><span class="line">login_user = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">login_passwd = <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后，关键一步，可以发送了，但是记得要关闭连接哦！</p>
<p><strong>参数格式：</strong><code>sendmail(self, from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功 ^_^ &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>哈哈，看看我的界面，已经收到了哈！</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b2.jpg" width="50%" height="50%"></p>
<p>跟着试了的同学以及攻城狮们，成功了没有</p>
<p>需要我发送代码的，给我留言哈，可以公号后台私信我吆！！</p>
<p>也可以自取哈！地址: <a href="https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw">https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw</a>  密码: s8ew</p>
<h2 id="发送其他格式的邮件"><a href="#发送其他格式的邮件" class="headerlink" title="发送其他格式的邮件"></a>发送其他格式的邮件</h2><p>上述展示了普通格式的邮件发送格式，下面咱们再看看想要发送一些HTML格式的，还有带附件的邮件形式。</p>
<p>再然后就可以自行发挥发送任何格式和组合的邮件了！</p>
<h3 id="1-发送-HTML-格式的邮件"><a href="#1-发送-HTML-格式的邮件" class="headerlink" title="1. 发送 HTML 格式的邮件"></a>1. 发送 HTML 格式的邮件</h3><p>在创建 MIMEText 时，将 _subtype 设置为 “html”，则可发送 html 格式的邮件</p>
<p>其他步骤和发送纯文本邮件配置和代码格式都一致</p>
<p>跟上面文本格式邮件对比下哈，会有很清晰的思路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通文本格式</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># html 格式</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>贴出详细代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Python&lt;/th&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;编程爱好者&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;需要代码的同学&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;加我微信&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;Johngo106X&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;双手奉上！&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;测试发送HTML信息&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>一些自定义的变量可以自己设置哈，全量代码可以在网盘中自取！！！</p>
<p>哈， 再看看 Johngo 的结果：</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b3.jpg" width="50%" height="50%"></p>
<p>下面再看看重要的附件，是怎么操作的</p>
<h3 id="2-发送带有附件的邮件"><a href="#2-发送带有附件的邮件" class="headerlink" title="2. 发送带有附件的邮件"></a>2. 发送带有附件的邮件</h3><p>类似的操作方法，不同的操作是实例化发送信息的这块稍有区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEMultipart()</span><br></pre></td></tr></table></figure>
<p>同样的我先把代码附上，需要详细代码的请自取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Python&lt;/th&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;编程爱好者&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;需要代码的同学&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;加我微信&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;Johngo106X&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;双手奉上！&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;原文链接&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;xxx&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">msg.attach(payload=MIMEText(words, _subtype=<span class="string">&quot;html&quot;</span>, _charset=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;附件邮件发送测试&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> &#123;<span class="string">&quot;test1.xlsx&quot;</span>, <span class="string">&quot;test2.xlsx&quot;</span>&#125;:</span><br><span class="line">    attachment = MIMEText(_text=<span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>).read(), _subtype=<span class="string">&quot;base64&quot;</span>, _charset=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line">    attachment[<span class="string">&quot;Content-Disposition&quot;</span>] = <span class="string">&quot;attachment; filename=%s&quot;</span> % file_path</span><br><span class="line">    msg.attach(payload=attachment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>同样的，咱们看看附件过来了没有</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b4.jpg" width="50%" height="50%"></p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>比较简单的几行代码，在某些时候就可以将事情事半功倍，适用于定时发邮件、快速自定义的发送相同文件内容的场景</p>
<p>代码先放到网盘，就暂且不往github上传了，地址链接: <a href="https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw">https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw</a>  密码: s8ew，自取哈！！</p>
<p>另外，我给到的是最基本的 Python 自定义发送邮件的操作，拿到手的同学和攻城狮们可以进行再次封装，更加好用一些。同时也可以分享出来</p>
<p>好了，今天就是有关自定义发送邮件小工具的全部分享内容了，如果感觉对你有些许帮助，还请轻轻点击转发，让更多的人看到，对 Johngo 来说，有莫大的帮助！</p>
<p>文中有任何错误的地方，烦请不吝赐教。非常感谢!</p>
]]></content>
      <categories>
        <category>编程轨迹</category>
      </categories>
  </entry>
  <entry>
    <title>Pro Git中文版 PDF</title>
    <url>/posts/f09e3832/</url>
    <content><![CDATA[<h4 id="《Pro-Git中文版》"><a href="#《Pro-Git中文版》" class="headerlink" title="《Pro Git中文版》"></a>《Pro Git中文版》</h4><h6 id="链接-https-pan-baidu-com-s-1anGEASiinAIU3eo-tcnGUw-提取码-eeg1"><a href="#链接-https-pan-baidu-com-s-1anGEASiinAIU3eo-tcnGUw-提取码-eeg1" class="headerlink" title="链接: https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw 提取码: eeg1"></a>链接: <a href="https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw">https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw</a> 提取码: eeg1</h6><p>高效的版本控制是成功开发软件项目的关键。自2005年诞生以来，Git以其分布式特点和对非线性开发的强有力支持，成为了许多软件项目的版本控制系统。本书不仅是Git日常操作指南，而且深入剖析了Git的内部原理，能有效帮助程序员提升软技能。如果你刚刚启程探索Git，本书对于Git的用法、基本命令和分支机制的讲解将助你轻松入门、不走弯路。如果你在Git之路上已经走了一些时日，本书关于Git服务器、配置文件和钩子系统的内容将为你补充继续前行所需的能量。如果你不得不同时使用Git和其他版本控制系统，本书会教你如何将Git作为客户端来轻松应对此种情景。<br><a id="more"></a></p>
<p><img src="/images/ab580dd5aaf33972eb7e630836096fcd1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">章 入门 1</span><br><span class="line"></span><br><span class="line">1.1 关于版本控制 1</span><br><span class="line"></span><br><span class="line">1.1.1 本地版本控制系统 1</span><br><span class="line"></span><br><span class="line">1.1.2 集中式版本控制系统 2</span><br><span class="line"></span><br><span class="line">1.1.3 分布式版本控制系统 3</span><br><span class="line"></span><br><span class="line">1.2 Git简史 4</span><br><span class="line"></span><br><span class="line">1.3 Git基础 4</span><br><span class="line"></span><br><span class="line">1.3.1 快照，而非差异 4</span><br><span class="line"></span><br><span class="line">1.3.2 几乎所有操作都在本地执行 5</span><br><span class="line"></span><br><span class="line">1.3.3 Git的完整性 6</span><br><span class="line"></span><br><span class="line">1.3.4 Git通常只增加数据 6</span><br><span class="line"></span><br><span class="line">1.3.5 三种状态 7</span><br><span class="line"></span><br><span class="line">1.4 命令行 8</span><br><span class="line"></span><br><span class="line">1.5 安装Git 8</span><br><span class="line"></span><br><span class="line">1.5.1 Linux上的安装方法 8</span><br><span class="line"></span><br><span class="line">1.5.2 Mac上的安装方法 8</span><br><span class="line"></span><br><span class="line">1.5.3 Windows上的安装方法 9</span><br><span class="line"></span><br><span class="line">1.5.4 从源码安装 9</span><br><span class="line"></span><br><span class="line">1.6 Git的首次配置 10</span><br><span class="line"></span><br><span class="line">1.6.1 用户身份 11</span><br><span class="line"></span><br><span class="line">1.6.2 个人编辑器 11</span><br><span class="line"></span><br><span class="line">1.6.3 检查个人设置 12</span><br><span class="line"></span><br><span class="line">1.7 获取帮助 12</span><br><span class="line"></span><br><span class="line">1.8 小结 12</span><br><span class="line"></span><br><span class="line">第2章 Git基础 13</span><br><span class="line"></span><br><span class="line">2.1 获取Git仓库 13</span><br><span class="line"></span><br><span class="line">2.1.1 在现有目录中初始化Git仓库 13</span><br><span class="line"></span><br><span class="line">2.1.2 克隆现有仓库 14</span><br><span class="line"></span><br><span class="line">2.2 在Git仓库中记录变更 14</span><br><span class="line"></span><br><span class="line">2.2.1 查看当前文件状态 15</span><br><span class="line"></span><br><span class="line">2.2.2 跟踪新文件 16</span><br><span class="line"></span><br><span class="line">2.2.3 暂存已修改的文件 16</span><br><span class="line"></span><br><span class="line">2.2.4 显示更简洁的状态信息 18</span><br><span class="line"></span><br><span class="line">2.2.5 忽略文件 18</span><br><span class="line"></span><br><span class="line">2.2.6 查看已暂存和未暂存的变更 19</span><br><span class="line"></span><br><span class="line">2.2.7 提交变更 21</span><br><span class="line"></span><br><span class="line">2.2.8 跳过暂存区 22</span><br><span class="line"></span><br><span class="line">2.2.9 移除文件 23</span><br><span class="line"></span><br><span class="line">2.2.10 移动文件 24</span><br><span class="line"></span><br><span class="line">2.3 查看提交历史 25</span><br><span class="line"></span><br><span class="line">2.4 撤销操作 30</span><br><span class="line"></span><br><span class="line">2.4.1 撤销已暂存的文件 30</span><br><span class="line"></span><br><span class="line">2.4.2 撤销对文件的修改 31</span><br><span class="line"></span><br><span class="line">2.5 远程仓库的使用 32</span><br><span class="line"></span><br><span class="line">2.5.1 显示远程仓库 32</span><br><span class="line"></span><br><span class="line">2.5.2 添加远程仓库 33</span><br><span class="line"></span><br><span class="line">2.5.3 从远程仓库获取和拉取数据 34</span><br><span class="line"></span><br><span class="line">2.5.4 将数据推送到远程仓库 34</span><br><span class="line"></span><br><span class="line">2.5.5 检查远程仓库 35</span><br><span class="line"></span><br><span class="line">2.5.6 删除和重命名远程仓库 36</span><br><span class="line"></span><br><span class="line">2.6 标记 36</span><br><span class="line"></span><br><span class="line">2.6.1 列举标签 36</span><br><span class="line"></span><br><span class="line">2.6.2 创建标签 37</span><br><span class="line"></span><br><span class="line">2.6.3 注释标签 37</span><br><span class="line"></span><br><span class="line">2.6.4 轻量标签 38</span><br><span class="line"></span><br><span class="line">2.6.5 补加标签 38</span><br><span class="line"></span><br><span class="line">2.6.6 共享标签 39</span><br><span class="line"></span><br><span class="line">2.6.7 检出标签 39</span><br><span class="line"></span><br><span class="line">2.7 Git别名 40</span><br><span class="line"></span><br><span class="line">2.8 小结 41</span><br><span class="line"></span><br><span class="line">第3章 Git分支机制 42</span><br><span class="line"></span><br><span class="line">3.1 分支机制简述 42</span><br><span class="line"></span><br><span class="line">3.1.1 创建新分支 44</span><br><span class="line"></span><br><span class="line">3.1.2 切换分支 45</span><br><span class="line"></span><br><span class="line">3.2 基本的分支与合并操作 48</span><br><span class="line"></span><br><span class="line">3.2.1 基本的分支操作 48</span><br><span class="line"></span><br><span class="line">3.2.2 基本的合并操作 52</span><br><span class="line"></span><br><span class="line">3.2.3 基本的合并冲突处理 53</span><br><span class="line"></span><br><span class="line">3.3 分支管理 55</span><br><span class="line"></span><br><span class="line">3.4 与分支有关的工作流 56</span><br><span class="line"></span><br><span class="line">3.4.1 长期分支 57</span><br><span class="line"></span><br><span class="line">3.4.2 主题分支 58</span><br><span class="line"></span><br><span class="line">3.5 远程分支 59</span><br><span class="line"></span><br><span class="line">3.5.1 推送 63</span><br><span class="line"></span><br><span class="line">3.5.2 跟踪分支 64</span><br><span class="line"></span><br><span class="line">3.5.3 拉取 66</span><br><span class="line"></span><br><span class="line">3.5.4 删除远程分支 66</span><br><span class="line"></span><br><span class="line">3.6 变基 66</span><br><span class="line"></span><br><span class="line">3.6.1 基本的变基操作 66</span><br><span class="line"></span><br><span class="line">3.6.2 更有趣的变基操作 69</span><br><span class="line"></span><br><span class="line">3.6.3 变基操作的潜在危害 71</span><br><span class="line"></span><br><span class="line">3.6.4 只在需要的时候执行变基操作 74</span><br><span class="line"></span><br><span class="line">3.6.5 变基操作与合并操作的对比 75</span><br><span class="line"></span><br><span class="line">3.7 小结 75</span><br><span class="line"></span><br><span class="line">第4章 Git服务器 76</span><br><span class="line"></span><br><span class="line">4.1 协议 76</span><br><span class="line"></span><br><span class="line">4.1.1 本地协议 76</span><br><span class="line"></span><br><span class="line">4.1.2 协议 78</span><br><span class="line"></span><br><span class="line">4.1.3 SSH协议 79</span><br><span class="line"></span><br><span class="line">4.1.4 Git协议 80</span><br><span class="line"></span><br><span class="line">4.2 在服务器上搭建Git 80</span><br><span class="line"></span><br><span class="line">4.2.1 将裸仓库放置在服务器上 81</span><br><span class="line"></span><br><span class="line">4.2.2 小型团队配置 82</span><br><span class="line"></span><br><span class="line">4.3 生成个人的SSH公钥 83</span><br><span class="line"></span><br><span class="line">4.4 设置服务器 84</span><br><span class="line"></span><br><span class="line">4.5 Git守护进程 85</span><br><span class="line"></span><br><span class="line">4.6 智能 87</span><br><span class="line"></span><br><span class="line">4.7 GitWeb 88</span><br><span class="line"></span><br><span class="line">4.8 GitLab 90</span><br><span class="line"></span><br><span class="line">4.8.1 安装 90</span><br><span class="line"></span><br><span class="line">4.8.2 管理 91</span><br><span class="line"></span><br><span class="line">4.8.3 基本用法 93</span><br><span class="line"></span><br><span class="line">4.8.4 协作 93</span><br><span class="line"></span><br><span class="line">4.9 第三方托管选择 94</span><br><span class="line"></span><br><span class="line">4.10 小结 94</span><br><span class="line"></span><br><span class="line">第5章 分布式Git 95</span><br><span class="line"></span><br><span class="line">5.1 分布式工作流 95</span><br><span class="line"></span><br><span class="line">5.1.1 集中式工作流 95</span><br><span class="line"></span><br><span class="line">5.1.2 集成管理者工作流 96</span><br><span class="line"></span><br><span class="line">5.1.3 司令官与副官工作流 97</span><br><span class="line"></span><br><span class="line">5.1.4 工作流小结 97</span><br><span class="line"></span><br><span class="line">5.2 为项目做贡献 98</span><br><span class="line"></span><br><span class="line">5.2.1 提交准则 98</span><br><span class="line"></span><br><span class="line">5.2.2 私有小型团队 100</span><br><span class="line"></span><br><span class="line">5.2.3 私有管理团队 105</span><br><span class="line"></span><br><span class="line">5.2.4 派生的公开项目 110</span><br><span class="line"></span><br><span class="line">5.2.5 通过电子邮件接受补丁的公开项目 113</span><br><span class="line"></span><br><span class="line">5.2.6 小结 115</span><br><span class="line"></span><br><span class="line">5.3 维护项目 115</span><br><span class="line"></span><br><span class="line">5.3.1 使用主题分支 115</span><br><span class="line"></span><br><span class="line">5.3.2 应用来自电子邮件的补丁 116</span><br><span class="line"></span><br><span class="line">5.3.3 检出远程分支 118</span><br><span class="line"></span><br><span class="line">5.3.4 确定引入内容 119</span><br><span class="line"></span><br><span class="line">5.3.5 整合所贡献的工作结果 120</span><br><span class="line"></span><br><span class="line">5.3.6 为发布版打标签 125</span><br><span class="line"></span><br><span class="line">5.3.7 生成构建编号 126</span><br><span class="line"></span><br><span class="line">5.3.8 准备发布 126</span><br><span class="line"></span><br><span class="line">5.3.9 简报 127</span><br><span class="line"></span><br><span class="line">5.4 小结 127</span><br><span class="line"></span><br><span class="line">第6章 GitHub 128</span><br><span class="line"></span><br><span class="line">6.1 账号设置与配置 128</span><br><span class="line"></span><br><span class="line">6.1.1 SSH访问 129</span><br><span class="line"></span><br><span class="line">6.1.2 头像 130</span><br><span class="line"></span><br><span class="line">6.1.3 电子邮件地址 131</span><br><span class="line"></span><br><span class="line">6.1.4 双因素身份验证 132</span><br><span class="line"></span><br><span class="line">6.2 为项目做贡献 132</span><br><span class="line"></span><br><span class="line">6.2.1 派生项目 132</span><br><span class="line"></span><br><span class="line">6.2.2 GitHub流程 133</span><br><span class="line"></span><br><span class="line">6.2.3 拉取请求的高级用法 140</span><br><span class="line"></span><br><span class="line">6.2.4 Markdown 144</span><br><span class="line"></span><br><span class="line">6.3 项目维护 148</span><br><span class="line"></span><br><span class="line">6.3.1 创建新仓库 148</span><br><span class="line"></span><br><span class="line">6.3.2 添加协作人员 150</span><br><span class="line"></span><br><span class="line">6.3.3 管理拉取请求 150</span><br><span class="line"></span><br><span class="line">6.3.4 提醒和通知 155</span><br><span class="line"></span><br><span class="line">6.3.5 特殊文件 158</span><br><span class="line"></span><br><span class="line">6.3.6 项目管理 159</span><br><span class="line"></span><br><span class="line">6.4 组织管理 160</span><br><span class="line"></span><br><span class="line">6.4.1 组织的基本操作 160</span><br><span class="line"></span><br><span class="line">6.4.2 团队 160</span><br><span class="line"></span><br><span class="line">6.4.3 审计日志 162</span><br><span class="line"></span><br><span class="line">6.5 GitHub脚本化 162</span><br><span class="line"></span><br><span class="line">6.5.1 钩子系统 162</span><br><span class="line"></span><br><span class="line">6.5.2 GitHub API 166</span><br><span class="line"></span><br><span class="line">6.6 小结 170</span><br><span class="line"></span><br><span class="line">第7章 Git工具 171</span><br><span class="line"></span><br><span class="line">7.1 选择修订版本 171</span><br><span class="line"></span><br><span class="line">7.1.1 单个修订版本 171</span><br><span class="line"></span><br><span class="line">7.1.2 提交范围 175</span><br><span class="line"></span><br><span class="line">7.2 交互式暂存 177</span><br><span class="line"></span><br><span class="line">7.2.1 暂存和取消暂存文件 178</span><br><span class="line"></span><br><span class="line">7.2.2 暂存补丁 180</span><br><span class="line"></span><br><span class="line">7.3 储藏与清理 181</span><br><span class="line"></span><br><span class="line">7.3.1 储藏工作成果 181</span><br><span class="line"></span><br><span class="line">7.3.2 灵活运用储藏 183</span><br><span class="line"></span><br><span class="line">7.3.3 从储藏中创建分支 184</span><br><span class="line"></span><br><span class="line">7.3.4 清理工作目录 184</span><br><span class="line"></span><br><span class="line">7.4 签署工作 186</span><br><span class="line"></span><br><span class="line">7.4.1 GPG简介 186</span><br><span class="line"></span><br><span class="line">7.4.2 签署标签 186</span><br><span class="line"></span><br><span class="line">7.4.3 验证标签 187</span><br><span class="line"></span><br><span class="line">7.4.4 签署提交 187</span><br><span class="line"></span><br><span class="line">7.4.5 所有人都得签署 189</span><br><span class="line"></span><br><span class="line">7.5 搜索 189</span><br><span class="line"></span><br><span class="line">7.5.1 git grep 189</span><br><span class="line"></span><br><span class="line">7.5.2 Git日志搜索 190</span><br><span class="line"></span><br><span class="line">7.6 重写历史 192</span><br><span class="line"></span><br><span class="line">7.6.1 修改 近一次提交 192</span><br><span class="line"></span><br><span class="line">7.6.2 修改多个提交消息 192</span><br><span class="line"></span><br><span class="line">7.6.3 重排提交 194</span><br><span class="line"></span><br><span class="line">7.6.4 压缩提交 195</span><br><span class="line"></span><br><span class="line">7.6.5 拆分提交 195</span><br><span class="line"></span><br><span class="line">7.6.6 超强命令：filter-branch 196</span><br><span class="line"></span><br><span class="line">7.7 重置揭秘 197</span><br><span class="line"></span><br><span class="line">7.7.1 三棵树 198</span><br><span class="line"></span><br><span class="line">7.7.2 工作流 199</span><br><span class="line"></span><br><span class="line">7.7.3 重置的作用 203</span><br><span class="line"></span><br><span class="line">7.7.4 利用路径进行重置 205</span><br><span class="line"></span><br><span class="line">7.7.5 压缩 207</span><br><span class="line"></span><br><span class="line">7.7.6 检出 209</span><br><span class="line"></span><br><span class="line">7.7.7 小结 210</span><br><span class="line"></span><br><span class="line">7.8 合并的高级用法 211</span><br><span class="line"></span><br><span class="line">7.8.1 合并冲突 211</span><br><span class="line"></span><br><span class="line">7.8.2 撤销合并 220</span><br><span class="line"></span><br><span class="line">7.8.3 其他类型的合并 222</span><br><span class="line"></span><br><span class="line">7.9 rerere 225</span><br><span class="line"></span><br><span class="line">7.10 使用Git调试 230</span><br><span class="line"></span><br><span class="line">7.10.1 文件标注 230</span><br><span class="line"></span><br><span class="line">7.10.2 二分查找 232</span><br><span class="line"></span><br><span class="line">7.11 子模块 233</span><br><span class="line"></span><br><span class="line">7.11.1 开始使用子模块 233</span><br><span class="line"></span><br><span class="line">7.11.2 克隆含有子模块的项目 235</span><br><span class="line"></span><br><span class="line">7.11.3 开发含有子模块的项目 236</span><br><span class="line"></span><br><span class="line">7.11.4 子模块技巧 245</span><br><span class="line"></span><br><span class="line">7.11.5 子模块的问题 246</span><br><span class="line"></span><br><span class="line">7.12 打包 248</span><br><span class="line"></span><br><span class="line">7.13 替换 251</span><br><span class="line"></span><br><span class="line">7.14 凭据存储 257</span><br><span class="line"></span><br><span class="line">7.14.1 底层实现 258</span><br><span class="line"></span><br><span class="line">7.14.2 自定义凭据缓存 259</span><br><span class="line"></span><br><span class="line">7.15 小结 261</span><br><span class="line"></span><br><span class="line">第8章 自定义Git 262</span><br><span class="line"></span><br><span class="line">8.1 配置Git 262</span><br><span class="line"></span><br><span class="line">8.1.1 客户端基本配置 262</span><br><span class="line"></span><br><span class="line">8.1.2 Git中的配色 265</span><br><span class="line"></span><br><span class="line">8.1.3 外部的合并与diff工具 265</span><br><span class="line"></span><br><span class="line">8.1.4 格式化与空白字符 268</span><br><span class="line"></span><br><span class="line">8.1.5 服务器配置 270</span><br><span class="line"></span><br><span class="line">8.2 Git属性 270</span><br><span class="line"></span><br><span class="line">8.2.1 二进制文件 271</span><br><span class="line"></span><br><span class="line">8.2.2 关键字扩展 273</span><br><span class="line"></span><br><span class="line">8.2.3 导出仓库 276</span><br><span class="line"></span><br><span class="line">8.2.4 合并策略 277</span><br><span class="line"></span><br><span class="line">8.3 Git钩子 277</span><br><span class="line"></span><br><span class="line">8.3.1 安装钩子 277</span><br><span class="line"></span><br><span class="line">8.3.2 客户端钩子 278</span><br><span class="line"></span><br><span class="line">8.3.3 服务器端钩子 279</span><br><span class="line"></span><br><span class="line">8.4 Git强制策略示例 280</span><br><span class="line"></span><br><span class="line">8.4.1 服务器端钩子 280</span><br><span class="line"></span><br><span class="line">8.4.2 客户端钩子 285</span><br><span class="line"></span><br><span class="line">8.5 小结 288</span><br><span class="line"></span><br><span class="line">第9章 Git与其他系统 289</span><br><span class="line"></span><br><span class="line">9.1 作为客户端的Git 289</span><br><span class="line"></span><br><span class="line">9.1.1 Git与Subversion 289</span><br><span class="line"></span><br><span class="line">9.1.2 Git与Mercurial 298</span><br><span class="line"></span><br><span class="line">9.1.3 Git与Perforce 305</span><br><span class="line"></span><br><span class="line">9.1.4 Git与TFS 317</span><br><span class="line"></span><br><span class="line">9.2 迁移到Git 325</span><br><span class="line"></span><br><span class="line">9.2.1 Subversion 325</span><br><span class="line"></span><br><span class="line">9.2.2 Mercurial 327</span><br><span class="line"></span><br><span class="line">9.2.3 Perforce 329</span><br><span class="line"></span><br><span class="line">9.2.4 TFS 330</span><br><span class="line"></span><br><span class="line">9.2.5 自定义导入工具 331</span><br><span class="line"></span><br><span class="line">9.3 小结 337</span><br><span class="line"></span><br><span class="line">0章 Git内幕 338</span><br><span class="line"></span><br><span class="line">10.1 底层命令和高层命令 338</span><br><span class="line"></span><br><span class="line">10.2 Git对象 339</span><br><span class="line"></span><br><span class="line">10.2.1 树对象 341</span><br><span class="line"></span><br><span class="line">10.2.2 提交对象 343</span><br><span class="line"></span><br><span class="line">10.2.3 对象存储 345</span><br><span class="line"></span><br><span class="line">10.3 Git引用 346</span><br><span class="line"></span><br><span class="line">10.3.1 HEAD 348</span><br><span class="line"></span><br><span class="line">10.3.2 标签对象 348</span><br><span class="line"></span><br><span class="line">10.3.3 远程引用 349</span><br><span class="line"></span><br><span class="line">10.4 包文件 350</span><br><span class="line"></span><br><span class="line">10.5 引用规格 352</span><br><span class="line"></span><br><span class="line">10.5.1 推送引用规格 354</span><br><span class="line"></span><br><span class="line">10.5.2 删除引用 354</span><br><span class="line"></span><br><span class="line">10.6 传输协议 354</span><br><span class="line"></span><br><span class="line">10.6.1 哑协议 355</span><br><span class="line"></span><br><span class="line">10.6.2 智能协议 356</span><br><span class="line"></span><br><span class="line">10.6.3 协议小结 359</span><br><span class="line"></span><br><span class="line">10.7 维护与数据恢复 359</span><br><span class="line"></span><br><span class="line">10.7.1 维护 359</span><br><span class="line"></span><br><span class="line">10.7.2 数据恢复 360</span><br><span class="line"></span><br><span class="line">10.7.3 移除对象 362</span><br><span class="line"></span><br><span class="line">10.8 环境变量 365</span><br><span class="line"></span><br><span class="line">10.8.1 全局行为 365</span><br><span class="line"></span><br><span class="line">10.8.2 仓库位置 365</span><br><span class="line"></span><br><span class="line">10.8.3 路径规格 366</span><br><span class="line"></span><br><span class="line">10.8.4 提交 366</span><br><span class="line"></span><br><span class="line">10.8.5 网络 366</span><br><span class="line"></span><br><span class="line">10.8.6 差异与合并 367</span><br><span class="line"></span><br><span class="line">10.8.7 调试 367</span><br><span class="line"></span><br><span class="line">10.8.8 杂项 369</span><br><span class="line"></span><br><span class="line">10.9 小结 369</span><br><span class="line"></span><br><span class="line">附录A 其他环境中的Git 370</span><br><span class="line"></span><br><span class="line">附录B 在应用程序中嵌入Git 381</span><br><span class="line"></span><br><span class="line">附录C Git命令 390</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>运营之光2.0 PDF</title>
    <url>/posts/9ec10684/</url>
    <content><![CDATA[<h4 id="《运营之光2-0》"><a href="#《运营之光2-0》" class="headerlink" title="《运营之光2.0》"></a>《运营之光2.0》</h4><h6 id="链接-https-pan-baidu-com-s-1wBNzCUsRUTefkcU1Rk0dbg-密码-jd7b"><a href="#链接-https-pan-baidu-com-s-1wBNzCUsRUTefkcU1Rk0dbg-密码-jd7b" class="headerlink" title="链接: https://pan.baidu.com/s/1wBNzCUsRUTefkcU1Rk0dbg 密码: jd7b"></a>链接: <a href="https://pan.baidu.com/s/1wBNzCUsRUTefkcU1Rk0dbg">https://pan.baidu.com/s/1wBNzCUsRUTefkcU1Rk0dbg</a> 密码: jd7b</h6><p>　　在互联网行业内，“运营”这个职能发展到一定阶段后，往往更需要有成熟的知识体系和工作方法来给予行业从业者以指引。<br><a id="more"></a></p>
<p>　　《运营之光：我的互联网运营方法论与自白 2.0》尤其难得之处在于：它既对“什么是运营”这样的概念认知类问题进行了解读，又带有大量实际的工作技巧、工作思维和工作方法，还包含了很多对于运营的思考、宏观分析和建议，可谓内容完整而全面，同时书中加入了作者亲历的大量真实案例，让全书读起来深入浅出、耐人寻味。</p>
<p>　　《运营之光》面世后，广受好评，入选了 2016 年度豆瓣“十大商业经管类书籍”，评分高达 8.6 分，也得到了大量忠实读者的热烈反馈。2.0 版结合读者们的需求，在面向用户的运营、企业服务类产品的运营、运营与产品之间的关系、运营职能的发展史等几方面进行了约 7 万余字的内容增补。</p>
<p>　　从内容的受众来说，它既有面向初入互联网行业的运营从业者的具体工作方法的讲解和建议，又有适合 3～5 年运营从业者阅读的一些案例解析、思考方法分享，也有适合创业者、互联网公司高管阅读的对一些运营体系搭建、不同类型产品所适合的运营方法等更为宏观的问题的解读。</p>
<p>　　我们希望《运营之光：我的互联网运营方法论与自白 2.0》可以成为面向互联网运营从业者和创业者的一本经典读物，并能够在方法论和案例方面做到持续更新。</p>
<p><img src="/images/63e7e6f6927b69013159c2a1e84065231.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">★专家力荐　&#x2F;11</span><br><span class="line"></span><br><span class="line">★推荐序　&#x2F;16</span><br><span class="line"></span><br><span class="line">★再版序　&#x2F;18</span><br><span class="line"></span><br><span class="line">★自序　&#x2F;20</span><br><span class="line"></span><br><span class="line">★第0章 引言　&#x2F;27</span><br><span class="line"></span><br><span class="line">0.1 为什么我觉得互联网的下一个时代将是运营驱动的时代　&#x2F;28</span><br><span class="line"></span><br><span class="line">.运营行业的现状如何</span><br><span class="line"></span><br><span class="line">.为什么随着互联网的发展运营越来越重要</span><br><span class="line"></span><br><span class="line">.大家对运营的认识发生了哪些改变</span><br><span class="line"></span><br><span class="line">.为什么行业如饥似渴、不惜血本想找的运营很少</span><br><span class="line"></span><br><span class="line">0.2 运营这件事的苦与乐　&#x2F;32</span><br><span class="line"></span><br><span class="line">.为什么运营的薪水较低</span><br><span class="line"></span><br><span class="line">.运营乐趣和“美”何在</span><br><span class="line"></span><br><span class="line">★第1章 运营是什么　&#x2F;37</span><br><span class="line"></span><br><span class="line">1.1 极度不标准的“运营”　&#x2F;38</span><br><span class="line"></span><br><span class="line">.经典的4大运营模块：内容运营、用户运营、活动运营和产品运营</span><br><span class="line"></span><br><span class="line">.特别的互联网运营岗位：新媒体运营、APP商店推广运营、SEO&#x2F;SEM运营、广告投放运营&#x2F;流量运营、淘宝店铺运营、编辑、QQ群&#x2F;小组运营等</span><br><span class="line"></span><br><span class="line">.不同业务类型的产品和公司运营工作内容的差异：工具类、社交&#x2F;社区类、内容类、电商类、平台类、游戏类等</span><br><span class="line"></span><br><span class="line">1.2 一个互联网人，到底该如何理解“运营”这个职能　&#x2F;45</span><br><span class="line"></span><br><span class="line">.为什么在互联网行业中会出现“运营”这样一个职能</span><br><span class="line"></span><br><span class="line">.作为一个运营从业者，到底该怎么定义和理解“运营”这件事</span><br><span class="line"></span><br><span class="line">.一家互联网公司的运营工作流程&amp;全貌是怎样的</span><br><span class="line"></span><br><span class="line">1.3 在互联网公司内，“运营”与“市场”的区别与关联　&#x2F;50</span><br><span class="line"></span><br><span class="line">1.4 如何看待“产品”和“运营”之间的关系　&#x2F;56</span><br><span class="line"></span><br><span class="line">1.5 运营的简史——互联网运营的20年发展与演变　&#x2F;59</span><br><span class="line"></span><br><span class="line">★第2章 运营之“光”　&#x2F;81</span><br><span class="line"></span><br><span class="line">2.1 为何超过80%的运营始终只能打杂　&#x2F;82</span><br><span class="line"></span><br><span class="line">.一个人怎样才能做好运营</span><br><span class="line"></span><br><span class="line">.目标导向意识</span><br><span class="line"></span><br><span class="line">.效率意识</span><br><span class="line"></span><br><span class="line">2.2 身为一个运营，我最大的竞争力和“信仰”　&#x2F;86</span><br><span class="line"></span><br><span class="line">.一个“不靠谱”的众筹：开放的心态</span><br><span class="line"></span><br><span class="line">.运营的两种逻辑：“回报前置”和“回报后置”</span><br><span class="line"></span><br><span class="line">.要做好运营，需要有“信仰”</span><br><span class="line"></span><br><span class="line">2.3“精益”的运营　&#x2F;92</span><br><span class="line"></span><br><span class="line">.两个在复杂的“不确定”环境下做好运营工作的基本理念</span><br><span class="line"></span><br><span class="line">.一些真实的案例</span><br><span class="line"></span><br><span class="line">2.4 运营的“做局”与“破局”　&#x2F;96</span><br><span class="line"></span><br><span class="line">.让自己拥有对于新鲜事物的高度敏感</span><br><span class="line"></span><br><span class="line">.让自己拥有对于用户的洞察</span><br><span class="line"></span><br><span class="line">.学会更具有打动力和说服力的表达</span><br><span class="line"></span><br><span class="line">2.6 我眼中的4个关键性“运营思维”　&#x2F;108</span><br><span class="line"></span><br><span class="line">2.6.1 4个关键性“运营思维”详述　&#x2F;108</span><br><span class="line"></span><br><span class="line">.流程化思维</span><br><span class="line"></span><br><span class="line">.精细化思维</span><br><span class="line"></span><br><span class="line">.杠杆化思维</span><br><span class="line"></span><br><span class="line">.生态化思维</span><br><span class="line"></span><br><span class="line">2.6.2 案例：脉脉“知识裸捐”霸屏营销背后的逻辑与思考　&#x2F;116</span><br><span class="line"></span><br><span class="line">2.7 一个优秀的运营，到底需要多懂“产品”　&#x2F;124</span><br><span class="line"></span><br><span class="line">.懂“产品”到底需要怎么个懂法</span><br><span class="line"></span><br><span class="line">.懂“产品”能给运营工作带来哪些帮助</span><br><span class="line"></span><br><span class="line">★第3章 运营的一些核心技能&amp;工作方法　&#x2F;130</span><br><span class="line"></span><br><span class="line">3.1 如何才能找到“掌控”运营指标的感觉　&#x2F;131</span><br><span class="line"></span><br><span class="line">.如何能够真正对运营指标负责</span><br><span class="line"></span><br><span class="line">.如何才能让事情对自己更加可控</span><br><span class="line"></span><br><span class="line">.拿到一个目标或运营指标后进行思考并最终落地的步骤</span><br><span class="line"></span><br><span class="line">3.2 一个运营必须具备的数据分析方法和意识　&#x2F;137</span><br><span class="line"></span><br><span class="line">.数据对于运营的价值有哪些</span><br><span class="line"></span><br><span class="line">.如何通过数据来界定问题到底出在哪里</span><br><span class="line"></span><br><span class="line">.如何通过数据来评估和具体化最佳达成路径</span><br><span class="line"></span><br><span class="line">.精细的数据分析帮助你深入了解用户</span><br><span class="line"></span><br><span class="line">.数据中可能隐藏着一些线索和彩蛋</span><br><span class="line"></span><br><span class="line">3.3 关于内容的运营　&#x2F;148</span><br><span class="line"></span><br><span class="line">3.3.1 内容的定位、调性和基本原则　&#x2F;149</span><br><span class="line"></span><br><span class="line">3.3.2 UGC型的内容生产生态如何持续　&#x2F;154</span><br><span class="line"></span><br><span class="line">3.3.3 PGC型的内容生产生态如何持续　&#x2F;157</span><br><span class="line"></span><br><span class="line">.如何写出好的、用户爱看爱传播的单篇内容</span><br><span class="line"></span><br><span class="line">.如何长期保证PGC内容体系的供应能力和做好长期内容规划</span><br><span class="line"></span><br><span class="line">3.3.4 如何思考内容的“组织”与“流通”　&#x2F;167</span><br><span class="line"></span><br><span class="line">3.4 转化型文案的常见写作方法　&#x2F;187</span><br><span class="line"></span><br><span class="line">.什么是转化型文案</span><br><span class="line"></span><br><span class="line">.短文案怎么写</span><br><span class="line"></span><br><span class="line">.中长型文案怎么写</span><br><span class="line"></span><br><span class="line">3.5 为何说“标题党”和“段子手”们都很难成为内容领域的顶尖高手　&#x2F;195</span><br><span class="line"></span><br><span class="line">3.6“用户运营”的逻辑、策略与工作方法　&#x2F;203</span><br><span class="line"></span><br><span class="line">3.6.1 为什么会有“用户运营”这个职能存在　&#x2F;204</span><br><span class="line"></span><br><span class="line">3.6.2 面向较大规模用户的整体运营　&#x2F;206</span><br><span class="line"></span><br><span class="line">.针对用户建立优质成长路径</span><br><span class="line"></span><br><span class="line">.针对现有用户进行用户分级，把运营变得更精细化</span><br><span class="line"></span><br><span class="line">.针对用户设计面向用户行为的激励体系</span><br><span class="line"></span><br><span class="line">.将沉默用户转化为活跃用户</span><br><span class="line"></span><br><span class="line">.通过部分用户带动全体用户</span><br><span class="line"></span><br><span class="line">3.6.3 面向较小规模特定用户的针对性运营　&#x2F;217</span><br><span class="line"></span><br><span class="line">.类Geek、发烧友人群，</span><br><span class="line"></span><br><span class="line">.目标领域中的顶尖公司、单位、组织等成员</span><br><span class="line"></span><br><span class="line">.学生党</span><br><span class="line"></span><br><span class="line">.美女</span><br><span class="line"></span><br><span class="line">.在某方面的需求强烈程度异于常人的人</span><br><span class="line"></span><br><span class="line">.中小V</span><br><span class="line"></span><br><span class="line">3.7 关于用户的增长与推广　&#x2F;223</span><br><span class="line"></span><br><span class="line">.依靠内容铺设带来的用户增长</span><br><span class="line"></span><br><span class="line">.依靠第三方渠道推广&amp;广告投放带来的用户增长</span><br><span class="line"></span><br><span class="line">3.8 关于撬动用户互动参与意愿的8个指导原则　&#x2F;226</span><br><span class="line"></span><br><span class="line">3.8.1 8个指导原则详述　&#x2F;226</span><br><span class="line"></span><br><span class="line">.物质激励、概率性事件、营造稀缺感、激发竞争意识、赋予用户某种炫耀、猎奇的可能性、营造强烈情绪&amp;认同感、赋予尊崇感&amp;被重视感、通过对比营造超值感</span><br><span class="line"></span><br><span class="line">3.8.2 懂球帝的教科书级运营案例　&#x2F;233</span><br><span class="line"></span><br><span class="line">3.8.3 简书的“神转折大赛”活动案例　&#x2F;241</span><br><span class="line"></span><br><span class="line">★第4章 运营的一些宏观规律和逻辑　&#x2F;251</span><br><span class="line"></span><br><span class="line">4.1 运营背后的客观规律：从“层次感”到“非线性”　&#x2F;252</span><br><span class="line"></span><br><span class="line">.规律一：带着短视的线性思维投入运营工作中，往往很难做好运营</span><br><span class="line"></span><br><span class="line">.规律二：一款产品在其早期过于关注用户增长，甚至出现“爆红”等现象，往往反而会加速其死亡</span><br><span class="line"></span><br><span class="line">.规律三：早期产品的运营，一定要围绕着“口碑”来进行</span><br><span class="line"></span><br><span class="line">4.2 4种不同阶段的产品及其运营侧重点的差异　&#x2F;257</span><br><span class="line"></span><br><span class="line">.探索期产品</span><br><span class="line"></span><br><span class="line">.快速增长期产品</span><br><span class="line"></span><br><span class="line">.成熟稳定期产品</span><br><span class="line"></span><br><span class="line">.衰退期产品</span><br><span class="line"></span><br><span class="line">4.3 如何结合产品业务类型规划运营路径　&#x2F;262</span><br><span class="line"></span><br><span class="line">.商业逻辑</span><br><span class="line"></span><br><span class="line">.典型用户行为频次</span><br><span class="line"></span><br><span class="line">.用户间是否通过产品结成某种关系</span><br><span class="line"></span><br><span class="line">4.4 如何搭建一款成熟产品的运营体系　&#x2F;271</span><br><span class="line"></span><br><span class="line">.保证基础业务的顺畅运转</span><br><span class="line"></span><br><span class="line">.尽量把产品的“开源”和“节流”变成一些固定动作</span><br><span class="line"></span><br><span class="line">.确保“最关键用户行为”的发生几率</span><br><span class="line"></span><br><span class="line">.核心用户的界定和维系机制的建立</span><br><span class="line"></span><br><span class="line">.阶段性通过活动、事件、营销等实现用户增长</span><br><span class="line"></span><br><span class="line">4.5 理解社区&#x2F;社群的典型运营路径和逻辑　&#x2F;278</span><br><span class="line"></span><br><span class="line">.创建和初始化</span><br><span class="line"></span><br><span class="line">.信任感与价值确立</span><br><span class="line"></span><br><span class="line">.社区的去中心化</span><br><span class="line"></span><br><span class="line">.社区的“自生长”</span><br><span class="line"></span><br><span class="line">4.6 2B类（面向企业提供服务型）产品的运营逻辑与案例　&#x2F;282</span><br><span class="line"></span><br><span class="line">4.6.1 2B类产品的运营逻辑　&#x2F;282</span><br><span class="line"></span><br><span class="line">.B类产品和2C类产品的运营之间存在着什么本质区别</span><br><span class="line"></span><br><span class="line">.一个在2C类产品中如鱼得水的运营不一定适合做2B类产品的运营</span><br><span class="line"></span><br><span class="line">.到底该怎么做好2B类产品的运营</span><br><span class="line"></span><br><span class="line">4.6.2 跟齐俊元聊Teambition的用户增长和运营底层逻辑　&#x2F;289</span><br><span class="line"></span><br><span class="line">★第5章 一个运营的职业发展与成长　&#x2F;299</span><br><span class="line"></span><br><span class="line">5.1 顶尖运营和普通初级运营的区别到底在哪里　&#x2F;300</span><br><span class="line"></span><br><span class="line">.通过内容的运营、创意策划、活动、渠道推广等手段获得产出</span><br><span class="line"></span><br><span class="line">.顶尖的运营对于公关、PR、传播的理解</span><br><span class="line"></span><br><span class="line">.产品有各种不同的形态</span><br><span class="line"></span><br><span class="line">.关于节奏感</span><br><span class="line"></span><br><span class="line">.高级运营应具备梳理框架或体系的能力</span><br><span class="line"></span><br><span class="line">.对于用户群体的影响力和控制力</span><br><span class="line"></span><br><span class="line">5.2 工作三五年后，一个互联网人的未来该在哪里　&#x2F;303</span><br><span class="line"></span><br><span class="line">.建议一：关于如何让自己拥有更多机会和选择</span><br><span class="line"></span><br><span class="line">.建议二：关于如何完成个人能力的提升和进阶</span><br><span class="line"></span><br><span class="line">.建议三：面临各种不同选择时该如何选择</span><br><span class="line"></span><br><span class="line">5.3 运营人的“择业”　&#x2F;310</span><br><span class="line"></span><br><span class="line">.我适合哪类运营岗位</span><br><span class="line"></span><br><span class="line">.我适合哪类产品</span><br><span class="line"></span><br><span class="line">.我要避开哪些坑</span><br><span class="line"></span><br><span class="line">5.4 一个运营的“不可替代性”和“核心竞争力”应该在哪里　&#x2F;318</span><br><span class="line"></span><br><span class="line">.“能够搭建起来一个生态”的能力</span><br><span class="line"></span><br><span class="line">.“懂得如何影响用户”的能力</span><br><span class="line"></span><br><span class="line">.“操盘”感</span><br><span class="line"></span><br><span class="line">5.5 我的8年运营生涯　&#x2F;324</span><br><span class="line"></span><br><span class="line">5.6 互联网运营的能力模型与成长路径　&#x2F;338</span><br><span class="line"></span><br><span class="line">.新人小白</span><br><span class="line"></span><br><span class="line">.入门型&#x2F;成长型运营</span><br><span class="line"></span><br><span class="line">.骨干型运营</span><br><span class="line"></span><br><span class="line">.专家型运营</span><br><span class="line"></span><br><span class="line">.高级专家型运营，综合型人才</span><br><span class="line"></span><br><span class="line">★第6章 一个运营人的自省与思考　&#x2F;346</span><br><span class="line"></span><br><span class="line">6.1 未来十年，互联网行业需要什么样的运营　&#x2F;347</span><br><span class="line"></span><br><span class="line">.需要“能够懂业务”的运营</span><br><span class="line"></span><br><span class="line">.需要有宏观视角，能对产品的成长负责的运营</span><br><span class="line"></span><br><span class="line">.需要“懂产品”的运营</span><br><span class="line"></span><br><span class="line">.需要能够赢得C端用户发自内心喜爱的运营</span><br><span class="line"></span><br><span class="line">6.2 我的运营观和运营“伦理”　&#x2F;352</span><br><span class="line"></span><br><span class="line">.运营一定要有“套路”吗</span><br><span class="line"></span><br><span class="line">.基于“触动”的逻辑来做一名有趣的运营</span><br><span class="line"></span><br><span class="line">6.3 站在运营的立场上，我对互联网行业的一些建议和思考　&#x2F;358</span><br><span class="line"></span><br><span class="line">★尾声 一个运营人眼中的互联网及其未来　&#x2F;364</span><br><span class="line"></span><br><span class="line">★附录 以“流量”为中心的运营时代已经结束了　&#x2F;371</span><br><span class="line"></span><br><span class="line">★后记&amp;致谢　&#x2F;381</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a> </p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em> </p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Redis设计与实现 PDF</title>
    <url>/posts/7c8573e/</url>
    <content><![CDATA[<h4 id="《Redis设计与实现》"><a href="#《Redis设计与实现》" class="headerlink" title="《Redis设计与实现》"></a>《Redis设计与实现》</h4><h6 id="链接-https-pan-baidu-com-s-17GgLaNeqZY7VlCBoiu-ehA-密码-6wtr"><a href="#链接-https-pan-baidu-com-s-17GgLaNeqZY7VlCBoiu-ehA-密码-6wtr" class="headerlink" title="链接: https://pan.baidu.com/s/17GgLaNeqZY7VlCBoiu-ehA 密码: 6wtr"></a>链接: <a href="https://pan.baidu.com/s/17GgLaNeqZY7VlCBoiu-ehA">https://pan.baidu.com/s/17GgLaNeqZY7VlCBoiu-ehA</a> 密码: 6wtr</h6><p>《Redis设计与实现》对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，这些知识可以帮助读者更好、更高效地使用Redis。本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制（replication）、集群（cluster）三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。<br><a id="more"></a></p>
<p><img src="/images/c12a5edde4767d9887914b792e89dfc81.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 引言 1</span><br><span class="line"></span><br><span class="line">1.1 Redis版本说明 1</span><br><span class="line"></span><br><span class="line">1.2 章节编排 1</span><br><span class="line"></span><br><span class="line">1.3 推荐的阅读方法 4</span><br><span class="line"></span><br><span class="line">1.4 行文规则 4</span><br><span class="line"></span><br><span class="line">1.5 配套网站 5</span><br><span class="line"></span><br><span class="line">第一部分·数据结构与对象</span><br><span class="line"></span><br><span class="line">第2章 简单动态字符串 8</span><br><span class="line"></span><br><span class="line">2.1 SDS的定义 9</span><br><span class="line"></span><br><span class="line">2.2 SDS与C字符串的区别 10</span><br><span class="line"></span><br><span class="line">2.3 SDS API 17</span><br><span class="line"></span><br><span class="line">2.4 重点回顾 18</span><br><span class="line"></span><br><span class="line">2.5 参考资料 18</span><br><span class="line"></span><br><span class="line">第3章 链表 19</span><br><span class="line"></span><br><span class="line">3.1 链表和链表节点的实现 20</span><br><span class="line"></span><br><span class="line">3.2 链表和链表节点的API 21</span><br><span class="line"></span><br><span class="line">3.3 重点回顾 22</span><br><span class="line"></span><br><span class="line">第4章 字典 23</span><br><span class="line"></span><br><span class="line">4.1 字典的实现 24</span><br><span class="line"></span><br><span class="line">4.2 哈希算法 27</span><br><span class="line"></span><br><span class="line">4.3 解决键冲突 28</span><br><span class="line"></span><br><span class="line">4.4 rehash 29</span><br><span class="line"></span><br><span class="line">4.5 渐进式rehash 32</span><br><span class="line"></span><br><span class="line">4.6 字典API 36</span><br><span class="line"></span><br><span class="line">4.7 重点回顾 37</span><br><span class="line"></span><br><span class="line">第5章 跳跃表 38</span><br><span class="line"></span><br><span class="line">5.1 跳跃表的实现 39</span><br><span class="line"></span><br><span class="line">5.2 跳跃表API 44</span><br><span class="line"></span><br><span class="line">5.3 重点回顾 45</span><br><span class="line"></span><br><span class="line">第6章 整数集合 46</span><br><span class="line"></span><br><span class="line">6.1 整数集合的实现 46</span><br><span class="line"></span><br><span class="line">6.2 升级 48</span><br><span class="line"></span><br><span class="line">6.3 升级的好处 50</span><br><span class="line"></span><br><span class="line">6.4 降级 51</span><br><span class="line"></span><br><span class="line">6.5 整数集合API 51</span><br><span class="line"></span><br><span class="line">6.6 重点回顾 51</span><br><span class="line"></span><br><span class="line">第7章 压缩列表 52</span><br><span class="line"></span><br><span class="line">7.1 压缩列表的构成 52</span><br><span class="line"></span><br><span class="line">7.2 压缩列表节点的构成 54</span><br><span class="line"></span><br><span class="line">7.3 连锁更新 57</span><br><span class="line"></span><br><span class="line">7.4 压缩列表API 59</span><br><span class="line"></span><br><span class="line">7.5 重点回顾 59</span><br><span class="line"></span><br><span class="line">第8章 对象 60</span><br><span class="line"></span><br><span class="line">8.1 对象的类型与编码 60</span><br><span class="line"></span><br><span class="line">8.2 字符串对象 64</span><br><span class="line"></span><br><span class="line">8.3 列表对象 68</span><br><span class="line"></span><br><span class="line">8.4 哈希对象 71</span><br><span class="line"></span><br><span class="line">8.5 集合对象 75</span><br><span class="line"></span><br><span class="line">8.6 有序集合对象 77</span><br><span class="line"></span><br><span class="line">8.7 类型检查与命令多态 81</span><br><span class="line"></span><br><span class="line">8.8 内存回收 84</span><br><span class="line"></span><br><span class="line">8.9 对象共享 85</span><br><span class="line"></span><br><span class="line">8.10 对象的空转时长 87</span><br><span class="line"></span><br><span class="line">8.11 重点回顾 88</span><br><span class="line"></span><br><span class="line">第二部分·单机数据库的实现</span><br><span class="line"></span><br><span class="line">第9章 数据库 90</span><br><span class="line"></span><br><span class="line">9.1 服务器中的数据库 90</span><br><span class="line"></span><br><span class="line">9.2 切换数据库 91</span><br><span class="line"></span><br><span class="line">9.3 数据库键空间 93</span><br><span class="line"></span><br><span class="line">9.4 设置键的生存时间或过期时间 99</span><br><span class="line"></span><br><span class="line">9.5 过期键删除策略 107</span><br><span class="line"></span><br><span class="line">9.6 Redis的过期键删除策略 108</span><br><span class="line"></span><br><span class="line">9.7 AOF、RDB和复制功能对过期键的处理 111</span><br><span class="line"></span><br><span class="line">9.8 数据库通知 113</span><br><span class="line"></span><br><span class="line">9.9 重点回顾 117</span><br><span class="line"></span><br><span class="line">第10章 RDB持久化 118</span><br><span class="line"></span><br><span class="line">10.1 RDB 文件的创建与载入 119</span><br><span class="line"></span><br><span class="line">10.2 自动间隔性保存 121</span><br><span class="line"></span><br><span class="line">10.3 RDB 文件结构 125</span><br><span class="line"></span><br><span class="line">10.4 分析RDB文件 133</span><br><span class="line"></span><br><span class="line">10.5 重点回顾 137</span><br><span class="line"></span><br><span class="line">10.6 参考资料 137</span><br><span class="line"></span><br><span class="line">第11章 AOF持久化 138</span><br><span class="line"></span><br><span class="line">11.1 AOF持久化的实现 139</span><br><span class="line"></span><br><span class="line">11.2 AOF文件的载入与数据还原 142</span><br><span class="line"></span><br><span class="line">11.3 AOF重写 143</span><br><span class="line"></span><br><span class="line">11.4 重点回顾 150</span><br><span class="line"></span><br><span class="line">第12章 事件 151</span><br><span class="line"></span><br><span class="line">12.1 文件事件 151</span><br><span class="line"></span><br><span class="line">12.2 时间事件 156</span><br><span class="line"></span><br><span class="line">12.3 事件的调度与执行 159</span><br><span class="line"></span><br><span class="line">12.4 重点回顾 161</span><br><span class="line"></span><br><span class="line">12.5 参考资料 161</span><br><span class="line"></span><br><span class="line">第13章 客户端 162</span><br><span class="line"></span><br><span class="line">13.1 客户端属性 163</span><br><span class="line"></span><br><span class="line">13.2 客户端的创建与关闭 172</span><br><span class="line"></span><br><span class="line">13.3 重点回顾 174</span><br><span class="line"></span><br><span class="line">第14章 服务器 176</span><br><span class="line"></span><br><span class="line">14.1 命令请求的执行过程 176</span><br><span class="line"></span><br><span class="line">14.2 serverCron函数 184</span><br><span class="line"></span><br><span class="line">14.3 初始化服务器 192</span><br><span class="line"></span><br><span class="line">14.4 重点回顾 196</span><br><span class="line"></span><br><span class="line">第三部分·多机数据库的实现</span><br><span class="line"></span><br><span class="line">第15章 复制 198</span><br><span class="line"></span><br><span class="line">15.1 旧版复制功能的实现 199</span><br><span class="line"></span><br><span class="line">15.2 旧版复制功能的缺陷 201</span><br><span class="line"></span><br><span class="line">15.3 新版复制功能的实现 203</span><br><span class="line"></span><br><span class="line">15.4 部分重同步的实现 204</span><br><span class="line"></span><br><span class="line">15.5 PSYNC 命令的实现 209</span><br><span class="line"></span><br><span class="line">15.6 复制的实现 211</span><br><span class="line"></span><br><span class="line">15.7 心跳检测 216</span><br><span class="line"></span><br><span class="line">15.8 重点回顾 218</span><br><span class="line"></span><br><span class="line">第16章 Sentinel 219</span><br><span class="line"></span><br><span class="line">16.1 启动并初始化Sentinel 220</span><br><span class="line"></span><br><span class="line">16.2 获取主服务器信息 227</span><br><span class="line"></span><br><span class="line">16.3 获取从服务器信息 229</span><br><span class="line"></span><br><span class="line">16.4 向主服务器和从服务器发送信息 230</span><br><span class="line"></span><br><span class="line">16.5 接收来自主服务器和从服务器的频道信息 231</span><br><span class="line"></span><br><span class="line">16.6 检测主观下线状态 234</span><br><span class="line"></span><br><span class="line">16.7 检查客观下线状态 236</span><br><span class="line"></span><br><span class="line">16.8 选举领头Sentinel 238</span><br><span class="line"></span><br><span class="line">16.9 故障转移 240</span><br><span class="line"></span><br><span class="line">16.10 重点回顾 243</span><br><span class="line"></span><br><span class="line">16.11 参考资料 244</span><br><span class="line"></span><br><span class="line">第17章 集群 245</span><br><span class="line"></span><br><span class="line">17.1 节点 245</span><br><span class="line"></span><br><span class="line">17.2 槽指派 251</span><br><span class="line"></span><br><span class="line">17.3 在集群中执行命令 258</span><br><span class="line"></span><br><span class="line">17.4 重新分片 265</span><br><span class="line"></span><br><span class="line">17.5 ASK错误 267</span><br><span class="line"></span><br><span class="line">17.6 复制与故障转移 273</span><br><span class="line"></span><br><span class="line">17.7 消息 281</span><br><span class="line"></span><br><span class="line">17.8 重点回顾 288</span><br><span class="line"></span><br><span class="line">第四部分·独立功能的实现</span><br><span class="line"></span><br><span class="line">第18章 发布与订阅 290</span><br><span class="line"></span><br><span class="line">18.1 频道的订阅与退订 292</span><br><span class="line"></span><br><span class="line">18.2 模式的订阅与退订 295</span><br><span class="line"></span><br><span class="line">18.3 发送消息 298</span><br><span class="line"></span><br><span class="line">18.4 查看订阅信息 300</span><br><span class="line"></span><br><span class="line">18.5 重点回顾 303</span><br><span class="line"></span><br><span class="line">18.6 参考资料 304</span><br><span class="line"></span><br><span class="line">第19章 事务 305</span><br><span class="line"></span><br><span class="line">19.1 事务的实现 306</span><br><span class="line"></span><br><span class="line">19.2 WATCH 命令的实现 310</span><br><span class="line"></span><br><span class="line">19.3 事务的ACID 性质 314</span><br><span class="line"></span><br><span class="line">19.4 重点回顾 319</span><br><span class="line"></span><br><span class="line">19.5 参考资料 320</span><br><span class="line"></span><br><span class="line">第20章 Lua脚本 321</span><br><span class="line"></span><br><span class="line">20.1 创建并修改Lua 环境 322</span><br><span class="line"></span><br><span class="line">20.2 Lua 环境协作组件 327</span><br><span class="line"></span><br><span class="line">20.3 EVAL命令的实现 329</span><br><span class="line"></span><br><span class="line">20.4 EVALSHA 命令的实现 332</span><br><span class="line"></span><br><span class="line">20.5 脚本管理命令的实现 333</span><br><span class="line"></span><br><span class="line">20.6 脚本复制 336</span><br><span class="line"></span><br><span class="line">20.7 重点回顾 342</span><br><span class="line"></span><br><span class="line">20.8 参考资料 343</span><br><span class="line"></span><br><span class="line">第21章 排序 344</span><br><span class="line"></span><br><span class="line">21.1 SORT 命令的实现 345</span><br><span class="line"></span><br><span class="line">21.2 ALPHA 选项的实现 347</span><br><span class="line"></span><br><span class="line">21.3 ASC 选项和DESC 选项的实现 348</span><br><span class="line"></span><br><span class="line">21.4 BY选项的实现 350</span><br><span class="line"></span><br><span class="line">21.5 带有ALPHA 选项的BY 选项的实现 352</span><br><span class="line"></span><br><span class="line">21.6 LIMIT 选项的实现 353</span><br><span class="line"></span><br><span class="line">21.7 GET选项的实现 355</span><br><span class="line"></span><br><span class="line">21.8 STORE 选项的实现 358</span><br><span class="line"></span><br><span class="line">21.9 多个选项的执行顺序 359</span><br><span class="line"></span><br><span class="line">21.10 重点回顾 361</span><br><span class="line"></span><br><span class="line">第22章 二进制位数组 362</span><br><span class="line"></span><br><span class="line">22.1 位数组的表示 363</span><br><span class="line"></span><br><span class="line">22.2 GETBIT命令的实现 365</span><br><span class="line"></span><br><span class="line">22.3 SETBIT 命令的实现 366</span><br><span class="line"></span><br><span class="line">22.4 BITCOUNT 命令的实现 369</span><br><span class="line"></span><br><span class="line">22.5 BITOP 命令的实现 376</span><br><span class="line"></span><br><span class="line">22.6 重点回顾 377</span><br><span class="line"></span><br><span class="line">22.7 参考资料 377</span><br><span class="line"></span><br><span class="line">第23章 慢查询日志 378</span><br><span class="line"></span><br><span class="line">23.1 慢查询记录的保存 380</span><br><span class="line"></span><br><span class="line">23.2 慢查询日志的阅览和删除 382</span><br><span class="line"></span><br><span class="line">23.3 添加新日志 383</span><br><span class="line"></span><br><span class="line">23.4 重点回顾 385</span><br><span class="line"></span><br><span class="line">第24章 监视器 386</span><br><span class="line"></span><br><span class="line">24.1 成为监视器 387</span><br><span class="line"></span><br><span class="line">24.2 向监视器发送命令信息 387</span><br><span class="line"></span><br><span class="line">24.3 重点回顾 388</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Web数据挖掘 PDF</title>
    <url>/posts/eeabf20b/</url>
    <content><![CDATA[<h4 id="《Web数据挖掘》"><a href="#《Web数据挖掘》" class="headerlink" title="《Web数据挖掘》"></a>《Web数据挖掘》</h4><h6 id="链接-https-pan-baidu-com-s-1gXNWqo1v4vZWN9wZPa4svw-提取码-tmy4"><a href="#链接-https-pan-baidu-com-s-1gXNWqo1v4vZWN9wZPa4svw-提取码-tmy4" class="headerlink" title="链接: https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw 提取码: tmy4"></a>链接: <a href="https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw">https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw</a> 提取码: tmy4</h6><p>过去几十年里，Web的迅速发展使其成为世界上规模的公共数据源。Web挖掘的目标是从Web超链接、网页内容和使用日志中探寻有用的信息。<br><a id="more"></a></p>
<p>　　《世界计算机教材精选：Web数据挖掘（第2版）》旨在阐述Web数据挖掘的概念及其核心算法，使读者获得相对完整的关于Web数据挖掘的算法和技术知识。本书不仅介绍了搜索、页面爬取和资源探索以及链接分析等传统的Web挖掘主题，而且还介绍了结构化数据的抽取、信息整合、观点挖掘和Web使用挖掘等内容，这些内容在已有书籍中没有提及过，但它们在Web数据挖掘中却占有非常重要的地位。全书分为两大部分：部分包括第2章到第5章，介绍数据挖掘的基础，第二部分包括第6章到2章，介绍Web相关的挖掘任务。从本书自版出版之后，很多领域已经有了重大的进展。新版大部分的章节都已经添加了新的材料来反应这些进展，主要的改动在1章和2章中，这两章已经被重新撰写并做了重要的扩展。</p>
<p>　　《世界计算机教材精选：Web数据挖掘（第2版）》不仅可作为本科生的教科书，也是在Web数据挖掘和相关领域研读博士学位的研究生的重要参考用书，同时对Web挖掘研究人员和实践人员获取知识、信息、甚至是创新想法也很有帮助。</p>
<p><img src="/images/5cc037c8083d2e572e321fb35c4f5b541.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">章 概述</span><br><span class="line"></span><br><span class="line">1.1 什么是万维网</span><br><span class="line"></span><br><span class="line">1.2 万维网和互联网的历史简述</span><br><span class="line"></span><br><span class="line">1.3 Web数据挖掘</span><br><span class="line"></span><br><span class="line">1.3.1 什么是数据挖掘</span><br><span class="line"></span><br><span class="line">1.3.2 什么是Web数据挖掘</span><br><span class="line"></span><br><span class="line">1.4 各章概要</span><br><span class="line"></span><br><span class="line">1.5 如何阅读本书</span><br><span class="line"></span><br><span class="line">文献评注</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">部分 数据挖掘基础</span><br><span class="line"></span><br><span class="line">第2章 关联规则和序列模式</span><br><span class="line"></span><br><span class="line">2.1 关联规则的基本概念</span><br><span class="line"></span><br><span class="line">2.2 Apriori算法</span><br><span class="line"></span><br><span class="line">2.2.1 频繁项目集生成</span><br><span class="line"></span><br><span class="line">2.2.2 关联规则生成</span><br><span class="line"></span><br><span class="line">2.3 关联规则挖掘的数据格式</span><br><span class="line"></span><br><span class="line">2.4 多小支持度的关联规则挖掘</span><br><span class="line"></span><br><span class="line">2.4.1 扩展模型</span><br><span class="line"></span><br><span class="line">2.4.2 挖掘算法</span><br><span class="line"></span><br><span class="line">2.4.3 规则生成</span><br><span class="line"></span><br><span class="line">2.5 分类关联规则挖掘</span><br><span class="line"></span><br><span class="line">2.5.1 问题描述</span><br><span class="line"></span><br><span class="line">2.5.2 挖掘算法</span><br><span class="line"></span><br><span class="line">2.5.3 多小支持度分类关联规则挖掘</span><br><span class="line"></span><br><span class="line">2.6 序列模式的基本概念</span><br><span class="line"></span><br><span class="line">2.7 基于GSP挖掘序列模式</span><br><span class="line"></span><br><span class="line">2.7.1 GSP算法</span><br><span class="line"></span><br><span class="line">2.7.2 多小支持度挖掘</span><br><span class="line"></span><br><span class="line">2.8 基于PrefixSpan算法的序列模式挖掘</span><br><span class="line"></span><br><span class="line">2.8.1 PrefixSpan算法</span><br><span class="line"></span><br><span class="line">2.8.2 多小支持度挖掘</span><br><span class="line"></span><br><span class="line">2.9 从序列模式中产生规则</span><br><span class="line"></span><br><span class="line">2.9.1 序列规则</span><br><span class="line"></span><br><span class="line">2.9.2 标签序列规则</span><br><span class="line"></span><br><span class="line">2.9.3 分类序列规则</span><br><span class="line"></span><br><span class="line">文献评注</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第3章 监督学习</span><br><span class="line"></span><br><span class="line">3.1 基本概念</span><br><span class="line"></span><br><span class="line">3.2 决策树归纳</span><br><span class="line"></span><br><span class="line">3.2.1 学习算法</span><br><span class="line"></span><br><span class="line">3.2.2 混杂度函数</span><br><span class="line"></span><br><span class="line">3.2.3 处理连续属性</span><br><span class="line"></span><br><span class="line">3.2.4 其他一些问题</span><br><span class="line"></span><br><span class="line">3.3 评估分类器</span><br><span class="line"></span><br><span class="line">3.3.1 评估方法</span><br><span class="line"></span><br><span class="line">3.3.2 查准率、查全率、F-score和平衡点（BreakevePoint）</span><br><span class="line"></span><br><span class="line">3.3.3 受试者工作特征曲线</span><br><span class="line"></span><br><span class="line">3.3.4 提升曲线</span><br><span class="line"></span><br><span class="line">3.4 规则归纳</span><br><span class="line"></span><br><span class="line">3.4.1 顺序化覆盖</span><br><span class="line"></span><br><span class="line">3.4.2 规则学习：Learn-One-Rule函数</span><br><span class="line"></span><br><span class="line">3.4.3 讨论</span><br><span class="line"></span><br><span class="line">3.5 基于关联规则的分类</span><br><span class="line"></span><br><span class="line">3.5.1 使用类关联规则进行分类</span><br><span class="line"></span><br><span class="line">3.5.2 使用类关联规则作为分类属性</span><br><span class="line"></span><br><span class="line">3.5.3 使用古典的关联规则分类</span><br><span class="line"></span><br><span class="line">3.6 朴素贝叶斯分类</span><br><span class="line"></span><br><span class="line">3.7 朴素贝叶斯文本分类</span><br><span class="line"></span><br><span class="line">3.7.1 概率框架</span><br><span class="line"></span><br><span class="line">3.7.2 朴素贝叶斯模型</span><br><span class="line"></span><br><span class="line">3.7.3 讨论</span><br><span class="line"></span><br><span class="line">3.8 支持向量机</span><br><span class="line"></span><br><span class="line">3.8.1 线性支持向量机：可分的情况</span><br><span class="line"></span><br><span class="line">3.8.2 线性支持向量机：数据不可分的情况</span><br><span class="line"></span><br><span class="line">3.8.3 非线性支持向量机：核方法总结</span><br><span class="line"></span><br><span class="line">3.9 A、近邻学习</span><br><span class="line"></span><br><span class="line">3.10 分类器的集成</span><br><span class="line"></span><br><span class="line">3.10.1 Bagging</span><br><span class="line"></span><br><span class="line">3.10.2 Boosting</span><br><span class="line"></span><br><span class="line">文献评注</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第4章 无监督学习</span><br><span class="line"></span><br><span class="line">4.1 基本概念</span><br><span class="line"></span><br><span class="line">4.2 A-均值聚类</span><br><span class="line"></span><br><span class="line">4.2.1 A-均值算法</span><br><span class="line"></span><br><span class="line">4.2.2 A-均值算法的硬盘版本</span><br><span class="line"></span><br><span class="line">4.2.3 优势和劣势</span><br><span class="line"></span><br><span class="line">4.3 聚类的表示</span><br><span class="line"></span><br><span class="line">4.3.1 聚类的一般表示方法</span><br><span class="line"></span><br><span class="line">4.3.2 任意形状的聚类</span><br><span class="line"></span><br><span class="line">4.4 层次聚类</span><br><span class="line"></span><br><span class="line">4.4.1 单连结方法</span><br><span class="line"></span><br><span class="line">4.4.2 全连结方法</span><br><span class="line"></span><br><span class="line">4.4.3 平均连结方法</span><br><span class="line"></span><br><span class="line">4.4.4 优势和劣势</span><br><span class="line"></span><br><span class="line">4.5 距离函数</span><br><span class="line"></span><br><span class="line">4.5.1 数字属性</span><br><span class="line"></span><br><span class="line">4.5.2 布尔属性和名词性属性</span><br><span class="line"></span><br><span class="line">4.5.3 文本文档</span><br><span class="line"></span><br><span class="line">4.6 数据标准化</span><br><span class="line"></span><br><span class="line">4.7 混合属性的处理</span><br><span class="line"></span><br><span class="line">4.8 采用哪种聚类算法</span><br><span class="line"></span><br><span class="line">4.9 聚类的评估</span><br><span class="line"></span><br><span class="line">4.10 发现数据区域和数据空洞</span><br><span class="line"></span><br><span class="line">文献评注</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第5章 部分监督学习</span><br><span class="line"></span><br><span class="line">5.1 从已标注数据和无标注数据中学习</span><br><span class="line"></span><br><span class="line">5.1.1 使用朴素贝叶斯分类器的EM算法</span><br><span class="line"></span><br><span class="line">5.1.2 Co-naining</span><br><span class="line"></span><br><span class="line">5.1.3 自学习</span><br><span class="line"></span><br><span class="line">5.1.4 直推式支持向量机</span><br><span class="line"></span><br><span class="line">5.1.5 基于图的方法</span><br><span class="line"></span><br><span class="line">5.1.6 讨论</span><br><span class="line"></span><br><span class="line">5.2 从正例和无标注数据中学习</span><br><span class="line"></span><br><span class="line">5.2.1 PU学习的应用</span><br><span class="line"></span><br><span class="line">5.2.2 理论基础</span><br><span class="line"></span><br><span class="line">5.2.3 建立分类器：两步方法</span><br><span class="line"></span><br><span class="line">5.2.4 建立分类器：偏置SVM</span><br><span class="line"></span><br><span class="line">5.2.5 建立分类器：概率估计</span><br><span class="line"></span><br><span class="line">5.2.6 讨论</span><br><span class="line"></span><br><span class="line">第2部分 Web挖掘</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>TensorFlow实践与智能系统 PDF</title>
    <url>/posts/a59327/</url>
    <content><![CDATA[<h4 id="《TensorFlow实践与智能系统》"><a href="#《TensorFlow实践与智能系统》" class="headerlink" title="《TensorFlow实践与智能系统》"></a>《TensorFlow实践与智能系统》</h4><h6 id="链接-https-pan-baidu-com-s-1EccZH2ZtJoC5ujb-7hgRdg-提取码-9iq7"><a href="#链接-https-pan-baidu-com-s-1EccZH2ZtJoC5ujb-7hgRdg-提取码-9iq7" class="headerlink" title="链接: https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg 提取码: 9iq7"></a>链接: <a href="https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg">https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg</a> 提取码: 9iq7</h6><p>山姆·亚伯拉罕、丹尼亚尔·哈夫纳、埃里克· 厄威特、阿里尔·斯卡尔皮内里著的《面向机器智能 的TensorFlow实践》是一本 的TensorFlow入门 指南。几位作者都来自研发一线，他们用自己的宝贵 经验，结合众多高质量的代码，生动讲解TensorFlow 的底层原理，并从实践角度介绍如何将两种常见模型 ——深度卷积网络、循环神经网络应用到图像理解和 自然语言处理的典型任务中。此外，还介绍了在模型 部署和编程中可用的诸多实用技巧。<br><a id="more"></a></p>
<pre><code> 全书分为四部分，共9章。 部分（ ～2章 ）讨论TensorFlow的设计模式以及选择TensorFlow 作为深度学习库的优势和面临的挑战，并给出详细的 安装指南。第二部分（第3～4章）深入介绍 TensorFlow API的基础知识和机器学习基础。第三部 分（第5～6章）探讨如何用TensorFlow实现 深度 模型，涉及卷积神经网络（或CNN）模型和循环神经 网络（或RNN）模型。第四部分（第7～8章）探讨 TensorFlow API中 新推出的特性，包括如何准备用 于部署的模型、一些有用的编程模式等。第9章给出 一些进一步了解TensorFlow的学习资源。
</code></pre><p><img src="/images/b8cb983fdbc4b51cc061c58a06b59ac51.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">部分　开启TensorFlow之旅</span><br><span class="line"></span><br><span class="line">第1章　引言</span><br><span class="line"></span><br><span class="line">1.1　无处不在的数据</span><br><span class="line"></span><br><span class="line">1.2　深度学习</span><br><span class="line"></span><br><span class="line">1.3　TensorFlow：一个现代的机器学习库</span><br><span class="line"></span><br><span class="line">1.4　TensorFlow：技术概要</span><br><span class="line"></span><br><span class="line">1.5　何为TensorFlow</span><br><span class="line"></span><br><span class="line">1.5.1　解读来自官网的单句描述</span><br><span class="line"></span><br><span class="line">1.5.2　单句描述未体现的内容</span><br><span class="line"></span><br><span class="line">1.6　何时使用TensorFlow</span><br><span class="line"></span><br><span class="line">1.7　TensorFlow的优势</span><br><span class="line"></span><br><span class="line">1.8　使用TensorFlow所面临的挑战</span><br><span class="line"></span><br><span class="line">1.9　高歌猛进</span><br><span class="line"></span><br><span class="line">第2章　安装TensorFlow</span><br><span class="line"></span><br><span class="line">2.1　选择安装环境</span><br><span class="line"></span><br><span class="line">2.2　Jupyter Notebook与matplotlib</span><br><span class="line"></span><br><span class="line">2.3　创建Virtualenv环境</span><br><span class="line"></span><br><span class="line">2.4　TensorFlow的简易安装</span><br><span class="line"></span><br><span class="line">2.5　源码构建及安装实例：在64位Ubuntu Linux上安装GPU版TensorFlow</span><br><span class="line"></span><br><span class="line">2.5.1　安装依赖库</span><br><span class="line"></span><br><span class="line">2.5.2　安装Bazel</span><br><span class="line"></span><br><span class="line">2.5.3　安装CUDA软件（ NVIDIA GPU）</span><br><span class="line"></span><br><span class="line">2.5.4　从源码构建和安装TensorFlow</span><br><span class="line"></span><br><span class="line">2.6　安装Jupyter Notebook</span><br><span class="line"></span><br><span class="line">2.7　安装matplotlib</span><br><span class="line"></span><br><span class="line">2.8　测试TensorFlow、Jupyter Notebook及matplotlib</span><br><span class="line"></span><br><span class="line">2.9　本章小结</span><br><span class="line"></span><br><span class="line">第二部分　TensorFlow与机器学习基础</span><br><span class="line"></span><br><span class="line">第3章　TensorFlow基础</span><br><span class="line"></span><br><span class="line">3.1　数据流图简介</span><br><span class="line"></span><br><span class="line">3.1.1　数据流图基础</span><br><span class="line"></span><br><span class="line">3.1.2　节点的依赖关系</span><br><span class="line"></span><br><span class="line">3.2　在TensorFlow中定义数据流图</span><br><span class="line"></span><br><span class="line">3.2.1　构建 个TensorFlow数据流图</span><br><span class="line"></span><br><span class="line">3.2.2　张量思维</span><br><span class="line"></span><br><span class="line">3.2.3　张量的形状</span><br><span class="line"></span><br><span class="line">3.2.4　TensorFlow的Operation</span><br><span class="line"></span><br><span class="line">3.2.5　TensorFlow的Graph对象</span><br><span class="line"></span><br><span class="line">3.2.6　TensorFlow Session</span><br><span class="line"></span><br><span class="line">3.2.7　利用占位节点添加输入</span><br><span class="line"></span><br><span class="line">3.2.8　Variable对象</span><br><span class="line"></span><br><span class="line">3.3　通过名称作用域组织数据流图</span><br><span class="line"></span><br><span class="line">3.4　练习：综合运用各种组件</span><br><span class="line"></span><br><span class="line">3.4.1　构建数据流图</span><br><span class="line"></span><br><span class="line">3.4.2　运行数据流图</span><br><span class="line"></span><br><span class="line">3.5　本章小结</span><br><span class="line"></span><br><span class="line">第4章　机器学习基础</span><br><span class="line"></span><br><span class="line">4.1　有监督学习简介</span><br><span class="line"></span><br><span class="line">4.2　保存训练检查点</span><br><span class="line"></span><br><span class="line">4.3　线性回归</span><br><span class="line"></span><br><span class="line">4.4　对数几率回归</span><br><span class="line"></span><br><span class="line">4.5　softmax分类</span><br><span class="line"></span><br><span class="line">4.6　多层神经网络</span><br><span class="line"></span><br><span class="line">4.7　梯度下降法与误差反向传播算法</span><br><span class="line"></span><br><span class="line">第三部分　用TensorFlow实现 的深度模型</span><br><span class="line"></span><br><span class="line">第5章　目标识别与分类</span><br><span class="line"></span><br><span class="line">5.1　卷积神经网络</span><br><span class="line"></span><br><span class="line">5.2　卷积</span><br><span class="line"></span><br><span class="line">5.2.1　输入和卷积核</span><br><span class="line"></span><br><span class="line">5.2.2　跨度</span><br><span class="line"></span><br><span class="line">5.2.3　边界填充</span><br><span class="line"></span><br><span class="line">5.2.4　数据格式</span><br><span class="line"></span><br><span class="line">5.2.5　深入探讨卷积核</span><br><span class="line"></span><br><span class="line">5.3　常见层</span><br><span class="line"></span><br><span class="line">5.3.1　卷积层</span><br><span class="line"></span><br><span class="line">5.3.2　激活函数</span><br><span class="line"></span><br><span class="line">5.3.3　池化层</span><br><span class="line"></span><br><span class="line">5.3.4　归一化</span><br><span class="line"></span><br><span class="line">5.3.5　 层</span><br><span class="line"></span><br><span class="line">5.4　图像与TensorFlow</span><br><span class="line"></span><br><span class="line">5.4.1　加载图像</span><br><span class="line"></span><br><span class="line">5.4.2　图像格式</span><br><span class="line"></span><br><span class="line">5.4.3　图像操作</span><br><span class="line"></span><br><span class="line">5.4.4　颜色</span><br><span class="line"></span><br><span class="line">5.5　CNN的实现</span><br><span class="line"></span><br><span class="line">5.5.1　Stanford Dogs数据集</span><br><span class="line"></span><br><span class="line">5.5.2　将图像转为TFRecord文件</span><br><span class="line"></span><br><span class="line">5.5.3　加载图像</span><br><span class="line"></span><br><span class="line">5.5.4　模型</span><br><span class="line"></span><br><span class="line">5.5.5　训练</span><br><span class="line"></span><br><span class="line">5.5.6　用TensorBoard调试滤波器</span><br><span class="line"></span><br><span class="line">5.6　本章小结</span><br><span class="line"></span><br><span class="line">第6章　循环神经网络与自然语言处理</span><br><span class="line"></span><br><span class="line">6.1　循环神经网络简介</span><br><span class="line"></span><br><span class="line">6.1.1　时序的世界</span><br><span class="line"></span><br><span class="line">6.1.2　近似任意程序</span><br><span class="line"></span><br><span class="line">6.1.3　随时间反向传播</span><br><span class="line"></span><br><span class="line">6.1.4　序列的编码和解码</span><br><span class="line"></span><br><span class="line">6.1.5　实现 个循环神经网络</span><br><span class="line"></span><br><span class="line">6.1.6　梯度消失与梯度</span><br><span class="line"></span><br><span class="line">6.1.7　长短时记忆网络</span><br><span class="line"></span><br><span class="line">6.1.8　RNN结构的变种</span><br><span class="line"></span><br><span class="line">6.2　词向量嵌入</span><br><span class="line"></span><br><span class="line">6.2.1　准备维基百科语料库</span><br><span class="line"></span><br><span class="line">6.2.2　模型结构</span><br><span class="line"></span><br><span class="line">6.2.3　噪声对比分类器</span><br><span class="line"></span><br><span class="line">6.2.4　训练模型</span><br><span class="line"></span><br><span class="line">6.3　序列分类</span><br><span class="line"></span><br><span class="line">6.3.1　Imdb影评数据集</span><br><span class="line"></span><br><span class="line">6.3.2　使用词向量嵌入</span><br><span class="line"></span><br><span class="line">6.3.3　序列标注模型</span><br><span class="line"></span><br><span class="line">6.3.4　来自 后相关活性值的softmax层</span><br><span class="line"></span><br><span class="line">6.3.5　梯度裁剪</span><br><span class="line"></span><br><span class="line">6.3.6　训练模型</span><br><span class="line"></span><br><span class="line">6.4　序列标注</span><br><span class="line"></span><br><span class="line">6.4.1　OCR数据集</span><br><span class="line"></span><br><span class="line">6.4.2　时间步之间共享的soft-max层</span><br><span class="line"></span><br><span class="line">6.4.3　训练模型</span><br><span class="line"></span><br><span class="line">6.4.4　双向RNN</span><br><span class="line"></span><br><span class="line">6.5　预测编码</span><br><span class="line"></span><br><span class="line">6.5.1　字符级语言建模</span><br><span class="line"></span><br><span class="line">6.5.2　ArXiv摘要API</span><br><span class="line"></span><br><span class="line">6.5.3　数据预处理</span><br><span class="line"></span><br><span class="line">6.5.4　预测编码模型</span><br><span class="line"></span><br><span class="line">6.5.5　训练模型</span><br><span class="line"></span><br><span class="line">6.5.6　生成相似序列</span><br><span class="line"></span><br><span class="line">6.6　本章小结</span><br><span class="line"></span><br><span class="line">第四部分　其他提示、技术与特性</span><br><span class="line"></span><br><span class="line">第7章　产品环境中模型的部署</span><br><span class="line"></span><br><span class="line">7.1　搭建TensorFlow服务开发环境</span><br><span class="line"></span><br><span class="line">7.1.1　Docker镜像</span><br><span class="line"></span><br><span class="line">7.1.2　Bazel工作区</span><br><span class="line"></span><br><span class="line">7.2　导出训练好的模型</span><br><span class="line"></span><br><span class="line">7.3　定义服务器接口</span><br><span class="line"></span><br><span class="line">7.4　实现推断服务器</span><br><span class="line"></span><br><span class="line">7.5　客户端应用</span><br><span class="line"></span><br><span class="line">7.6　产品准备</span><br><span class="line"></span><br><span class="line">7.7　本章小结</span><br><span class="line"></span><br><span class="line">第8章　辅助函数、代码结构和类</span><br><span class="line"></span><br><span class="line">8.1　确保目录结构存在</span><br><span class="line"></span><br><span class="line">8.2　下载函数</span><br><span class="line"></span><br><span class="line">8.3　磁盘缓存修饰器</span><br><span class="line"></span><br><span class="line">8.4　属性字典</span><br><span class="line"></span><br><span class="line">8.5　惰性属性修饰器</span><br><span class="line"></span><br><span class="line">8.6　覆盖数据流图修饰器</span><br><span class="line"></span><br><span class="line">第9章　结语：其他资源</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Machine Learning Yearning完整中文版 PDF</title>
    <url>/posts/2b3ca9ea/</url>
    <content><![CDATA[<h4 id="《Machine-Learning-Yearning完整中文版》"><a href="#《Machine-Learning-Yearning完整中文版》" class="headerlink" title="《Machine Learning Yearning完整中文版》"></a>《Machine Learning Yearning完整中文版》</h4><p><img src="/images/65942a68ac7674f0385f315ec1a8a0de1.jpg" width="50%" height="50%"></p>
<p><img src="/images/65942a68ac7674f0385f315ec1a8a0de2.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<h6 id="链接-https-pan-baidu-com-s-1-ypJ5I0dtYiiyTRekxtRDw-提取码-wxoj"><a href="#链接-https-pan-baidu-com-s-1-ypJ5I0dtYiiyTRekxtRDw-提取码-wxoj" class="headerlink" title="链接:https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw 提取码:wxoj"></a>链接:<a href="https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw">https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw</a> 提取码:wxoj</h6><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>labuladong的算法小抄官方完整版 PDF</title>
    <url>/posts/bb83b47b/</url>
    <content><![CDATA[<h4 id="《labuladong的算法小抄官方完整版》"><a href="#《labuladong的算法小抄官方完整版》" class="headerlink" title="《labuladong的算法小抄官方完整版》"></a>《labuladong的算法小抄官方完整版》</h4><h4 id="本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF"><a href="#本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF" class="headerlink" title="本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF"></a>本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF</h4><h4 id="获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="获取链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>获取链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><a id="more"></a>
<!-- more -->
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h4 id="获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="获取链接：https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>获取链接：<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h4><p>前不久在 GitHub 出现了一个手把手带你刷 LeetCode 的项目：fucking-algorithm。 该项目此前在 GitHub 开源后，连续多次霸榜 GitHub Trending 首页，用了两个月 Star 数便破 50k，受欢迎程度由此可见一斑。</p>
<p><img src="/images/19497e27d67795d836b02c288ce705f51.jpg" width="50%" height="50%"></p>
<h4 id="链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱-1"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱-1" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 核心套路篇 ／ 21</span><br><span class="line"></span><br><span class="line">1.1 学习算法和刷题的框架思维 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.1 数据结构的存储方式 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.2 数据结构的基本操作 ／ 23</span><br><span class="line"></span><br><span class="line">1.1.3 算法刷题指南 ／ 25</span><br><span class="line"></span><br><span class="line">1.1.4 最后总结 ／ 30</span><br><span class="line"></span><br><span class="line">1.2 动态规划解题套路框架 ／ 31</span><br><span class="line"></span><br><span class="line">1.2.1 斐波那契数列 ／ 32</span><br><span class="line"></span><br><span class="line">1.2.2 凑零钱问题 ／ 37</span><br><span class="line"></span><br><span class="line">1.2.3 最后总结 ／ 42</span><br><span class="line"></span><br><span class="line">1.3 回溯算法解题套路框架 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.1 全排列问题 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.2 N 皇后问题 ／ 48</span><br><span class="line"></span><br><span class="line">1.3.3 最后总结 ／ 51</span><br><span class="line"></span><br><span class="line">1.4 BFS 算法套路框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.1 算法框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.2 二叉树的最小高度 ／ 54</span><br><span class="line"></span><br><span class="line">1.4.3 解开密码锁的最少次数 ／ 56</span><br><span class="line"></span><br><span class="line">1.5 双指针技巧套路框架 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.1 快、慢指针的常用算法 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.2 左、右指针的常用算法 ／ 68</span><br><span class="line"></span><br><span class="line">1.6 我写了首诗，保你闭着眼睛都能写出二分搜索算法 ／ 71</span><br><span class="line"></span><br><span class="line">1.6.1 二分搜索框架 ／ 72</span><br><span class="line"></span><br><span class="line">1.6.2 寻找一个数（基本的二分搜索） ／ 73</span><br><span class="line"></span><br><span class="line">1.6.3 寻找左侧边界的二分搜索 ／ 75</span><br><span class="line"></span><br><span class="line">1.6.4 寻找右侧边界的二分搜索 ／ 79</span><br><span class="line"></span><br><span class="line">1.6.5 逻辑统一 ／ 82</span><br><span class="line"></span><br><span class="line">1.7 我写了一个模板，把滑动窗口算法变成了默写题 ／ 85</span><br><span class="line"></span><br><span class="line">1.7.1 最小覆盖子串 ／ 87</span><br><span class="line"></span><br><span class="line">1.7.2 字符串排列 ／ 91</span><br><span class="line"></span><br><span class="line">1.7.3 找所有字母异位词 ／ 93</span><br><span class="line"></span><br><span class="line">1.7.4 最长无重复子串 ／ 94</span><br><span class="line"></span><br><span class="line">第2章 动态规划系列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1 动态规划设计：最长递增子序列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1.1 动态规划解法 ／ 97</span><br><span class="line"></span><br><span class="line">2.1.2 二分搜索解法 ／ 100</span><br><span class="line"></span><br><span class="line">2.2 二维递增子序列：信封嵌套问题 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.1 题目概述 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.2 思路分析 ／ 105</span><br><span class="line"></span><br><span class="line">2.2.3 最后总结 ／ 107</span><br><span class="line"></span><br><span class="line">2.3 最大子数组问题 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.1 思路分析 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.2 最后总结 ／ 110</span><br><span class="line"></span><br><span class="line">2.4 动态规划答疑：最优子结构及dp 遍历方向 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.1 最优子结构详解 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.2 dp 数组的遍历方向 ／ 113</span><br><span class="line"></span><br><span class="line">2.5 经典动态规划：最长公共子序列 ／ 117</span><br><span class="line"></span><br><span class="line">2.6 经典动态规划：编辑距离 ／ 123</span><br><span class="line"></span><br><span class="line">2.6.1 思路分析 ／ 124</span><br><span class="line"></span><br><span class="line">2.6.2 代码详解 ／ 125</span><br><span class="line"></span><br><span class="line">2.6.3 动态规划优化 ／ 129</span><br><span class="line"></span><br><span class="line">2.6.4 扩展延伸 ／ 131</span><br><span class="line"></span><br><span class="line">2.7 子序列问题解题模板：最长回文子序列 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.1 两种思路 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.2 最长回文子序列 ／ 137</span><br><span class="line"></span><br><span class="line">2.7.3 代码实现 ／ 139</span><br><span class="line"></span><br><span class="line">2.8 状态压缩：对动态规划进行降维打击 ／ 141</span><br><span class="line"></span><br><span class="line">2.9 以最小插入次数构造回文串 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.1 思路分析 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.2 状态转移方程 ／ 149</span><br><span class="line"></span><br><span class="line">2.9.3 代码实现 ／ 152</span><br><span class="line"></span><br><span class="line">2.10 动态规划之正则表达式 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.1 思路分析 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.2 动态规划解法 ／ 157</span><br><span class="line"></span><br><span class="line">2.11 不同的定义产生不同的解法 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.1 第一种思路 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.2 第二种思路 ／ 165</span><br><span class="line"></span><br><span class="line">2.11.3 最后总结 ／ 167</span><br><span class="line"></span><br><span class="line">2.12 经典动态规划：高楼扔鸡蛋 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.1 解析题目 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.2 思路分析 ／ 169</span><br><span class="line"></span><br><span class="line">2.12.3 疑难解答 ／ 172</span><br><span class="line"></span><br><span class="line">2.13 经典动态规划：高楼扔鸡蛋（进阶） ／ 173</span><br><span class="line"></span><br><span class="line">2.13.1 二分搜索优化 ／ 173</span><br><span class="line"></span><br><span class="line">2.13.2 重新定义状态转移 ／ 176</span><br><span class="line"></span><br><span class="line">2.13.3 还可以再优化 ／ 180</span><br><span class="line"></span><br><span class="line">2.14 经典动态规划：戳气球问题 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.1 回溯思路 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.2 动态规划思路 ／ 182</span><br><span class="line"></span><br><span class="line">2.14.3 写出代码 ／ 185</span><br><span class="line"></span><br><span class="line">2.15 经典动态规划：0-1 背包问题 ／ 188</span><br><span class="line"></span><br><span class="line">2.16 经典动态规划：子集背包问题 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.1 问题分析 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.2 思路分析 ／ 193</span><br><span class="line"></span><br><span class="line">2.16.3 进行状态压缩 ／ 194</span><br><span class="line"></span><br><span class="line">2.17 经典动态规划：完全背包问题 ／ 196</span><br><span class="line"></span><br><span class="line">2.18 题目千百变，套路不会变 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.1 线性排列情况 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.2 环形排列情况 ／ 203</span><br><span class="line"></span><br><span class="line">2.18.3 树形排列情况 ／ 205</span><br><span class="line"></span><br><span class="line">2.19 动态规划和回溯算法，到底是什么关系 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.1 回溯思路 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.2 消除重叠子问题 ／ 210</span><br><span class="line"></span><br><span class="line">2.19.3 动态规划 ／ 211</span><br><span class="line"></span><br><span class="line">第3章 数据结构系列 ／ 216</span><br><span class="line"></span><br><span class="line">3.1 手把手教你写 LRU 缓存淘汰算法 ／ 216</span><br><span class="line"></span><br><span class="line">3.1.1 LRU 算法描述 ／ 218</span><br><span class="line"></span><br><span class="line">3.1.2 LRU 算法设计 ／ 219</span><br><span class="line"></span><br><span class="line">3.1.3 代码实现 ／ 220</span><br><span class="line"></span><br><span class="line">3.2 层层拆解，带你手写LFU 算法 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.1 算法描述 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.2 思路分析 ／ 228</span><br><span class="line"></span><br><span class="line">3.2.3 代码框架 ／ 230</span><br><span class="line"></span><br><span class="line">3.2.4 LFU 核心逻辑 ／ 232</span><br><span class="line"></span><br><span class="line">3.3 二叉搜索树操作集锦 ／ 235</span><br><span class="line"></span><br><span class="line">3.3.1 判断 BST 的合法性 ／ 236</span><br><span class="line"></span><br><span class="line">3.3.2 在 BST 中查找一个数是否存在 ／ 238</span><br><span class="line"></span><br><span class="line">3.3.3 在 BST 中插入一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.3.4 在 BST 中删除一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.4 完全二叉树的节点数为什么那么难算 ／ 243</span><br><span class="line"></span><br><span class="line">3.4.1 思路分析 ／ 244</span><br><span class="line"></span><br><span class="line">3.4.2 复杂度分析 ／ 245</span><br><span class="line"></span><br><span class="line">3.5 用各种遍历框架序列化和反序列化二叉树 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.1 题目描述 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.2 前序遍历解法 ／ 248</span><br><span class="line"></span><br><span class="line">3.5.3 后序遍历解法 ／ 252</span><br><span class="line"></span><br><span class="line">3.5.4 中序遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.5.5 层级遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.6 Git 原理之二叉树最近公共祖先 ／ 260</span><br><span class="line"></span><br><span class="line">3.6.1 二叉树的最近公共祖先 ／ 261</span><br><span class="line"></span><br><span class="line">3.6.2 思路分析 ／ 263</span><br><span class="line"></span><br><span class="line">3.7 特殊数据结构：单调栈 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.1 单调栈解题模板 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.2 题目变形 ／ 268</span><br><span class="line"></span><br><span class="line">3.7.3 如何处理循环数组 ／ 268</span><br><span class="line"></span><br><span class="line">3.8 特殊数据结构：单调队列 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.1 搭建解题框架 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.2 实现单调队列数据结构 ／ 273</span><br><span class="line"></span><br><span class="line">3.8.3 算法复杂度分析 ／ 276</span><br><span class="line"></span><br><span class="line">3.9 如何判断回文链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.1 判断回文单链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.2 优化空间复杂度 ／ 280</span><br><span class="line"></span><br><span class="line">3.9.3 最后总结 ／ 282</span><br><span class="line"></span><br><span class="line">3.10 秀操作之纯递归反转链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.1 递归反转整个链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.2 反转链表前N 个节点 ／ 286</span><br><span class="line"></span><br><span class="line">3.10.3 反转链表的一部分 ／ 287</span><br><span class="line"></span><br><span class="line">3.10.4 最后总结 ／ 288</span><br><span class="line"></span><br><span class="line">3.11 秀操作之k 个一组反转链表 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.1 分析问题 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.2 代码实现 ／ 291</span><br><span class="line"></span><br><span class="line">3.11.3 最后总结 ／ 292</span><br><span class="line"></span><br><span class="line">第4章 算法思维系列 ／ 293</span><br><span class="line"></span><br><span class="line">4.1 回溯算法解决子集、组合、排列问题 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.1 子集 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.2 组合 ／ 297</span><br><span class="line"></span><br><span class="line">4.1.3 排列 ／ 299</span><br><span class="line"></span><br><span class="line">4.2 回溯算法最佳实践：解数独 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.1 直观感受 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.2 代码实现 ／ 301</span><br><span class="line"></span><br><span class="line">4.3 回溯算法最佳实践：括号生成 ／ 306</span><br><span class="line"></span><br><span class="line">4.4 BFS 算法暴力破解各种智力题 ／ 310</span><br><span class="line"></span><br><span class="line">4.4.1 题目解析 ／ 311</span><br><span class="line"></span><br><span class="line">4.4.2 思路分析 ／ 311</span><br><span class="line"></span><br><span class="line">4.5 2Sum 问题的核心思想 ／ 315</span><br><span class="line"></span><br><span class="line">4.5.1 2Sum I ／ 315</span><br><span class="line"></span><br><span class="line">4.5.2 2Sum II ／ 316</span><br><span class="line"></span><br><span class="line">4.5.3 最后总结 ／ 318</span><br><span class="line"></span><br><span class="line">4.6 一个函数解决 nSum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.1 2Sum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.2 3Sum 问题 ／ 322</span><br><span class="line"></span><br><span class="line">4.6.3 4Sum 问题 ／ 324</span><br><span class="line"></span><br><span class="line">4.6.4 100Sum 问题 ／ 325</span><br><span class="line"></span><br><span class="line">4.7 拆解复杂问题：实现计算器 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.1 字符串转整数 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.2 处理加减法 ／ 329</span><br><span class="line"></span><br><span class="line">4.7.3 处理乘除法 ／ 331</span><br><span class="line"></span><br><span class="line">4.7.4 处理括号 ／ 333</span><br><span class="line"></span><br><span class="line">4.7.5 最后总结 ／ 336</span><br><span class="line"></span><br><span class="line">4.8 摊烧饼也得有点递归思维 ／ 337</span><br><span class="line"></span><br><span class="line">4.8.1 思路分析 ／ 338</span><br><span class="line"></span><br><span class="line">4.8.2 代码实现 ／ 339</span><br><span class="line"></span><br><span class="line">4.9 前缀和技巧解决子数组问题 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.1 什么是前缀和 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.2 优化解法 ／ 343</span><br><span class="line"></span><br><span class="line">4.9.3 最后总结 ／ 344</span><br><span class="line"></span><br><span class="line">4.10 扁平化嵌套列表 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.1 题目描述 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.2 解题思路 ／ 346</span><br><span class="line"></span><br><span class="line">4.10.3 进阶思路 ／ 349</span><br><span class="line"></span><br><span class="line">第5章 高频面试系列 ／ 351</span><br><span class="line"></span><br><span class="line">5.1 如何高效寻找素数 ／ 351</span><br><span class="line"></span><br><span class="line">5.2 如何高效进行模幂运算 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.1 如何处理数组指数 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.2 如何处理 mod 运算 ／ 356</span><br><span class="line"></span><br><span class="line">5.2.3 如何高效求幂 ／ 358</span><br><span class="line"></span><br><span class="line">5.3 如何运用二分搜索算法 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.1 问题分析 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.2 扩展延伸 ／ 362</span><br><span class="line"></span><br><span class="line">5.4 如何高效解决接雨水问题 ／ 364</span><br><span class="line"></span><br><span class="line">5.5 如何去除有序数组的重复元素 ／ 371</span><br><span class="line"></span><br><span class="line">5.6 如何寻找最长回文子串 ／ 373</span><br><span class="line"></span><br><span class="line">5.7 如何运用贪心思想玩跳跃游戏 ／ 376</span><br><span class="line"></span><br><span class="line">5.8 如何运用贪心算法做时间管理 ／ 381</span><br><span class="line"></span><br><span class="line">5.9 如何判定括号合法性 ／ 386</span><br><span class="line"></span><br><span class="line">5.10 如何调度考生的座位 ／ 389</span><br><span class="line"></span><br><span class="line">5.11 Union-Find 算法详解 ／ 396</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>推荐算法在业界的应用实践合集 PDF</title>
    <url>/posts/cc8484ed/</url>
    <content><![CDATA[<h4 id="《推荐算法在业界的应用实践合集》"><a href="#《推荐算法在业界的应用实践合集》" class="headerlink" title="《推荐算法在业界的应用实践合集》"></a>《推荐算法在业界的应用实践合集》</h4><p>链接:<a href="https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ">https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ</a></p>
<p><img src="/images/295f441d3dd70c31813460c2832ccd1b1.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p><img src="/images/295f441d3dd70c31813460c2832ccd1b2.jpg" width="50%" height="50%"></p>
<p><img src="/images/295f441d3dd70c31813460c2832ccd1b3.jpg" width="50%" height="50%"></p>
<p>链接:<a href="https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ">https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ</a> 提取码:3qbx</p>
<h6 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">从推荐推理奔向未来 AI</span><br><span class="line"></span><br><span class="line">达观数据个性化推荐系统实践</span><br><span class="line"></span><br><span class="line">Embedding 技术在民宿推荐中的应用</span><br><span class="line"></span><br><span class="line">过 程 的 推 荐 多 样 性 提 升 算 法 </span><br><span class="line"></span><br><span class="line">: 深 度 学 习 排 序 系 统 及 模 型 </span><br><span class="line"></span><br><span class="line">验 证 周 期 场 景 下 的 算 法 设 计 </span><br><span class="line"></span><br><span class="line">能 导 购 推 荐 技 术 实 践 </span><br><span class="line"></span><br><span class="line">随 谈 </span><br><span class="line"></span><br><span class="line">分享平台:DataFun 公众号:DataFunTalk</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">美 图 个 性 化 推 送 的 AI 探 索 之 路 </span><br><span class="line"></span><br><span class="line">深度学习在阿里 B2B 电商推荐系统中的实践</span><br><span class="line"></span><br><span class="line">问题上的应用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>利用Python进行数据分析 PDF</title>
    <url>/posts/558dd557/</url>
    <content><![CDATA[<h4 id="《利用Python进行数据分析》"><a href="#《利用Python进行数据分析》" class="headerlink" title="《利用Python进行数据分析》"></a>《利用Python进行数据分析》</h4><p>这本书几乎是数据分析入门必读书了</p>
<p>主要介绍了python 3个库numpy（数组），pandas（数据分析）和matplotlib（绘图）的学习<br><a id="more"></a></p>
<p>阅读本书可以获得一份关于在Python下操作、处理、清洗、规整数据集的完整说明。本书第二版针对Python 3.6进行了更新，并增加实际案例向你展示如何高效地解决一系列数据分析问题。你将在阅读过程中学习到新版本的pandas、NumPy、IPython和Jupyter。</p>
<p>本书由Wes McKinney创作，他是Python pandas项目的创始人。本书是对Python数据科学工具的实操化、现代化的介绍，非常适合刚学Python的数据分析师或刚学数据科学以及科学计算的Python编程者。数据文件和相关的材料可以在GitHub上找到：</p>
<p>l 使用IPython shell和Jupyter notebook进行探索性计算</p>
<p>l 学习NumPy(Numerical Python)的基础和高级特性</p>
<p>l 入门pandas库中的数据分析工具</p>
<p>l 使用灵活工具对数据进行载入、清洗、变换、合并和重塑</p>
<p>l 使用matplotlib创建富含信息的可视化</p>
<p>l 将pandas的groupby功能应用于对数据集的切片、分块和汇总</p>
<p>l 分析并操作规则和不规则的时间序列数据</p>
<p>利用完整的、详细的示例学习如何解决现实中数据分析问题</p>
<h4 id="获取链接-https-pan-baidu-com-s-1GPAeBzRfm-q9k6Git-Xc5g-密码-qune"><a href="#获取链接-https-pan-baidu-com-s-1GPAeBzRfm-q9k6Git-Xc5g-密码-qune" class="headerlink" title="获取链接: https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g 密码: qune"></a>获取链接: <a href="https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g">https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g</a> 密码: qune</h4><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p><img src="/images/6dc7268c125782b470a111351071ec9a1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言1</span><br><span class="line"></span><br><span class="line">第1章 准备工作7</span><br><span class="line"></span><br><span class="line">1.1 本书内容7</span><br><span class="line"></span><br><span class="line">1.1.1 什么类型的数据7</span><br><span class="line"></span><br><span class="line">1.2 为何利用Python进行数据分析8</span><br><span class="line"></span><br><span class="line">1.2.1 Python作为胶水8</span><br><span class="line"></span><br><span class="line">1.2.2 解决“双语言”难题8</span><br><span class="line"></span><br><span class="line">1.2.3 为何不使用Python9</span><br><span class="line"></span><br><span class="line">1.3 重要的Python库9</span><br><span class="line"></span><br><span class="line">1.3.1 NumPy9</span><br><span class="line"></span><br><span class="line">1.3.2 pandas10</span><br><span class="line"></span><br><span class="line">1.3.3 matplotlib11</span><br><span class="line"></span><br><span class="line">1.3.4 IPython与Jupyter11</span><br><span class="line"></span><br><span class="line">1.3.5 SciPy12</span><br><span class="line"></span><br><span class="line">1.3.6 scikit-learn12</span><br><span class="line"></span><br><span class="line">1.3.7 statsmodels13</span><br><span class="line"></span><br><span class="line">1.4 安装与设置13</span><br><span class="line"></span><br><span class="line">1.4.1 Windows14</span><br><span class="line"></span><br><span class="line">1.4.2 Apple（OS X和macOS）14</span><br><span class="line"></span><br><span class="line">1.4.3 GNU&#x2F;Linux14</span><br><span class="line"></span><br><span class="line">1.4.4 安装及更新Python包15</span><br><span class="line"></span><br><span class="line">1.4.5 Python 2和Python 316</span><br><span class="line"></span><br><span class="line">1.4.6 集成开发环境和文本编辑器16</span><br><span class="line"></span><br><span class="line">1.5 社区和会议17</span><br><span class="line"></span><br><span class="line">1.6 快速浏览本书17</span><br><span class="line"></span><br><span class="line">1.6.1 代码示例18</span><br><span class="line"></span><br><span class="line">1.6.2 示例数据18</span><br><span class="line"></span><br><span class="line">1.6.3导入约定18</span><br><span class="line"></span><br><span class="line">1.6.4术语19</span><br><span class="line"></span><br><span class="line">第2章 Python语言基础、IPython及Jupyter notebook20</span><br><span class="line"></span><br><span class="line">2.1 Python解释器21</span><br><span class="line"></span><br><span class="line">2.2 IPython基础22</span><br><span class="line"></span><br><span class="line">2.2.1 运行IPython命令行22</span><br><span class="line"></span><br><span class="line">2.2.2 运行 Jupyter notebook23</span><br><span class="line"></span><br><span class="line">2.2.3 Tab补全25</span><br><span class="line"></span><br><span class="line">2.2.4 内省27</span><br><span class="line"></span><br><span class="line">2.2.5 %run命令28</span><br><span class="line"></span><br><span class="line">2.2.6 执行剪贴板中的程序30</span><br><span class="line"></span><br><span class="line">2.2.7 终端快捷键30</span><br><span class="line"></span><br><span class="line">2.2.8 关于魔术命令31</span><br><span class="line"></span><br><span class="line">2.2.9　matplotlib集成33</span><br><span class="line"></span><br><span class="line">2.3 Python语言基础34</span><br><span class="line"></span><br><span class="line">2.3.1 语言语义34</span><br><span class="line"></span><br><span class="line">2.3.2 标量类型42</span><br><span class="line"></span><br><span class="line">2.3.3 控制流49</span><br><span class="line"></span><br><span class="line">第3章 内建数据结构、函数及文件54</span><br><span class="line"></span><br><span class="line">3.1 数据结构和序列54</span><br><span class="line"></span><br><span class="line">3.1.1 元组54</span><br><span class="line"></span><br><span class="line">3.1.2 列表57</span><br><span class="line"></span><br><span class="line">3.1.3 内建序列函数61</span><br><span class="line"></span><br><span class="line">3.1.4 字典64</span><br><span class="line"></span><br><span class="line">3.1.5集合67</span><br><span class="line"></span><br><span class="line">3.1.6 列表、集合和字典的推导式69</span><br><span class="line"></span><br><span class="line">3.2 函数72</span><br><span class="line"></span><br><span class="line">3.2.1 命名空间、作用域和本地函数72</span><br><span class="line"></span><br><span class="line">3.2.2 返回多个值73</span><br><span class="line"></span><br><span class="line">3.2.3 函数是对象74</span><br><span class="line"></span><br><span class="line">3.2.4 匿名（Lambda）函数75</span><br><span class="line"></span><br><span class="line">3.2.5 柯里化：部分参数应用76</span><br><span class="line"></span><br><span class="line">3.2.6 生成器77</span><br><span class="line"></span><br><span class="line">3.2.7 错误和异常处理79</span><br><span class="line"></span><br><span class="line">3.3 文件与操作系统82</span><br><span class="line"></span><br><span class="line">3.3.1 字节与Unicode文件85</span><br><span class="line"></span><br><span class="line">3.4 本章小结86</span><br><span class="line"></span><br><span class="line">第4章 NumPy基础：数组与向量化计算87</span><br><span class="line"></span><br><span class="line">4.1 NumPy ndarray：多维数组对象89</span><br><span class="line"></span><br><span class="line">4.1.1 生成ndarray90</span><br><span class="line"></span><br><span class="line">4.1.2 ndarray的数据类型92</span><br><span class="line"></span><br><span class="line">4.1.3 NumPy数组算术94</span><br><span class="line"></span><br><span class="line">4.1.4 基础索引与切片95</span><br><span class="line"></span><br><span class="line">4.1.5 布尔索引100</span><br><span class="line"></span><br><span class="line">4.1.6 神奇索引103</span><br><span class="line"></span><br><span class="line">4.1.7 数组转置和换轴104</span><br><span class="line"></span><br><span class="line">4.2 通用函数：快速的逐元素数组函数106</span><br><span class="line"></span><br><span class="line">4.3 使用数组进行面向数组编程109</span><br><span class="line"></span><br><span class="line">4.3.1 将条件逻辑作为数组操作110</span><br><span class="line"></span><br><span class="line">4.3.2 数学和统计方法111</span><br><span class="line"></span><br><span class="line">4.3.3 布尔值数组的方法113</span><br><span class="line"></span><br><span class="line">4.3.4 排序114</span><br><span class="line"></span><br><span class="line">4.3.5 唯一值与其他集合逻辑115</span><br><span class="line"></span><br><span class="line">4.4 使用数组进行文件输入和输出115</span><br><span class="line"></span><br><span class="line">4.5 线性代数116</span><br><span class="line"></span><br><span class="line">4.6 伪随机数生成118</span><br><span class="line"></span><br><span class="line">4.7 示例：随机漫步120</span><br><span class="line"></span><br><span class="line">4.7.1 一次性模拟多次随机漫步121</span><br><span class="line"></span><br><span class="line">4.8 本章小结122</span><br><span class="line"></span><br><span class="line">第5章 pandas入门123</span><br><span class="line"></span><br><span class="line">5.1 pandas数据结构介绍123</span><br><span class="line"></span><br><span class="line">5.1.1 Series123</span><br><span class="line"></span><br><span class="line">5.1.2 DataFrame128</span><br><span class="line"></span><br><span class="line">5.1.3 索引对象134</span><br><span class="line"></span><br><span class="line">5.2 基本功能135</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>计算广告：互联网商业变现的市场与技术-刘鹏 PDF</title>
    <url>/posts/228ae5c1/</url>
    <content><![CDATA[<h4 id="《计算广告：互联网商业变现的市场与技术-刘鹏》"><a href="#《计算广告：互联网商业变现的市场与技术-刘鹏》" class="headerlink" title="《计算广告：互联网商业变现的市场与技术-刘鹏》"></a>《计算广告：互联网商业变现的市场与技术-刘鹏》</h4><h6 id="链接-https-pan-baidu-com-s-1IxhuOXTGnS11ETHmVGxEBg-提取码-uj8o"><a href="#链接-https-pan-baidu-com-s-1IxhuOXTGnS11ETHmVGxEBg-提取码-uj8o" class="headerlink" title="链接:https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg 提取码:uj8o"></a>链接:<a href="https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg">https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg</a> 提取码:uj8o</h6><p>计算广告是一项新兴的研究课题，它涉及大规模搜索和文本分析、信息获取、统计模型、机器学习、分类、优化以及微观经济学等诸多领域的知识。本书从实践出发，系统地介绍计算广告的产品、问题、系统和算法，并且从工业界的视角对这一领域具体技术的深入剖析。<br><a id="more"></a></p>
<p>《计算广告 互联网商业变现的市场与技术》立足于广告市场的根本问题，从计算广告各个阶段所遇到的市场挑战出发，以广告系统业务形态的需求和变化为主线，依次介绍广告系统、竞价广告系统、程序化交易市场等重要课题，并对计算广告涉及的关键技术和算法做深入的探讨。</p>
<p>无论是互联网公司商业化部门的产品技术人员，还是对个性化系统、大数据变现或交易有兴趣的产品技术人员，传统企业互联网化进程的决策者，传统广告业务的从业者，互联网创业者，计算机相关专业研究生， 都会从阅读《计算广告 互联网商业变现的市场与技术》中受益匪浅。</p>
<p><img src="/images/eb72032800ffd8a55e3b1131eb14cf681.jpg" width="50%" height="50%"></p>
<h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">□□部分在线广告市场与背景</span><br><span class="line"></span><br><span class="line">□□ 章在线广告综述 3</span><br><span class="line"></span><br><span class="line">1.1 大数据与广告的关系 4</span><br><span class="line"></span><br><span class="line">1.□ 广告的定义与目的 5</span><br><span class="line"></span><br><span class="line">1.3 在线广告创意类型 8</span><br><span class="line"></span><br><span class="line">1.4 在线广告简史. 11</span><br><span class="line"></span><br><span class="line">1.5 泛广告商业产品. 16</span><br><span class="line"></span><br><span class="line">1.6 延伸思考 18</span><br><span class="line"></span><br><span class="line">第□ 章计算广告基础. 19</span><br><span class="line"></span><br><span class="line">□.1 广告有效性原理. □0</span><br><span class="line"></span><br><span class="line">□.□ 互联网广告的技术特点 □□</span><br><span class="line"></span><br><span class="line">□.3 计算广告的核心问题. □3</span><br><span class="line"></span><br><span class="line">□.3.1 广告收入的分解 □4</span><br><span class="line"></span><br><span class="line">□.3.□ 结算方式与eCPM估计的关系. □5</span><br><span class="line"></span><br><span class="line">□.4 在线广告相关行业协会 □7</span><br><span class="line"></span><br><span class="line">□.4.1 交互广告局. □8</span><br><span class="line"></span><br><span class="line">□.4.□ 美国广告代理协会 □8</span><br><span class="line"></span><br><span class="line">□.4.3 美国国家广告商协会. □9</span><br><span class="line"></span><br><span class="line">□.5 延伸思考 □9</span><br><span class="line"></span><br><span class="line">第二部分在线广告产品逻辑</span><br><span class="line"></span><br><span class="line">第3 章在线广告产品概览 33</span><br><span class="line"></span><br><span class="line">3.1 商业产品的设计原则. 34</span><br><span class="line"></span><br><span class="line">3.□ 需求方层级组织与接口 35</span><br><span class="line"></span><br><span class="line">3.3 供给方管理接口. 38</span><br><span class="line"></span><br><span class="line">3.4 延伸思考 39</span><br><span class="line"></span><br><span class="line">第4 章合约广告. 41</span><br><span class="line"></span><br><span class="line">4.1 广告位合约 4□</span><br><span class="line"></span><br><span class="line">4.□ 受众定向 43</span><br><span class="line"></span><br><span class="line">4.□.1 受众定向方法概览 43</span><br><span class="line"></span><br><span class="line">4.□.□ 受众定向标签体系 46</span><br><span class="line"></span><br><span class="line">4.3 展示量合约 47</span><br><span class="line"></span><br><span class="line">4.3.1 流量预测. 48</span><br><span class="line"></span><br><span class="line">4.3.□ 流量塑形. 48</span><br><span class="line"></span><br><span class="line">4.3.3 在线分配. 49</span><br><span class="line"></span><br><span class="line">4.3.4 产品案例. 50</span><br><span class="line"></span><br><span class="line">4.4 延伸思考 51</span><br><span class="line"></span><br><span class="line">第5 章搜索与竞价广告. 53</span><br><span class="line"></span><br><span class="line">5.1 搜索广告 54</span><br><span class="line"></span><br><span class="line">5.1.1 搜索广告产品形态 55</span><br><span class="line"></span><br><span class="line">5.1.□ 搜索广告产品新形式. 57</span><br><span class="line"></span><br><span class="line">5.1.3 搜索广告产品策略 59</span><br><span class="line"></span><br><span class="line">5.1.4 产品案例. 61</span><br><span class="line"></span><br><span class="line">5.□ 位置拍卖与机制设计. 64</span><br><span class="line"></span><br><span class="line">5.□.1 定价问题. 64</span><br><span class="line"></span><br><span class="line">5.□.□ 市场保留价. 67</span><br><span class="line"></span><br><span class="line">5.□.3 价格挤压. 68</span><br><span class="line"></span><br><span class="line">5.□.4 定价结果示例 68</span><br><span class="line"></span><br><span class="line">5.3 广告网络 69</span><br><span class="line"></span><br><span class="line">5.3.1 广告网络产品形态 69</span><br><span class="line"></span><br><span class="line">5.3.□ 广告网络产品策略 71</span><br><span class="line"></span><br><span class="line">5.3.3 产品案例. 7□</span><br><span class="line"></span><br><span class="line">5.4 竞价广告需求方产品. 73</span><br><span class="line"></span><br><span class="line">5.4.1 搜索引擎营销 73</span><br><span class="line"></span><br><span class="line">5.4.□ 媒体购买□台 74</span><br><span class="line"></span><br><span class="line">5.4.3 产品案例. 74</span><br><span class="line"></span><br><span class="line">5.5 竞价广告与合约广告的比较 76</span><br><span class="line"></span><br><span class="line">5.6 延伸思考 77</span><br><span class="line"></span><br><span class="line">第6 章程序化交易广告. 79</span><br><span class="line"></span><br><span class="line">6.1 实时竞价 80</span><br><span class="line"></span><br><span class="line">6.□ 其他程序化交易方式. 83</span><br><span class="line"></span><br><span class="line">6.□.1 优选. 83</span><br><span class="line"></span><br><span class="line">6.□.□ 私有市场. 84</span><br><span class="line"></span><br><span class="line">6.□.3 广告交易方式谱系 85</span><br><span class="line"></span><br><span class="line">6.3 广告交易□台. 86</span><br><span class="line"></span><br><span class="line">6.4 需求方□台 88</span><br><span class="line"></span><br><span class="line">6.4.1 需求方□台产品策略. 89</span><br><span class="line"></span><br><span class="line">6.4.□ 出价策略. 89</span><br><span class="line"></span><br><span class="line">6.4.3 重定向. 90</span><br><span class="line"></span><br><span class="line">6.4.4 新客推荐. 9□</span><br><span class="line"></span><br><span class="line">6.4.5 产品案例. 93</span><br><span class="line"></span><br><span class="line">6.5 供给方□台 95</span><br><span class="line"></span><br><span class="line">6.5.1 供给方□台产品策略. 95</span><br><span class="line"></span><br><span class="line">6.5.□ 产品案例. 96</span><br><span class="line"></span><br><span class="line">6.6 数据加工与交易. 97</span><br><span class="line"></span><br><span class="line">6.6.1 有价值的数据来源 98</span><br><span class="line"></span><br><span class="line">6.6.□ 三方数据划分. 100</span><br><span class="line"></span><br><span class="line">6.6.3 数据管理□台. 100</span><br><span class="line"></span><br><span class="line">6.6.4 数据交易□台. 101</span><br><span class="line"></span><br><span class="line">6.6.5 产品案例 101</span><br><span class="line"></span><br><span class="line">6.7 在线广告产品交互关系. 104</span><br><span class="line"></span><br><span class="line">6.8 延伸思考. 106</span><br><span class="line"></span><br><span class="line">第7 章移动互联与原生广告. 107</span><br><span class="line"></span><br><span class="line">7.1 原生广告相关产品 108</span><br><span class="line"></span><br><span class="line">7.1.1 信息流广告. 108</span><br><span class="line"></span><br><span class="line">7.1.□ 搜索广告 109</span><br><span class="line"></span><br><span class="line">7.1.3 软文广告 109</span><br><span class="line"></span><br><span class="line">7.1.4 联盟 109</span><br><span class="line"></span><br><span class="line">7.□ 移动广告的现状与挑战. 110</span><br><span class="line"></span><br><span class="line">7.□.1 移动广告的特点. 110</span><br><span class="line"></span><br><span class="line">7.□.□ 移动广告的创意形式 111</span><br><span class="line"></span><br><span class="line">7.□.3 移动广告的挑战. 11□</span><br><span class="line"></span><br><span class="line">7.3 原生广告□台 114</span><br><span class="line"></span><br><span class="line">7.3.1 表现原生与意图原生 114</span><br><span class="line"></span><br><span class="line">7.3.□ 植入式原生广告. 115</span><br><span class="line"></span><br><span class="line">7.3.3 产品案例 117</span><br><span class="line"></span><br><span class="line">7.4 原生广告与程序化交易. 119</span><br><span class="line"></span><br><span class="line">7.5 延伸思考. 119</span><br><span class="line"></span><br><span class="line">第8 章在线广告产品实践. 1□1</span><br><span class="line"></span><br><span class="line">8.1 媒体实战. 1□1</span><br><span class="line"></span><br><span class="line">8.1.1 变现方式和产品决策 1□□</span><br><span class="line"></span><br><span class="line">8.1.□ 数据支持方案决策. 1□3</span><br><span class="line"></span><br><span class="line">8.□ 广告主实战 1□4</span><br><span class="line"></span><br><span class="line">8.3 数据提供方实战 1□6</span><br><span class="line"></span><br><span class="line">8.4 延伸思考. 1□7</span><br><span class="line"></span><br><span class="line">第三部分计算广告关键技术</span><br><span class="line"></span><br><span class="line">第9 章计算广告技术概览. 131</span><br><span class="line"></span><br><span class="line">9.1 个性化系统框架 13□</span><br><span class="line"></span><br><span class="line">9.□ 各类广告系统优化目标. 133</span><br><span class="line"></span><br><span class="line">9.3 计算广告系统架构 134</span><br><span class="line"></span><br><span class="line">9.3.1 广告投放引擎. 134</span><br><span class="line"></span><br><span class="line">9.3.□ 数据高速公路. 136</span><br><span class="line"></span><br><span class="line">9.3.3 离线数据处理. 137</span><br><span class="line"></span><br><span class="line">9.3.4 在线数据处理. 138</span><br><span class="line"></span><br><span class="line">9.4 计算广告系统主要技术. 138</span><br><span class="line"></span><br><span class="line">9.5 用开源工具搭建计算广告系统 140</span><br><span class="line"></span><br><span class="line">9.5.1Web服务器Nginx 140</span><br><span class="line"></span><br><span class="line">9.5.□分布式配置和集群管理工具ZooKeeper 14□</span><br><span class="line"></span><br><span class="line">9.5.3全文检索引擎Lucene. 14□</span><br><span class="line"></span><br><span class="line">9.5.4跨语言通信接口Thrift 143</span><br><span class="line"></span><br><span class="line">9.5.5数据高速公路Flume 144</span><br><span class="line"></span><br><span class="line">9.5.6分布式数据处理□台Hadoop 144</span><br><span class="line"></span><br><span class="line">9.5.7特征在线缓存Redis. 145</span><br><span class="line"></span><br><span class="line">9.5.8流计算□台Storm. 146</span><br><span class="line"></span><br><span class="line">9.5.9高效的迭代计算框架Spark 146</span><br><span class="line"></span><br><span class="line">9.6 延伸思考. 147</span><br><span class="line"></span><br><span class="line">□□0章基础知识准备 149</span><br><span class="line"></span><br><span class="line">10.1 信息检索 149</span><br><span class="line"></span><br><span class="line">10.1.1 倒排索引 150</span><br><span class="line"></span><br><span class="line">10.1.□ 向量空间模型. 15□</span><br><span class="line"></span><br><span class="line">10.□ □优化方法. 153</span><br><span class="line"></span><br><span class="line">10.□.1 拉格朗日法与凸优化 154</span><br><span class="line"></span><br><span class="line">10.□.□ 下降单纯形法. 155</span><br><span class="line"></span><br><span class="line">10.□.3 梯度下降法. 155</span><br><span class="line"></span><br><span class="line">10.□.4 拟牛顿法 156</span><br><span class="line"></span><br><span class="line">10.□.5 Trust-Region 法. 160</span><br><span class="line"></span><br><span class="line">10.3 统计机器学习. 16□</span><br><span class="line"></span><br><span class="line">10.3.1 □大熵与指数族分布 16□</span><br><span class="line"></span><br><span class="line">10.3.□混合模型和EM算法 164</span><br><span class="line"></span><br><span class="line">10.3.3 贝叶斯学习. 165</span><br><span class="line"></span><br><span class="line">10.4 统计模型分布式优化框架 169</span><br><span class="line"></span><br><span class="line">□□1章合约广告核心技术 171</span><br><span class="line"></span><br><span class="line">11.1 广告排期系统. 171</span><br><span class="line"></span><br><span class="line">11.□ 担保式投送系统. 173</span><br><span class="line"></span><br><span class="line">11.□.1 流量预测 175</span><br><span class="line"></span><br><span class="line">11.□.□ 频次控制 176</span><br><span class="line"></span><br><span class="line">11.3 在线分配 178</span><br><span class="line"></span><br><span class="line">11.3.1 在线分配问题. 178</span><br><span class="line"></span><br><span class="line">11.3.□ 在线分配问题举例. 181</span><br><span class="line"></span><br><span class="line">11.3.3 极限性能研究. 18□</span><br><span class="line"></span><br><span class="line">11.3.4 实用优化算法. 183</span><br><span class="line"></span><br><span class="line">11.4 延伸思考 19□</span><br><span class="line"></span><br><span class="line">□□□章受众定向核心技术 193</span><br><span class="line"></span><br><span class="line">1□.1 受众定向技术分类. 194</span><br><span class="line"></span><br><span class="line">1□.□ 上下文定向. 195</span><br><span class="line"></span><br><span class="line">1□.□.1 半在线抓取系统. 196</span><br><span class="line"></span><br><span class="line">1□.□.□ 文本主题挖掘. 197</span><br><span class="line"></span><br><span class="line">1□.3 行为定向 □01</span><br><span class="line"></span><br><span class="line">1□.3.1 行为定向建模问题. □01</span><br><span class="line"></span><br><span class="line">1□.3.□ 行为定向特征生成. □0□</span><br><span class="line"></span><br><span class="line">1□.3.3 行为定向决策过程. □06</span><br><span class="line"></span><br><span class="line">1□.3.4 行为定向的评测. □06</span><br><span class="line"></span><br><span class="line">1□.4 人口属性预测. □09</span><br><span class="line"></span><br><span class="line">1□.5 数据管理□台. □10</span><br><span class="line"></span><br><span class="line">1□.6 延伸思考 □10</span><br><span class="line"></span><br><span class="line">□□3章竞价广告核心技术 □13</span><br><span class="line"></span><br><span class="line">13.1 竞价广告计价算法. □14</span><br><span class="line"></span><br><span class="line">13.□ 搜索广告系统. □16</span><br><span class="line"></span><br><span class="line">13.□.1 查询扩展 □16</span><br><span class="line"></span><br><span class="line">13.□.□ 广告放置 □19</span><br><span class="line"></span><br><span class="line">13.3 广告网络 □□0</span><br><span class="line"></span><br><span class="line">13.4 广告检索 □□3</span><br><span class="line"></span><br><span class="line">13.4.1 布尔表达式的检索. □□3</span><br><span class="line"></span><br><span class="line">13.4.□ 相关性检索. □□7</span><br><span class="line"></span><br><span class="line">13.5 点击率预测. □31</span><br><span class="line"></span><br><span class="line">13.5.1 点击率预测模型. □3□</span><br><span class="line"></span><br><span class="line">13.5.□ 优化算法 □33</span><br><span class="line"></span><br><span class="line">13.5.3 点击率模型的校正. □44</span><br><span class="line"></span><br><span class="line">13.5.4 点击率模型的特征. □44</span><br><span class="line"></span><br><span class="line">13.5.5 点击率模型评测. □49</span><br><span class="line"></span><br><span class="line">13.5.6 智能频次控制. □51</span><br><span class="line"></span><br><span class="line">13.6 探索与利用. □51</span><br><span class="line"></span><br><span class="line">13.6.1 UCB 方法. □5□</span><br><span class="line"></span><br><span class="line">13.6.□考虑上下文的bandit □53</span><br><span class="line"></span><br><span class="line">13.7 延伸思考 □54</span><br><span class="line"></span><br><span class="line">□□4章程序化交易核心技术 □55</span><br><span class="line"></span><br><span class="line">14.1 广告交易□台. □55</span><br><span class="line"></span><br><span class="line">14.1.1cookie映射. □56</span><br><span class="line"></span><br><span class="line">14.1.□ 询价优化 □59</span><br><span class="line"></span><br><span class="line">14.□ 需求方□台. □61</span><br><span class="line"></span><br><span class="line">14.□.1 定制化用户标签. □63</span><br><span class="line"></span><br><span class="line">14.□.□ DSP 中的点击率预测 □64</span><br><span class="line"></span><br><span class="line">14.□.3 点击价值估计. □66</span><br><span class="line"></span><br><span class="line">14.□.4 出价策略 □67</span><br><span class="line"></span><br><span class="line">14.3 供给方□台. □67</span><br><span class="line"></span><br><span class="line">14.4 延伸思考 □68</span><br><span class="line"></span><br><span class="line">□□5章其他广告相关技术 □69</span><br><span class="line"></span><br><span class="line">15.1 创意优化 □70</span><br><span class="line"></span><br><span class="line">15.1.1 程序化创意. □70</span><br><span class="line"></span><br><span class="line">15.1.□ 点击热力图. □71</span><br><span class="line"></span><br><span class="line">15.□ 实验框架 □7□</span><br><span class="line"></span><br><span class="line">15.3 流量保护和效果监测 □73</span><br><span class="line"></span><br><span class="line">15.3.1 反作弊 □73</span><br><span class="line"></span><br><span class="line">15.3.□ 广告监测 □76</span><br><span class="line"></span><br><span class="line">15.3.3 广告安全 □77</span><br><span class="line"></span><br><span class="line">15.4 隐私保护和数据安全 □78</span><br><span class="line"></span><br><span class="line">15.4.1 隐私保护问题. □78</span><br><span class="line"></span><br><span class="line">15.4.□ 程序化交易中的数据安全 □80</span><br><span class="line"></span><br><span class="line">15.5 延伸思考 □8□</span><br><span class="line"></span><br><span class="line">第四部分附录</span><br><span class="line"></span><br><span class="line">附录A主要术语及缩写索引. □85</span><br><span class="line"></span><br><span class="line">参考文献 □91</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>百面机器学习 PDF</title>
    <url>/posts/bcee7062/</url>
    <content><![CDATA[<h4 id="《百面机器学习》"><a href="#《百面机器学习》" class="headerlink" title="《百面机器学习》"></a>《百面机器学习》</h4><h6 id="链接-https-pan-baidu-com-s-1fZgli2Lkd00XcStqm-36xQ"><a href="#链接-https-pan-baidu-com-s-1fZgli2Lkd00XcStqm-36xQ" class="headerlink" title="链接:https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ"></a>链接:<a href="https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ">https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ</a></h6><p>《百面机器学习 算法工程师带你去面试》<br><a id="more"></a></p>
<p>人工智能领域正在以超乎人们想象的速度发展，本书赶在人工智能彻底占领世界之前完成编写，实属万幸。</p>
<p>书中收录了超过100道机器学习算法工程师的面试题目和解答，其中大部分源于Hulu算法研究岗位的真实场景。本书从日常工作、生活中各种有趣的现象出发，不仅囊括了机器学习的基本知识，而且还包含了成为出众算法工程师的相关技能，更重要的是凝聚了笔者对人工智能领域的一颗热忱之心，旨在培养读者发现问题、解决问题、扩展问题的能力，建立对机器学习的热爱，共绘人工智能世界的宏伟蓝图。</p>
<p>“不积跬步，无以至千里”，本书将从特征工程、模型评估、降维等经典机器学习领域出发，构建一个算法工程师必-备的知识体系；见神经网络、强化学习、生成对抗网络等新科研进展之微，知深度学习领域胜败兴衰之著；“博观而约取，厚积而薄发”，在末一章为读者展示生活中各种引领时代的人工智能应用。</p>
<h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《百面机器学习　算法工程师带你去面试》</span><br><span class="line"></span><br><span class="line">推荐序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">机器学习算法工程师的自我修养</span><br><span class="line"></span><br><span class="line">第 1章 特征工程</span><br><span class="line"></span><br><span class="line">第 1节 特征归一化</span><br><span class="line"></span><br><span class="line">第 2节 类别型特征</span><br><span class="line"></span><br><span class="line">第3节 高维组合特征的处理</span><br><span class="line"></span><br><span class="line">第4节 组合特征</span><br><span class="line"></span><br><span class="line">第5节 文本表示模型</span><br><span class="line"></span><br><span class="line">第6节 Word2Vec</span><br><span class="line"></span><br><span class="line">第7节 图像数据不足时的处理方法</span><br><span class="line"></span><br><span class="line">第 2章 模型评估</span><br><span class="line"></span><br><span class="line">第 1节 评估指标的局限性</span><br><span class="line"></span><br><span class="line">第 2节 ROC 曲线</span><br><span class="line"></span><br><span class="line">第3节 余弦距离的应用</span><br><span class="line"></span><br><span class="line">第4节 A&#x2F;B 测试的陷阱</span><br><span class="line"></span><br><span class="line">第5节 模型评估的方法</span><br><span class="line"></span><br><span class="line">第6节 超参数调优</span><br><span class="line"></span><br><span class="line">第7节 过拟合与欠拟合</span><br><span class="line"></span><br><span class="line">第3章 经典算法</span><br><span class="line"></span><br><span class="line">第 1节 支持向量机</span><br><span class="line"></span><br><span class="line">第 2节 逻辑回归</span><br><span class="line"></span><br><span class="line">第3节 决策树</span><br><span class="line"></span><br><span class="line">第4章 降维</span><br><span class="line"></span><br><span class="line">第 1节 PCA 最大方差理论</span><br><span class="line"></span><br><span class="line">第 2节 PCA 最小平方误差理论</span><br><span class="line"></span><br><span class="line">第3节 线性判别分析</span><br><span class="line"></span><br><span class="line">第4节 线性判别分析与主成分分析</span><br><span class="line"></span><br><span class="line">第5章 非监督学习</span><br><span class="line"></span><br><span class="line">第 1节 K 均值聚类</span><br><span class="line"></span><br><span class="line">第 2节 高斯混合模型</span><br><span class="line"></span><br><span class="line">第3节 自组织映射神经网络</span><br><span class="line"></span><br><span class="line">第4节 非监督学习算法的评估</span><br><span class="line"></span><br><span class="line">第6章 概率图模型</span><br><span class="line"></span><br><span class="line">第 1节 概率图模型的联合概率分布</span><br><span class="line"></span><br><span class="line">第 2节 概率图表示</span><br><span class="line"></span><br><span class="line">第3节 生成式模型与判别式模型</span><br><span class="line"></span><br><span class="line">第4节 马尔可夫模型</span><br><span class="line"></span><br><span class="line">第5节 主题模型</span><br><span class="line"></span><br><span class="line">第7章 优化算法</span><br><span class="line"></span><br><span class="line">第 1节 有监督学习的损失函数</span><br><span class="line"></span><br><span class="line">第 2节 机器学习中的优化问题</span><br><span class="line"></span><br><span class="line">第3节 经典优化算法</span><br><span class="line"></span><br><span class="line">第4节 梯度验证</span><br><span class="line"></span><br><span class="line">第5节 随机梯度下降法</span><br><span class="line"></span><br><span class="line">第6节 随机梯度下降法的加速</span><br><span class="line"></span><br><span class="line">第7节 L1 正则化与稀疏性</span><br><span class="line"></span><br><span class="line">第8章 采样</span><br><span class="line"></span><br><span class="line">第 1节 采样的作用</span><br><span class="line"></span><br><span class="line">第 2节 均匀分布随机数</span><br><span class="line"></span><br><span class="line">第3节 常见的采样方法</span><br><span class="line"></span><br><span class="line">第4节 高斯分布的采样</span><br><span class="line"></span><br><span class="line">第5节 马尔科夫蒙特卡洛采样法</span><br><span class="line"></span><br><span class="line">第6节 贝叶斯网络的采样</span><br><span class="line"></span><br><span class="line">第7节 不均衡样本集的重采样</span><br><span class="line"></span><br><span class="line">第9章 前向神经网络</span><br><span class="line"></span><br><span class="line">第 1节 多层感知机与布尔函数</span><br><span class="line"></span><br><span class="line">第 2节 深度神经网络中的激活函数</span><br><span class="line"></span><br><span class="line">第3节 多层感知机的反向传播算法</span><br><span class="line"></span><br><span class="line">第4节 神经网络训练技巧</span><br><span class="line"></span><br><span class="line">第5节 深度卷积神经网络</span><br><span class="line"></span><br><span class="line">第6节 深度残差网络</span><br><span class="line"></span><br><span class="line">第 10章 循环神经网络</span><br><span class="line"></span><br><span class="line">第 1节 循环神经网络和卷积神经网络</span><br><span class="line"></span><br><span class="line">第 2节 循环神经网络的梯度消失问题</span><br><span class="line"></span><br><span class="line">第3节 循环神经网络中的激活函数</span><br><span class="line"></span><br><span class="line">第4节 长短期记忆网络</span><br><span class="line"></span><br><span class="line">第5节 Seq2Seq 模型</span><br><span class="line"></span><br><span class="line">第6节 注意力机制</span><br><span class="line"></span><br><span class="line">第 11章 强化学习</span><br><span class="line"></span><br><span class="line">第 1节　强化学习基础</span><br><span class="line"></span><br><span class="line">第 2节 视频游戏里的强化学习</span><br><span class="line"></span><br><span class="line">第3节 策略梯度</span><br><span class="line"></span><br><span class="line">第4节 探索与利用</span><br><span class="line"></span><br><span class="line">第 12章 集成学习</span><br><span class="line"></span><br><span class="line">第 1节 集成学习的种类</span><br><span class="line"></span><br><span class="line">第 2节 集成学习的步骤和例子</span><br><span class="line"></span><br><span class="line">第3节 基分类器</span><br><span class="line"></span><br><span class="line">第4节 偏差与方差</span><br><span class="line"></span><br><span class="line">第5节 梯度提升决策树的基本原理</span><br><span class="line"></span><br><span class="line">第6节 XGBoost 与GBDT 的联系和区别</span><br><span class="line"></span><br><span class="line">第 13章 生成式对抗网络</span><br><span class="line"></span><br><span class="line">第 1节 初识GANs 的秘密</span><br><span class="line"></span><br><span class="line">第 2节 WGAN：抓住低维的幽灵</span><br><span class="line"></span><br><span class="line">第3节 DCGAN：当GANs 遇上卷积</span><br><span class="line"></span><br><span class="line">第4节 ALI：包揽推断业务</span><br><span class="line"></span><br><span class="line">第5节 IRGAN：生成离散样本</span><br><span class="line"></span><br><span class="line">第6节 SeqGAN：生成文本序列</span><br><span class="line"></span><br><span class="line">第 14章 人工智能的热门应用</span><br><span class="line"></span><br><span class="line">第 1节 计算广告</span><br><span class="line"></span><br><span class="line">第 2节 游戏中的人工智能</span><br><span class="line"></span><br><span class="line">第3节 AI 在自动驾驶中的应用</span><br><span class="line"></span><br><span class="line">第4节 机器翻译</span><br><span class="line"></span><br><span class="line">第5节 人机交互中的智能计算</span><br><span class="line"></span><br><span class="line">后记</span><br><span class="line"></span><br><span class="line">作者随笔</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">《百面深度学习 算法工程师带你去面试》</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第 一部分 算法和模型</span><br><span class="line"></span><br><span class="line">第 1章 卷积神经网络</span><br><span class="line"></span><br><span class="line">01 卷积基础知识</span><br><span class="line"></span><br><span class="line">02 卷积的变种</span><br><span class="line"></span><br><span class="line">03 卷积神经网络的整体结构</span><br><span class="line"></span><br><span class="line">04 卷积神经网络的基础模块</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 2章 循环神经网络</span><br><span class="line"></span><br><span class="line">01 循环神经网络与序列建模</span><br><span class="line"></span><br><span class="line">02 循环神经网络中的Dropout</span><br><span class="line"></span><br><span class="line">03 循环神经网络中的长期依赖问题</span><br><span class="line"></span><br><span class="line">04 长短期记忆网络</span><br><span class="line"></span><br><span class="line">05 Seq2Seq 架构</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第3章 图神经网络</span><br><span class="line"></span><br><span class="line">01 图神经网络的基本结构</span><br><span class="line"></span><br><span class="line">02 图神经网络在推荐系统中的应用</span><br><span class="line"></span><br><span class="line">03 图神经网络的推理能力</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第4章 生成模型</span><br><span class="line"></span><br><span class="line">01 深度信念网络与深度波尔兹曼机</span><br><span class="line"></span><br><span class="line">02 变分自编码器基础知识</span><br><span class="line"></span><br><span class="line">03 变分自编码器的改进</span><br><span class="line"></span><br><span class="line">04 生成式矩匹配网络与深度自回归网络</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第5章 生成式对抗网络</span><br><span class="line"></span><br><span class="line">01 生成式对抗网络的基本原理</span><br><span class="line"></span><br><span class="line">02 生成式对抗网络的改进</span><br><span class="line"></span><br><span class="line">03 生成式对抗网络的效果评估</span><br><span class="line"></span><br><span class="line">04 生成式对抗网络的应用</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第6章 强化学习</span><br><span class="line"></span><br><span class="line">01 强化学习基础知识</span><br><span class="line"></span><br><span class="line">02 强化学习算法</span><br><span class="line"></span><br><span class="line">03 深度强化学习</span><br><span class="line"></span><br><span class="line">04 强化学习的应用</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第7章 元学习</span><br><span class="line"></span><br><span class="line">01 元学习的主要概念</span><br><span class="line"></span><br><span class="line">02 元学习的主要方法</span><br><span class="line"></span><br><span class="line">03 元学习的数据集准备</span><br><span class="line"></span><br><span class="line">04 元学习的两个简单模型</span><br><span class="line"></span><br><span class="line">05 基于度量学习的元学习模型</span><br><span class="line"></span><br><span class="line">06 基于神经图灵机的元学习模型</span><br><span class="line"></span><br><span class="line">07 基于学习优化器的元学习模型</span><br><span class="line"></span><br><span class="line">08 基于学习初始点的元学习模型</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第8章 自动化机器学习</span><br><span class="line"></span><br><span class="line">01 自动化机器学习的基本概念</span><br><span class="line"></span><br><span class="line">02 模型和超参数自动化调优</span><br><span class="line"></span><br><span class="line">03 神经网络架构搜索</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第二部分 应用</span><br><span class="line"></span><br><span class="line">第9章 计算机视觉</span><br><span class="line"></span><br><span class="line">01 物体检测</span><br><span class="line"></span><br><span class="line">02 图像分割</span><br><span class="line"></span><br><span class="line">03 光学字符识别</span><br><span class="line"></span><br><span class="line">04 图像标注</span><br><span class="line"></span><br><span class="line">05 人体姿态识别</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 10章 自然语言处理</span><br><span class="line"></span><br><span class="line">01 语言的特征表示</span><br><span class="line"></span><br><span class="line">02 机器翻译</span><br><span class="line"></span><br><span class="line">03 问答系统</span><br><span class="line"></span><br><span class="line">04 对话系统</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 11章　推荐系统</span><br><span class="line"></span><br><span class="line">01　推荐系统基础</span><br><span class="line"></span><br><span class="line">02　推荐系统设计与算法</span><br><span class="line"></span><br><span class="line">03　推荐系统评估</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　12章 计算广告</span><br><span class="line"></span><br><span class="line">01　点击率预估</span><br><span class="line"></span><br><span class="line">02　广告召回</span><br><span class="line"></span><br><span class="line">03　广告投放策略</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　13章 视频处理</span><br><span class="line"></span><br><span class="line">01　视频编解码</span><br><span class="line"></span><br><span class="line">02　视频监控</span><br><span class="line"></span><br><span class="line">03　图像质量评价</span><br><span class="line"></span><br><span class="line">04　超分辨率重建</span><br><span class="line"></span><br><span class="line">05　网络通信</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　14章 计算机听觉</span><br><span class="line"></span><br><span class="line">01　音频信号的特征提取</span><br><span class="line"></span><br><span class="line">02　自动语音识别</span><br><span class="line"></span><br><span class="line">03　音频事件识别</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　15章 自动驾驶</span><br><span class="line"></span><br><span class="line">01　自动驾驶的基本概念</span><br><span class="line"></span><br><span class="line">02　端到端的自动驾驶模型</span><br><span class="line"></span><br><span class="line">03　自动驾驶的决策系统</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">作者随笔</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Sed and Awk 101 Hacks -中文版 PDF</title>
    <url>/posts/cbe940f4/</url>
    <content><![CDATA[<h4 id="《Sed-and-Awk-101-Hacks-中文版》"><a href="#《Sed-and-Awk-101-Hacks-中文版》" class="headerlink" title="《Sed and Awk 101 Hacks -中文版》"></a>《Sed and Awk 101 Hacks -中文版》</h4><p>目前来说是 Sed 和 Awk 最经典书籍，大家不妨可以看下</p>
<h6 id="链接-https-pan-baidu-com-s-1L2hJuEQQJZuhamLirIi4rQ-提取码-46s7"><a href="#链接-https-pan-baidu-com-s-1L2hJuEQQJZuhamLirIi4rQ-提取码-46s7" class="headerlink" title="链接:https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ 提取码:46s7"></a>链接:<a href="https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ">https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ</a> 提取码:46s7</h6><a id="more"></a>
<h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p><img src="/images/ed43074ae0612e2237cbcba5d38568ab1.jpg" width="50%" height="50%"></p>
<p><img src="/images/ed43074ae0612e2237cbcba5d38568ab2.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第一章:Sed 语法和基本命令 </span><br><span class="line"></span><br><span class="line">第二章:sed 替换命令 </span><br><span class="line"></span><br><span class="line">第三章:正则表达式</span><br><span class="line"></span><br><span class="line">第四章:执行 sed </span><br><span class="line"></span><br><span class="line">第五章:sed 附加命令 </span><br><span class="line"></span><br><span class="line">第六章:保持空间和模式空间命令</span><br><span class="line"></span><br><span class="line">第九章:awk 内置变量 </span><br><span class="line"></span><br><span class="line">第十章:awk 变量的操作符 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>labuladong的算法小抄官方完整版 PDF</title>
    <url>/posts/52e0114e/</url>
    <content><![CDATA[<h4 id="《labuladong的算法小抄官方完整版》"><a href="#《labuladong的算法小抄官方完整版》" class="headerlink" title="《labuladong的算法小抄官方完整版》"></a>《labuladong的算法小抄官方完整版》</h4><h4 id="本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF"><a href="#本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF" class="headerlink" title="本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF"></a>本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF</h4><h4 id="获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="获取链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>获取链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><a id="more"></a>
<!-- more -->
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h4 id="获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="获取链接：https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>获取链接：<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h4><p>前不久在 GitHub 出现了一个手把手带你刷 LeetCode 的项目：fucking-algorithm。 该项目此前在 GitHub 开源后，连续多次霸榜 GitHub Trending 首页，用了两个月 Star 数便破 50k，受欢迎程度由此可见一斑。</p>
<p><img src="/images/1765143a58f6ddd6c3fd6df4dfb347be1.jpg" width="50%" height="50%"></p>
<h4 id="链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱-1"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱-1" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 核心套路篇 ／ 21</span><br><span class="line"></span><br><span class="line">1.1 学习算法和刷题的框架思维 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.1 数据结构的存储方式 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.2 数据结构的基本操作 ／ 23</span><br><span class="line"></span><br><span class="line">1.1.3 算法刷题指南 ／ 25</span><br><span class="line"></span><br><span class="line">1.1.4 最后总结 ／ 30</span><br><span class="line"></span><br><span class="line">1.2 动态规划解题套路框架 ／ 31</span><br><span class="line"></span><br><span class="line">1.2.1 斐波那契数列 ／ 32</span><br><span class="line"></span><br><span class="line">1.2.2 凑零钱问题 ／ 37</span><br><span class="line"></span><br><span class="line">1.2.3 最后总结 ／ 42</span><br><span class="line"></span><br><span class="line">1.3 回溯算法解题套路框架 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.1 全排列问题 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.2 N 皇后问题 ／ 48</span><br><span class="line"></span><br><span class="line">1.3.3 最后总结 ／ 51</span><br><span class="line"></span><br><span class="line">1.4 BFS 算法套路框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.1 算法框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.2 二叉树的最小高度 ／ 54</span><br><span class="line"></span><br><span class="line">1.4.3 解开密码锁的最少次数 ／ 56</span><br><span class="line"></span><br><span class="line">1.5 双指针技巧套路框架 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.1 快、慢指针的常用算法 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.2 左、右指针的常用算法 ／ 68</span><br><span class="line"></span><br><span class="line">1.6 我写了首诗，保你闭着眼睛都能写出二分搜索算法 ／ 71</span><br><span class="line"></span><br><span class="line">1.6.1 二分搜索框架 ／ 72</span><br><span class="line"></span><br><span class="line">1.6.2 寻找一个数（基本的二分搜索） ／ 73</span><br><span class="line"></span><br><span class="line">1.6.3 寻找左侧边界的二分搜索 ／ 75</span><br><span class="line"></span><br><span class="line">1.6.4 寻找右侧边界的二分搜索 ／ 79</span><br><span class="line"></span><br><span class="line">1.6.5 逻辑统一 ／ 82</span><br><span class="line"></span><br><span class="line">1.7 我写了一个模板，把滑动窗口算法变成了默写题 ／ 85</span><br><span class="line"></span><br><span class="line">1.7.1 最小覆盖子串 ／ 87</span><br><span class="line"></span><br><span class="line">1.7.2 字符串排列 ／ 91</span><br><span class="line"></span><br><span class="line">1.7.3 找所有字母异位词 ／ 93</span><br><span class="line"></span><br><span class="line">1.7.4 最长无重复子串 ／ 94</span><br><span class="line"></span><br><span class="line">第2章 动态规划系列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1 动态规划设计：最长递增子序列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1.1 动态规划解法 ／ 97</span><br><span class="line"></span><br><span class="line">2.1.2 二分搜索解法 ／ 100</span><br><span class="line"></span><br><span class="line">2.2 二维递增子序列：信封嵌套问题 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.1 题目概述 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.2 思路分析 ／ 105</span><br><span class="line"></span><br><span class="line">2.2.3 最后总结 ／ 107</span><br><span class="line"></span><br><span class="line">2.3 最大子数组问题 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.1 思路分析 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.2 最后总结 ／ 110</span><br><span class="line"></span><br><span class="line">2.4 动态规划答疑：最优子结构及dp 遍历方向 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.1 最优子结构详解 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.2 dp 数组的遍历方向 ／ 113</span><br><span class="line"></span><br><span class="line">2.5 经典动态规划：最长公共子序列 ／ 117</span><br><span class="line"></span><br><span class="line">2.6 经典动态规划：编辑距离 ／ 123</span><br><span class="line"></span><br><span class="line">2.6.1 思路分析 ／ 124</span><br><span class="line"></span><br><span class="line">2.6.2 代码详解 ／ 125</span><br><span class="line"></span><br><span class="line">2.6.3 动态规划优化 ／ 129</span><br><span class="line"></span><br><span class="line">2.6.4 扩展延伸 ／ 131</span><br><span class="line"></span><br><span class="line">2.7 子序列问题解题模板：最长回文子序列 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.1 两种思路 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.2 最长回文子序列 ／ 137</span><br><span class="line"></span><br><span class="line">2.7.3 代码实现 ／ 139</span><br><span class="line"></span><br><span class="line">2.8 状态压缩：对动态规划进行降维打击 ／ 141</span><br><span class="line"></span><br><span class="line">2.9 以最小插入次数构造回文串 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.1 思路分析 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.2 状态转移方程 ／ 149</span><br><span class="line"></span><br><span class="line">2.9.3 代码实现 ／ 152</span><br><span class="line"></span><br><span class="line">2.10 动态规划之正则表达式 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.1 思路分析 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.2 动态规划解法 ／ 157</span><br><span class="line"></span><br><span class="line">2.11 不同的定义产生不同的解法 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.1 第一种思路 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.2 第二种思路 ／ 165</span><br><span class="line"></span><br><span class="line">2.11.3 最后总结 ／ 167</span><br><span class="line"></span><br><span class="line">2.12 经典动态规划：高楼扔鸡蛋 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.1 解析题目 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.2 思路分析 ／ 169</span><br><span class="line"></span><br><span class="line">2.12.3 疑难解答 ／ 172</span><br><span class="line"></span><br><span class="line">2.13 经典动态规划：高楼扔鸡蛋（进阶） ／ 173</span><br><span class="line"></span><br><span class="line">2.13.1 二分搜索优化 ／ 173</span><br><span class="line"></span><br><span class="line">2.13.2 重新定义状态转移 ／ 176</span><br><span class="line"></span><br><span class="line">2.13.3 还可以再优化 ／ 180</span><br><span class="line"></span><br><span class="line">2.14 经典动态规划：戳气球问题 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.1 回溯思路 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.2 动态规划思路 ／ 182</span><br><span class="line"></span><br><span class="line">2.14.3 写出代码 ／ 185</span><br><span class="line"></span><br><span class="line">2.15 经典动态规划：0-1 背包问题 ／ 188</span><br><span class="line"></span><br><span class="line">2.16 经典动态规划：子集背包问题 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.1 问题分析 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.2 思路分析 ／ 193</span><br><span class="line"></span><br><span class="line">2.16.3 进行状态压缩 ／ 194</span><br><span class="line"></span><br><span class="line">2.17 经典动态规划：完全背包问题 ／ 196</span><br><span class="line"></span><br><span class="line">2.18 题目千百变，套路不会变 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.1 线性排列情况 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.2 环形排列情况 ／ 203</span><br><span class="line"></span><br><span class="line">2.18.3 树形排列情况 ／ 205</span><br><span class="line"></span><br><span class="line">2.19 动态规划和回溯算法，到底是什么关系 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.1 回溯思路 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.2 消除重叠子问题 ／ 210</span><br><span class="line"></span><br><span class="line">2.19.3 动态规划 ／ 211</span><br><span class="line"></span><br><span class="line">第3章 数据结构系列 ／ 216</span><br><span class="line"></span><br><span class="line">3.1 手把手教你写 LRU 缓存淘汰算法 ／ 216</span><br><span class="line"></span><br><span class="line">3.1.1 LRU 算法描述 ／ 218</span><br><span class="line"></span><br><span class="line">3.1.2 LRU 算法设计 ／ 219</span><br><span class="line"></span><br><span class="line">3.1.3 代码实现 ／ 220</span><br><span class="line"></span><br><span class="line">3.2 层层拆解，带你手写LFU 算法 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.1 算法描述 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.2 思路分析 ／ 228</span><br><span class="line"></span><br><span class="line">3.2.3 代码框架 ／ 230</span><br><span class="line"></span><br><span class="line">3.2.4 LFU 核心逻辑 ／ 232</span><br><span class="line"></span><br><span class="line">3.3 二叉搜索树操作集锦 ／ 235</span><br><span class="line"></span><br><span class="line">3.3.1 判断 BST 的合法性 ／ 236</span><br><span class="line"></span><br><span class="line">3.3.2 在 BST 中查找一个数是否存在 ／ 238</span><br><span class="line"></span><br><span class="line">3.3.3 在 BST 中插入一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.3.4 在 BST 中删除一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.4 完全二叉树的节点数为什么那么难算 ／ 243</span><br><span class="line"></span><br><span class="line">3.4.1 思路分析 ／ 244</span><br><span class="line"></span><br><span class="line">3.4.2 复杂度分析 ／ 245</span><br><span class="line"></span><br><span class="line">3.5 用各种遍历框架序列化和反序列化二叉树 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.1 题目描述 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.2 前序遍历解法 ／ 248</span><br><span class="line"></span><br><span class="line">3.5.3 后序遍历解法 ／ 252</span><br><span class="line"></span><br><span class="line">3.5.4 中序遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.5.5 层级遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.6 Git 原理之二叉树最近公共祖先 ／ 260</span><br><span class="line"></span><br><span class="line">3.6.1 二叉树的最近公共祖先 ／ 261</span><br><span class="line"></span><br><span class="line">3.6.2 思路分析 ／ 263</span><br><span class="line"></span><br><span class="line">3.7 特殊数据结构：单调栈 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.1 单调栈解题模板 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.2 题目变形 ／ 268</span><br><span class="line"></span><br><span class="line">3.7.3 如何处理循环数组 ／ 268</span><br><span class="line"></span><br><span class="line">3.8 特殊数据结构：单调队列 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.1 搭建解题框架 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.2 实现单调队列数据结构 ／ 273</span><br><span class="line"></span><br><span class="line">3.8.3 算法复杂度分析 ／ 276</span><br><span class="line"></span><br><span class="line">3.9 如何判断回文链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.1 判断回文单链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.2 优化空间复杂度 ／ 280</span><br><span class="line"></span><br><span class="line">3.9.3 最后总结 ／ 282</span><br><span class="line"></span><br><span class="line">3.10 秀操作之纯递归反转链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.1 递归反转整个链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.2 反转链表前N 个节点 ／ 286</span><br><span class="line"></span><br><span class="line">3.10.3 反转链表的一部分 ／ 287</span><br><span class="line"></span><br><span class="line">3.10.4 最后总结 ／ 288</span><br><span class="line"></span><br><span class="line">3.11 秀操作之k 个一组反转链表 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.1 分析问题 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.2 代码实现 ／ 291</span><br><span class="line"></span><br><span class="line">3.11.3 最后总结 ／ 292</span><br><span class="line"></span><br><span class="line">第4章 算法思维系列 ／ 293</span><br><span class="line"></span><br><span class="line">4.1 回溯算法解决子集、组合、排列问题 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.1 子集 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.2 组合 ／ 297</span><br><span class="line"></span><br><span class="line">4.1.3 排列 ／ 299</span><br><span class="line"></span><br><span class="line">4.2 回溯算法最佳实践：解数独 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.1 直观感受 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.2 代码实现 ／ 301</span><br><span class="line"></span><br><span class="line">4.3 回溯算法最佳实践：括号生成 ／ 306</span><br><span class="line"></span><br><span class="line">4.4 BFS 算法暴力破解各种智力题 ／ 310</span><br><span class="line"></span><br><span class="line">4.4.1 题目解析 ／ 311</span><br><span class="line"></span><br><span class="line">4.4.2 思路分析 ／ 311</span><br><span class="line"></span><br><span class="line">4.5 2Sum 问题的核心思想 ／ 315</span><br><span class="line"></span><br><span class="line">4.5.1 2Sum I ／ 315</span><br><span class="line"></span><br><span class="line">4.5.2 2Sum II ／ 316</span><br><span class="line"></span><br><span class="line">4.5.3 最后总结 ／ 318</span><br><span class="line"></span><br><span class="line">4.6 一个函数解决 nSum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.1 2Sum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.2 3Sum 问题 ／ 322</span><br><span class="line"></span><br><span class="line">4.6.3 4Sum 问题 ／ 324</span><br><span class="line"></span><br><span class="line">4.6.4 100Sum 问题 ／ 325</span><br><span class="line"></span><br><span class="line">4.7 拆解复杂问题：实现计算器 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.1 字符串转整数 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.2 处理加减法 ／ 329</span><br><span class="line"></span><br><span class="line">4.7.3 处理乘除法 ／ 331</span><br><span class="line"></span><br><span class="line">4.7.4 处理括号 ／ 333</span><br><span class="line"></span><br><span class="line">4.7.5 最后总结 ／ 336</span><br><span class="line"></span><br><span class="line">4.8 摊烧饼也得有点递归思维 ／ 337</span><br><span class="line"></span><br><span class="line">4.8.1 思路分析 ／ 338</span><br><span class="line"></span><br><span class="line">4.8.2 代码实现 ／ 339</span><br><span class="line"></span><br><span class="line">4.9 前缀和技巧解决子数组问题 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.1 什么是前缀和 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.2 优化解法 ／ 343</span><br><span class="line"></span><br><span class="line">4.9.3 最后总结 ／ 344</span><br><span class="line"></span><br><span class="line">4.10 扁平化嵌套列表 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.1 题目描述 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.2 解题思路 ／ 346</span><br><span class="line"></span><br><span class="line">4.10.3 进阶思路 ／ 349</span><br><span class="line"></span><br><span class="line">第5章 高频面试系列 ／ 351</span><br><span class="line"></span><br><span class="line">5.1 如何高效寻找素数 ／ 351</span><br><span class="line"></span><br><span class="line">5.2 如何高效进行模幂运算 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.1 如何处理数组指数 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.2 如何处理 mod 运算 ／ 356</span><br><span class="line"></span><br><span class="line">5.2.3 如何高效求幂 ／ 358</span><br><span class="line"></span><br><span class="line">5.3 如何运用二分搜索算法 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.1 问题分析 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.2 扩展延伸 ／ 362</span><br><span class="line"></span><br><span class="line">5.4 如何高效解决接雨水问题 ／ 364</span><br><span class="line"></span><br><span class="line">5.5 如何去除有序数组的重复元素 ／ 371</span><br><span class="line"></span><br><span class="line">5.6 如何寻找最长回文子串 ／ 373</span><br><span class="line"></span><br><span class="line">5.7 如何运用贪心思想玩跳跃游戏 ／ 376</span><br><span class="line"></span><br><span class="line">5.8 如何运用贪心算法做时间管理 ／ 381</span><br><span class="line"></span><br><span class="line">5.9 如何判定括号合法性 ／ 386</span><br><span class="line"></span><br><span class="line">5.10 如何调度考生的座位 ／ 389</span><br><span class="line"></span><br><span class="line">5.11 Union-Find 算法详解 ／ 396</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>NumPy学习指南（第2版）版 PDF</title>
    <url>/posts/25e721d8/</url>
    <content><![CDATA[<h4 id="《NumPy学习指南（第2版）版》"><a href="#《NumPy学习指南（第2版）版》" class="headerlink" title="《NumPy学习指南（第2版）版》"></a>《NumPy学习指南（第2版）版》</h4><h6 id="链接-https-pan-baidu-com-s-1JgvWbUdRzQtyvsaNTGu1Fw-提取码-3nwc"><a href="#链接-https-pan-baidu-com-s-1JgvWbUdRzQtyvsaNTGu1Fw-提取码-3nwc" class="headerlink" title="链接:https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw 提取码:3nwc"></a>链接:<a href="https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw">https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw</a> 提取码:3nwc</h6><p><img src="/images/6d2c79ab5153f9556165b4778c3ea5431.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p>《图灵程序设计丛书;Python数据分析基础教程：NumPy学习指南（第2版）》是NumPy的入门教程，主要介绍NumPy以及相关的Python科学计算库，如SciPy和Matplotlib。《图灵程序设计丛书;Python数据分析基础教程：NumPy学习指南（第2版）》内容涵盖NumPy安装、数组对象、常用函数、矩阵运算、线性代数、金融函数、窗函数、质量控制、Matplotlib绘图、SciPy简介以及Pygame等内容，涉及面较广。另外，Ivan　Idris针对每个知识点给出了简短而明晰的示例，并为大部分示例给出了实用场景（如股票数据分析），在帮助初学者入门的同时，提高了本书可读性。</p>
<h6 id="链接-https-pan-baidu-com-s-1JgvWbUdRzQtyvsaNTGu1Fw-提取码-3nwc-1"><a href="#链接-https-pan-baidu-com-s-1JgvWbUdRzQtyvsaNTGu1Fw-提取码-3nwc-1" class="headerlink" title="链接:https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw 提取码:3nwc"></a>链接:<a href="https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw">https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw</a> 提取码:3nwc</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章　NumPy快速入门</span><br><span class="line"></span><br><span class="line">1.1 　Python</span><br><span class="line"></span><br><span class="line">1.2 　动手实践：在不同的操作系统上安装Python</span><br><span class="line"></span><br><span class="line">1.3 　Windows</span><br><span class="line"></span><br><span class="line">1.4 　动手实践：在Windows上安装NumPy、Matplotlib、SciPy和IPython</span><br><span class="line"></span><br><span class="line">1.5 　Linux</span><br><span class="line"></span><br><span class="line">1.6 　动手实践：在Linux上安装NumPy、Matplotlib、SciPy和IPython</span><br><span class="line"></span><br><span class="line">1.7 　Mac OS X</span><br><span class="line"></span><br><span class="line">1.8 　动手实践：在Mac OS X上安装NumPy、Matplotlib和SciPy</span><br><span class="line"></span><br><span class="line">1.9 　动手实践：使用MacPorts或Fink安装NumPy、SciPy、Matplotlib和IPython</span><br><span class="line"></span><br><span class="line">1.10 　编译源代码</span><br><span class="line"></span><br><span class="line">1.11 　数组对象</span><br><span class="line"></span><br><span class="line">1.12 　动手实践：向量加法</span><br><span class="line"></span><br><span class="line">1.13 　IPython：一个交互式shell工具</span><br><span class="line"></span><br><span class="line">1.14 　在线资源和帮助</span><br><span class="line"></span><br><span class="line">1.15 　本章小结</span><br><span class="line"></span><br><span class="line">第2章　NumPy基础</span><br><span class="line"></span><br><span class="line">2.1 　NumPy数组对象</span><br><span class="line"></span><br><span class="line">2.2 　动手实践：创建多维数组</span><br><span class="line"></span><br><span class="line">2.2.1 　选取数组元素</span><br><span class="line"></span><br><span class="line">2.2.2 　NumPy数据类型</span><br><span class="line"></span><br><span class="line">2.2.3 　数据类型对象</span><br><span class="line"></span><br><span class="line">2.2.4 　字符编码</span><br><span class="line"></span><br><span class="line">2.2.5 　自定义数据类型</span><br><span class="line"></span><br><span class="line">2.2.6 　dtype类的属性</span><br><span class="line"></span><br><span class="line">2.3 　动手实践：创建自定义数据类型</span><br><span class="line"></span><br><span class="line">2.4 　一维数组的索引和切片</span><br><span class="line"></span><br><span class="line">2.5 　动手实践：多维数组的切片和索引</span><br><span class="line"></span><br><span class="line">2.6 　动手实践：改变数组的维度</span><br><span class="line"></span><br><span class="line">2.7 　数组的组合</span><br><span class="line"></span><br><span class="line">2.8 　动手实践：组合数组</span><br><span class="line"></span><br><span class="line">2.9 　数组的分割</span><br><span class="line"></span><br><span class="line">2.10 　动手实践：分割数组</span><br><span class="line"></span><br><span class="line">2.11 　数组的属性</span><br><span class="line"></span><br><span class="line">2.12 　动手实践：数组的转换</span><br><span class="line"></span><br><span class="line">2.13 　本章小结</span><br><span class="line"></span><br><span class="line">第3章　常用函数</span><br><span class="line"></span><br><span class="line">3.1 　文件读写</span><br><span class="line"></span><br><span class="line">3.2 　动手实践：读写文件</span><br><span class="line"></span><br><span class="line">3.3 　CSV文件</span><br><span class="line"></span><br><span class="line">3.4 　动手实践：读入CSV文件</span><br><span class="line"></span><br><span class="line">3.5 　成交量加权平均价格（VWAP）</span><br><span class="line"></span><br><span class="line">3.6 　动手实践：计算成交量加权平均价格</span><br><span class="line"></span><br><span class="line">3.6.1 　算术平均值函数</span><br><span class="line"></span><br><span class="line">3.6.2 　时间加权平均价格</span><br><span class="line"></span><br><span class="line">3.7 　取值范围</span><br><span class="line"></span><br><span class="line">3.8 　动手实践：找到最大值和最小值</span><br><span class="line"></span><br><span class="line">3.9 　统计分析</span><br><span class="line"></span><br><span class="line">3.10 　动手实践：简单统计分析</span><br><span class="line"></span><br><span class="line">3.11 　股票收益率</span><br><span class="line"></span><br><span class="line">3.12 　动手实践：分析股票收益率</span><br><span class="line"></span><br><span class="line">3.13 　日期分析</span><br><span class="line"></span><br><span class="line">3.14 　动手实践：分析日期数据</span><br><span class="line"></span><br><span class="line">3.15 　周汇总</span><br><span class="line"></span><br><span class="line">3.16 　动手实践：汇总数据</span><br><span class="line"></span><br><span class="line">3.17 　真实波动幅度均值（ATR）</span><br><span class="line"></span><br><span class="line">3.18 　动手实践：计算真实波动幅度均值</span><br><span class="line"></span><br><span class="line">3.19 　简单移动平均线</span><br><span class="line"></span><br><span class="line">3.20 　动手实践：计算简单移动平均线</span><br><span class="line"></span><br><span class="line">3.21 　指数移动平均线</span><br><span class="line"></span><br><span class="line">3.22 　动手实践：计算指数移动平均线</span><br><span class="line"></span><br><span class="line">3.23 　布林带</span><br><span class="line"></span><br><span class="line">3.24 　动手实践：绘制布林带</span><br><span class="line"></span><br><span class="line">3.25 　线性模型</span><br><span class="line"></span><br><span class="line">3.26 　动手实践：用线性模型预测价格</span><br><span class="line"></span><br><span class="line">3.27 　趋势线</span><br><span class="line"></span><br><span class="line">3.28 　动手实践：绘制趋势线</span><br><span class="line"></span><br><span class="line">3.29 　ndarray对象的方法</span><br><span class="line"></span><br><span class="line">3.30 　动手实践：数组的修剪和压缩</span><br><span class="line"></span><br><span class="line">3.31 　阶乘</span><br><span class="line"></span><br><span class="line">3.32 　动手实践：计算阶乘</span><br><span class="line"></span><br><span class="line">3.33 　本章小结</span><br><span class="line"></span><br><span class="line">第4章　便捷函数</span><br><span class="line"></span><br><span class="line">4.1 　相关性</span><br><span class="line"></span><br><span class="line">4.2 　动手实践：股票相关性分析</span><br><span class="line"></span><br><span class="line">4.3 　多项式</span><br><span class="line"></span><br><span class="line">4.4 　动手实践：多项式拟合</span><br><span class="line"></span><br><span class="line">4.5 　净额成交量</span><br><span class="line"></span><br><span class="line">4.6 　动手实践：计算OBV</span><br><span class="line"></span><br><span class="line">4.7 　交易过程模拟</span><br><span class="line"></span><br><span class="line">4.8 　动手实践：避免使用循环</span><br><span class="line"></span><br><span class="line">4.9 　数据平滑</span><br><span class="line"></span><br><span class="line">4.10 　动手实践：使用hanning函数平滑数据</span><br><span class="line"></span><br><span class="line">4.11 　本章小结</span><br><span class="line"></span><br><span class="line">第5章　矩阵和通用函数</span><br><span class="line"></span><br><span class="line">5.1 　矩阵</span><br><span class="line"></span><br><span class="line">5.2 　动手实践：创建矩阵</span><br><span class="line"></span><br><span class="line">5.3 　从已有矩阵创建新矩阵</span><br><span class="line"></span><br><span class="line">5.4 　动手实践：从已有矩阵创建新矩阵</span><br><span class="line"></span><br><span class="line">5.5 　通用函数</span><br><span class="line"></span><br><span class="line">5.6 　动手实践：创建通用函数</span><br><span class="line"></span><br><span class="line">5.7 　通用函数的方法</span><br><span class="line"></span><br><span class="line">5.8 　动手实践：在add上调用通用函数的方法</span><br><span class="line"></span><br><span class="line">5.9 　算术运算</span><br><span class="line"></span><br><span class="line">5.10 　动手实践：数组的除法运算</span><br><span class="line"></span><br><span class="line">5.11 　模运算</span><br><span class="line"></span><br><span class="line">5.12 　动手实践：模运算</span><br><span class="line"></span><br><span class="line">5.13 　斐波那契数列</span><br><span class="line"></span><br><span class="line">5.14 　动手实践：计算斐波那契数列</span><br><span class="line"></span><br><span class="line">5.15 　利萨茹曲线</span><br><span class="line"></span><br><span class="line">5.16 　动手实践：绘制利萨茹曲线</span><br><span class="line"></span><br><span class="line">5.17 　方波</span><br><span class="line"></span><br><span class="line">5.18 　动手实践：绘制方波</span><br><span class="line"></span><br><span class="line">5.19 　锯齿波和三角波</span><br><span class="line"></span><br><span class="line">5.20 　动手实践：绘制锯齿波和三角波</span><br><span class="line"></span><br><span class="line">5.21 　位操作函数和比较函数</span><br><span class="line"></span><br><span class="line">5.22 　动手实践：玩转二进制位</span><br><span class="line"></span><br><span class="line">5.23 　本章小结</span><br><span class="line"></span><br><span class="line">第6章　深入学习NumPy模块</span><br><span class="line"></span><br><span class="line">6.1 　线性代数</span><br><span class="line"></span><br><span class="line">6.2 　动手实践：计算逆矩阵</span><br><span class="line"></span><br><span class="line">6.3 　求解线性方程组</span><br><span class="line"></span><br><span class="line">6.4 　动手实践：求解线性方程组</span><br><span class="line"></span><br><span class="line">6.5 　特征值和特征向量</span><br><span class="line"></span><br><span class="line">6.6 　动手实践：求解特征值和特征向量</span><br><span class="line"></span><br><span class="line">6.7 　奇异值分解</span><br><span class="line"></span><br><span class="line">6.8 　动手实践：分解矩阵</span><br><span class="line"></span><br><span class="line">6.9 　广义逆矩阵</span><br><span class="line"></span><br><span class="line">6.10 　动手实践：计算广义逆矩阵</span><br><span class="line"></span><br><span class="line">6.11 　行列式</span><br><span class="line"></span><br><span class="line">6.12 　动手实践：计算矩阵的行列式</span><br><span class="line"></span><br><span class="line">6.13 　快速傅里叶变换</span><br><span class="line"></span><br><span class="line">6.14 　动手实践：计算傅里叶变换</span><br><span class="line"></span><br><span class="line">6.15 　移频</span><br><span class="line"></span><br><span class="line">6.16 　动手实践：移频</span><br><span class="line"></span><br><span class="line">6.17 　随机数</span><br><span class="line"></span><br><span class="line">6.18 　动手实践：硬币赌博游戏</span><br><span class="line"></span><br><span class="line">6.19 　超几何分布</span><br><span class="line"></span><br><span class="line">6.20 　动手实践：模拟游戏秀节目</span><br><span class="line"></span><br><span class="line">6.21 　连续分布</span><br><span class="line"></span><br><span class="line">6.22 　动手实践：绘制正态分布</span><br><span class="line"></span><br><span class="line">6.23 　对数正态分布</span><br><span class="line"></span><br><span class="line">6.24 　动手实践：绘制对数正态分布</span><br><span class="line"></span><br><span class="line">6.25 　本章小结</span><br><span class="line"></span><br><span class="line">第7章　专用函数</span><br><span class="line"></span><br><span class="line">7.1 　排序</span><br><span class="line"></span><br><span class="line">7.2 　动手实践：按字典序排序</span><br><span class="line"></span><br><span class="line">7.3 　复数</span><br><span class="line"></span><br><span class="line">7.4 　动手实践：对复数进行排序</span><br><span class="line"></span><br><span class="line">7.5 　搜索</span><br><span class="line"></span><br><span class="line">7.6 　动手实践：使用searchsorted函数</span><br><span class="line"></span><br><span class="line">7.7 　数组元素抽取</span><br><span class="line"></span><br><span class="line">7.8 　动手实践：从数组中抽取元素</span><br><span class="line"></span><br><span class="line">7.9 　金融函数</span><br><span class="line"></span><br><span class="line">7.10 　动手实践：计算终值</span><br><span class="line"></span><br><span class="line">7.11 　现值</span><br><span class="line"></span><br><span class="line">7.12 　动手实践：计算现值</span><br><span class="line"></span><br><span class="line">7.13 　净现值</span><br><span class="line"></span><br><span class="line">7.14 　动手实践：计算净现值</span><br><span class="line"></span><br><span class="line">7.15 　内部收益率</span><br><span class="line"></span><br><span class="line">7.16 　动手实践：计算内部收益率</span><br><span class="line"></span><br><span class="line">7.17 　分期付款</span><br><span class="line"></span><br><span class="line">7.18 　动手实践：计算分期付款</span><br><span class="line"></span><br><span class="line">7.19 　付款期数</span><br><span class="line"></span><br><span class="line">7.20 　动手实践：计算付款期数</span><br><span class="line"></span><br><span class="line">7.21 　利率</span><br><span class="line"></span><br><span class="line">7.22 　动手实践：计算利率</span><br><span class="line"></span><br><span class="line">7.23 　窗函数</span><br><span class="line"></span><br><span class="line">7.24 　动手实践：绘制巴特利特窗</span><br><span class="line"></span><br><span class="line">7.25 　布莱克曼窗</span><br><span class="line"></span><br><span class="line">7.26 　动手实践：使用布莱克曼窗平滑股价数据</span><br><span class="line"></span><br><span class="line">7.27 　汉明窗</span><br><span class="line"></span><br><span class="line">7.28 　动手实践：绘制汉明窗</span><br><span class="line"></span><br><span class="line">7.29 　凯泽窗</span><br><span class="line"></span><br><span class="line">7.30 　动手实践：绘制凯泽窗</span><br><span class="line"></span><br><span class="line">7.31 　专用数学函数</span><br><span class="line"></span><br><span class="line">7.32 　动手实践：绘制修正的贝塞尔函数</span><br><span class="line"></span><br><span class="line">7.33 　sinc函数</span><br><span class="line"></span><br><span class="line">7.34 　动手实践：绘制sinc函数</span><br><span class="line"></span><br><span class="line">7.35 　本章小结</span><br><span class="line"></span><br><span class="line">第8章　质量控制</span><br><span class="line"></span><br><span class="line">8.1 　断言函数</span><br><span class="line"></span><br><span class="line">8.2 　动手实践：使用assert_almost_equal断言近似相等</span><br><span class="line"></span><br><span class="line">8.3 　近似相等</span><br><span class="line"></span><br><span class="line">8.4 　动手实践：使用assert_approx_equal断言近似相等</span><br><span class="line"></span><br><span class="line">8.5 　数组近似相等</span><br><span class="line"></span><br><span class="line">8.6 　动手实践：断言数组近似相等</span><br><span class="line"></span><br><span class="line">8.7 　数组相等</span><br><span class="line"></span><br><span class="line">8.8 　动手实践：比较数组</span><br><span class="line"></span><br><span class="line">8.9 　数组排序</span><br><span class="line"></span><br><span class="line">8.10 　动手实践：核对数组排序</span><br><span class="line"></span><br><span class="line">8.11 　对象比较</span><br><span class="line"></span><br><span class="line">8.12 　动手实践：比较对象</span><br><span class="line"></span><br><span class="line">8.13 　字符串比较</span><br><span class="line"></span><br><span class="line">8.14 　动手实践：比较字符串</span><br><span class="line"></span><br><span class="line">8.15 　浮点数比较</span><br><span class="line"></span><br><span class="line">8.16 　动手实践：使用assert_array_ almost_equal_nulp比较浮点数</span><br><span class="line"></span><br><span class="line">8.17 　多ULP的浮点数比较</span><br><span class="line"></span><br><span class="line">8.18 　动手实践：设置maxulp并比较浮点数</span><br><span class="line"></span><br><span class="line">8.19 　单元测试</span><br><span class="line"></span><br><span class="line">8.20 　动手实践：编写单元测试</span><br><span class="line"></span><br><span class="line">8.21 　nose和测试装饰器</span><br><span class="line"></span><br><span class="line">8.22 　动手实践：使用测试装饰器</span><br><span class="line"></span><br><span class="line">8.23 　文档字符串</span><br><span class="line"></span><br><span class="line">8.24 　动手实践：执行文档字符串测试</span><br><span class="line"></span><br><span class="line">8.25 　本章小结</span><br><span class="line"></span><br><span class="line">第9章　使用Matplotlib绘图</span><br><span class="line"></span><br><span class="line">9.1 　简单绘图</span><br><span class="line"></span><br><span class="line">9.2 　动手实践：绘制多项式函数</span><br><span class="line"></span><br><span class="line">9.3 　格式字符串</span><br><span class="line"></span><br><span class="line">9.4 　动手实践：绘制多项式函数及其导函数</span><br><span class="line"></span><br><span class="line">9.5 　子图</span><br><span class="line"></span><br><span class="line">9.6 　动手实践：绘制多项式函数及其导函数</span><br><span class="line"></span><br><span class="line">9.7 　财经</span><br><span class="line"></span><br><span class="line">9.8 　动手实践：绘制全年股票价格</span><br><span class="line"></span><br><span class="line">9.9 　直方图</span><br><span class="line"></span><br><span class="line">9.10 　动手实践：绘制股价分布直方图</span><br><span class="line"></span><br><span class="line">9.11 　对数坐标图</span><br><span class="line"></span><br><span class="line">9.12 　动手实践：绘制股票成交量</span><br><span class="line"></span><br><span class="line">9.13 　散点图</span><br><span class="line"></span><br><span class="line">9.14 　动手实践：绘制股票收益率和成交量变化的散点图</span><br><span class="line"></span><br><span class="line">9.15 　着色</span><br><span class="line"></span><br><span class="line">9.16 　动手实践：根据条件进行着色</span><br><span class="line"></span><br><span class="line">9.17 　图例和注释</span><br><span class="line"></span><br><span class="line">9.18 　动手实践：使用图例和注释</span><br><span class="line"></span><br><span class="line">9.19 　三维绘图</span><br><span class="line"></span><br><span class="line">9.20 　动手实践：在三维空间中绘图</span><br><span class="line"></span><br><span class="line">9.21 　等高线图</span><br><span class="line"></span><br><span class="line">9.22 　动手实践：绘制色彩填充的等高线图</span><br><span class="line"></span><br><span class="line">9.23 　动画</span><br><span class="line"></span><br><span class="line">9.24 　动手实践：制作动画</span><br><span class="line"></span><br><span class="line">9.25 　本章小结</span><br><span class="line"></span><br><span class="line">第10章　NumPy的扩展：SciPy</span><br><span class="line"></span><br><span class="line">10.1 　MATLAB和Octave</span><br><span class="line"></span><br><span class="line">10.2 　动手实践：保存和加载.mat文件</span><br><span class="line"></span><br><span class="line">10.3 　统计</span><br><span class="line"></span><br><span class="line">10.4 　动手实践：分析随机数</span><br><span class="line"></span><br><span class="line">10.5 　样本比对和SciKits</span><br><span class="line"></span><br><span class="line">10.6 　动手实践：比较股票对数收益率</span><br><span class="line"></span><br><span class="line">10.7 　信号处理</span><br><span class="line"></span><br><span class="line">10.8 　动手实践：检测QQQ股价的线性趋势</span><br><span class="line"></span><br><span class="line">10.9 　傅里叶分析</span><br><span class="line"></span><br><span class="line">10.10 　动手实践：对去除趋势后的信号进行滤波处理</span><br><span class="line"></span><br><span class="line">10.11 　数学优化</span><br><span class="line"></span><br><span class="line">10.12 　动手实践：拟合正弦波</span><br><span class="line"></span><br><span class="line">10.13 　数值积分</span><br><span class="line"></span><br><span class="line">10.14 　动手实践：计算高斯积分</span><br><span class="line"></span><br><span class="line">10.15 　插值</span><br><span class="line"></span><br><span class="line">10.16 　动手实践：一维插值</span><br><span class="line"></span><br><span class="line">10.17 　图像处理</span><br><span class="line"></span><br><span class="line">10.18 　动手实践：处理Lena图像</span><br><span class="line"></span><br><span class="line">10.19 　音频处理</span><br><span class="line"></span><br><span class="line">10.20 　动手实践：重复音频片段</span><br><span class="line"></span><br><span class="line">10.21 　本章小结</span><br><span class="line"></span><br><span class="line">第11章　玩转Pygame</span><br><span class="line"></span><br><span class="line">11.1 　Pygame</span><br><span class="line"></span><br><span class="line">11.2 　动手实践：安装Pygame</span><br><span class="line"></span><br><span class="line">11.3 　Hello World</span><br><span class="line"></span><br><span class="line">11.4 　动手实践：制作简单游戏</span><br><span class="line"></span><br><span class="line">11.5 　动画</span><br><span class="line"></span><br><span class="line">11.6 　动手实践：使用NumPy和Pygame制作动画对象</span><br><span class="line"></span><br><span class="line">11.7 　Matplotlib</span><br><span class="line"></span><br><span class="line">11.8 　动手实践：在Pygame中使用Matplotlib</span><br><span class="line"></span><br><span class="line">11.9 　屏幕像素</span><br><span class="line"></span><br><span class="line">11.10 　动手实践：访问屏幕像素</span><br><span class="line"></span><br><span class="line">11.11 　人工智能</span><br><span class="line"></span><br><span class="line">11.12 　动手实践：数据点聚类</span><br><span class="line"></span><br><span class="line">11.13 　OpenGL和Pygame</span><br><span class="line"></span><br><span class="line">11.14 　动手实践：绘制谢尔宾斯基地毯</span><br><span class="line"></span><br><span class="line">11.15 　模拟游戏</span><br><span class="line"></span><br><span class="line">11.16 　动手实践：模拟生命</span><br><span class="line"></span><br><span class="line">11.17 　本章小结</span><br><span class="line"></span><br><span class="line">突击测验答案</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言实战 PDF</title>
    <url>/posts/4520a83d/</url>
    <content><![CDATA[<h4 id="《Go语言实战》"><a href="#《Go语言实战》" class="headerlink" title="《Go语言实战》"></a>《Go语言实战》</h4><h6 id="https-pan-baidu-com-s-1mWOzCk1VlWs-zCTo6tr3Mw-密码-277h"><a href="#https-pan-baidu-com-s-1mWOzCk1VlWs-zCTo6tr3Mw-密码-277h" class="headerlink" title="https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw 密码:277h"></a><a href="https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw">https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw</a> 密码:277h</h6><p>Go语言结合了底层系统语言的能力以及现代语言的高级特性，旨在降低构建简单、可靠、高效软件的门槛。本书向读者提供一个专注、全面且符合语言习惯的视角。<br><a id="more"></a></p>
<p>Go语言实战同时关注语言的规范和实现，涉及的内容包括语法、类型系统、并发、管道、测试，以及其他一些主题。</p>
<p>Go语言实战目标读者是已经有一定其他编程语言经验，想要开始学习Go 语言或者更深入了解Go 语言及其内部机制的中级开发者。本书会提供一个专注、全面且符合习惯的视角。本书关注Go 语言的规范和实现，涉及的内容包括语法、Go 的类型系统、并发、通道和测试等主题。</p>
<p>Go语言实战 主要内容</p>
<p>● Go语言规范和实现。</p>
<p>● Go语言的类型系统。</p>
<p>● Go语言的数据结构的内部实现。</p>
<p>● 测试和基准测试。</p>
<p><img src="/images/590c1bf9e5fb80a46b7301dc7f2c22d31.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章　关于Go语言的介绍　1</span><br><span class="line"></span><br><span class="line">1．1　用Go解决现代编程难题　2</span><br><span class="line"></span><br><span class="line">1．1．1　开发速度　2</span><br><span class="line"></span><br><span class="line">1．1．2　并发　3</span><br><span class="line"></span><br><span class="line">1．1．3　Go语言的类型系统　5</span><br><span class="line"></span><br><span class="line">1．1．4　内存管理　7</span><br><span class="line"></span><br><span class="line">1．2　你好，Go　7</span><br><span class="line"></span><br><span class="line">1．3　小结　8</span><br><span class="line"></span><br><span class="line">第2章　快速开始一个Go程序　9</span><br><span class="line"></span><br><span class="line">2．1　程序架构　9</span><br><span class="line"></span><br><span class="line">2．2　main包　11</span><br><span class="line"></span><br><span class="line">2．3　search包　13</span><br><span class="line"></span><br><span class="line">2．3．1　search．go　13</span><br><span class="line"></span><br><span class="line">2．3．2　feed．go　21</span><br><span class="line"></span><br><span class="line">2．3．3　match．go default．go　24</span><br><span class="line"></span><br><span class="line">2．4　RSS匹配器　30</span><br><span class="line"></span><br><span class="line">2．5　小结　36</span><br><span class="line"></span><br><span class="line">第3章　打包和工具链　37</span><br><span class="line"></span><br><span class="line">3．1　包　37</span><br><span class="line"></span><br><span class="line">3．1．1　包名惯例　38</span><br><span class="line"></span><br><span class="line">3．1．2　main包　38</span><br><span class="line"></span><br><span class="line">3．2　导入　39</span><br><span class="line"></span><br><span class="line">3．2．1　远程导入　40</span><br><span class="line"></span><br><span class="line">3．2．2　命名导入　40</span><br><span class="line"></span><br><span class="line">3．3　函数init　41</span><br><span class="line"></span><br><span class="line">3．4　使用Go的工具　42</span><br><span class="line"></span><br><span class="line">3．5　进一步介绍Go开发工具　44</span><br><span class="line"></span><br><span class="line">3．5．1　go vet　44</span><br><span class="line"></span><br><span class="line">3．5．2　Go代码格式化　45</span><br><span class="line"></span><br><span class="line">3．5．3　Go语言的文档　45</span><br><span class="line"></span><br><span class="line">3．6　与其他Go开发者合作　48</span><br><span class="line"></span><br><span class="line">3．7　依赖管理　48</span><br><span class="line"></span><br><span class="line">3．7．1　第三方依赖　49</span><br><span class="line"></span><br><span class="line">3．7．2　对gb的介绍　50</span><br><span class="line"></span><br><span class="line">3．8　小结　52</span><br><span class="line"></span><br><span class="line">第4章　数组、切片和映射　53</span><br><span class="line"></span><br><span class="line">4．1　数组的内部实现和基础功能　53</span><br><span class="line"></span><br><span class="line">4．1．1　内部实现　53</span><br><span class="line"></span><br><span class="line">4．1．2　声明和初始化　54</span><br><span class="line"></span><br><span class="line">4．1．3　使用数组　55</span><br><span class="line"></span><br><span class="line">4．1．4　多维数组　58</span><br><span class="line"></span><br><span class="line">4．1．5　在函数间传递数组　59</span><br><span class="line"></span><br><span class="line">4．2　切片的内部实现和基础功能　60</span><br><span class="line"></span><br><span class="line">4．2．1　内部实现　60</span><br><span class="line"></span><br><span class="line">4．2．2　创建和初始化　61</span><br><span class="line"></span><br><span class="line">4．2．3　使用切片　63</span><br><span class="line"></span><br><span class="line">4．2．4　多维切片　74</span><br><span class="line"></span><br><span class="line">4．2．5　在函数间传递切片　75</span><br><span class="line"></span><br><span class="line">4．3　映射的内部实现和基础功能　76</span><br><span class="line"></span><br><span class="line">4．3．1　内部实现　76</span><br><span class="line"></span><br><span class="line">4．3．2　创建和初始化　78</span><br><span class="line"></span><br><span class="line">4．3．3　使用映射　79</span><br><span class="line"></span><br><span class="line">4．3．4　在函数间传递映射　81</span><br><span class="line"></span><br><span class="line">4．4　小结　82</span><br><span class="line"></span><br><span class="line">第5章　Go语言的类型系统　83</span><br><span class="line"></span><br><span class="line">5．1　用户定义的类型　83</span><br><span class="line"></span><br><span class="line">5．2　方法　87</span><br><span class="line"></span><br><span class="line">5．3　类型的本质　90</span><br><span class="line"></span><br><span class="line">5．3．1　内置类型　91</span><br><span class="line"></span><br><span class="line">5．3．2　引用类型　91</span><br><span class="line"></span><br><span class="line">5．3．3　结构类型　93</span><br><span class="line"></span><br><span class="line">5．4　接口　95</span><br><span class="line"></span><br><span class="line">5．4．1　标准库　96</span><br><span class="line"></span><br><span class="line">5．4．2　实现　98</span><br><span class="line"></span><br><span class="line">5．4．3　方法集　99</span><br><span class="line"></span><br><span class="line">5．4．4　多态　103</span><br><span class="line"></span><br><span class="line">5．5　嵌入类型　105</span><br><span class="line"></span><br><span class="line">5．6　公开或未公开的标识符　113</span><br><span class="line"></span><br><span class="line">5．7　小结　121</span><br><span class="line"></span><br><span class="line">第6章　并发　122</span><br><span class="line"></span><br><span class="line">6．1　并发与并行　122</span><br><span class="line"></span><br><span class="line">6．2　goroutine　125</span><br><span class="line"></span><br><span class="line">6．3　竞争状态　132</span><br><span class="line"></span><br><span class="line">6．4　锁住共享资源　135</span><br><span class="line"></span><br><span class="line">6．4．1　原子函数　135</span><br><span class="line"></span><br><span class="line">6．4．2　互斥锁　138</span><br><span class="line"></span><br><span class="line">6．5　通道　140</span><br><span class="line"></span><br><span class="line">6．5．1　无缓冲的通道　141</span><br><span class="line"></span><br><span class="line">6．5．2　有缓冲的通道　146</span><br><span class="line"></span><br><span class="line">6．6　小结　149</span><br><span class="line"></span><br><span class="line">第7章　并发模式　150</span><br><span class="line"></span><br><span class="line">7．1　runner　150</span><br><span class="line"></span><br><span class="line">7．2　pool　158</span><br><span class="line"></span><br><span class="line">7．3　work　168</span><br><span class="line"></span><br><span class="line">7．4　小结　174</span><br><span class="line"></span><br><span class="line">第8章　标准库　176</span><br><span class="line"></span><br><span class="line">8．1　文档与源代码　177</span><br><span class="line"></span><br><span class="line">8．2　记录日志　178</span><br><span class="line"></span><br><span class="line">8．2．1　log包　179</span><br><span class="line"></span><br><span class="line">8．2．2　定制的日志记录器　182</span><br><span class="line"></span><br><span class="line">8．2．3　结论　186</span><br><span class="line"></span><br><span class="line">8．3　编码 解码　187</span><br><span class="line"></span><br><span class="line">8．3．1　解码JSON　187</span><br><span class="line"></span><br><span class="line">8．3．2　编码JSON　192</span><br><span class="line"></span><br><span class="line">8．3．3　结论　193</span><br><span class="line"></span><br><span class="line">8．4　输入和输出　193</span><br><span class="line"></span><br><span class="line">8．4．1　Writer和Reader接口　194</span><br><span class="line"></span><br><span class="line">8．4．2　整合并完成工作　195</span><br><span class="line"></span><br><span class="line">8．4．3　简单的curl　199</span><br><span class="line"></span><br><span class="line">8．4．4　结论　200</span><br><span class="line"></span><br><span class="line">8．5　小结　200</span><br><span class="line"></span><br><span class="line">第9章　测试和性能　201</span><br><span class="line"></span><br><span class="line">9．1　单元测试　201</span><br><span class="line"></span><br><span class="line">9．1．1　基础单元测试　202</span><br><span class="line"></span><br><span class="line">9．1．2　表组测试　205</span><br><span class="line"></span><br><span class="line">9．1．3　模仿调用　208</span><br><span class="line"></span><br><span class="line">9．1．4　测试服务端点　212</span><br><span class="line"></span><br><span class="line">9．2　示例　217</span><br><span class="line"></span><br><span class="line">9．3　基准测试　220</span><br><span class="line"></span><br><span class="line">9．4　小结　224</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>c++primerplus6 PDF</title>
    <url>/posts/322798ab/</url>
    <content><![CDATA[<h4 id="《c-primerplus6》"><a href="#《c-primerplus6》" class="headerlink" title="《c++primerplus6》"></a>《c++primerplus6》</h4><h4 id="C-经典书籍"><a href="#C-经典书籍" class="headerlink" title="C++ 经典书籍"></a>C++ 经典书籍</h4><p>Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他最早接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和C Primer Plus。<br><a id="more"></a></p>
<p><img src="/images/6a58ae7c8511fed961544492f18ac94f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第 1章 预备知识 1</span><br><span class="line"></span><br><span class="line">1．1　C++简介　1</span><br><span class="line"></span><br><span class="line">1．2　C++简史　2</span><br><span class="line"></span><br><span class="line">1．2．1　C语言　2</span><br><span class="line"></span><br><span class="line">1．2．2　C语言编程原理　2</span><br><span class="line"></span><br><span class="line">1．2．3　面向对象编程　3</span><br><span class="line"></span><br><span class="line">1．2．4　C++和泛型编程　3</span><br><span class="line"></span><br><span class="line">1．2．5　C++的起源　4</span><br><span class="line"></span><br><span class="line">1．3　可移植性和标准　5</span><br><span class="line"></span><br><span class="line">1．3．1　C++的发展　5</span><br><span class="line"></span><br><span class="line">1．3．2　本书遵循的C++标准　6</span><br><span class="line"></span><br><span class="line">1．4　程序创建的技巧　6</span><br><span class="line"></span><br><span class="line">1．4．1　创建源代码文件　6</span><br><span class="line"></span><br><span class="line">1．4．2　编译和链接　7</span><br><span class="line"></span><br><span class="line">1．5　总结　10</span><br><span class="line"></span><br><span class="line">第　2章 开始学习C++　11</span><br><span class="line"></span><br><span class="line">2．1　进入C++　11</span><br><span class="line"></span><br><span class="line">2．1．1　main( )函数　12</span><br><span class="line"></span><br><span class="line">2．1．2　C++注释　14</span><br><span class="line"></span><br><span class="line">2．1．3　C++预处理器和iostream文件　14</span><br><span class="line"></span><br><span class="line">2．1．4　头文件名　15</span><br><span class="line"></span><br><span class="line">2．1．5　名称空间　15</span><br><span class="line"></span><br><span class="line">2．1．6　使用cout进行C++输出　16</span><br><span class="line"></span><br><span class="line">2．1．7　C++源代码的格式化　17</span><br><span class="line"></span><br><span class="line">2．2　C++语句　18</span><br><span class="line"></span><br><span class="line">2．2．1　声明语句和变量　19</span><br><span class="line"></span><br><span class="line">2．2．2　赋值语句　20</span><br><span class="line"></span><br><span class="line">2．2．3　cout的新花样　20</span><br><span class="line"></span><br><span class="line">2．3　其他C++语句　21</span><br><span class="line"></span><br><span class="line">2．3．1　使用cin　21</span><br><span class="line"></span><br><span class="line">2．3．2　使用cout进行拼接　21</span><br><span class="line"></span><br><span class="line">2．3．3　类简介　22</span><br><span class="line"></span><br><span class="line">2．4　函数　23</span><br><span class="line"></span><br><span class="line">2．4．1　使用有返回值的函数　23</span><br><span class="line"></span><br><span class="line">2．4．2　函数变体　25</span><br><span class="line"></span><br><span class="line">2．4．3　用户定义的函数　26</span><br><span class="line"></span><br><span class="line">2．4．4　用户定义的有返回值的函数　28</span><br><span class="line"></span><br><span class="line">2．4．5　在多函数程序中使用using编译指令　29</span><br><span class="line"></span><br><span class="line">2．5　总结　30</span><br><span class="line"></span><br><span class="line">2．6　复习题　30</span><br><span class="line"></span><br><span class="line">2．7　编程练习　30</span><br><span class="line"></span><br><span class="line">第3章　处理数据　32</span><br><span class="line"></span><br><span class="line">3．1　简单变量　32</span><br><span class="line"></span><br><span class="line">3．1．1　变量名　33</span><br><span class="line"></span><br><span class="line">3．1．2　整型　34</span><br><span class="line"></span><br><span class="line">3．1．3　整型short、int、long和long long　34</span><br><span class="line"></span><br><span class="line">3．1．4　无符号类型　37</span><br><span class="line"></span><br><span class="line">3．1．5　选择整型类型　38</span><br><span class="line"></span><br><span class="line">3．1．6　整型字面值　39</span><br><span class="line"></span><br><span class="line">3．1．7　C++如何确定常量的类型　40</span><br><span class="line"></span><br><span class="line">3．1．8　char类型：字符和小整数　41</span><br><span class="line"></span><br><span class="line">3．1．9　bool类型　46</span><br><span class="line"></span><br><span class="line">3．2　const限定符　46</span><br><span class="line"></span><br><span class="line">3．3　浮点数　47</span><br><span class="line"></span><br><span class="line">3．3．1　书写浮点数　47</span><br><span class="line"></span><br><span class="line">3．3．2　浮点类型　48</span><br><span class="line"></span><br><span class="line">3．3．3　浮点常量　49</span><br><span class="line"></span><br><span class="line">3．3．4　浮点数的优缺点　49</span><br><span class="line"></span><br><span class="line">3．4　C++算术运算符　50</span><br><span class="line"></span><br><span class="line">3．4．1　运算符优先级和结合性　51</span><br><span class="line"></span><br><span class="line">3．4．2　除法分支　51</span><br><span class="line"></span><br><span class="line">3．4．3　求模运算符　52</span><br><span class="line"></span><br><span class="line">3．4．4　类型转换　53</span><br><span class="line"></span><br><span class="line">3．4．5　C++11中的auto声明　56</span><br><span class="line"></span><br><span class="line">3．5　总结　57</span><br><span class="line"></span><br><span class="line">3．6　复习题　57</span><br><span class="line"></span><br><span class="line">3．7　编程练习　58</span><br><span class="line"></span><br><span class="line">第4章　复合类型　59</span><br><span class="line"></span><br><span class="line">4．1　数组　59</span><br><span class="line"></span><br><span class="line">4．1．1　程序说明　61</span><br><span class="line"></span><br><span class="line">4．1．2　数组的初始化规则　61</span><br><span class="line"></span><br><span class="line">4．1．3　C++11数组初始化方法　62</span><br><span class="line"></span><br><span class="line">4．2　字符串　62</span><br><span class="line"></span><br><span class="line">4．2．1　拼接字符串常量　63</span><br><span class="line"></span><br><span class="line">4．2．2　在数组中使用字符串　63</span><br><span class="line"></span><br><span class="line">4．2．3　字符串输入　64</span><br><span class="line"></span><br><span class="line">4．2．4　每次读取一行字符串输入　65</span><br><span class="line"></span><br><span class="line">4．2．5　混合输入字符串和数字　67</span><br><span class="line"></span><br><span class="line">4．3　string类简介　68</span><br><span class="line"></span><br><span class="line">4．3．1　C++11字符串初始化　69</span><br><span class="line"></span><br><span class="line">4．3．2　赋值、拼接和附加　69</span><br><span class="line"></span><br><span class="line">4．3．3　string类的其他操作　70</span><br><span class="line"></span><br><span class="line">4．3．4　string类I&#x2F;O　71</span><br><span class="line"></span><br><span class="line">4．3．5　其他形式的字符串字面值　72</span><br><span class="line"></span><br><span class="line">4．4　结构简介　73</span><br><span class="line"></span><br><span class="line">4．4．1　在程序中使用结构　74</span><br><span class="line"></span><br><span class="line">4．4．2　C++11结构初始化　75</span><br><span class="line"></span><br><span class="line">4．4．3　结构可以将string类作为成员吗　75</span><br><span class="line"></span><br><span class="line">4．4．4　其他结构属性　76</span><br><span class="line"></span><br><span class="line">4．4．5　结构数组　77</span><br><span class="line"></span><br><span class="line">4．4．6　结构中的位字段　78</span><br><span class="line"></span><br><span class="line">4．5　共用体　78</span><br><span class="line"></span><br><span class="line">4．6　枚举　79</span><br><span class="line"></span><br><span class="line">4．6．1　设置枚举量的值　80</span><br><span class="line"></span><br><span class="line">4．6．2　枚举的取值范围　80</span><br><span class="line"></span><br><span class="line">4．7　指针和自由存储空间　80</span><br><span class="line"></span><br><span class="line">4．7．1　声明和初始化指针　82</span><br><span class="line"></span><br><span class="line">4．7．2　指针的危险　84</span><br><span class="line"></span><br><span class="line">4．7．3　指针和数字　84</span><br><span class="line"></span><br><span class="line">4．7．4　使用new来分配内存　84</span><br><span class="line"></span><br><span class="line">4．7．5　使用delete释放内存　86</span><br><span class="line"></span><br><span class="line">4．7．6　使用new来创建动态数组　86</span><br><span class="line"></span><br><span class="line">4．8　指针、数组和指针算术　88</span><br><span class="line"></span><br><span class="line">4．8．1　程序说明　89</span><br><span class="line"></span><br><span class="line">4．8．2　指针小结　90</span><br><span class="line"></span><br><span class="line">4．8．3　指针和字符串　92</span><br><span class="line"></span><br><span class="line">4．8．4　使用new创建动态结构　94</span><br><span class="line"></span><br><span class="line">4．8．5　自动存储、静态存储和动态存储　96</span><br><span class="line"></span><br><span class="line">4．9　类型组合　97</span><br><span class="line"></span><br><span class="line">4．10　数组的替代品　99</span><br><span class="line"></span><br><span class="line">4．10．1　模板类vector　99</span><br><span class="line"></span><br><span class="line">4．10．2　模板类array（C++11）　99</span><br><span class="line"></span><br><span class="line">4．10．3　比较数组、vector对象和array对象　99</span><br><span class="line"></span><br><span class="line">4．11　总结　101</span><br><span class="line"></span><br><span class="line">4．12　复习题　101</span><br><span class="line"></span><br><span class="line">4．13　编程练习　102</span><br><span class="line"></span><br><span class="line">第5章　循环和关系表达式　104</span><br><span class="line"></span><br><span class="line">5．1　for循环　104</span><br><span class="line"></span><br><span class="line">5．1．1　for循环的组成部分　105</span><br><span class="line"></span><br><span class="line">5．1．2　回到for循环　109</span><br><span class="line"></span><br><span class="line">5．1．3　修改步长　110</span><br><span class="line"></span><br><span class="line">5．1．4　使用for循环访问字符串　110</span><br><span class="line"></span><br><span class="line">5．1．5　递增运算符（++）和递减运算符（ ）　111</span><br><span class="line"></span><br><span class="line">5．1．6　副作用和顺序点　112</span><br><span class="line"></span><br><span class="line">5．1．7　前缀格式和后缀格式　112</span><br><span class="line"></span><br><span class="line">5．1．8　递增&#x2F;递减运算符和指针　112</span><br><span class="line"></span><br><span class="line">5．1．9　组合赋值运算符　113</span><br><span class="line"></span><br><span class="line">5．1．10　复合语句（语句块）　113</span><br><span class="line"></span><br><span class="line">5．1．11　其他语法技巧——逗号运算符　115</span><br><span class="line"></span><br><span class="line">5．1．12　关系表达式　116</span><br><span class="line"></span><br><span class="line">5．1．13　赋值、比较和可能犯的错误　117</span><br><span class="line"></span><br><span class="line">5．1．14　C-风格字符串的比较　118</span><br><span class="line"></span><br><span class="line">5．1．15　比较string类字符串　120</span><br><span class="line"></span><br><span class="line">5．2　while循环　120</span><br><span class="line"></span><br><span class="line">5．2．1　for与while　121</span><br><span class="line"></span><br><span class="line">5．2．2　等待一段时间：编写延时循环　123</span><br><span class="line"></span><br><span class="line">5．3　do while循环　124</span><br><span class="line"></span><br><span class="line">5．4　基于范围的for循环（C++11）　125</span><br><span class="line"></span><br><span class="line">5．5　循环和文本输入　125</span><br><span class="line"></span><br><span class="line">5．5．1　使用原始的cin进行输入　126</span><br><span class="line"></span><br><span class="line">5．5．2　使用cin．get(char)进行补救　126</span><br><span class="line"></span><br><span class="line">5．5．3　使用哪一个cin．get( )　127</span><br><span class="line"></span><br><span class="line">5．5．4　文件尾条件　128</span><br><span class="line"></span><br><span class="line">5．5．5　另一个cin．get( )版本　129</span><br><span class="line"></span><br><span class="line">5．6　嵌套循环和二维数组　131</span><br><span class="line"></span><br><span class="line">5．6．1　初始化二维数组　132</span><br><span class="line"></span><br><span class="line">5．6．2　使用二维数组　133</span><br><span class="line"></span><br><span class="line">5．7　总结　134</span><br><span class="line"></span><br><span class="line">5．8　复习题　134</span><br><span class="line"></span><br><span class="line">5．9　编程练习　135</span><br><span class="line"></span><br><span class="line">第6章　分支语句和逻辑运算符　137</span><br><span class="line"></span><br><span class="line">6．1　if语句　137</span><br><span class="line"></span><br><span class="line">6．1．1　if else语句　138</span><br><span class="line"></span><br><span class="line">6．1．2　格式化if else语句　139</span><br><span class="line"></span><br><span class="line">6．1．3　if else if else结构　140</span><br><span class="line"></span><br><span class="line">6．2　逻辑表达式　141</span><br><span class="line"></span><br><span class="line">6．2．1　逻辑OR运算符：||　141</span><br><span class="line"></span><br><span class="line">6．2．2　逻辑AND运算符：&amp;&amp;　142</span><br><span class="line"></span><br><span class="line">6．2．3　用&amp;&amp;来设置取值范围　144</span><br><span class="line"></span><br><span class="line">6．2．4　逻辑NOT运算符：!　145</span><br><span class="line"></span><br><span class="line">6．2．5　逻辑运算符细节　146</span><br><span class="line"></span><br><span class="line">6．2．6　其他表示方式　146</span><br><span class="line"></span><br><span class="line">6．3　字符函数库cctype　147</span><br><span class="line"></span><br><span class="line">6．4　：运算符　148</span><br><span class="line"></span><br><span class="line">6．5　switch语句　149</span><br><span class="line"></span><br><span class="line">6．5．1　将枚举量用作标签　151</span><br><span class="line"></span><br><span class="line">6．5．2　switch和if else　152</span><br><span class="line"></span><br><span class="line">6．6　break和continue语句　153</span><br><span class="line"></span><br><span class="line">6．7　读取数字的循环　154</span><br><span class="line"></span><br><span class="line">6．8　简单文件输入&#x2F;输出　157</span><br><span class="line"></span><br><span class="line">6．8．1　文本I&#x2F;O和文本文件　157</span><br><span class="line"></span><br><span class="line">6．8．2　写入到文本文件中　158</span><br><span class="line"></span><br><span class="line">6．8．3　读取文本文件　160</span><br><span class="line"></span><br><span class="line">6．9　总结　163</span><br><span class="line"></span><br><span class="line">6．10　复习题　163</span><br><span class="line"></span><br><span class="line">6．11　编程练习　165</span><br><span class="line"></span><br><span class="line">第7章　函数——C++的编程模块　167</span><br><span class="line"></span><br><span class="line">7．1　复习函数的基本知识　167</span><br><span class="line"></span><br><span class="line">7．1．1　定义函数　168</span><br><span class="line"></span><br><span class="line">7．1．2　函数原型和函数调用　169</span><br><span class="line"></span><br><span class="line">7．2　函数参数和按值传递　171</span><br><span class="line"></span><br><span class="line">7．2．1　多个参数　172</span><br><span class="line"></span><br><span class="line">7．2．2　另一个接受两个参数的函数　174</span><br><span class="line"></span><br><span class="line">7．3　函数和数组　175</span><br><span class="line"></span><br><span class="line">7．3．1　函数如何使用指针来处理数组　176</span><br><span class="line"></span><br><span class="line">7．3．2　将数组作为参数意味着什么　176</span><br><span class="line"></span><br><span class="line">7．3．3　更多数组函数示例　178</span><br><span class="line"></span><br><span class="line">7．3．4　使用数组区间的函数　181</span><br><span class="line"></span><br><span class="line">7．3．5　指针和const　182</span><br><span class="line"></span><br><span class="line">7．4　函数和二维数组　185</span><br><span class="line"></span><br><span class="line">7．5　函数和C-风格字符串　186</span><br><span class="line"></span><br><span class="line">7．5．1　将C-风格字符串作为参数的函数　186</span><br><span class="line"></span><br><span class="line">7．5．2　返回C-风格字符串的函数　187</span><br><span class="line"></span><br><span class="line">7．6　函数和结构　188</span><br><span class="line"></span><br><span class="line">7．6．1　传递和返回结构　188</span><br><span class="line"></span><br><span class="line">7．6．2　另一个处理结构的函数示例　189</span><br><span class="line"></span><br><span class="line">7．6．3　传递结构的地址　192</span><br><span class="line"></span><br><span class="line">7．7　函数和string对象　194</span><br><span class="line"></span><br><span class="line">7．8　函数与array对象　195</span><br><span class="line"></span><br><span class="line">7．9　递归　196</span><br><span class="line"></span><br><span class="line">7．9．1　包含一个递归调用的递归　196</span><br><span class="line"></span><br><span class="line">7．9．2　包含多个递归调用的递归　197</span><br><span class="line"></span><br><span class="line">7．10　函数指针　198</span><br><span class="line"></span><br><span class="line">7．10．1　函数指针的基础知识　199</span><br><span class="line"></span><br><span class="line">7．10．2　函数指针示例　200</span><br><span class="line"></span><br><span class="line">7．10．3　深入探讨函数指针　201</span><br><span class="line"></span><br><span class="line">7．10．4　使用typedef进行简化　204</span><br><span class="line"></span><br><span class="line">7．11　总结　204</span><br><span class="line"></span><br><span class="line">7．12　复习题　205</span><br><span class="line"></span><br><span class="line">7．13　编程练习　206</span><br><span class="line"></span><br><span class="line">第8章　函数探幽　208</span><br><span class="line"></span><br><span class="line">8．1　C++内联函数　208</span><br><span class="line"></span><br><span class="line">8．2　引用变量　210</span><br><span class="line"></span><br><span class="line">8．2．1　创建引用变量　210</span><br><span class="line"></span><br><span class="line">8．2．2　将引用用作函数参数　212</span><br><span class="line"></span><br><span class="line">8．2．3　引用的属性和特别之处　214</span><br><span class="line"></span><br><span class="line">8．2．4　将引用用于结构　216</span><br><span class="line"></span><br><span class="line">8．2．5　将引用用于类对象　220</span><br><span class="line"></span><br><span class="line">8．2．6　对象、继承和引用　222</span><br><span class="line"></span><br><span class="line">8．2．7　何时使用引用参数　224</span><br><span class="line"></span><br><span class="line">8．3　默认参数　225</span><br><span class="line"></span><br><span class="line">8．4　函数重载　227</span><br><span class="line"></span><br><span class="line">8．4．1　重载示例　228</span><br><span class="line"></span><br><span class="line">8．4．2　何时使用函数重载　230</span><br><span class="line"></span><br><span class="line">8．5　函数模板　230</span><br><span class="line"></span><br><span class="line">8．5．1　重载的模板　232</span><br><span class="line"></span><br><span class="line">8．5．2　模板的局限性　233</span><br><span class="line"></span><br><span class="line">8．5．3　显式具体化　234</span><br><span class="line"></span><br><span class="line">8．5．4　实例化和具体化　236</span><br><span class="line"></span><br><span class="line">8．5．5　编译器选择使用哪个函数版本　237</span><br><span class="line"></span><br><span class="line">8．5．6　模板函数的发展　241</span><br><span class="line"></span><br><span class="line">8．6　总结　243</span><br><span class="line"></span><br><span class="line">8．7　复习题　243</span><br><span class="line"></span><br><span class="line">8．8　编程练习　244</span><br><span class="line"></span><br><span class="line">第9章　内存模型和名称空间　246</span><br><span class="line"></span><br><span class="line">9．1　单独编译　246</span><br><span class="line"></span><br><span class="line">9．2　存储持续性、作用域和链接性　250</span><br><span class="line"></span><br><span class="line">9．2．1　作用域和链接　250</span><br><span class="line"></span><br><span class="line">9．2．2　自动存储持续性　250</span><br><span class="line"></span><br><span class="line">9．2．3　静态持续变量　253</span><br><span class="line"></span><br><span class="line">9．2．4　静态持续性、外部链接性　254</span><br><span class="line"></span><br><span class="line">9．2．5　静态持续性、内部链接性　257</span><br><span class="line"></span><br><span class="line">9．2．6　静态存储持续性、无链接性　258</span><br><span class="line"></span><br><span class="line">9．2．7　说明符和限定符　260</span><br><span class="line"></span><br><span class="line">9．2．8　函数和链接性　261</span><br><span class="line"></span><br><span class="line">9．2．9　语言链接性　262</span><br><span class="line"></span><br><span class="line">9．2．10　存储方案和动态分配　262</span><br><span class="line"></span><br><span class="line">9．3　名称空间　266</span><br><span class="line"></span><br><span class="line">9．3．1　传统的C++名称空间　266</span><br><span class="line"></span><br><span class="line">9．3．2　新的名称空间特性　267</span><br><span class="line"></span><br><span class="line">9．3．3　名称空间示例　271</span><br><span class="line"></span><br><span class="line">9．3．4　名称空间及其前途　274</span><br><span class="line"></span><br><span class="line">9．4　总结　274</span><br><span class="line"></span><br><span class="line">9．5　复习题　275</span><br><span class="line"></span><br><span class="line">9．6　编程练习　276</span><br><span class="line"></span><br><span class="line">第　10章 对象和类　278</span><br><span class="line"></span><br><span class="line">10．1　过程性编程和面向对象编程　278</span><br><span class="line"></span><br><span class="line">10．2　抽象和类　279</span><br><span class="line"></span><br><span class="line">10．2．1　类型是什么　279</span><br><span class="line"></span><br><span class="line">10．2．2　C++中的类　280</span><br><span class="line"></span><br><span class="line">10．2．3　实现类成员函数　283</span><br><span class="line"></span><br><span class="line">10．2．4　使用类　285</span><br><span class="line"></span><br><span class="line">10．2．5　修改实现　286</span><br><span class="line"></span><br><span class="line">10．2．6　小结　287</span><br><span class="line"></span><br><span class="line">10．3　类的构造函数和析构函数　288</span><br><span class="line"></span><br><span class="line">10．3．1　声明和定义构造函数　288</span><br><span class="line"></span><br><span class="line">10．3．2　使用构造函数　289</span><br><span class="line"></span><br><span class="line">10．3．3　默认构造函数　290</span><br><span class="line"></span><br><span class="line">10．3．4　析构函数　290</span><br><span class="line"></span><br><span class="line">10．3．5　改进Stock类　291</span><br><span class="line"></span><br><span class="line">10．3．6　构造函数和析构函数小结　296</span><br><span class="line"></span><br><span class="line">10．4　this指针　296</span><br><span class="line"></span><br><span class="line">10．5　对象数组　300</span><br><span class="line"></span><br><span class="line">10．6　类作用域　302</span><br><span class="line"></span><br><span class="line">10．6．1　作用域为类的常量　302</span><br><span class="line"></span><br><span class="line">10．6．2　作用域内枚举（C++11）　303</span><br><span class="line"></span><br><span class="line">10．7　抽象数据类型　304</span><br><span class="line"></span><br><span class="line">10．8　总结　307</span><br><span class="line"></span><br><span class="line">10．9　复习题　307</span><br><span class="line"></span><br><span class="line">10．10　编程练习　308</span><br><span class="line"></span><br><span class="line">第　11章 使用类　310</span><br><span class="line"></span><br><span class="line">11．1　运算符重载　310</span><br><span class="line"></span><br><span class="line">11．2　计算时间：一个运算符重载示例　311</span><br><span class="line"></span><br><span class="line">11．2．1　添加加法运算符　313</span><br><span class="line"></span><br><span class="line">11．2．2　重载限制　315</span><br><span class="line"></span><br><span class="line">11．2．3　其他重载运算符　316</span><br><span class="line"></span><br><span class="line">11．3　友元　318</span><br><span class="line"></span><br><span class="line">11．3．1　创建友元　319</span><br><span class="line"></span><br><span class="line">11．3．2　常用的友元：重载&lt;&lt;运算符　320</span><br><span class="line"></span><br><span class="line">11．4　重载运算符：作为成员函数还是非成员函数　324</span><br><span class="line"></span><br><span class="line">11．5　再谈重载：一个矢量类　324</span><br><span class="line"></span><br><span class="line">11．5．1　使用状态成员　329</span><br><span class="line"></span><br><span class="line">11．5．2　为Vector类重载算术运算符　331</span><br><span class="line"></span><br><span class="line">11．5．3　对实现的说明　332</span><br><span class="line"></span><br><span class="line">11．5．4　使用Vector类来模拟随机漫步　332</span><br><span class="line"></span><br><span class="line">11．6　类的自动转换和强制类型转换　334</span><br><span class="line"></span><br><span class="line">11．6．1　转换函数　338</span><br><span class="line"></span><br><span class="line">11．6．2　转换函数和友元函数　341</span><br><span class="line"></span><br><span class="line">11．7　总结　343</span><br><span class="line"></span><br><span class="line">11．8　复习题　344</span><br><span class="line"></span><br><span class="line">11．9　编程练习　344</span><br><span class="line"></span><br><span class="line">第　12章 类和动态内存分配　346</span><br><span class="line"></span><br><span class="line">12．1　动态内存和类　346</span><br><span class="line"></span><br><span class="line">12．1．1　复习示例和静态类成员　346</span><br><span class="line"></span><br><span class="line">12．1．2　特殊成员函数　352</span><br><span class="line"></span><br><span class="line">12．1．3　回到Stringbad：复制构造函数的哪里出了问题　354</span><br><span class="line"></span><br><span class="line">12．1．4　Stringbad的其他问题：赋值运算符　356</span><br><span class="line"></span><br><span class="line">12．2　改进后的新String类　357</span><br><span class="line"></span><br><span class="line">12．2．1　修订后的默认构造函数　357</span><br><span class="line"></span><br><span class="line">12．2．2　比较成员函数　358</span><br><span class="line"></span><br><span class="line">12．2．3　使用中括号表示法访问字符　359</span><br><span class="line"></span><br><span class="line">12．2．4　静态类成员函数　360</span><br><span class="line"></span><br><span class="line">12．2．5　进一步重载赋值运算符　360</span><br><span class="line"></span><br><span class="line">12．3　在构造函数中使用new时应注意的事项　364</span><br><span class="line"></span><br><span class="line">12．3．1　应该和不应该　365</span><br><span class="line"></span><br><span class="line">12．3．2　包含类成员的类的逐成员复制　365</span><br><span class="line"></span><br><span class="line">12．4　有关返回对象的说明　366</span><br><span class="line"></span><br><span class="line">12．4．1　返回指向const对象的引用　366</span><br><span class="line"></span><br><span class="line">12．4．2　返回指向非const对象的引用　366</span><br><span class="line"></span><br><span class="line">12．4．3　返回对象　367</span><br><span class="line"></span><br><span class="line">12．4．4　返回const对象　367</span><br><span class="line"></span><br><span class="line">12．5　使用指向对象的指针　368</span><br><span class="line"></span><br><span class="line">12．5．1　再谈new和delete　369</span><br><span class="line"></span><br><span class="line">12．5．2　指针和对象小结　370</span><br><span class="line"></span><br><span class="line">12．5．3　再谈定位new运算符　371</span><br><span class="line"></span><br><span class="line">12．6　复习各种技术　374</span><br><span class="line"></span><br><span class="line">12．6．1　重载&lt;&lt;运算符　374</span><br><span class="line"></span><br><span class="line">12．6．2　转换函数　375</span><br><span class="line"></span><br><span class="line">12．6．3　其构造函数使用new的类　375</span><br><span class="line"></span><br><span class="line">12．7　队列模拟　375</span><br><span class="line"></span><br><span class="line">12．7．1　队列类　376</span><br><span class="line"></span><br><span class="line">12．7．2　Customer类　382</span><br><span class="line"></span><br><span class="line">12．7．3　ATM模拟　384</span><br><span class="line"></span><br><span class="line">12．8　总结　387</span><br><span class="line"></span><br><span class="line">12．9　复习题　388</span><br><span class="line"></span><br><span class="line">12．10　编程练习　389</span><br><span class="line"></span><br><span class="line">第　13章 类继承　392</span><br><span class="line"></span><br><span class="line">13．1　一个简单的基类　393</span><br><span class="line"></span><br><span class="line">13．1．1　派生一个类　394</span><br><span class="line"></span><br><span class="line">13．1．2　构造函数：访问权限的考虑　395</span><br><span class="line"></span><br><span class="line">13．1．3　使用派生类　397</span><br><span class="line"></span><br><span class="line">13．1．4　派生类和基类之间的特殊关系　398</span><br><span class="line"></span><br><span class="line">13．2　继承：is-a关系　400</span><br><span class="line"></span><br><span class="line">13．3　多态公有继承　400</span><br><span class="line"></span><br><span class="line">13．4　静态联编和动态联编　409</span><br><span class="line"></span><br><span class="line">13．4．1　指针和引用类型的兼容性　409</span><br><span class="line"></span><br><span class="line">13．4．2　虚成员函数和动态联编　411</span><br><span class="line"></span><br><span class="line">13．4．3　有关虚函数注意事项　412</span><br><span class="line"></span><br><span class="line">13．5　访问控制：protected　414</span><br><span class="line"></span><br><span class="line">13．6　抽象基类　415</span><br><span class="line"></span><br><span class="line">13．6．1　应用ABC概念　416</span><br><span class="line"></span><br><span class="line">13．6．2　ABC理念　421</span><br><span class="line"></span><br><span class="line">13．7　继承和动态内存分配　421</span><br><span class="line"></span><br><span class="line">13．7．1　第 一种情况：派生类不使用new　421</span><br><span class="line"></span><br><span class="line">13．7．2　第二种情况：派生类使用new　422</span><br><span class="line"></span><br><span class="line">13．7．3　使用动态内存分配和友元的继承示例　423</span><br><span class="line"></span><br><span class="line">13．8　类设计回顾　427</span><br><span class="line"></span><br><span class="line">13．8．1　编译器生成的成员函数　427</span><br><span class="line"></span><br><span class="line">13．8．2　其他的类方法　428</span><br><span class="line"></span><br><span class="line">13．8．3　公有继承的考虑因素　429</span><br><span class="line"></span><br><span class="line">13．8．4　类函数小结　432</span><br><span class="line"></span><br><span class="line">13．9　总结　433</span><br><span class="line"></span><br><span class="line">13．10　复习题　433</span><br><span class="line"></span><br><span class="line">13．11　编程练习　434</span><br><span class="line"></span><br><span class="line">第　14章 C++中的代码重用　436</span><br><span class="line"></span><br><span class="line">14．1　包含对象成员的类　436</span><br><span class="line"></span><br><span class="line">14．1．1　valarray类简介　437</span><br><span class="line"></span><br><span class="line">14．1．2　Student类的设计　437</span><br><span class="line"></span><br><span class="line">14．1．3　Student类示例　438</span><br><span class="line"></span><br><span class="line">14．2　私有继承　443</span><br><span class="line"></span><br><span class="line">14．2．1　Student类示例（新版本）　443</span><br><span class="line"></span><br><span class="line">14．2．2　使用包含还是私有继承　447</span><br><span class="line"></span><br><span class="line">14．2．3　保护继承　448</span><br><span class="line"></span><br><span class="line">14．2．4　使用using重新定义访问权限　448</span><br><span class="line"></span><br><span class="line">14．3　多重继承　449</span><br><span class="line"></span><br><span class="line">14．3．1　有多少Worker　452</span><br><span class="line"></span><br><span class="line">14．3．2　哪个方法　455</span><br><span class="line"></span><br><span class="line">14．3．3　MI小结　461</span><br><span class="line"></span><br><span class="line">14．4　类模板　462</span><br><span class="line"></span><br><span class="line">14．4．1　定义类模板　462</span><br><span class="line"></span><br><span class="line">14．4．2　使用模板类　464</span><br><span class="line"></span><br><span class="line">14．4．3　深入探讨模板类　465</span><br><span class="line"></span><br><span class="line">14．4．4　数组模板示例和非类型参数　469</span><br><span class="line"></span><br><span class="line">14．4．5　模板多功能性　470</span><br><span class="line"></span><br><span class="line">14．4．6　模板的具体化　473</span><br><span class="line"></span><br><span class="line">14．4．7　成员模板　474</span><br><span class="line"></span><br><span class="line">14．4．8　将模板用作参数　476</span><br><span class="line"></span><br><span class="line">14．4．9　模板类和友元　477</span><br><span class="line"></span><br><span class="line">14．4．10　模板别名（C++11）　482</span><br><span class="line"></span><br><span class="line">14．5　总结　482</span><br><span class="line"></span><br><span class="line">14．6　复习题　483</span><br><span class="line"></span><br><span class="line">14．7　编程练习　484</span><br><span class="line"></span><br><span class="line">第　15章 友元、异常和其他　488</span><br><span class="line"></span><br><span class="line">15．1　友元　488</span><br><span class="line"></span><br><span class="line">15．1．1　友元类　488</span><br><span class="line"></span><br><span class="line">15．1．2　友元成员函数　492</span><br><span class="line"></span><br><span class="line">15．1．3　其他友元关系　494</span><br><span class="line"></span><br><span class="line">15．1．4　共同的友元　495</span><br><span class="line"></span><br><span class="line">15．2　嵌套类　495</span><br><span class="line"></span><br><span class="line">15．2．1　嵌套类和访问权限　496</span><br><span class="line"></span><br><span class="line">15．2．2　模板中的嵌套　497</span><br><span class="line"></span><br><span class="line">15．3　异常　499</span><br><span class="line"></span><br><span class="line">15．3．1　调用abort()　500</span><br><span class="line"></span><br><span class="line">15．3．2　返回错误码　500</span><br><span class="line"></span><br><span class="line">15．3．3　异常机制　501</span><br><span class="line"></span><br><span class="line">15．3．4　将对象用作异常类型　504</span><br><span class="line"></span><br><span class="line">15．3．5　异常规范和C++11　506</span><br><span class="line"></span><br><span class="line">15．3．6　栈解退　506</span><br><span class="line"></span><br><span class="line">15．3．7　其他异常特性　510</span><br><span class="line"></span><br><span class="line">15．3．8　exception类　511</span><br><span class="line"></span><br><span class="line">15．3．9　异常、类和继承　514</span><br><span class="line"></span><br><span class="line">15．3．10　异常何时会迷失方向　517</span><br><span class="line"></span><br><span class="line">15．3．11　有关异常的注意事项　519</span><br><span class="line"></span><br><span class="line">15．4　RTTI　520</span><br><span class="line"></span><br><span class="line">15．4．1　RTTI的用途　520</span><br><span class="line"></span><br><span class="line">15．4．2　RTTI的工作原理　521</span><br><span class="line"></span><br><span class="line">15．5　类型转换运算符　526</span><br><span class="line"></span><br><span class="line">15．6　总结　528</span><br><span class="line"></span><br><span class="line">15．7　复习题　528</span><br><span class="line"></span><br><span class="line">15．8　编程练习　529</span><br><span class="line"></span><br><span class="line">第　16章 string类和标准模板库　530</span><br><span class="line"></span><br><span class="line">16．1　string类　530</span><br><span class="line"></span><br><span class="line">16．1．1　构造字符串　530</span><br><span class="line"></span><br><span class="line">16．1．2　string类输入　533</span><br><span class="line"></span><br><span class="line">16．1．3　使用字符串　535</span><br><span class="line"></span><br><span class="line">16．1．4　string还提供了哪些功能　538</span><br><span class="line"></span><br><span class="line">16．1．5　字符串种类　539</span><br><span class="line"></span><br><span class="line">16．2　智能指针模板类　539</span><br><span class="line"></span><br><span class="line">16．2．1　使用智能指针　540</span><br><span class="line"></span><br><span class="line">16．2．2　有关智能指针的注意事项　542</span><br><span class="line"></span><br><span class="line">16．2．3　unique_ptr为何优于auto_ptr　543</span><br><span class="line"></span><br><span class="line">16．2．4　选择智能指针　545</span><br><span class="line"></span><br><span class="line">16．3　标准模板库　545</span><br><span class="line"></span><br><span class="line">16．3．1　模板类vector　546</span><br><span class="line"></span><br><span class="line">16．3．2　可对矢量执行的操作　547</span><br><span class="line"></span><br><span class="line">16．3．3　对矢量可执行的其他操作　550</span><br><span class="line"></span><br><span class="line">16．3．4　基于范围的for循环（C++11）　553</span><br><span class="line"></span><br><span class="line">16．4　泛型编程　553</span><br><span class="line"></span><br><span class="line">16．4．1　为何使用迭代器　553</span><br><span class="line"></span><br><span class="line">16．4．2　迭代器类型　556</span><br><span class="line"></span><br><span class="line">16．4．3　迭代器层次结构　557</span><br><span class="line"></span><br><span class="line">16．4．4　概念、改进和模型　558</span><br><span class="line"></span><br><span class="line">16．4．5　容器种类　562</span><br><span class="line"></span><br><span class="line">16．4．6　关联容器　568</span><br><span class="line"></span><br><span class="line">16．4．7　无序关联容器（C++11）　572</span><br><span class="line"></span><br><span class="line">16．5　函数对象　572</span><br><span class="line"></span><br><span class="line">16．5．1　函数符概念　573</span><br><span class="line"></span><br><span class="line">16．5．2　预定义的函数符　575</span><br><span class="line"></span><br><span class="line">16．5．3　自适应函数符和函数适配器　576</span><br><span class="line"></span><br><span class="line">16．6　算法　577</span><br><span class="line"></span><br><span class="line">16．6．1　算法组　578</span><br><span class="line"></span><br><span class="line">16．6．2　算法的通用特征　578</span><br><span class="line"></span><br><span class="line">16．6．3　STL和string类　579</span><br><span class="line"></span><br><span class="line">16．6．4　函数和容器方法　579</span><br><span class="line"></span><br><span class="line">16．6．5　使用STL　581</span><br><span class="line"></span><br><span class="line">16．7　其他库　583</span><br><span class="line"></span><br><span class="line">16．7．1　vector、valarray和array　583</span><br><span class="line"></span><br><span class="line">16．7．2　模板initializer_list（C++11）　586</span><br><span class="line"></span><br><span class="line">16．7．3　使用initializer_list　587</span><br><span class="line"></span><br><span class="line">16．8　总结　588</span><br><span class="line"></span><br><span class="line">16．9　复习题　589</span><br><span class="line"></span><br><span class="line">16．10　编程练习　590</span><br><span class="line"></span><br><span class="line">第　17章 输入、输出和文件　592</span><br><span class="line"></span><br><span class="line">17．1　C++输入和输出概述　592</span><br><span class="line"></span><br><span class="line">17．1．1　流和缓冲区　593</span><br><span class="line"></span><br><span class="line">17．1．2　流、缓冲区和iostream文件　594</span><br><span class="line"></span><br><span class="line">17．1．3　重定向　596</span><br><span class="line"></span><br><span class="line">17．2　使用cout进行输出　597</span><br><span class="line"></span><br><span class="line">17．2．1　重载的&lt;&lt;运算符　597</span><br><span class="line"></span><br><span class="line">17．2．2　其他ostream方法　598</span><br><span class="line"></span><br><span class="line">17．2．3　刷新输出缓冲区　600</span><br><span class="line"></span><br><span class="line">17．2．4　用cout进行格式化　601</span><br><span class="line"></span><br><span class="line">17．3　使用cin进行输入　611</span><br><span class="line"></span><br><span class="line">17．3．1　cin&gt;&gt;如何检查输入　612</span><br><span class="line"></span><br><span class="line">17．3．2　流状态　613</span><br><span class="line"></span><br><span class="line">17．3．3　其他istream类方法　616</span><br><span class="line"></span><br><span class="line">17．3．4　其他istream方法　620</span><br><span class="line"></span><br><span class="line">17．4　文件输入和输出　622</span><br><span class="line"></span><br><span class="line">17．4．1　简单的文件I&#x2F;O　623</span><br><span class="line"></span><br><span class="line">17．4．2　流状态检查和is_open()　625</span><br><span class="line"></span><br><span class="line">17．4．3　打开多个文件　625</span><br><span class="line"></span><br><span class="line">17．4．4　命令行处理技术　626</span><br><span class="line"></span><br><span class="line">17．4．5　文件模式　627</span><br><span class="line"></span><br><span class="line">17．4．6　随机存取　633</span><br><span class="line"></span><br><span class="line">17．5　内核格式化　638</span><br><span class="line"></span><br><span class="line">17．6　总结　640</span><br><span class="line"></span><br><span class="line">17．7　复习题　641</span><br><span class="line"></span><br><span class="line">17．8　编程练习　642</span><br><span class="line"></span><br><span class="line">第　18章 探讨C++新标准　644</span><br><span class="line"></span><br><span class="line">18．1　复习前面介绍过的C++11功能　644</span><br><span class="line"></span><br><span class="line">18．1．1　新类型　644</span><br><span class="line"></span><br><span class="line">18．1．2　统一的初始化　644</span><br><span class="line"></span><br><span class="line">18．1．3　声明　645</span><br><span class="line"></span><br><span class="line">18．1．4　智能指针　646</span><br><span class="line"></span><br><span class="line">18．1．5　异常规范方面的修改　647</span><br><span class="line"></span><br><span class="line">18．1．6　作用域内枚举　647</span><br><span class="line"></span><br><span class="line">18．1．7　对类的修改　647</span><br><span class="line"></span><br><span class="line">18．1．8　模板和STL方面的修改　648</span><br><span class="line"></span><br><span class="line">18．1．9　右值引用　649</span><br><span class="line"></span><br><span class="line">18．2　移动语义和右值引用　650</span><br><span class="line"></span><br><span class="line">18．2．1　为何需要移动语义　650</span><br><span class="line"></span><br><span class="line">18．2．2　一个移动示例　651</span><br><span class="line"></span><br><span class="line">18．2．3　移动构造函数解析　654</span><br><span class="line"></span><br><span class="line">18．2．4　赋值　655</span><br><span class="line"></span><br><span class="line">18．2．5　强制移动　655</span><br><span class="line"></span><br><span class="line">18．3　新的类功能　658</span><br><span class="line"></span><br><span class="line">18．3．1　特殊的成员函数　658</span><br><span class="line"></span><br><span class="line">18．3．2　默认的方法和禁用的方法　659</span><br><span class="line"></span><br><span class="line">18．3．3　委托构造函数　660</span><br><span class="line"></span><br><span class="line">18．3．4　继承构造函数　660</span><br><span class="line"></span><br><span class="line">18．3．5　管理虚方法：override和final　661</span><br><span class="line"></span><br><span class="line">18．4　Lambda函数　662</span><br><span class="line"></span><br><span class="line">18．4．1　比较函数指针、函数符和Lambda函数　662</span><br><span class="line"></span><br><span class="line">18．4．2　为何使用lambda　664</span><br><span class="line"></span><br><span class="line">18．5　包装器　666</span><br><span class="line"></span><br><span class="line">18．5．1　包装器function及模板的低效性　666</span><br><span class="line"></span><br><span class="line">18．5．2　修复问题　667</span><br><span class="line"></span><br><span class="line">18．5．3　其他方式　669</span><br><span class="line"></span><br><span class="line">18．6　可变参数模板　669</span><br><span class="line"></span><br><span class="line">18．6．1　模板和函数参数包　669</span><br><span class="line"></span><br><span class="line">18．6．2　展开参数包　670</span><br><span class="line"></span><br><span class="line">18．6．3　在可变参数模板函数中使用递归　670</span><br><span class="line"></span><br><span class="line">18．7　C++11新增的其他功能　672</span><br><span class="line"></span><br><span class="line">18．7．1　并行编程　672</span><br><span class="line"></span><br><span class="line">18．7．2　新增的库　672</span><br><span class="line"></span><br><span class="line">18．7．3　低级编程　673</span><br><span class="line"></span><br><span class="line">18．7．4　杂项　673</span><br><span class="line"></span><br><span class="line">18．8　语言变化　674</span><br><span class="line"></span><br><span class="line">18．8．1　Boost项目　674</span><br><span class="line"></span><br><span class="line">18．8．2　TR1　674</span><br><span class="line"></span><br><span class="line">18．8．3　使用Boost　674</span><br><span class="line"></span><br><span class="line">18．9　接下来的任务　675</span><br><span class="line"></span><br><span class="line">18．10　总结　675</span><br><span class="line"></span><br><span class="line">18．11　复习题　676</span><br><span class="line"></span><br><span class="line">18．12　编程练习　678</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python进阶 PDF</title>
    <url>/posts/a298853a/</url>
    <content><![CDATA[<h4 id="《Python进阶》"><a href="#《Python进阶》" class="headerlink" title="《Python进阶》"></a>《Python进阶》</h4><p><img src="/images/5557efa3216ace1b2d9ce35a9bb8ff8d1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言　　xvii</span><br><span class="line"></span><br><span class="line">第一部分　序幕</span><br><span class="line"></span><br><span class="line">第1章　Python 数据模型　　2</span><br><span class="line"></span><br><span class="line">1.1　一摞 Python 风格的纸牌　　3</span><br><span class="line"></span><br><span class="line">1.2　如何使用特殊方法　　6</span><br><span class="line"></span><br><span class="line">1.2.1　模拟数值类型　　7</span><br><span class="line"></span><br><span class="line">1.2.2　字符串表示形式　　9</span><br><span class="line"></span><br><span class="line">1.2.3　算术运算符　　10</span><br><span class="line"></span><br><span class="line">1.2.4　自定义的布尔值　　10</span><br><span class="line"></span><br><span class="line">1.3　特殊方法一览　　10</span><br><span class="line"></span><br><span class="line">1.4　为什么 len 不是普通方法　　12</span><br><span class="line"></span><br><span class="line">1.5　本章小结　　12</span><br><span class="line"></span><br><span class="line">1.6　延伸阅读　　13</span><br><span class="line"></span><br><span class="line">第二部分　数据结构</span><br><span class="line"></span><br><span class="line">第2章　序列构成的数组　　16</span><br><span class="line"></span><br><span class="line">2.1　内置序列类型概览　　17</span><br><span class="line"></span><br><span class="line">2.2　列表推导和生成器表达式　　18</span><br><span class="line"></span><br><span class="line">2.3　元组不仅仅是不可变的列表　　22</span><br><span class="line"></span><br><span class="line">2.4　切片　　28</span><br><span class="line"></span><br><span class="line">2.5　对序列使用 + 和 *　　31</span><br><span class="line"></span><br><span class="line">2.6　序列的增量赋值　　33</span><br><span class="line"></span><br><span class="line">2.7　 list.sort 方法和内置函数 sorted　　36</span><br><span class="line"></span><br><span class="line">2.8　用 bisect 来管理已排序的序列　　37</span><br><span class="line"></span><br><span class="line">2.9　当列表不是首选时　　41</span><br><span class="line"></span><br><span class="line">2.10　本章小结　　49</span><br><span class="line"></span><br><span class="line">2.11　延伸阅读　　50</span><br><span class="line"></span><br><span class="line">第3章　字典和集合　　54</span><br><span class="line"></span><br><span class="line">3.1　泛映射类型　　54</span><br><span class="line"></span><br><span class="line">3.2　字典推导　　56</span><br><span class="line"></span><br><span class="line">3.3　常见的映射方法　　57</span><br><span class="line"></span><br><span class="line">3.4　映射的弹性键查询　　61</span><br><span class="line"></span><br><span class="line">3.5　字典的变种　　65</span><br><span class="line"></span><br><span class="line">3.6　子类化 UserDict　　65</span><br><span class="line"></span><br><span class="line">3.7　不可变映射类型　　67</span><br><span class="line"></span><br><span class="line">3.8　集合论　　68</span><br><span class="line"></span><br><span class="line">3.9　 dict 和 set 的背后　　73</span><br><span class="line"></span><br><span class="line">3.10　本章小结　　80</span><br><span class="line"></span><br><span class="line">3.11　延伸阅读　　81</span><br><span class="line"></span><br><span class="line">第4章　文本和字节序列　　83</span><br><span class="line"></span><br><span class="line">4.1　字符问题　　84</span><br><span class="line"></span><br><span class="line">4.2　字节概要　　85</span><br><span class="line"></span><br><span class="line">4.3　基本的编解码器　　88</span><br><span class="line"></span><br><span class="line">4.4　了解编解码问题　　89</span><br><span class="line"></span><br><span class="line">4.5　处理文本文件　　94</span><br><span class="line"></span><br><span class="line">4.6　为了正确比较而规范化 Unicode 字符串　　99</span><br><span class="line"></span><br><span class="line">4.7　Unicode 文本排序　　105</span><br><span class="line"></span><br><span class="line">4.8　Unicode 数据库　　108</span><br><span class="line"></span><br><span class="line">4.9　支持字符串和字节序列的双模式 API　　109</span><br><span class="line"></span><br><span class="line">4.10　本章小结　　112</span><br><span class="line"></span><br><span class="line">4.11　延伸阅读　　113</span><br><span class="line"></span><br><span class="line">第三部分　把函数视作对象</span><br><span class="line"></span><br><span class="line">第5章　一等函数　　118</span><br><span class="line"></span><br><span class="line">5.1　把函数视作对象　　119</span><br><span class="line"></span><br><span class="line">5.2　高阶函数　　120</span><br><span class="line"></span><br><span class="line">5.3　匿名函数　　122</span><br><span class="line"></span><br><span class="line">5.4　可调用对象　　122</span><br><span class="line"></span><br><span class="line">5.5　用户定义的可调用类型　　123</span><br><span class="line"></span><br><span class="line">5.6　函数内省　　124</span><br><span class="line"></span><br><span class="line">5.7　从定位参数到仅限关键字参数　　126</span><br><span class="line"></span><br><span class="line">5.8　获取关于参数的信息　　127</span><br><span class="line"></span><br><span class="line">5.9　函数注解　　131</span><br><span class="line"></span><br><span class="line">5.10　支持函数式编程的包　　132</span><br><span class="line"></span><br><span class="line">5.11　本章小结　　137</span><br><span class="line"></span><br><span class="line">5.12　延伸阅读　　137</span><br><span class="line"></span><br><span class="line">第6章　使用一等函数实现设计模式　　141</span><br><span class="line"></span><br><span class="line">6.1　案例分析：重构“策略”模式　　142</span><br><span class="line"></span><br><span class="line">6.2　“命令”模式　　150</span><br><span class="line"></span><br><span class="line">6.3　本章小结　　151</span><br><span class="line"></span><br><span class="line">6.4　延伸阅读　　152</span><br><span class="line"></span><br><span class="line">第7章　函数装饰器和闭包　　154</span><br><span class="line"></span><br><span class="line">7.1　装饰器基础知识　　155</span><br><span class="line"></span><br><span class="line">7.2　Python 何时执行装饰器　　156</span><br><span class="line"></span><br><span class="line">7.3　使用装饰器改进“策略”模式　　157</span><br><span class="line"></span><br><span class="line">7.4　变量作用域规则　　159</span><br><span class="line"></span><br><span class="line">7.5　闭包　　161</span><br><span class="line"></span><br><span class="line">7.6　 nonlocal 声明　　164</span><br><span class="line"></span><br><span class="line">7.7　实现一个简单的装饰器　　165</span><br><span class="line"></span><br><span class="line">7.8　标准库中的装饰器　　168</span><br><span class="line"></span><br><span class="line">7.9　叠放装饰器　　172</span><br><span class="line"></span><br><span class="line">7.10　参数化装饰器　　173</span><br><span class="line"></span><br><span class="line">7.11　本章小结　　177</span><br><span class="line"></span><br><span class="line">7.12　延伸阅读　　178</span><br><span class="line"></span><br><span class="line">第四部分　面向对象惯用法</span><br><span class="line"></span><br><span class="line">第8章　对象引用、可变性和垃圾回收　　182</span><br><span class="line"></span><br><span class="line">8.1　变量不是盒子　　183</span><br><span class="line"></span><br><span class="line">8.2　标识、相等性和别名　　184</span><br><span class="line"></span><br><span class="line">8.3　默认做浅复制　　187</span><br><span class="line"></span><br><span class="line">8.4　函数的参数作为引用时　　190</span><br><span class="line"></span><br><span class="line">8.5　 del 和垃圾回收　　195</span><br><span class="line"></span><br><span class="line">8.6　弱引用　　196</span><br><span class="line"></span><br><span class="line">8.7　Python 对不可变类型施加的把戏　　199</span><br><span class="line"></span><br><span class="line">8.8　本章小结　　201</span><br><span class="line"></span><br><span class="line">8.9　延伸阅读　　201</span><br><span class="line"></span><br><span class="line">第9章　符合 Python 风格的对象　　205</span><br><span class="line"></span><br><span class="line">9.1　对象表示形式　　206</span><br><span class="line"></span><br><span class="line">9.2　再谈向量类　　206</span><br><span class="line"></span><br><span class="line">9.3　备选构造方法　　208</span><br><span class="line"></span><br><span class="line">9.4　 classmethod 与 staticmethod　　209</span><br><span class="line"></span><br><span class="line">9.5　格式化显示　　210</span><br><span class="line"></span><br><span class="line">9.6　可散列的 Vector2d　　213</span><br><span class="line"></span><br><span class="line">9.7　Python 的私有属性和“受保护的”属性　　218</span><br><span class="line"></span><br><span class="line">9.8　使用 __slots__ 类属性节省空间　　220</span><br><span class="line"></span><br><span class="line">9.9　覆盖类属性　　222</span><br><span class="line"></span><br><span class="line">9.10　本章小结　　224</span><br><span class="line"></span><br><span class="line">9.11　延伸阅读　　225</span><br><span class="line"></span><br><span class="line">第10章　序列的修改、散列和切片　　229</span><br><span class="line"></span><br><span class="line">10.1　 Vector 类：用户定义的序列类型　　230</span><br><span class="line"></span><br><span class="line">10.2　 Vector 类第1 版：与 Vector2d 类兼容　　230</span><br><span class="line"></span><br><span class="line">10.3　协议和鸭子类型　　232</span><br><span class="line"></span><br><span class="line">10.4　 Vector 类第2 版：可切片的序列　　233</span><br><span class="line"></span><br><span class="line">10.5　 Vector 类第3 版：动态存取属性　　237</span><br><span class="line"></span><br><span class="line">10.6　 Vector 类第4 版：散列和快速等值测试　　240</span><br><span class="line"></span><br><span class="line">10.7　 Vector 类第5 版：格式化　　244</span><br><span class="line"></span><br><span class="line">10.8　本章小结　　251</span><br><span class="line"></span><br><span class="line">10.9　延伸阅读　　251</span><br><span class="line"></span><br><span class="line">第11章　接口：从协议到抽象基类　　256</span><br><span class="line"></span><br><span class="line">11.1　Python 文化中的接口和协议　　257</span><br><span class="line"></span><br><span class="line">11.2　Python 喜欢序列　　258</span><br><span class="line"></span><br><span class="line">11.3　使用猴子补丁在运行时实现协议　　260</span><br><span class="line"></span><br><span class="line">11.4　Alex Martelli 的水禽　　262</span><br><span class="line"></span><br><span class="line">11.5　定义抽象基类的子类　　266</span><br><span class="line"></span><br><span class="line">11.6　标准库中的抽象基类　　267</span><br><span class="line"></span><br><span class="line">11.7　定义并使用一个抽象基类　　270</span><br><span class="line"></span><br><span class="line">11.8　 Tombola 子类的测试方法　　278</span><br><span class="line"></span><br><span class="line">11.9　Python 使用 register 的方式　　281</span><br><span class="line"></span><br><span class="line">11.10　鹅的行为有可能像鸭子　　281</span><br><span class="line"></span><br><span class="line">11.11　本章小结　　283</span><br><span class="line"></span><br><span class="line">11.12　延伸阅读　　284</span><br><span class="line"></span><br><span class="line">第12章　继承的优缺点　　289</span><br><span class="line"></span><br><span class="line">12.1　子类化内置类型很麻烦　　289</span><br><span class="line"></span><br><span class="line">12.2　多重继承和方法解析顺序　　292</span><br><span class="line"></span><br><span class="line">12.3　多重继承的真实应用　　296</span><br><span class="line"></span><br><span class="line">12.4　处理多重继承　　298</span><br><span class="line"></span><br><span class="line">12.5　一个现代示例：Django 通用视图中的混入　　301</span><br><span class="line"></span><br><span class="line">12.6　本章小结　　304</span><br><span class="line"></span><br><span class="line">12.7　延伸阅读　　304</span><br><span class="line"></span><br><span class="line">第13章　正确重载运算符　　307</span><br><span class="line"></span><br><span class="line">13.1　运算符重载基础　　308</span><br><span class="line"></span><br><span class="line">13.2　一元运算符　　308</span><br><span class="line"></span><br><span class="line">13.3　重载向量加法运算符 +　　310</span><br><span class="line"></span><br><span class="line">13.4　重载标量乘法运算符 *　　315</span><br><span class="line"></span><br><span class="line">13.5　众多比较运算符　　318</span><br><span class="line"></span><br><span class="line">13.6　增量赋值运算符　　321</span><br><span class="line"></span><br><span class="line">13.7　本章小结　　325</span><br><span class="line"></span><br><span class="line">13.8　延伸阅读　　326</span><br><span class="line"></span><br><span class="line">第五部分　控制流程</span><br><span class="line"></span><br><span class="line">第14章　可迭代的对象、迭代器和生成器　　330</span><br><span class="line"></span><br><span class="line">14.1　 Sentence 类第1 版：单词序列　　331</span><br><span class="line"></span><br><span class="line">14.2　可迭代的对象与迭代器的对比　　334</span><br><span class="line"></span><br><span class="line">14.3　 Sentence 类第2 版：典型的迭代器　　337</span><br><span class="line"></span><br><span class="line">14.4　 Sentence 类第3 版：生成器函数　　339</span><br><span class="line"></span><br><span class="line">14.5　 Sentence 类第4 版：惰性实现　　343</span><br><span class="line"></span><br><span class="line">14.6　 Sentence 类第5 版：生成器表达式　　344</span><br><span class="line"></span><br><span class="line">14.7　何时使用生成器表达式　　345</span><br><span class="line"></span><br><span class="line">14.8　另一个示例：等差数列生成器　　346</span><br><span class="line"></span><br><span class="line">14.9　标准库中的生成器函数　　349</span><br><span class="line"></span><br><span class="line">14.10　Python　　3.3 中新出现的句法： yield from　　357</span><br><span class="line"></span><br><span class="line">14.11　可迭代的归约函数　　358</span><br><span class="line"></span><br><span class="line">14.12　深入分析 iter 函数　　359</span><br><span class="line"></span><br><span class="line">14.13　案例分析：在数据库转换工具中使用生成器　　360</span><br><span class="line"></span><br><span class="line">14.14　把生成器当成协程　　362</span><br><span class="line"></span><br><span class="line">14.15　本章小结　　362</span><br><span class="line"></span><br><span class="line">14.16　延伸阅读　　363</span><br><span class="line"></span><br><span class="line">第15章　上下文管理器和 else 块　　368</span><br><span class="line"></span><br><span class="line">15.1　先做这个，再做那个： if 语句之外的 else 块　　369</span><br><span class="line"></span><br><span class="line">15.2　上下文管理器和 with 块　　370</span><br><span class="line"></span><br><span class="line">15.3　 contextlib 模块中的实用工具　　374</span><br><span class="line"></span><br><span class="line">15.4　使用 @contextmanager　　375</span><br><span class="line"></span><br><span class="line">15.5　本章小结　　378</span><br><span class="line"></span><br><span class="line">15.6　延伸阅读　　378</span><br><span class="line"></span><br><span class="line">第16章　协程　　381</span><br><span class="line"></span><br><span class="line">16.1　生成器如何进化成协程　　382</span><br><span class="line"></span><br><span class="line">16.2　用作协程的生成器的基本行为　　382</span><br><span class="line"></span><br><span class="line">16.3　示例：使用协程计算移动平均值　　385</span><br><span class="line"></span><br><span class="line">16.4　预激协程的装饰器　　386</span><br><span class="line"></span><br><span class="line">16.5　终止协程和异常处理　　388</span><br><span class="line"></span><br><span class="line">16.6　让协程返回值　　391</span><br><span class="line"></span><br><span class="line">16.7　使用 yield from　　393</span><br><span class="line"></span><br><span class="line">16.8　 yield from 的意义　　398</span><br><span class="line"></span><br><span class="line">16.9　使用案例：使用协程做离散事件仿真　　403</span><br><span class="line"></span><br><span class="line">16.10　本章小结　　410</span><br><span class="line"></span><br><span class="line">16.11　延伸阅读　　411</span><br><span class="line"></span><br><span class="line">第17章　使用期物处理并发　　416</span><br><span class="line"></span><br><span class="line">17.1　示例：网络下载的三种风格　　416</span><br><span class="line"></span><br><span class="line">17.2　阻塞型 I&#x2F;O 和 GIL　　424</span><br><span class="line"></span><br><span class="line">17.3　使用 concurrent.futures 模块启动进程　　424</span><br><span class="line"></span><br><span class="line">17.4　实验 Executor.map 方法　　426</span><br><span class="line"></span><br><span class="line">17.5　显示下载进度并处理错误　　429</span><br><span class="line"></span><br><span class="line">17.6　本章小结　　437</span><br><span class="line"></span><br><span class="line">17.7　延伸阅读　　438</span><br><span class="line"></span><br><span class="line">第18章　使用 asyncio 包处理并发　　442</span><br><span class="line"></span><br><span class="line">18.1　线程与协程对比　　443</span><br><span class="line"></span><br><span class="line">18.2　使用 asyncio 和 aiohttp 包下载　　450</span><br><span class="line"></span><br><span class="line">18.3　避免阻塞型调用　　454</span><br><span class="line"></span><br><span class="line">18.4　改进 asyncio 下载脚本　　456</span><br><span class="line"></span><br><span class="line">18.5　从回调到期物和协程　　462</span><br><span class="line"></span><br><span class="line">18.6　使用 asyncio 包编写服务器　　466</span><br><span class="line"></span><br><span class="line">18.7　本章小结　　475</span><br><span class="line"></span><br><span class="line">18.8　延伸阅读　　476</span><br><span class="line"></span><br><span class="line">第六部分　元编程</span><br><span class="line"></span><br><span class="line">第19章　动态属性和特性　　482</span><br><span class="line"></span><br><span class="line">19.1　使用动态属性转换数据　　483</span><br><span class="line"></span><br><span class="line">19.2　使用特性验证属性　　498</span><br><span class="line"></span><br><span class="line">19.3　特性全解析　　500</span><br><span class="line"></span><br><span class="line">19.4　定义一个特性工厂函数　　504</span><br><span class="line"></span><br><span class="line">19.5　处理属性删除操作　　506</span><br><span class="line"></span><br><span class="line">19.6　处理属性的重要属性和函数　　507</span><br><span class="line"></span><br><span class="line">19.7　本章小结　　510</span><br><span class="line"></span><br><span class="line">19.8　延伸阅读　　510</span><br><span class="line"></span><br><span class="line">第20章　属性描述符　　514</span><br><span class="line"></span><br><span class="line">20.1　描述符示例：验证属性　　514</span><br><span class="line"></span><br><span class="line">20.2　覆盖型与非覆盖型描述符对比　　526</span><br><span class="line"></span><br><span class="line">20.3　方法是描述符　　531</span><br><span class="line"></span><br><span class="line">20.4　描述符用法建议　　533</span><br><span class="line"></span><br><span class="line">20.5　描述符的文档字符串和覆盖删除操作　　534</span><br><span class="line"></span><br><span class="line">20.6　本章小结　　535</span><br><span class="line"></span><br><span class="line">20.7　延伸阅读　　536</span><br><span class="line"></span><br><span class="line">第21章　类元编程　　538</span><br><span class="line"></span><br><span class="line">21.1　类工厂函数　　539</span><br><span class="line"></span><br><span class="line">21.2　定制描述符的类装饰器　　541</span><br><span class="line"></span><br><span class="line">21.3　导入时和运行时比较　　543</span><br><span class="line"></span><br><span class="line">21.4　元类基础知识　　547</span><br><span class="line"></span><br><span class="line">21.5　定制描述符的元类　　552</span><br><span class="line"></span><br><span class="line">21.6　元类的特殊方法 __prepare__　　554</span><br><span class="line"></span><br><span class="line">21.7　类作为对象　　556</span><br><span class="line"></span><br><span class="line">21.8　本章小结　　557</span><br><span class="line"></span><br><span class="line">21.9　延伸阅读　　557</span><br><span class="line"></span><br><span class="line">结语　　560</span><br><span class="line"></span><br><span class="line">附录 A　辅助脚本　　563</span><br><span class="line"></span><br><span class="line">Python 术语表　　588</span><br><span class="line"></span><br><span class="line">作者简介　　600</span><br><span class="line"></span><br><span class="line">关于封面　　600</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>啊哈c语言 PDF</title>
    <url>/posts/d59fb5ac/</url>
    <content><![CDATA[<h4 id="《啊哈c语言》"><a href="#《啊哈c语言》" class="headerlink" title="《啊哈c语言》"></a>《啊哈c语言》</h4><h4 id="C-经典书籍"><a href="#C-经典书籍" class="headerlink" title="C 经典书籍"></a>C 经典书籍</h4><p>这是一本非常有趣的编程启蒙书，全书从中小学生的角度来讲述，没有生涩的内容，取而代之的是生动活泼的漫画和风趣幽默的文字。并配合超萌的编程软件，从开始学习与计算机对话到自己独立制作一个游戏，由浅入深地讲述编程的思维。同时，与计算机展开的逻辑较量一定会让你觉得很有意思。你可以在茶余饭后阅读本书，甚至蹲在马桶上时也可以看得津津有味。编程将会改变我们的思维，教会我们如何思考，让我们的思维插上计算机的翅膀，以一种全新的方式来看世界。现在就让我们一起走进计算机编程的神奇世界，探索和发现计算机编程的魔力吧！<br><a id="more"></a></p>
<h6 id="链接-https-pan-baidu-com-s-1WBw0eL9qahPL9IV4Zr8PGA-密码-gi21"><a href="#链接-https-pan-baidu-com-s-1WBw0eL9qahPL9IV4Zr8PGA-密码-gi21" class="headerlink" title="链接:https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA 密码:gi21"></a>链接:<a href="https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA">https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA</a> 密码:gi21</h6><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p><img src="/images/3c94e7df4d4d8bab5a600934b21ce3cb1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目 录</span><br><span class="line"></span><br><span class="line">第1章 编程改变思维 1</span><br><span class="line"></span><br><span class="line">第1节 为什么要学习编程 1</span><br><span class="line"></span><br><span class="line">第2节 本书是讲什么的，写给谁看的 4</span><br><span class="line"></span><br><span class="line">第2章 梦想启航 7</span><br><span class="line"></span><br><span class="line">第1节 编程的魔力 7</span><br><span class="line"></span><br><span class="line">第2节 让计算机开口说话 9</span><br><span class="line"></span><br><span class="line">第3节 多彩一点 18</span><br><span class="line"></span><br><span class="line">第4节 让计算机做加法 21</span><br><span class="line"></span><br><span class="line">第5节 数字的家――变量 26</span><br><span class="line"></span><br><span class="line">第6节 数据输出――我说咋地就咋地 31</span><br><span class="line"></span><br><span class="line">第7节 数据输入――我说算啥就算啥 33</span><br><span class="line"></span><br><span class="line">第8节 究竟有多少种小房子 37</span><br><span class="line"></span><br><span class="line">第9节 拨开云雾见月明 40</span><br><span class="line"></span><br><span class="line">第10节 逻辑挑战1：交换小房子中的数 42</span><br><span class="line"></span><br><span class="line">第11节 天啊！这怎么能看懂 45</span><br><span class="line"></span><br><span class="line">第3章 较量才刚刚开始 49</span><br><span class="line"></span><br><span class="line">第1节 大于、小于还是相等 49</span><br><span class="line"></span><br><span class="line">第2节 判断正数 50</span><br><span class="line"></span><br><span class="line">第3节 偶数判断 54</span><br><span class="line"></span><br><span class="line">第4节 神器else 56</span><br><span class="line"></span><br><span class="line">第5节 请告诉我谁大 59</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战2：3个数怎么办 61</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战3：我要排序 66</span><br><span class="line"></span><br><span class="line">第8节 运算符总结 71</span><br><span class="line"></span><br><span class="line">第9节 1＞2究竟对不对 71</span><br><span class="line"></span><br><span class="line">第10节 讨厌的嵌套 74</span><br><span class="line"></span><br><span class="line">第11节 if-else语法总结 78</span><br><span class="line"></span><br><span class="line">第4章 重量级选手登场 79</span><br><span class="line"></span><br><span class="line">第1节 永不停止的哭声 79</span><br><span class="line"></span><br><span class="line">第2节 我说几遍就几遍 83</span><br><span class="line"></span><br><span class="line">第3节 if对while说：我对你很重要 88</span><br><span class="line"></span><br><span class="line">第4节 求和！求和！！求和！！！ 90</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战4：60秒倒计时开始 95</span><br><span class="line"></span><br><span class="line">第6节 这个有点晕――循环嵌套来了 99</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战5：奔跑的字母 104</span><br><span class="line"></span><br><span class="line">第8节 究竟循环了多少次 108</span><br><span class="line"></span><br><span class="line">第9节 逻辑挑战6：奔跑的小人 110</span><br><span class="line"></span><br><span class="line">第10节 for隆重登场 114</span><br><span class="line"></span><br><span class="line">第5章 好戏在后面 118</span><br><span class="line"></span><br><span class="line">第1节 程序的3种结构 118</span><br><span class="line"></span><br><span class="line">第2节 嗦一下 119</span><br><span class="line"></span><br><span class="line">第3节 逻辑挑战7：判读质数很简单 120</span><br><span class="line"></span><br><span class="line">第4节 更快一点：break 125</span><br><span class="line"></span><br><span class="line">第5节 continue 126</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战8：验证哥德巴赫猜想 127</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战9：水仙花数 130</span><br><span class="line"></span><br><span class="line">第8节 逻辑挑战10：解决奥数难题 135</span><br><span class="line"></span><br><span class="line">第9节 逻辑挑战11：猜数游戏 138</span><br><span class="line"></span><br><span class="line">第10节 逻辑挑战12：你好坏，关机啦 142</span><br><span class="line"></span><br><span class="line">第6章 天啊！一大串数正在接近 144</span><br><span class="line"></span><br><span class="line">第1节 逆序输出 144</span><br><span class="line"></span><br><span class="line">第2节 申请100个小房子怎么办 145</span><br><span class="line"></span><br><span class="line">第3节 100个数的逆序 147</span><br><span class="line"></span><br><span class="line">第4节 逻辑挑战13：陶陶摘苹果 148</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战14：一个萝卜一个坑 151</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战15：选择排序 156</span><br><span class="line"></span><br><span class="line">第7节 二维数组 159</span><br><span class="line"></span><br><span class="line">第8节 剩下的一些东西 161</span><br><span class="line"></span><br><span class="line">第7章 有了它你能做更多的事 165</span><br><span class="line"></span><br><span class="line">第1节 字符的妙用 165</span><br><span class="line"></span><br><span class="line">第2节 多余的回车键 167</span><br><span class="line"></span><br><span class="line">第3节 字符的本质 169</span><br><span class="line"></span><br><span class="line">第4节 人名怎么存储呢 171</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战16：字母的排序 176</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战17：字典序 177</span><br><span class="line"></span><br><span class="line">第7节 多行字符 179</span><br><span class="line"></span><br><span class="line">第8节 存储一个迷宫 182</span><br><span class="line"></span><br><span class="line">第8章 游戏时间到了 184</span><br><span class="line"></span><br><span class="line">第1节 走迷宫 184</span><br><span class="line"></span><br><span class="line">第2节 推箱子 194</span><br><span class="line"></span><br><span class="line">附录A 标识符命名规则 197</span><br><span class="line"></span><br><span class="line">附录B 运算符的优先级和结合性 199</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据库原理（第5版） PDF</title>
    <url>/posts/4c96e416/</url>
    <content><![CDATA[<h4 id="《数据库原理（第5版）》"><a href="#《数据库原理（第5版）》" class="headerlink" title="《数据库原理（第5版）》"></a>《数据库原理（第5版）》</h4><h6 id="链接-https-pan-baidu-com-s-1jR-uS6VtNQYj6A-PfePm8Q-密码-kfi2"><a href="#链接-https-pan-baidu-com-s-1jR-uS6VtNQYj6A-PfePm8Q-密码-kfi2" class="headerlink" title="链接:https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q 密码:kfi2"></a>链接:<a href="https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q">https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q</a> 密码:kfi2</h6><p>《数据库系统概论（第5版）》dy 版于1983年出版，至今已修订至第5版。第5版被列入“十二五”普通高等教育本科guo家规划教材。相应课程于2004年被评为北京市精品课程，2005年被评为guo家精品课程，2014年被批准为guo家精品资源共享课。<br><a id="more"></a></p>
<p>《数据库系统概论（第5版）》系统全面地阐述了数据库系统的基础理论、基本技术和基本方法。全书分为4篇16章。dy篇基础篇，包括绪论、关系数据库、关系数据库标准语言SQL、数据库安全性和数据库完整性，共5章；第二篇设计与应用开发篇，包括关系数据理论、数据库设计和数据库编程，共3章；第三篇系统篇，包括关系查询处理和查询优化、数据库恢复技术、并发控制和数据库管理系统，共4章；第四篇新技术篇，包括数据库技术发展概述、大数据管理、内存数据库系统和数据仓库与联机分析处理技术，共4章。</p>
<p>《数据库系统概论（第5版）》可以作为高等学校计算机类专业、信息管理与信息系统等相关专业数据库课程的教材。也可供从事数据库系统研究、开发和应用的研究人员和工程技术人员参考。</p>
<p><img src="/images/fb2c92b4a05610db92d74cea0845145b1.jpg" width="50%" height="50%"></p>
<h6 id="链接-https-pan-baidu-com-s-1jR-uS6VtNQYj6A-PfePm8Q-密码-kfi2-1"><a href="#链接-https-pan-baidu-com-s-1jR-uS6VtNQYj6A-PfePm8Q-密码-kfi2-1" class="headerlink" title="链接:https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q 密码:kfi2"></a>链接:<a href="https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q">https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q</a> 密码:kfi2</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dy篇 基础篇</span><br><span class="line"></span><br><span class="line">dy 章 绪论</span><br><span class="line"></span><br><span class="line">1.1 数据库系统概述</span><br><span class="line"></span><br><span class="line">1.1.1 数据库的4个基本概念</span><br><span class="line"></span><br><span class="line">1.1.2 数据管理技术的产生和发展</span><br><span class="line"></span><br><span class="line">1.1.3 数据库系统的特点</span><br><span class="line"></span><br><span class="line">1.2 数据模型</span><br><span class="line"></span><br><span class="line">1.2.1 两类数据模型</span><br><span class="line"></span><br><span class="line">1.2.2 概念模型</span><br><span class="line"></span><br><span class="line">1.2.3 数据模型的组成要素</span><br><span class="line"></span><br><span class="line">1.2.4 常用的数据模型</span><br><span class="line"></span><br><span class="line">1.2.5 层次模型</span><br><span class="line"></span><br><span class="line">1.2.6 网状模型</span><br><span class="line"></span><br><span class="line">1.2.7 关系模型</span><br><span class="line"></span><br><span class="line">1.3 数据库系统的结构</span><br><span class="line"></span><br><span class="line">1.3.1 数据库系统模式的概念</span><br><span class="line"></span><br><span class="line">1.3.2 数据库系统的三级模式结构</span><br><span class="line"></span><br><span class="line">1.3.3 数据库的二级映像功能与数据独立性</span><br><span class="line"></span><br><span class="line">1.4 数据库系统的组成</span><br><span class="line"></span><br><span class="line">1.5 小结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">本章参考文献</span><br><span class="line"></span><br><span class="line">第2章 关系数据库</span><br><span class="line"></span><br><span class="line">2.1 关系数据结构及形式化定义</span><br><span class="line"></span><br><span class="line">2.1.1 关系</span><br><span class="line"></span><br><span class="line">2.1.2 关系模式</span><br><span class="line"></span><br><span class="line">2.1.3 关系数据库</span><br><span class="line"></span><br><span class="line">2.1.4 关系模型的存储结构</span><br><span class="line"></span><br><span class="line">2.2 关系操作</span><br><span class="line"></span><br><span class="line">2.2.1 基本的关系操作</span><br><span class="line"></span><br><span class="line">2.2.2 关系数据语言的分类</span><br><span class="line"></span><br><span class="line">2.3 关系的完整性</span><br><span class="line"></span><br><span class="line">2.3.1 实体完整性</span><br><span class="line"></span><br><span class="line">2.3.2 参照完整性</span><br><span class="line"></span><br><span class="line">2.3.3 用户定义的完整性</span><br><span class="line"></span><br><span class="line">2.4 关系代数</span><br><span class="line"></span><br><span class="line">2.4.1 传统的集合运算</span><br><span class="line"></span><br><span class="line">2.4.2 专门的关系运算</span><br><span class="line"></span><br><span class="line">2.5 关系演算</span><br><span class="line"></span><br><span class="line">2.5.1 元组关系演算语言ALPHA</span><br><span class="line"></span><br><span class="line">2.5.2 元组关系演算</span><br><span class="line"></span><br><span class="line">2.5.3 域关系演算语言QBE</span><br><span class="line"></span><br><span class="line">2.6 小结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">实验</span><br><span class="line"></span><br><span class="line">本章参考文献</span><br><span class="line"></span><br><span class="line">第3章 关系数据库标准语言SQL</span><br><span class="line"></span><br><span class="line">3.1 SQL.概述</span><br><span class="line"></span><br><span class="line">3.1.1 SQL的产生与发展</span><br><span class="line"></span><br><span class="line">3.1.2 SQL的特点</span><br><span class="line"></span><br><span class="line">3.1.3 SQL的基本概念</span><br><span class="line"></span><br><span class="line">3.2 学生一课程数据库</span><br><span class="line"></span><br><span class="line">3.3 数据定义</span><br><span class="line"></span><br><span class="line">3.3.1 模式的定义与删除</span><br><span class="line"></span><br><span class="line">3.3.2 基本表的定义、删除与修改</span><br><span class="line"></span><br><span class="line">3.3.3 索引的建立与删除</span><br><span class="line"></span><br><span class="line">3.3.4 数据字典</span><br><span class="line"></span><br><span class="line">3.4 数据查询</span><br><span class="line"></span><br><span class="line">3.4.1 单表查询</span><br><span class="line"></span><br><span class="line">3.4.2 连接查询</span><br><span class="line"></span><br><span class="line">3.4.3 嵌套查询</span><br><span class="line"></span><br><span class="line">3.4.4 集合查询</span><br><span class="line"></span><br><span class="line">3.4.5 基于派生表的查询</span><br><span class="line"></span><br><span class="line">3.4.6 SEI.，EC&#39;I’语句的一般格式</span><br><span class="line"></span><br><span class="line">3.5 数据更新</span><br><span class="line"></span><br><span class="line">3.5.1 插入数据</span><br><span class="line"></span><br><span class="line">3.5.2 修改数据</span><br><span class="line"></span><br><span class="line">3.5.3 删除数据</span><br><span class="line"></span><br><span class="line">3.6 空值的处理</span><br><span class="line"></span><br><span class="line">3.7 视图</span><br><span class="line"></span><br><span class="line">3.7.1 定义视图</span><br><span class="line"></span><br><span class="line">3.7.2 查询视图</span><br><span class="line"></span><br><span class="line">3.7.3 更新视图</span><br><span class="line"></span><br><span class="line">3.7.4 视图的作用</span><br><span class="line"></span><br><span class="line">3.8 小结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">实验</span><br><span class="line"></span><br><span class="line">本章参考文献</span><br><span class="line"></span><br><span class="line">第4章 数据库安全性</span><br><span class="line"></span><br><span class="line">4.1 数据库安全性概述</span><br><span class="line"></span><br><span class="line">4.1.1 数据库的不安全因素</span><br><span class="line"></span><br><span class="line">4.1.2 安全标准简介</span><br><span class="line"></span><br><span class="line">4.2 数据库安全性控制</span><br><span class="line"></span><br><span class="line">4.2.1 用户身份鉴别</span><br><span class="line"></span><br><span class="line">4.2.2 存取控制</span><br><span class="line"></span><br><span class="line">4.2.3 自主存取控制方法</span><br><span class="line"></span><br><span class="line">4.2.4 授权：授予与收回</span><br><span class="line"></span><br><span class="line">4.2.5 数据库角色</span><br><span class="line"></span><br><span class="line">4.2.6 强制存取控制方法</span><br><span class="line"></span><br><span class="line">4.3 视图机制</span><br><span class="line"></span><br><span class="line">4.4 审计</span><br><span class="line"></span><br><span class="line">4.5 数据加密</span><br><span class="line"></span><br><span class="line">4.6 其他安全性保护</span><br><span class="line"></span><br><span class="line">4.7 小结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">实验</span><br><span class="line"></span><br><span class="line">本章参考文献</span><br><span class="line"></span><br><span class="line">第5章 数据库完整性</span><br><span class="line"></span><br><span class="line">5.1 实体完整性</span><br><span class="line"></span><br><span class="line">5.1.1 定义实体完整性</span><br><span class="line"></span><br><span class="line">5.1.2 实体完整性检查和违约处理</span><br><span class="line"></span><br><span class="line">5.2 参照完整性</span><br><span class="line"></span><br><span class="line">5.2.1 定义参照完整性</span><br><span class="line"></span><br><span class="line">5.2.2 参照完整性检查和违约处理</span><br><span class="line"></span><br><span class="line">5.3 用户定义的完整性</span><br><span class="line"></span><br><span class="line">5.3.1 属性上的约束条件</span><br><span class="line"></span><br><span class="line">5.3.2 元组上的约束条件</span><br><span class="line"></span><br><span class="line">5.4 完整性约束命名子句</span><br><span class="line"></span><br><span class="line">5.5 域中的完整性限制</span><br><span class="line"></span><br><span class="line">5.6 断言</span><br><span class="line"></span><br><span class="line">5.7 触发器</span><br><span class="line"></span><br><span class="line">5.7.1 定义触发器</span><br><span class="line"></span><br><span class="line">5.7.2 激活触发器</span><br><span class="line"></span><br><span class="line">5.7.3 删除触发器</span><br><span class="line"></span><br><span class="line">5.8 小结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第二篇 设计与应用开发篇</span><br><span class="line"></span><br><span class="line">第三篇 系统篇</span><br><span class="line"></span><br><span class="line">第四篇 新技术篇</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术 卷1 基础知识 原书第9版 PDF</title>
    <url>/posts/3b91d480/</url>
    <content><![CDATA[<h4 id="《Java核心技术-卷1-基础知识-原书第9版》"><a href="#《Java核心技术-卷1-基础知识-原书第9版》" class="headerlink" title="《Java核心技术 卷1 基础知识 原书第9版》"></a>《Java核心技术 卷1 基础知识 原书第9版》</h4><h6 id="链接-https-pan-baidu-com-s-1L97jTawydJ6Yf5Sf0JfyAw-密码-x1x3"><a href="#链接-https-pan-baidu-com-s-1L97jTawydJ6Yf5Sf0JfyAw-密码-x1x3" class="headerlink" title="链接:https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw 密码:x1x3"></a>链接:<a href="https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw">https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw</a> 密码:x1x3</h6><p>Cay S.Horstmann，圣何塞州立大学计算机科学系教授、Java语言的倡导者，也是《Scala for theImpatient》一书（Addison-Wesley，2012）的作者和《Core JavaServer·Faces，3rd》一书（Prentice Hall, 2010）的合著者。他还经常在计算机会议上发表演讲。CrayCornell，已经教授程序设计专业课程20多年，并撰写了多部专著。他是Apress的创始人之一，他写的程序设计专业书籍非常畅销，曾荣获Jolt震撼大奖，并获得VisualBasic Magazine的读者最喜爱作品大奖。<br><a id="more"></a></p>
<p>编辑推荐</p>
<p>Java领域最有影响力和价值的著作之一，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评；</p>
<p>根据Java SE 7全面更新，系统全面讲解Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强</p>
<p><img src="/images/c52379bffbc0809e0ebb5e9dc2a1d3231.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 Java程序设计概述</span><br><span class="line"></span><br><span class="line">1.1 Java程序设计平台</span><br><span class="line"></span><br><span class="line">1.2 Java“白皮书”的关键术语</span><br><span class="line"></span><br><span class="line">1.2.1 简单性</span><br><span class="line"></span><br><span class="line">1.2.2 面向对象</span><br><span class="line"></span><br><span class="line">1.2.3 网络技能</span><br><span class="line"></span><br><span class="line">1.2.4 健壮性</span><br><span class="line"></span><br><span class="line">1.2.5 安全性</span><br><span class="line"></span><br><span class="line">1.2.6 体系结构中立</span><br><span class="line"></span><br><span class="line">1.2.7 可移植性</span><br><span class="line"></span><br><span class="line">1.2.8 解释型</span><br><span class="line"></span><br><span class="line">1.2.9 高性能</span><br><span class="line"></span><br><span class="line">1.2.10 多线程</span><br><span class="line"></span><br><span class="line">1.2.11 动态性</span><br><span class="line"></span><br><span class="line">1.3 Java applet与Internet</span><br><span class="line"></span><br><span class="line">1.4 Java发展简史</span><br><span class="line"></span><br><span class="line">1.5 关于Java的常见误解</span><br><span class="line"></span><br><span class="line">第2章 Java程序设计环境</span><br><span class="line"></span><br><span class="line">2.1 安装Java开发工具箱</span><br><span class="line"></span><br><span class="line">2.1.1 下载JDK</span><br><span class="line"></span><br><span class="line">2.1.2 设置执行路径</span><br><span class="line"></span><br><span class="line">2.1.3 安装库源文件和文档</span><br><span class="line"></span><br><span class="line">2.1.4 安装本书中的示例</span><br><span class="line"></span><br><span class="line">2.1.5 导航Java目录</span><br><span class="line"></span><br><span class="line">2.2 选择开发环境</span><br><span class="line"></span><br><span class="line">2.3 使用命令行工具</span><br><span class="line"></span><br><span class="line">2.4 使用集成开发环境</span><br><span class="line"></span><br><span class="line">2.5 运行图形化应用程序</span><br><span class="line"></span><br><span class="line">2.6 建立并运行applet</span><br><span class="line"></span><br><span class="line">第3章 Java的基本程序设计结构</span><br><span class="line"></span><br><span class="line">3.1 一个简单的Java应用程序</span><br><span class="line"></span><br><span class="line">3.2 注释</span><br><span class="line"></span><br><span class="line">3.3 数据类型</span><br><span class="line"></span><br><span class="line">3.3.1 整型</span><br><span class="line"></span><br><span class="line">3.3.2 浮点类型</span><br><span class="line"></span><br><span class="line">3.3.3 char类型</span><br><span class="line"></span><br><span class="line">3.3.4 boolean类型</span><br><span class="line"></span><br><span class="line">3.4 变量</span><br><span class="line"></span><br><span class="line">3.4.1 变量初始化</span><br><span class="line"></span><br><span class="line">3.4.2 常量</span><br><span class="line"></span><br><span class="line">3.5 运算符</span><br><span class="line"></span><br><span class="line">3.5.1 自增运算符与自减运算符</span><br><span class="line"></span><br><span class="line">3.5.2 关系运算符与boolean运算符</span><br><span class="line"></span><br><span class="line">3.5.3 位运算符</span><br><span class="line"></span><br><span class="line">3.5.4 数学函数与常量</span><br><span class="line"></span><br><span class="line">3.5.5 数值类型之间的转换</span><br><span class="line"></span><br><span class="line">3.5.6 强制类型转换</span><br><span class="line"></span><br><span class="line">3.5.7 括号与运算符级别</span><br><span class="line"></span><br><span class="line">3.5.8 枚举类型</span><br><span class="line"></span><br><span class="line">3.6 字符串</span><br><span class="line"></span><br><span class="line">3.6.1 子串</span><br><span class="line"></span><br><span class="line">3.6.2 拼接</span><br><span class="line"></span><br><span class="line">3.6.3 不可变字符串</span><br><span class="line"></span><br><span class="line">3.6.4 检测字符串是否相等</span><br><span class="line"></span><br><span class="line">3.6.5 空串与Null串</span><br><span class="line"></span><br><span class="line">3.6.6 代码点与代码单元</span><br><span class="line"></span><br><span class="line">3.6.7 字符串API</span><br><span class="line"></span><br><span class="line">3.6.8 阅读联机API文档</span><br><span class="line"></span><br><span class="line">3.6.9 构建字符串</span><br><span class="line"></span><br><span class="line">3.7 输入输出</span><br><span class="line"></span><br><span class="line">3.7.1 读取输入</span><br><span class="line"></span><br><span class="line">3.7.2 格式化输出</span><br><span class="line"></span><br><span class="line">3.7.3 文件输入与输出</span><br><span class="line"></span><br><span class="line">3.8 控制流程</span><br><span class="line"></span><br><span class="line">3.8.1 块作用域</span><br><span class="line"></span><br><span class="line">3.8.2 条件语句</span><br><span class="line"></span><br><span class="line">3.8.3 循环</span><br><span class="line"></span><br><span class="line">3.8.4 确定循环</span><br><span class="line"></span><br><span class="line">3.8.5 多重选择：switch语句</span><br><span class="line"></span><br><span class="line">3.8.6 中断控制流程语句</span><br><span class="line"></span><br><span class="line">3.9 大数值</span><br><span class="line"></span><br><span class="line">3.10 数组</span><br><span class="line"></span><br><span class="line">3.10.1 for each循环</span><br><span class="line"></span><br><span class="line">3.10.2 数组初始化以及匿名数组</span><br><span class="line"></span><br><span class="line">3.10.3 数组拷贝</span><br><span class="line"></span><br><span class="line">3.10.4 命令行参数</span><br><span class="line"></span><br><span class="line">3.10.5 数组排序</span><br><span class="line"></span><br><span class="line">3.10.6 多维数组</span><br><span class="line"></span><br><span class="line">3.10.7 不规则数组</span><br><span class="line"></span><br><span class="line">第4章 对象与类</span><br><span class="line"></span><br><span class="line">4.1 面向对象程序设计概述</span><br><span class="line"></span><br><span class="line">4.1.1 类</span><br><span class="line"></span><br><span class="line">4.1.2 对象</span><br><span class="line"></span><br><span class="line">4.1.3 识别类</span><br><span class="line"></span><br><span class="line">4.1.4 类之间的关系</span><br><span class="line"></span><br><span class="line">4.2 使用预定义类</span><br><span class="line"></span><br><span class="line">4.2.1 对象与对象变量</span><br><span class="line"></span><br><span class="line">4.2.2 Java类库中的Gregorian-Calendar类</span><br><span class="line"></span><br><span class="line">4.2.3 更改器方法与访问器方法</span><br><span class="line"></span><br><span class="line">4.3 用户自定义类</span><br><span class="line"></span><br><span class="line">4.3.1 Employee类</span><br><span class="line"></span><br><span class="line">4.3.2 多个源文件的使用</span><br><span class="line"></span><br><span class="line">4.3.3 剖析Employee类</span><br><span class="line"></span><br><span class="line">4.3.4 从构造器开始</span><br><span class="line"></span><br><span class="line">4.3.5 隐式参数与显式参数</span><br><span class="line"></span><br><span class="line">4.3.6 封装的优点</span><br><span class="line"></span><br><span class="line">4.3.7 基于类的访问权限</span><br><span class="line"></span><br><span class="line">4.3.8 私有方法</span><br><span class="line"></span><br><span class="line">4.3.9 final实例域</span><br><span class="line"></span><br><span class="line">4.4 静态域与静态方法</span><br><span class="line"></span><br><span class="line">4.4.1 静态域</span><br><span class="line"></span><br><span class="line">4.4.2 静态常量</span><br><span class="line"></span><br><span class="line">4.4.3 静态方法</span><br><span class="line"></span><br><span class="line">4.4.4 工厂方法</span><br><span class="line"></span><br><span class="line">4.4.5 main方法</span><br><span class="line"></span><br><span class="line">4.5 方法参数</span><br><span class="line"></span><br><span class="line">4.6 对象构造</span><br><span class="line"></span><br><span class="line">4.6.1 重载</span><br><span class="line"></span><br><span class="line">4.6.2 默认域初始化</span><br><span class="line"></span><br><span class="line">4.6.3 无参数的构造器</span><br><span class="line"></span><br><span class="line">4.6.4 显式域初始化</span><br><span class="line"></span><br><span class="line">4.6.5 参数名</span><br><span class="line"></span><br><span class="line">4.6.6 调用另一个构造器</span><br><span class="line"></span><br><span class="line">4.6.7 初始化块</span><br><span class="line"></span><br><span class="line">4.6.8 对象析构与finalize方法</span><br><span class="line"></span><br><span class="line">4.7 包</span><br><span class="line"></span><br><span class="line">4.7.1 类的导入</span><br><span class="line"></span><br><span class="line">4.7.2 静态导入</span><br><span class="line"></span><br><span class="line">4.7.3 将类放入包中</span><br><span class="line"></span><br><span class="line">4.7.4 包作用域</span><br><span class="line"></span><br><span class="line">4.8 类路径</span><br><span class="line"></span><br><span class="line">4.9 文档注释</span><br><span class="line"></span><br><span class="line">4.9.1 注释的插入</span><br><span class="line"></span><br><span class="line">4.9.2 类注释</span><br><span class="line"></span><br><span class="line">4.9.3 方法注释</span><br><span class="line"></span><br><span class="line">4.9.4 域注释</span><br><span class="line"></span><br><span class="line">4.9.5 通用注释</span><br><span class="line"></span><br><span class="line">4.9.6 包与概述注释</span><br><span class="line"></span><br><span class="line">4.9.7 注释的抽取</span><br><span class="line"></span><br><span class="line">4.10 类设计技巧</span><br><span class="line"></span><br><span class="line">第5章 继承</span><br><span class="line"></span><br><span class="line">5.1 类、超类和子类</span><br><span class="line"></span><br><span class="line">5.1.1 继承层次</span><br><span class="line"></span><br><span class="line">5.1.2 多态</span><br><span class="line"></span><br><span class="line">5.1.3 动态绑定</span><br><span class="line"></span><br><span class="line">5.1.4 阻止继承：final类和方法</span><br><span class="line"></span><br><span class="line">5.1.5 强制类型转换</span><br><span class="line"></span><br><span class="line">5.1.6 抽象类</span><br><span class="line"></span><br><span class="line">5.1.7 受保护访问</span><br><span class="line"></span><br><span class="line">5.2 Object：所有类的超类</span><br><span class="line"></span><br><span class="line">5.2.1 equals方法</span><br><span class="line"></span><br><span class="line">5.2.2 相等测试与继承</span><br><span class="line"></span><br><span class="line">5.2.3 hashCode方法</span><br><span class="line"></span><br><span class="line">5.2.4 toString方法</span><br><span class="line"></span><br><span class="line">5.3 泛型数组列表</span><br><span class="line"></span><br><span class="line">5.3.1 访问数组列表元素</span><br><span class="line"></span><br><span class="line">5.3.2 类型化与原始数组列表的兼容性</span><br><span class="line"></span><br><span class="line">5.4 对象包装器与自动装箱</span><br><span class="line"></span><br><span class="line">5.5 参数数量可变的方法</span><br><span class="line"></span><br><span class="line">5.6 枚举类</span><br><span class="line"></span><br><span class="line">5.7 反射</span><br><span class="line"></span><br><span class="line">5.7.1 Class类</span><br><span class="line"></span><br><span class="line">5.7.2 捕获异常</span><br><span class="line"></span><br><span class="line">5.7.3 利用反射分析类的能力</span><br><span class="line"></span><br><span class="line">5.7.4 在运行时使用反射分析对象</span><br><span class="line"></span><br><span class="line">5.7.5 使用反射编写泛型数组代码</span><br><span class="line"></span><br><span class="line">5.7.6 调用任意方法</span><br><span class="line"></span><br><span class="line">5.8 继承设计的技巧</span><br><span class="line"></span><br><span class="line">第6章 接口与内部类</span><br><span class="line"></span><br><span class="line">6.1 接口</span><br><span class="line"></span><br><span class="line">6.1.1 接口的特性</span><br><span class="line"></span><br><span class="line">6.1.2 接口与抽象类</span><br><span class="line"></span><br><span class="line">6.2 对象克隆</span><br><span class="line"></span><br><span class="line">6.3 接口与回调</span><br><span class="line"></span><br><span class="line">6.4 内部类</span><br><span class="line"></span><br><span class="line">6.4.1 使用内部类访问对象状态</span><br><span class="line"></span><br><span class="line">6.4.2 内部类的特殊语法规则</span><br><span class="line"></span><br><span class="line">6.4.3 内部类是否有用、必要和安全</span><br><span class="line"></span><br><span class="line">6.4.4 局部内部类</span><br><span class="line"></span><br><span class="line">6.4.5 由外部方法访问final变量</span><br><span class="line"></span><br><span class="line">6.4.6 匿名内部类</span><br><span class="line"></span><br><span class="line">6.4.7 静态内部类</span><br><span class="line"></span><br><span class="line">6.5 代理</span><br><span class="line"></span><br><span class="line">第7章 图形程序设计</span><br><span class="line"></span><br><span class="line">7.1 Swing概述</span><br><span class="line"></span><br><span class="line">7.2 创建框架</span><br><span class="line"></span><br><span class="line">7.3 框架定位</span><br><span class="line"></span><br><span class="line">7.3.1 框架属性</span><br><span class="line"></span><br><span class="line">7.3.2 确定合适的框架大小</span><br><span class="line"></span><br><span class="line">7.4 在组件中显示信息</span><br><span class="line"></span><br><span class="line">7.5 处理2D图形</span><br><span class="line"></span><br><span class="line">7.6 使用颜色</span><br><span class="line"></span><br><span class="line">7.7 文本使用特殊字体</span><br><span class="line"></span><br><span class="line">7.8 显示图像</span><br><span class="line"></span><br><span class="line">第8章 事件处理</span><br><span class="line"></span><br><span class="line">8.1 事件处理基础</span><br><span class="line"></span><br><span class="line">8.1.1 实例：处理按钮点击事件</span><br><span class="line"></span><br><span class="line">8.1.2 建议使用内部类</span><br><span class="line"></span><br><span class="line">8.1.3 创建包含一个方法调用的监听器</span><br><span class="line"></span><br><span class="line">8.1.4 实例：改变观感</span><br><span class="line"></span><br><span class="line">8.1.5 适配器类</span><br><span class="line"></span><br><span class="line">8.2 动作</span><br><span class="line"></span><br><span class="line">8.3 鼠标事件</span><br><span class="line"></span><br><span class="line">8.4 AWT事件继承层次</span><br><span class="line"></span><br><span class="line">第9章 Swing用户界面组件</span><br><span class="line"></span><br><span class="line">9.1 Swing和模型-视图-控制器设计模式</span><br><span class="line"></span><br><span class="line">9.1.1 设计模式</span><br><span class="line"></span><br><span class="line">9.1.2 模型-视图-控制器模式</span><br><span class="line"></span><br><span class="line">9.1.3 Swing按钮的模型-视图-控制器分析</span><br><span class="line"></span><br><span class="line">9.2 布局管理概述</span><br><span class="line"></span><br><span class="line">9.2.1 边框布局</span><br><span class="line"></span><br><span class="line">9.2.2 网格布局</span><br><span class="line"></span><br><span class="line">9.3 文本输入</span><br><span class="line"></span><br><span class="line">9.3.1 文本域</span><br><span class="line"></span><br><span class="line">9.3.2 标签和标签组件</span><br><span class="line"></span><br><span class="line">9.3.3 密码域</span><br><span class="line"></span><br><span class="line">9.3.4 文本区</span><br><span class="line"></span><br><span class="line">9.3.5 滚动窗格</span><br><span class="line"></span><br><span class="line">9.4 选择组件</span><br><span class="line"></span><br><span class="line">9.4.1 复选框</span><br><span class="line"></span><br><span class="line">9.4.2 单选按钮</span><br><span class="line"></span><br><span class="line">9.4.3 边框</span><br><span class="line"></span><br><span class="line">9.4.4 组合框</span><br><span class="line"></span><br><span class="line">9.4.5 滑动条</span><br><span class="line"></span><br><span class="line">9.5 菜单</span><br><span class="line"></span><br><span class="line">9.5.1 菜单创建</span><br><span class="line"></span><br><span class="line">9.5.2 菜单项中的图标</span><br><span class="line"></span><br><span class="line">9.5.3 复选框和单选按钮菜单项</span><br><span class="line"></span><br><span class="line">9.5.4 弹出菜单</span><br><span class="line"></span><br><span class="line">9.5.5 快捷键和加速器</span><br><span class="line"></span><br><span class="line">9.5.6 启用和禁用菜单项</span><br><span class="line"></span><br><span class="line">9.5.7 工具栏</span><br><span class="line"></span><br><span class="line">9.5.8 工具提示</span><br><span class="line"></span><br><span class="line">9.6 复杂的布局管理</span><br><span class="line"></span><br><span class="line">9.6.1 网格组布局</span><br><span class="line"></span><br><span class="line">9.6.2 组布局</span><br><span class="line"></span><br><span class="line">9.6.3 不使用布局管理器</span><br><span class="line"></span><br><span class="line">9.6.4 定制布局管理器</span><br><span class="line"></span><br><span class="line">9.6.5 遍历顺序</span><br><span class="line"></span><br><span class="line">9.7 对话框</span><br><span class="line"></span><br><span class="line">9.7.1 选项对话框</span><br><span class="line"></span><br><span class="line">9.7.2 创建对话框</span><br><span class="line"></span><br><span class="line">9.7.3 数据交换</span><br><span class="line"></span><br><span class="line">9.7.4 文件对话框</span><br><span class="line"></span><br><span class="line">9.7.5 颜色选择器</span><br><span class="line"></span><br><span class="line">第10章 部署应用程序和applet</span><br><span class="line"></span><br><span class="line">10.1 JAR文件</span><br><span class="line"></span><br><span class="line">10.1.1 清单文件</span><br><span class="line"></span><br><span class="line">10.1.2 可运行JAR文件</span><br><span class="line"></span><br><span class="line">10.1.3 资源</span><br><span class="line"></span><br><span class="line">10.1.4 密封</span><br><span class="line"></span><br><span class="line">10.2 Java Web Start</span><br><span class="line"></span><br><span class="line">10.2.1 沙箱</span><br><span class="line"></span><br><span class="line">10.2.2 签名代码</span><br><span class="line"></span><br><span class="line">10.2.3 JNLP API</span><br><span class="line"></span><br><span class="line">10.3 applet</span><br><span class="line"></span><br><span class="line">10.3.1 一个简单的applet</span><br><span class="line"></span><br><span class="line">10.3.2 applet的HTML标记和属性</span><br><span class="line"></span><br><span class="line">10.3.3 object标记</span><br><span class="line"></span><br><span class="line">10.3.4 使用参数向applet传递信息</span><br><span class="line"></span><br><span class="line">10.3.5 访问图像和音频文件</span><br><span class="line"></span><br><span class="line">10.3.6 applet上下文</span><br><span class="line"></span><br><span class="line">10.4.1 属性映射</span><br><span class="line"></span><br><span class="line">10.4.2 Preferences API</span><br><span class="line"></span><br><span class="line">第11章 异常、断言、日志和调试</span><br><span class="line"></span><br><span class="line">11.1 处理错误</span><br><span class="line"></span><br><span class="line">11.1.1 异常分类</span><br><span class="line"></span><br><span class="line">11.1.2 声明已检查异常</span><br><span class="line"></span><br><span class="line">11.1.3 如何抛出异常</span><br><span class="line"></span><br><span class="line">11.1.4 创建异常类</span><br><span class="line"></span><br><span class="line">11.2 捕获异常</span><br><span class="line"></span><br><span class="line">11.2.1 捕获多个异常</span><br><span class="line"></span><br><span class="line">11.2.2 再次抛出异常与异常链</span><br><span class="line"></span><br><span class="line">11.2.3 finally子句</span><br><span class="line"></span><br><span class="line">11.2.4 带资源的try语句</span><br><span class="line"></span><br><span class="line">11.2.5 分析堆栈跟踪元素</span><br><span class="line"></span><br><span class="line">11.3 使用异常机制的技巧</span><br><span class="line"></span><br><span class="line">11.4 使用断言</span><br><span class="line"></span><br><span class="line">11.4.1 启用和禁用断言</span><br><span class="line"></span><br><span class="line">11.4.2 使用断言完成参数检查</span><br><span class="line"></span><br><span class="line">11.4.3 为文档假设使用断言</span><br><span class="line"></span><br><span class="line">11.5 记录日志</span><br><span class="line"></span><br><span class="line">11.5.1 基本日志</span><br><span class="line"></span><br><span class="line">11.5.2 高级日志</span><br><span class="line"></span><br><span class="line">11.5.3 修改日志管理器配置</span><br><span class="line"></span><br><span class="line">11.5.4 本地化</span><br><span class="line"></span><br><span class="line">11.5.5 处理器</span><br><span class="line"></span><br><span class="line">11.5.6 过滤器</span><br><span class="line"></span><br><span class="line">11.5.7 格式化器</span><br><span class="line"></span><br><span class="line">11.5.8 日志记录说明</span><br><span class="line"></span><br><span class="line">11.6 调试技巧</span><br><span class="line"></span><br><span class="line">11.7 GUI程序排错技巧</span><br><span class="line"></span><br><span class="line">11.8 使用调试器</span><br><span class="line"></span><br><span class="line">第12章 泛型程序设计</span><br><span class="line"></span><br><span class="line">12.1 为什么要使用泛型程序设计</span><br><span class="line"></span><br><span class="line">12.2 定义简单泛型类</span><br><span class="line"></span><br><span class="line">12.3 泛型方法</span><br><span class="line"></span><br><span class="line">12.4 类型变量的限定</span><br><span class="line"></span><br><span class="line">12.5 泛型代码和虚拟机</span><br><span class="line"></span><br><span class="line">12.5.1 翻译泛型表达式</span><br><span class="line"></span><br><span class="line">12.5.2 翻译泛型方法</span><br><span class="line"></span><br><span class="line">12.5.3 调用遗留代码</span><br><span class="line"></span><br><span class="line">12.6 约束与局限性</span><br><span class="line"></span><br><span class="line">12.6.1 不能用基本类型实例化类型参数</span><br><span class="line"></span><br><span class="line">12.6.2 运行时类型查询只适用于原始类型</span><br><span class="line"></span><br><span class="line">12.6.3 不能创建参数化类型的数组</span><br><span class="line"></span><br><span class="line">12.6.4 Varargs警告</span><br><span class="line"></span><br><span class="line">12.6.5 不能实例化类型变量</span><br><span class="line"></span><br><span class="line">12.6.6 泛型类的静态上下文中类型变量无效</span><br><span class="line"></span><br><span class="line">12.6.7 不能抛出或捕获泛型类的实例</span><br><span class="line"></span><br><span class="line">12.6.8 注意擦除后的冲突</span><br><span class="line"></span><br><span class="line">12.7 泛型类型的继承规则</span><br><span class="line"></span><br><span class="line">12.8 通配符类型</span><br><span class="line"></span><br><span class="line">12.8.1 通配符的超类型限定</span><br><span class="line"></span><br><span class="line">12.8.2 无限定通配符</span><br><span class="line"></span><br><span class="line">12.8.3 通配符捕获</span><br><span class="line"></span><br><span class="line">12.9 反射和泛型</span><br><span class="line"></span><br><span class="line">12.9.1 使用Class参数进行类型匹配</span><br><span class="line"></span><br><span class="line">12.9.2 虚拟机中的泛型类型信息</span><br><span class="line"></span><br><span class="line">第13章 集合</span><br><span class="line"></span><br><span class="line">13.1 集合接口</span><br><span class="line"></span><br><span class="line">13.1.1 将集合的接口与实现分离</span><br><span class="line"></span><br><span class="line">13.1.2 Java类库中的集合接口和迭代器接口</span><br><span class="line"></span><br><span class="line">13.2 具体的集合</span><br><span class="line"></span><br><span class="line">13.2.1 链表</span><br><span class="line"></span><br><span class="line">13.2.2 数组列表</span><br><span class="line"></span><br><span class="line">13.2.3 散列集</span><br><span class="line"></span><br><span class="line">13.2.4 树集</span><br><span class="line"></span><br><span class="line">13.2.5 对象的比较</span><br><span class="line"></span><br><span class="line">13.2.6 队列与双端队列</span><br><span class="line"></span><br><span class="line">13.2.7 优先级队列</span><br><span class="line"></span><br><span class="line">13.2.8 映射表</span><br><span class="line"></span><br><span class="line">13.2.9 专用集与映射表类</span><br><span class="line"></span><br><span class="line">13.3 集合框架</span><br><span class="line"></span><br><span class="line">13.3.1 视图与包装器</span><br><span class="line"></span><br><span class="line">13.3.2 批操作</span><br><span class="line"></span><br><span class="line">13.3.3 集合与数组之间的转换</span><br><span class="line"></span><br><span class="line">13.4 算法</span><br><span class="line"></span><br><span class="line">13.4.1 排序与混排</span><br><span class="line"></span><br><span class="line">13.4.2 二分查找</span><br><span class="line"></span><br><span class="line">13.4.3 简单算法</span><br><span class="line"></span><br><span class="line">13.4.4 编写自己的算法</span><br><span class="line"></span><br><span class="line">13.5 遗留的集合</span><br><span class="line"></span><br><span class="line">13.5.1 Hashtable类</span><br><span class="line"></span><br><span class="line">13.5.2 枚举</span><br><span class="line"></span><br><span class="line">13.5.3 属性映射表</span><br><span class="line"></span><br><span class="line">13.5.4 栈</span><br><span class="line"></span><br><span class="line">13.5.5 位集</span><br><span class="line"></span><br><span class="line">第14章 多线程</span><br><span class="line"></span><br><span class="line">14.1 什么是线程</span><br><span class="line"></span><br><span class="line">14.2 中断线程</span><br><span class="line"></span><br><span class="line">14.3 线程状态</span><br><span class="line"></span><br><span class="line">14.3.1 新创建线程</span><br><span class="line"></span><br><span class="line">14.3.2 可运行线程</span><br><span class="line"></span><br><span class="line">14.3.3 被阻塞线程和等待线程</span><br><span class="line"></span><br><span class="line">14.3.4 被终止的线程</span><br><span class="line"></span><br><span class="line">14.4 线程属性</span><br><span class="line"></span><br><span class="line">14.4.1 线程优先级</span><br><span class="line"></span><br><span class="line">14.4.2 守护线程</span><br><span class="line"></span><br><span class="line">14.4.3 未捕获异常处理器</span><br><span class="line"></span><br><span class="line">14.5 同步</span><br><span class="line"></span><br><span class="line">14.5.1 竞争条件的一个例子</span><br><span class="line"></span><br><span class="line">14.5.2 竞争条件详解</span><br><span class="line"></span><br><span class="line">14.5.3 锁对象</span><br><span class="line"></span><br><span class="line">14.5.4 条件对象</span><br><span class="line"></span><br><span class="line">14.5.5 synchronized关键字</span><br><span class="line"></span><br><span class="line">14.5.6 同步阻塞</span><br><span class="line"></span><br><span class="line">14.5.7 监视器概念</span><br><span class="line"></span><br><span class="line">14.5.8 Volatile域</span><br><span class="line"></span><br><span class="line">14.5.9 final变量</span><br><span class="line"></span><br><span class="line">14.5.10 原子性</span><br><span class="line"></span><br><span class="line">14.5.11 死锁</span><br><span class="line"></span><br><span class="line">14.5.12 线程局部变量</span><br><span class="line"></span><br><span class="line">14.5.13 锁测试与超时</span><br><span class="line"></span><br><span class="line">14.5.14 读&#x2F;写锁</span><br><span class="line"></span><br><span class="line">14.5.15 为什么弃用stop和suspend方法</span><br><span class="line"></span><br><span class="line">14.6 阻塞队列</span><br><span class="line"></span><br><span class="line">14.7 线程安全的集合</span><br><span class="line"></span><br><span class="line">14.7.1 高效的映射表、集合和队列</span><br><span class="line"></span><br><span class="line">14.7.2 写数组的拷贝</span><br><span class="line"></span><br><span class="line">14.7.3 较早的线程安全集合</span><br><span class="line"></span><br><span class="line">14.8 Callable与Future</span><br><span class="line"></span><br><span class="line">14.9 执行器</span><br><span class="line"></span><br><span class="line">14.9.1 线程池</span><br><span class="line"></span><br><span class="line">14.9.2 预定执行</span><br><span class="line"></span><br><span class="line">14.9.3 控制任务组</span><br><span class="line"></span><br><span class="line">14.9.4 Fork-Join框架</span><br><span class="line"></span><br><span class="line">14.10 同步器</span><br><span class="line"></span><br><span class="line">14.10.1 信号量</span><br><span class="line"></span><br><span class="line">14.10.2 倒计时门栓</span><br><span class="line"></span><br><span class="line">14.10.3 障栅</span><br><span class="line"></span><br><span class="line">14.10.4 交换器</span><br><span class="line"></span><br><span class="line">14.10.5 同步队列</span><br><span class="line"></span><br><span class="line">14.11 线程与Swing</span><br><span class="line"></span><br><span class="line">14.11.1 运行耗时的任务</span><br><span class="line"></span><br><span class="line">14.11.2 使用Swing工作线程</span><br><span class="line"></span><br><span class="line">14.11.3 单一线程规则</span><br><span class="line"></span><br><span class="line">附录 Java关键字</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>第一行代码-Android&amp;源代码 PDF</title>
    <url>/posts/a5f54123/</url>
    <content><![CDATA[<h4 id="《第一行代码-Android-amp-源代码》"><a href="#《第一行代码-Android-amp-源代码》" class="headerlink" title="《第一行代码-Android&amp;源代码》"></a>《第一行代码-Android&amp;源代码》</h4><h6 id="链接-https-pan-baidu-com-s-1f1uJXr3aLiFPhh9FtuBJ7g-密码-bvqp"><a href="#链接-https-pan-baidu-com-s-1f1uJXr3aLiFPhh9FtuBJ7g-密码-bvqp" class="headerlink" title="链接:https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g 密码:bvqp"></a>链接:<a href="https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g">https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g</a> 密码:bvqp</h6><p>《第一行代码 Android 第3版》被Android开发者誉为“Android学习第一书”。全书系统全面、循序渐进地介绍了Android软件开发的必备知识、经验和技巧。<br><a id="more"></a></p>
<p>《第一行代码 Android 第3版》基于Android 10.0对第2版进行了全面更新，不仅将所有知识点都在Android 10.0系统上进行了重新适配，同时加入Kotlin语言的全面讲解，使用Kotlin对全书代码进行重写，而且还介绍了新系统特性以及Jetpack架构组件的使用，使本书更加实用。</p>
<p>《第一行代码 Android 第3版》内容通俗易懂，由浅入深，既是Android初学者的入门必备，也是Android开发者的进阶首要选择。</p>
<p><img src="/images/f458afbb9d3308308f022abcb047f04b1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第　1章 开始启程——你的第 一行</span><br><span class="line"></span><br><span class="line">Android代码　1</span><br><span class="line"></span><br><span class="line">1.1　了解全貌，Android王国简介　2</span><br><span class="line"></span><br><span class="line">1.1.1　Android系统架构　2</span><br><span class="line"></span><br><span class="line">1.1.2　Android已发布的版本　3</span><br><span class="line"></span><br><span class="line">1.1.3　Android应用开发特色　4</span><br><span class="line"></span><br><span class="line">1.2　手把手带你搭建开发环境　5</span><br><span class="line"></span><br><span class="line">1.2.1　准备所需要的工具　5</span><br><span class="line"></span><br><span class="line">1.2.2　搭建开发环境　5</span><br><span class="line"></span><br><span class="line">1.3　创建你的第 一个Android项目　9</span><br><span class="line"></span><br><span class="line">1.3.1　创建HelloWorld项目　9</span><br><span class="line"></span><br><span class="line">1.3.2　启动模拟器　11</span><br><span class="line"></span><br><span class="line">1.3.3　运行HelloWorld　14</span><br><span class="line"></span><br><span class="line">1.3.4　分析你的第 一个Android程序　15</span><br><span class="line"></span><br><span class="line">1.3.5　详解项目中的资源　20</span><br><span class="line"></span><br><span class="line">1.3.6　详解build.gradle文件　22</span><br><span class="line"></span><br><span class="line">1.4　前行必备：掌握日志工具的使用　25</span><br><span class="line"></span><br><span class="line">1.4.1　使用Android的日志工具Log　25</span><br><span class="line"></span><br><span class="line">1.4.2　为什么使用Log而不使用println()　26</span><br><span class="line"></span><br><span class="line">1.5　小结与点评　28</span><br><span class="line"></span><br><span class="line">第　2章 探究新语言，快速入门Kotlin</span><br><span class="line"></span><br><span class="line">编程　30</span><br><span class="line"></span><br><span class="line">2.1　Kotlin语言简介　31</span><br><span class="line"></span><br><span class="line">2.2　如何运行Kotlin代码　32</span><br><span class="line"></span><br><span class="line">2.3　编程之本：变量和函数　35</span><br><span class="line"></span><br><span class="line">2.3.1　变量　35</span><br><span class="line"></span><br><span class="line">2.3.2　函数　37</span><br><span class="line"></span><br><span class="line">2.4　程序的逻辑控制　41</span><br><span class="line"></span><br><span class="line">2.4.1　if条件语句　41</span><br><span class="line"></span><br><span class="line">2.4.2　when条件语句　42</span><br><span class="line"></span><br><span class="line">2.4.3　循环语句　45</span><br><span class="line"></span><br><span class="line">2.5　面向对象编程　48</span><br><span class="line"></span><br><span class="line">2.5.1　类与对象　49</span><br><span class="line"></span><br><span class="line">2.5.2　继承与构造函数　50</span><br><span class="line"></span><br><span class="line">2.5.3　接口　55</span><br><span class="line"></span><br><span class="line">2.5.4　数据类与单例类　58</span><br><span class="line"></span><br><span class="line">2.6　Lambda编程　61</span><br><span class="line"></span><br><span class="line">2.6.1　集合的创建与遍历　61</span><br><span class="line"></span><br><span class="line">2.6.2　集合的函数式API　65</span><br><span class="line"></span><br><span class="line">2.6.3　Java函数式API的使用　69</span><br><span class="line"></span><br><span class="line">2.7　空指针检查　71</span><br><span class="line"></span><br><span class="line">2.7.1　可空类型系统　72</span><br><span class="line"></span><br><span class="line">2.7.2　判空辅助工具　73</span><br><span class="line"></span><br><span class="line">2.8　Kotlin中的小魔术　77</span><br><span class="line"></span><br><span class="line">2.8.1　字符串内嵌表达式　77</span><br><span class="line"></span><br><span class="line">2.8.2　函数的参数默认值　78</span><br><span class="line"></span><br><span class="line">2.9　小结与点评　81</span><br><span class="line"></span><br><span class="line">第3章　先从看得到的入手，探究</span><br><span class="line"></span><br><span class="line">Activity　82</span><br><span class="line"></span><br><span class="line">3.1　Activity是什么　82</span><br><span class="line"></span><br><span class="line">3.2　Activity的基本用法　82</span><br><span class="line"></span><br><span class="line">3.2.1　手动创建Activity　83</span><br><span class="line"></span><br><span class="line">3.2.2　创建和加载布局　85</span><br><span class="line"></span><br><span class="line">3.2.3　在AndroidManifest文件中</span><br><span class="line"></span><br><span class="line">注册　88</span><br><span class="line"></span><br><span class="line">3.2.4　在Activity中使用Toast　90</span><br><span class="line"></span><br><span class="line">3.2.5　在Activity中使用Menu　92</span><br><span class="line"></span><br><span class="line">3.2.6　销毁一个Activity　96</span><br><span class="line"></span><br><span class="line">3.3　使用Intent在Activity之间穿梭　96</span><br><span class="line"></span><br><span class="line">3.3.1　使用显式Intent　96</span><br><span class="line"></span><br><span class="line">3.3.2　使用隐式Intent　99</span><br><span class="line"></span><br><span class="line">3.3.3　更多隐式Intent的用法　101</span><br><span class="line"></span><br><span class="line">3.3.4　向下一个Activity传递数据　105</span><br><span class="line"></span><br><span class="line">3.3.5　返回数据给上一个Activity　106</span><br><span class="line"></span><br><span class="line">3.4　Activity的生命周期　108</span><br><span class="line"></span><br><span class="line">3.4.1　返回栈　108</span><br><span class="line"></span><br><span class="line">3.4.2　Activity状态　109</span><br><span class="line"></span><br><span class="line">3.4.3　Activity的生存期　110</span><br><span class="line"></span><br><span class="line">3.4.4　体验Activity的生命周期　111</span><br><span class="line"></span><br><span class="line">3.4.5　Activity被回收了怎么办　117</span><br><span class="line"></span><br><span class="line">3.5　Activity的启动模式　118</span><br><span class="line"></span><br><span class="line">3.5.1　standard　119</span><br><span class="line"></span><br><span class="line">3.5.2　singleTop　120</span><br><span class="line"></span><br><span class="line">3.5.3　singleTask　122</span><br><span class="line"></span><br><span class="line">3.5.4　singleInstance　123</span><br><span class="line"></span><br><span class="line">3.6　Activity的最佳实践　126</span><br><span class="line"></span><br><span class="line">3.6.1　知晓当前是在哪一个Activity　126</span><br><span class="line"></span><br><span class="line">3.6.2　随时随地退出程序　127</span><br><span class="line"></span><br><span class="line">3.6.3　启动Activity的最佳写法　129</span><br><span class="line"></span><br><span class="line">3.7　Kotlin课堂：标准函数和静态方法　130</span><br><span class="line"></span><br><span class="line">3.7.1　标准函数with、run和apply　130</span><br><span class="line"></span><br><span class="line">3.7.2　定义静态方法　133</span><br><span class="line"></span><br><span class="line">3.8　小结与点评　137</span><br><span class="line"></span><br><span class="line">第4章　软件也要拼脸蛋，UI开发的</span><br><span class="line"></span><br><span class="line">点点滴滴　138</span><br><span class="line"></span><br><span class="line">4.1　该如何编写程序界面　138</span><br><span class="line"></span><br><span class="line">4.2　常用控件的使用方法　139</span><br><span class="line"></span><br><span class="line">4.2.1　TextView　139</span><br><span class="line"></span><br><span class="line">4.2.2　Button　142</span><br><span class="line"></span><br><span class="line">4.2.3　EditText　144</span><br><span class="line"></span><br><span class="line">4.2.4　ImageView　149</span><br><span class="line"></span><br><span class="line">4.2.5　ProgressBar　151</span><br><span class="line"></span><br><span class="line">4.2.6　AlertDialog　154</span><br><span class="line"></span><br><span class="line">4.3　详解3种基本布局　156</span><br><span class="line"></span><br><span class="line">4.3.1　LinearLayout　156</span><br><span class="line"></span><br><span class="line">4.3.2　RelativeLayout　163</span><br><span class="line"></span><br><span class="line">4.3.3　FrameLayout　166</span><br><span class="line"></span><br><span class="line">4.4　系统控件不够用？创建自定义控件　169</span><br><span class="line"></span><br><span class="line">4.4.1　引入布局　169</span><br><span class="line"></span><br><span class="line">4.4.2　创建自定义控件　172</span><br><span class="line"></span><br><span class="line">4.5　最常用和最难用的控件：ListView　174</span><br><span class="line"></span><br><span class="line">4.5.1　ListView的简单用法　174</span><br><span class="line"></span><br><span class="line">4.5.2　定制ListView的界面　176</span><br><span class="line"></span><br><span class="line">4.5.3　提升ListView的运行效率　179</span><br><span class="line"></span><br><span class="line">4.5.4　ListView的点击事件　180</span><br><span class="line"></span><br><span class="line">4.6　更强大的滚动控件：RecyclerView　182</span><br><span class="line"></span><br><span class="line">4.6.1　RecyclerView的基本用法　183</span><br><span class="line"></span><br><span class="line">4.6.2　实现横向滚动和瀑布流布局　186</span><br><span class="line"></span><br><span class="line">4.6.3　RecyclerView的点击事件　191</span><br><span class="line"></span><br><span class="line">4.7　编写界面的最佳实践　193</span><br><span class="line"></span><br><span class="line">4.7.1　制作9-Patch图片　193</span><br><span class="line"></span><br><span class="line">4.7.2　编写精美的聊天界面　196</span><br><span class="line"></span><br><span class="line">4.8　Kotlin课堂：延迟初始化和密封类　201</span><br><span class="line"></span><br><span class="line">4.8.1　对变量延迟初始化　201</span><br><span class="line"></span><br><span class="line">4.8.2　使用密封类优化代码　204</span><br><span class="line"></span><br><span class="line">4.9　小结与点评　206</span><br><span class="line"></span><br><span class="line">第5章　手机平板要兼顾，探究</span><br><span class="line"></span><br><span class="line">Fragment　207</span><br><span class="line"></span><br><span class="line">5.1　Fragment是什么　207</span><br><span class="line"></span><br><span class="line">5.2　Fragment的使用方式　209</span><br><span class="line"></span><br><span class="line">5.2.1　Fragment的简单用法　210</span><br><span class="line"></span><br><span class="line">5.2.2　动态添加Fragment　212</span><br><span class="line"></span><br><span class="line">5.2.3　在Fragment中实现返回栈　215</span><br><span class="line"></span><br><span class="line">5.2.4　Fragment和Activity之间的</span><br><span class="line"></span><br><span class="line">交互　216</span><br><span class="line"></span><br><span class="line">5.3　Fragment的生命周期　217</span><br><span class="line"></span><br><span class="line">5.3.1　Fragment的状态和回调　217</span><br><span class="line"></span><br><span class="line">5.3.2　体验Fragment的生命周期　219</span><br><span class="line"></span><br><span class="line">5.4　动态加载布局的技巧　221</span><br><span class="line"></span><br><span class="line">5.4.1　使用限定符　221</span><br><span class="line"></span><br><span class="line">5.4.2　使用最小宽度限定符　224</span><br><span class="line"></span><br><span class="line">5.5　Fragment的最佳实践：一个简易</span><br><span class="line"></span><br><span class="line">版的新闻应用　225</span><br><span class="line"></span><br><span class="line">5.6　Kotlin课堂：扩展函数和运算符</span><br><span class="line"></span><br><span class="line">重载　234</span><br><span class="line"></span><br><span class="line">5.6.1　大有用途的扩展函数　234</span><br><span class="line"></span><br><span class="line">5.6.2　有趣的运算符重载　236</span><br><span class="line"></span><br><span class="line">5.7　小结与点评　240</span><br><span class="line"></span><br><span class="line">第6章　全局大喇叭，详解广播机制　242</span><br><span class="line"></span><br><span class="line">6.1　广播机制简介　242</span><br><span class="line"></span><br><span class="line">6.2　接收系统广播　243</span><br><span class="line"></span><br><span class="line">6.2.1　动态注册监听时间变化　243</span><br><span class="line"></span><br><span class="line">6.2.2　静态注册实现开机启动　245</span><br><span class="line"></span><br><span class="line">6.3　发送自定义广播　249</span><br><span class="line"></span><br><span class="line">6.3.1　发送标准广播　249</span><br><span class="line"></span><br><span class="line">6.3.2　发送有序广播　252</span><br><span class="line"></span><br><span class="line">6.4　广播的最佳实践：实现强制下线功能　255</span><br><span class="line"></span><br><span class="line">6.5　Kotlin课堂：高阶函数详解　261</span><br><span class="line"></span><br><span class="line">6.5.1　定义高阶函数　261</span><br><span class="line"></span><br><span class="line">6.5.2　内联函数的作用　265</span><br><span class="line"></span><br><span class="line">6.5.3　noinline与crossinline　268</span><br><span class="line"></span><br><span class="line">6.6　Git时间：初识版本控制工具　271</span><br><span class="line"></span><br><span class="line">6.6.1　安装Git　271</span><br><span class="line"></span><br><span class="line">6.6.2　创建代码仓库　272</span><br><span class="line"></span><br><span class="line">6.6.3　提交本地代码　274</span><br><span class="line"></span><br><span class="line">6.7　小结与点评　274</span><br><span class="line"></span><br><span class="line">第7章　数据存储全方案，详解</span><br><span class="line"></span><br><span class="line">持久化技术　275</span><br><span class="line"></span><br><span class="line">7.1　持久化技术简介　275</span><br><span class="line"></span><br><span class="line">7.2　文件存储　276</span><br><span class="line"></span><br><span class="line">7.2.1　将数据存储到文件中　276</span><br><span class="line"></span><br><span class="line">7.2.2　从文件中读取数据　279</span><br><span class="line"></span><br><span class="line">7.3　SharedPreferences存储　281</span><br><span class="line"></span><br><span class="line">7.3.1　将数据存储到SharedPre-</span><br><span class="line"></span><br><span class="line">ferences中　282</span><br><span class="line"></span><br><span class="line">7.3.2　从SharedPreferences中读取</span><br><span class="line"></span><br><span class="line">数据　284</span><br><span class="line"></span><br><span class="line">7.3.3　实现记住密码功能　285</span><br><span class="line"></span><br><span class="line">7.4　SQLite数据库存储　288</span><br><span class="line"></span><br><span class="line">7.4.1　创建数据库　289</span><br><span class="line"></span><br><span class="line">7.4.2　升级数据库　295</span><br><span class="line"></span><br><span class="line">7.4.3　添加数据　297</span><br><span class="line"></span><br><span class="line">7.4.4　更新数据　300</span><br><span class="line"></span><br><span class="line">7.4.5　删除数据　302</span><br><span class="line"></span><br><span class="line">7.4.6　查询数据　304</span><br><span class="line"></span><br><span class="line">7.4.7　使用SQL操作数据库　307</span><br><span class="line"></span><br><span class="line">7.5　SQLite数据库的最佳实践　307</span><br><span class="line"></span><br><span class="line">7.5.1　使用事务　308</span><br><span class="line"></span><br><span class="line">7.5.2　升级数据库的最佳写法　309</span><br><span class="line"></span><br><span class="line">7.6　Kotlin课堂：高阶函数的应用　312</span><br><span class="line"></span><br><span class="line">7.6.1　简化SharedPreferences的用法　312</span><br><span class="line"></span><br><span class="line">7.6.2　简化ContentValues的用法　314</span><br><span class="line"></span><br><span class="line">7.7　小结与点评　317</span><br><span class="line"></span><br><span class="line">第8章　跨程序共享数据，探究ContentProvider　318</span><br><span class="line"></span><br><span class="line">8.1　ContentProvider简介　318</span><br><span class="line"></span><br><span class="line">8.2　运行时权限　319</span><br><span class="line"></span><br><span class="line">8.2.1　Android权限机制详解　319</span><br><span class="line"></span><br><span class="line">8.2.2　在程序运行时申请权限　322</span><br><span class="line"></span><br><span class="line">8.3　访问其他程序中的数据　326</span><br><span class="line"></span><br><span class="line">8.3.1　ContentResolver的基本用法　326</span><br><span class="line"></span><br><span class="line">8.3.2　读取系统联系人　329</span><br><span class="line"></span><br><span class="line">8.4　创建自己的ContentProvider　332</span><br><span class="line"></span><br><span class="line">8.4.1　创建ContentProvider的步骤　332</span><br><span class="line"></span><br><span class="line">8.4.2　实现跨程序数据共享　336</span><br><span class="line"></span><br><span class="line">8.5　Kotlin课堂：泛型和委托　345</span><br><span class="line"></span><br><span class="line">8.5.1　泛型的基本用法　345</span><br><span class="line"></span><br><span class="line">8.5.2　类委托和委托属性　347</span><br><span class="line"></span><br><span class="line">8.5.3　实现一个自己的lazy函数　350</span><br><span class="line"></span><br><span class="line">8.6　小结与点评　352</span><br><span class="line"></span><br><span class="line">第9章　丰富你的程序，运用手机</span><br><span class="line"></span><br><span class="line">多媒体　353</span><br><span class="line"></span><br><span class="line">9.1　将程序运行到手机上　353</span><br><span class="line"></span><br><span class="line">9.2　使用通知　355</span><br><span class="line"></span><br><span class="line">9.2.1　创建通知渠道　355</span><br><span class="line"></span><br><span class="line">9.2.2　通知的基本用法　357</span><br><span class="line"></span><br><span class="line">9.2.3　通知的进阶技巧　362</span><br><span class="line"></span><br><span class="line">9.3　调用摄像头和相册　367</span><br><span class="line"></span><br><span class="line">9.3.1　调用摄像头拍照　367</span><br><span class="line"></span><br><span class="line">9.3.2　从相册中选择图片　371</span><br><span class="line"></span><br><span class="line">9.4　播放多媒体文件　374</span><br><span class="line"></span><br><span class="line">9.4.1　播放音频　374</span><br><span class="line"></span><br><span class="line">9.4.2　播放视频　377</span><br><span class="line"></span><br><span class="line">9.5　Kotlin课堂：使用infix函数构建</span><br><span class="line"></span><br><span class="line">更可读的语法　381</span><br><span class="line"></span><br><span class="line">9.6　Git时间：版本控制工具进阶　383</span><br><span class="line"></span><br><span class="line">9.6.1　忽略文件　384</span><br><span class="line"></span><br><span class="line">9.6.2　查看修改内容　385</span><br><span class="line"></span><br><span class="line">9.6.3　撤销未提交的修改　387</span><br><span class="line"></span><br><span class="line">9.6.4　查看提交记录　388</span><br><span class="line"></span><br><span class="line">9.7　小结与点评　389</span><br><span class="line"></span><br><span class="line">第　10章 后台默默的劳动者，探究</span><br><span class="line"></span><br><span class="line">Service　390</span><br><span class="line"></span><br><span class="line">10.1　Service是什么　390</span><br><span class="line"></span><br><span class="line">10.2　Android多线程编程　391</span><br><span class="line"></span><br><span class="line">10.2.1　线程的基本用法　391</span><br><span class="line"></span><br><span class="line">10.2.2　在子线程中更新UI　392</span><br><span class="line"></span><br><span class="line">10.2.3　解析异步消息处理机制　395</span><br><span class="line"></span><br><span class="line">10.2.4　使用AsyncTask　396</span><br><span class="line"></span><br><span class="line">10.3　Service的基本用法　399</span><br><span class="line"></span><br><span class="line">10.3.1　定义一个Service　399</span><br><span class="line"></span><br><span class="line">10.3.2　启动和停止Service　401</span><br><span class="line"></span><br><span class="line">10.3.3　Activity和Service进行</span><br><span class="line"></span><br><span class="line">通信　404</span><br><span class="line"></span><br><span class="line">10.4　Service的生命周期　408</span><br><span class="line"></span><br><span class="line">10.5　Service的更多技巧　408</span><br><span class="line"></span><br><span class="line">10.5.1　使用前台Service　409</span><br><span class="line"></span><br><span class="line">10.5.2　使用IntentService　411</span><br><span class="line"></span><br><span class="line">10.6　Kotlin课堂：泛型的高级特性　415</span><br><span class="line"></span><br><span class="line">10.6.1　对泛型进行实化　415</span><br><span class="line"></span><br><span class="line">10.6.2　泛型实化的应用　417</span><br><span class="line"></span><br><span class="line">10.6.3　泛型的协变　418</span><br><span class="line"></span><br><span class="line">10.6.3　泛型的逆变　422</span><br><span class="line"></span><br><span class="line">10.7　小结与点评　425</span><br><span class="line"></span><br><span class="line">第　11章 看看精彩的世界，使用网络</span><br><span class="line"></span><br><span class="line">技术　427</span><br><span class="line"></span><br><span class="line">11.1　WebView的用法　427</span><br><span class="line"></span><br><span class="line">11.2　使用HTTP访问网络　429</span><br><span class="line"></span><br><span class="line">11.2.1　使用HttpURLConnection　430</span><br><span class="line"></span><br><span class="line">11.2.2　使用OkHttp　433</span><br><span class="line"></span><br><span class="line">11.3　解析XML格式数据　436</span><br><span class="line"></span><br><span class="line">11.3.1　Pull解析方式　438</span><br><span class="line"></span><br><span class="line">11.3.2　SAX解析方式　441</span><br><span class="line"></span><br><span class="line">11.4　解析JSON格式数据　444</span><br><span class="line"></span><br><span class="line">11.4.1　使用JSONObject　445</span><br><span class="line"></span><br><span class="line">11.4.2　使用GSON　446</span><br><span class="line"></span><br><span class="line">11.5　网络请求回调的实现方式　448</span><br><span class="line"></span><br><span class="line">11.6　最好用的网络库：Retrofit　451</span><br><span class="line"></span><br><span class="line">11.6.1　Retrofit的基本用法　452</span><br><span class="line"></span><br><span class="line">11.6.2　处理复杂的接口地址类型　456</span><br><span class="line"></span><br><span class="line">11.6.3　Retrofit构建器的最佳写法　459</span><br><span class="line"></span><br><span class="line">11.7　Kotlin课堂：使用协程编写高效的</span><br><span class="line"></span><br><span class="line">并发程序　461</span><br><span class="line"></span><br><span class="line">11.7.1　协程的基本用法　461</span><br><span class="line"></span><br><span class="line">11.7.2　更多的作用域构建器　467</span><br><span class="line"></span><br><span class="line">11.7.3　使用协程简化回调的写法　471</span><br><span class="line"></span><br><span class="line">11.8　小结与点评　474</span><br><span class="line"></span><br><span class="line">第　12章 最佳的UI体验，Material</span><br><span class="line"></span><br><span class="line">Design实战　475</span><br><span class="line"></span><br><span class="line">12.1　什么是Material Design　475</span><br><span class="line"></span><br><span class="line">12.2　Toolbar　476</span><br><span class="line"></span><br><span class="line">12.3　滑动菜单　483</span><br><span class="line"></span><br><span class="line">12.3.1　DrawerLayout　483</span><br><span class="line"></span><br><span class="line">12.3.2　NavigationView　486</span><br><span class="line"></span><br><span class="line">12.4　悬浮按钮和可交互提示　491</span><br><span class="line"></span><br><span class="line">12.4.1　FloatingActionButton　491</span><br><span class="line"></span><br><span class="line">12.4.2　Snackbar　494</span><br><span class="line"></span><br><span class="line">12.4.3　CoordinatorLayout　496</span><br><span class="line"></span><br><span class="line">12.5　卡片式布局　498</span><br><span class="line"></span><br><span class="line">12.5.1　MaterialCardView　498</span><br><span class="line"></span><br><span class="line">12.5.2　AppBarLayout　504</span><br><span class="line"></span><br><span class="line">12.6　下拉刷新　507</span><br><span class="line"></span><br><span class="line">12.7　可折叠式标题栏　510</span><br><span class="line"></span><br><span class="line">12.7.1　CollapsingToolbarLayout　510</span><br><span class="line"></span><br><span class="line">12.7.2　充分利用系统状态栏空间　519</span><br><span class="line"></span><br><span class="line">12.8　Kotlin课堂：编写好用的工具方法　522</span><br><span class="line"></span><br><span class="line">12.8.1　求N个数的最大最小值　522</span><br><span class="line"></span><br><span class="line">12.8.2　简化Toast的用法　524</span><br><span class="line"></span><br><span class="line">12.8.3　简化Snackbar的用法　526</span><br><span class="line"></span><br><span class="line">12.9　Git时间：版本控制工具的高级</span><br><span class="line"></span><br><span class="line">用法　528</span><br><span class="line"></span><br><span class="line">12.9.1　分支的用法　528</span><br><span class="line"></span><br><span class="line">12.9.2　与远程版本库协作　530</span><br><span class="line"></span><br><span class="line">12.10　小结与点评　532</span><br><span class="line"></span><br><span class="line">第　13章 高级程序开发组件，探究</span><br><span class="line"></span><br><span class="line">Jetpack　533</span><br><span class="line"></span><br><span class="line">13.1　Jetpack简介　533</span><br><span class="line"></span><br><span class="line">13.2　ViewModel　534</span><br><span class="line"></span><br><span class="line">13.2.1　ViewModel的基本用法　536</span><br><span class="line"></span><br><span class="line">13.2.2　向ViewModel传递参数　539</span><br><span class="line"></span><br><span class="line">13.3　Lifecycles　541</span><br><span class="line"></span><br><span class="line">13.4　LiveData　545</span><br><span class="line"></span><br><span class="line">13.4.1　LiveData的基本用法　545</span><br><span class="line"></span><br><span class="line">13.4.2　map和switchMap　549</span><br><span class="line"></span><br><span class="line">13.5　Room　554</span><br><span class="line"></span><br><span class="line">13.5.1　使用Room进行増删改查　555</span><br><span class="line"></span><br><span class="line">13.5.2　Room的数据库升级　562</span><br><span class="line"></span><br><span class="line">13.6　WorkManager　565</span><br><span class="line"></span><br><span class="line">13.6.1　WorkManager的基本用法　566</span><br><span class="line"></span><br><span class="line">13.6.2　使用WorkManager处理</span><br><span class="line"></span><br><span class="line">复杂的任务　568</span><br><span class="line"></span><br><span class="line">13.7　Kotlin课堂：使用DSL构建专有的</span><br><span class="line"></span><br><span class="line">语法结构　571</span><br><span class="line"></span><br><span class="line">13.8　小结与点评　577</span><br><span class="line"></span><br><span class="line">第　14章 继续进阶，你还应该掌握的</span><br><span class="line"></span><br><span class="line">高级技巧　579</span><br><span class="line"></span><br><span class="line">14.1　全局获取Context的技巧　579</span><br><span class="line"></span><br><span class="line">14.2　使用Intent传递对象　582</span><br><span class="line"></span><br><span class="line">14.2.1　Serializable方式　582</span><br><span class="line"></span><br><span class="line">14.2.2　Parcelable方式　583</span><br><span class="line"></span><br><span class="line">14.3　定制自己的日志工具　584</span><br><span class="line"></span><br><span class="line">14.4　调试Android程序　586</span><br><span class="line"></span><br><span class="line">14.5　深色主题　589</span><br><span class="line"></span><br><span class="line">14.6　Kotlin课堂：Java与Kotlin代码</span><br><span class="line"></span><br><span class="line">之间的转换　596</span><br><span class="line"></span><br><span class="line">14.7　总结　600</span><br><span class="line"></span><br><span class="line">第　15章 进入实战，开发一个天气</span><br><span class="line"></span><br><span class="line">预报App　601</span><br><span class="line"></span><br><span class="line">15.1　功能需求及技术可行性分析　601</span><br><span class="line"></span><br><span class="line">15.2　Git时间：将代码托管到GitHub上　605</span><br><span class="line"></span><br><span class="line">15.3　搭建MVVM项目架构　612</span><br><span class="line"></span><br><span class="line">15.4　搜索全球城市数据　615</span><br><span class="line"></span><br><span class="line">15.4.1　实现逻辑层代码　615</span><br><span class="line"></span><br><span class="line">15.4.2　实现UI层代码　620</span><br><span class="line"></span><br><span class="line">15.5　显示天气信息　626</span><br><span class="line"></span><br><span class="line">15.5.1　实现逻辑层代码　626</span><br><span class="line"></span><br><span class="line">15.5.2　实现UI层代码　631</span><br><span class="line"></span><br><span class="line">15.5.3　记录选中的城市　645</span><br><span class="line"></span><br><span class="line">15.6　手动刷新天气和切换城市　647</span><br><span class="line"></span><br><span class="line">15.6.1　手动刷新天气　648</span><br><span class="line"></span><br><span class="line">15.6.2　切换城市　650</span><br><span class="line"></span><br><span class="line">15.7　制作App的图标　654</span><br><span class="line"></span><br><span class="line">15.8　生成正式签名的APK文件　659</span><br><span class="line"></span><br><span class="line">15.8.1　使用Android Studio生成　660</span><br><span class="line"></span><br><span class="line">15.8.2　使用Gradle生成　663</span><br><span class="line"></span><br><span class="line">15.9　你还可以做的事情　666</span><br><span class="line"></span><br><span class="line">第　16章 编写并发布一个开源库，PermissionX　669</span><br><span class="line"></span><br><span class="line">16.1　开发前的准备工作　669</span><br><span class="line"></span><br><span class="line">16.2　实现PermissionX开源库　673</span><br><span class="line"></span><br><span class="line">16.3　对开源库进行测试　678</span><br><span class="line"></span><br><span class="line">16.4　将开源库发布到jcenter仓库　681</span><br><span class="line"></span><br><span class="line">16.5　体验我们的成果　688</span><br><span class="line"></span><br><span class="line">16.6　结束语　691</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>推荐系统实践 PDF</title>
    <url>/posts/d2f271b5/</url>
    <content><![CDATA[<h4 id="《推荐系统实践》"><a href="#《推荐系统实践》" class="headerlink" title="《推荐系统实践》"></a>《推荐系统实践》</h4><h6 id="链接-https-pan-baidu-com-s-1bAsYKO0H3c-me9FXhqlMig-密码-w1qj"><a href="#链接-https-pan-baidu-com-s-1bAsYKO0H3c-me9FXhqlMig-密码-w1qj" class="headerlink" title="链接:https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig 密码:w1qj"></a>链接:<a href="https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig">https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig</a> 密码:w1qj</h6><p>随着信息技术和互联网的发展，人们逐渐从信息匮乏的时代走入了信息过载（information overload）的时代 。在这个时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：对于信息消费者，从大量信息中找到自己感兴趣的信息是一件非常困难的事情；对于信息生产者，让自己生产的信息脱颖而出，受到广大用户的关注，也是一件非常困难的事情。推荐系统就是解决这一矛盾的重要工具。推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。<br><a id="more"></a></p>
<p><img src="/images/37e8ea123342a1b9e8a9f22d926087e51.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 好的推荐系统</span><br><span class="line"></span><br><span class="line">1.1 什么是推荐系统</span><br><span class="line"></span><br><span class="line">1.2 个性化推荐系统的应用</span><br><span class="line"></span><br><span class="line">1.2.1 电子商务</span><br><span class="line"></span><br><span class="line">1.2.2 电影和视频网站</span><br><span class="line"></span><br><span class="line">1.2.3 个性化音乐网络电台</span><br><span class="line"></span><br><span class="line">1.2.4 社交网络</span><br><span class="line"></span><br><span class="line">1.2.5 个性化阅读</span><br><span class="line"></span><br><span class="line">1.2.6 基于位置的服务</span><br><span class="line"></span><br><span class="line">1.2.7 个性化邮件</span><br><span class="line"></span><br><span class="line">1.2.8 个性化广告</span><br><span class="line"></span><br><span class="line">1.3 推荐系统评测</span><br><span class="line"></span><br><span class="line">1.3.1 推荐系统实验方法</span><br><span class="line"></span><br><span class="line">1.3.2 评测指标</span><br><span class="line"></span><br><span class="line">1.3.3 评测维度</span><br><span class="line"></span><br><span class="line">第2章 利用用户行为数据</span><br><span class="line"></span><br><span class="line">2.1 用户行为数据简介</span><br><span class="line"></span><br><span class="line">2.2 用户行为分析</span><br><span class="line"></span><br><span class="line">2.2.1 用户活跃度和物品流行度的分布</span><br><span class="line"></span><br><span class="line">2.2.2 用户活跃度和物品流行度的关系</span><br><span class="line"></span><br><span class="line">2.3 实验设计和算法评测</span><br><span class="line"></span><br><span class="line">2.3.1 数据集</span><br><span class="line"></span><br><span class="line">2.3.2 实验设计</span><br><span class="line"></span><br><span class="line">2.3.3 评测指标</span><br><span class="line"></span><br><span class="line">2.4 基于邻域的算法</span><br><span class="line"></span><br><span class="line">2.4.1 基于用户的协同过滤算法</span><br><span class="line"></span><br><span class="line">2.4.2 基于物品的协同过滤算法</span><br><span class="line"></span><br><span class="line">2.4.3 UserCF和ItemCF的综合比较</span><br><span class="line"></span><br><span class="line">2.5 隐语义模型</span><br><span class="line"></span><br><span class="line">2.5.1 基础算法</span><br><span class="line"></span><br><span class="line">2.5.2 基于LFM的实际系统的例子</span><br><span class="line"></span><br><span class="line">2.5.3 LFM和基于邻域的方法的比较</span><br><span class="line"></span><br><span class="line">2.6 基于图的模型</span><br><span class="line"></span><br><span class="line">2.6.1 用户行为数据的二分图表示</span><br><span class="line"></span><br><span class="line">2.6.2 基于图的推荐算法</span><br><span class="line"></span><br><span class="line">第3章 推荐系统冷启动问题</span><br><span class="line"></span><br><span class="line">3.1 冷启动问题简介</span><br><span class="line"></span><br><span class="line">3.2 利用用户注册信息</span><br><span class="line"></span><br><span class="line">3.3 选择合适的物品启动用户的兴趣</span><br><span class="line"></span><br><span class="line">3.4 利用物品的内容信息</span><br><span class="line"></span><br><span class="line">3.5 发挥专家的作用</span><br><span class="line"></span><br><span class="line">第4章 利用用户标签数据</span><br><span class="line"></span><br><span class="line">4.1 UGC标签系统的代表应用</span><br><span class="line"></span><br><span class="line">4.1.1 Delicious</span><br><span class="line"></span><br><span class="line">4.1.2 CiteULike</span><br><span class="line"></span><br><span class="line">4.1.3 Last.fm</span><br><span class="line"></span><br><span class="line">4.1.4 豆瓣</span><br><span class="line"></span><br><span class="line">4.1.5 Hulu</span><br><span class="line"></span><br><span class="line">4.2 标签系统中的推荐问题</span><br><span class="line"></span><br><span class="line">4.2.1 用户为什么进行标注</span><br><span class="line"></span><br><span class="line">4.2.2 用户如何打标签</span><br><span class="line"></span><br><span class="line">4.2.3 用户打什么样的标签</span><br><span class="line"></span><br><span class="line">4.3 基于标签的推荐系统</span><br><span class="line"></span><br><span class="line">4.3.1 实验设置</span><br><span class="line"></span><br><span class="line">4.3.2 一个最简单的算法</span><br><span class="line"></span><br><span class="line">4.3.3 算法的改进</span><br><span class="line"></span><br><span class="line">4.3.4 基于图的推荐算法</span><br><span class="line"></span><br><span class="line">4.3.5 基于标签的推荐解释</span><br><span class="line"></span><br><span class="line">4.4 给用户推荐标签</span><br><span class="line"></span><br><span class="line">4.4.1 为什么要给用户推荐标签</span><br><span class="line"></span><br><span class="line">4.4.2 如何给用户推荐标签</span><br><span class="line"></span><br><span class="line">4.4.3 实验设置</span><br><span class="line"></span><br><span class="line">4.4.4 基于图的标签推荐算法</span><br><span class="line"></span><br><span class="line">4.5 扩展阅读</span><br><span class="line"></span><br><span class="line">第5章 利用上下文信息</span><br><span class="line"></span><br><span class="line">5.1 时间上下文信息</span><br><span class="line"></span><br><span class="line">5.1.1 时间效应简介</span><br><span class="line"></span><br><span class="line">5.1.2 时间效应举例</span><br><span class="line"></span><br><span class="line">5.1.3 系统时间特性的分析</span><br><span class="line"></span><br><span class="line">5.1.4 推荐系统的实时性</span><br><span class="line"></span><br><span class="line">5.1.5 推荐算法的时间多样性</span><br><span class="line"></span><br><span class="line">5.1.6 时间上下文推荐算法</span><br><span class="line"></span><br><span class="line">5.1.7 时间段图模型</span><br><span class="line"></span><br><span class="line">5.1.8 离线实验</span><br><span class="line"></span><br><span class="line">5.2 地点上下文信息</span><br><span class="line"></span><br><span class="line">5.3 扩展阅读</span><br><span class="line"></span><br><span class="line">第6章 利用社交网络数据</span><br><span class="line"></span><br><span class="line">6.1 获取社交网络数据的途径</span><br><span class="line"></span><br><span class="line">6.1.1 电子邮件</span><br><span class="line"></span><br><span class="line">6.1.2 用户注册信息</span><br><span class="line"></span><br><span class="line">6.1.3 用户的位置数据</span><br><span class="line"></span><br><span class="line">6.1.4 论坛和讨论组</span><br><span class="line"></span><br><span class="line">6.1.5 即时聊天工具</span><br><span class="line"></span><br><span class="line">6.1.6 社交网站</span><br><span class="line"></span><br><span class="line">6.2 社交网络数据简介</span><br><span class="line"></span><br><span class="line">6.3 基于社交网络的推荐</span><br><span class="line"></span><br><span class="line">6.3.1 基于邻域的社会化推荐算法</span><br><span class="line"></span><br><span class="line">6.3.2 基于图的社会化推荐算法</span><br><span class="line"></span><br><span class="line">6.3.3 实际系统中的社会化推荐算法</span><br><span class="line"></span><br><span class="line">6.3.4 社会化推荐系统和协同过滤推荐系统</span><br><span class="line"></span><br><span class="line">6.3.5 信息流推荐</span><br><span class="line"></span><br><span class="line">6.4 给用户推荐好友</span><br><span class="line"></span><br><span class="line">6.4.1 基于内容的匹配</span><br><span class="line"></span><br><span class="line">6.4.2 基于共同兴趣的好友推荐</span><br><span class="line"></span><br><span class="line">6.4.3 基于社交网络图的好友推荐</span><br><span class="line"></span><br><span class="line">6.4.4 基于用户调查的好友推荐算法对比</span><br><span class="line"></span><br><span class="line">6.5 扩展阅读</span><br><span class="line"></span><br><span class="line">第7章 推荐系统实例</span><br><span class="line"></span><br><span class="line">7.1 外围架构</span><br><span class="line"></span><br><span class="line">7.2 推荐系统架构</span><br><span class="line"></span><br><span class="line">7.3 推荐引擎的架构</span><br><span class="line"></span><br><span class="line">7.3.1 生成用户特征向量</span><br><span class="line"></span><br><span class="line">7.3.2 特征?物品相关推荐</span><br><span class="line"></span><br><span class="line">7.3.3 过滤模块</span><br><span class="line"></span><br><span class="line">7.3.4 排名模块</span><br><span class="line"></span><br><span class="line">7.4 扩展阅读</span><br><span class="line"></span><br><span class="line">第8章 评分预测问题</span><br><span class="line"></span><br><span class="line">8.1 离线实验方法</span><br><span class="line"></span><br><span class="line">8.2 评分预测算法</span><br><span class="line"></span><br><span class="line">8.2.1 平均值</span><br><span class="line"></span><br><span class="line">8.2.2 基于邻域的方法</span><br><span class="line"></span><br><span class="line">8.2.3 隐语义模型与矩阵分解模型</span><br><span class="line"></span><br><span class="line">8.2.4 加入时间信息</span><br><span class="line"></span><br><span class="line">8.2.5 模型融合</span><br><span class="line"></span><br><span class="line">8.2.6 Netflix Prize的相关实验结果</span><br><span class="line"></span><br><span class="line">后记</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>统计学习方法 PDF</title>
    <url>/posts/4bfb200f/</url>
    <content><![CDATA[<h4 id="《统计学习方法》"><a href="#《统计学习方法》" class="headerlink" title="《统计学习方法》"></a>《统计学习方法》</h4><h6 id="链接-https-pan-baidu-com-s-1k0yGfLj7SNbJuLO-2VSgYA-密码-m5qp"><a href="#链接-https-pan-baidu-com-s-1k0yGfLj7SNbJuLO-2VSgYA-密码-m5qp" class="headerlink" title="链接:https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA 密码:m5qp"></a>链接:<a href="https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA">https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA</a> 密码:m5qp</h6><p>统计学习是计算机及其应用领域的一门重要的学科。《统计学习方法》全面系统地介绍了统计学习的主要方法，特别是监督学习方法，包括感知机、k近邻法、朴素贝叶斯法、决策树、逻辑斯谛回归与支持向量机、提升方法、em算法、隐马尔可夫模型和条件场等。除章概论和后一章总结外，每章介绍一种方法。叙述从具体问题或实例入手，由浅入深，阐明思路，给出必要的数学推导，便于读者掌握统计学习方法的实质，学会运用。为满足读者进一步学习的需要，书中还介绍了一些相关研究，给出了少量习题，列出了主要参考文献。《统计学习方法》是统计学习及相关课程的教学参考书，适用于高等院校文数据挖掘、信息检索及自然语言处理等专业的大学生、研究生，也可供从事计算机应用相关专业的研发人员参考。…<br><a id="more"></a></p>
<p><img src="/images/d700849c99373355acf96f764805ab871.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">章统计学习方法概论</span><br><span class="line"></span><br><span class="line">1.1统计学习</span><br><span class="line"></span><br><span class="line">1.2监督学习</span><br><span class="line"></span><br><span class="line">1.3统计学习三要素</span><br><span class="line"></span><br><span class="line">1.4模型评估与模型选择</span><br><span class="line"></span><br><span class="line">1.5i~则化与交衩验证</span><br><span class="line"></span><br><span class="line">1.6泛化能力</span><br><span class="line"></span><br><span class="line">1.7生成模型与判别模型</span><br><span class="line"></span><br><span class="line">1.8分类问题</span><br><span class="line"></span><br><span class="line">1.9标注问题</span><br><span class="line"></span><br><span class="line">1.10回归问题</span><br><span class="line"></span><br><span class="line">章概要</span><br><span class="line"></span><br><span class="line">继续阅读</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第2章感知机</span><br><span class="line"></span><br><span class="line">2.1感知机模型</span><br><span class="line"></span><br><span class="line">2.2感知机学习策略</span><br><span class="line"></span><br><span class="line">2.3感知机学习算法</span><br><span class="line"></span><br><span class="line">章概要</span><br><span class="line"></span><br><span class="line">继续阅读</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第3章众近邻法</span><br><span class="line"></span><br><span class="line">3.1k近邻算法</span><br><span class="line"></span><br><span class="line">3.2k近邻模型</span><br><span class="line"></span><br><span class="line">3.3k近邻法的实现：kd树</span><br><span class="line"></span><br><span class="line">章概要</span><br><span class="line"></span><br><span class="line">继续阅读</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第4章朴素贝叶斯法</span><br><span class="line"></span><br><span class="line">4.1朴素贝叶斯法的学习与分类</span><br><span class="line"></span><br><span class="line">4.2朴素贝叶斯法的参数估计</span><br><span class="line"></span><br><span class="line">章概要</span><br><span class="line"></span><br><span class="line">继续阅读</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第5章决策树</span><br><span class="line"></span><br><span class="line">第6章逻辑斯谛回归与大熵模型</span><br><span class="line"></span><br><span class="line">第7章支持向量机</span><br><span class="line"></span><br><span class="line">第8章提升方法</span><br><span class="line"></span><br><span class="line">第9章em算法及其推广</span><br><span class="line"></span><br><span class="line">0章隐马尔可夫模型</span><br><span class="line"></span><br><span class="line">1章条件场</span><br><span class="line"></span><br><span class="line">2章统计学习方法总结</span><br><span class="line"></span><br><span class="line">附录a梯度下降法</span><br><span class="line"></span><br><span class="line">附录b牛顿法和拟牛顿法</span><br><span class="line"></span><br><span class="line">附录c拉格朗日对偶性</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>labuladong的算法小抄完整版 PDF</title>
    <url>/posts/3cfc1099/</url>
    <content><![CDATA[<h4 id="《labuladong的算法小抄完整版》"><a href="#《labuladong的算法小抄完整版》" class="headerlink" title="《labuladong的算法小抄完整版》"></a>《labuladong的算法小抄完整版》</h4><h4 id="本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF"><a href="#本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF" class="headerlink" title="本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF"></a>本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF</h4><h4 id="获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="获取链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>获取链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><a id="more"></a>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h4 id="获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="获取链接：https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>获取链接：<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h4><p>前不久在 GitHub 出现了一个手把手带你刷 LeetCode 的项目：fucking-algorithm。 该项目此前在 GitHub 开源后，连续多次霸榜 GitHub Trending 首页，用了两个月 Star 数便破 50k，受欢迎程度由此可见一斑。</p>
<p><img src="/images/0686daece5ea8ac441ac52a2b9bcff401.jpg" width="50%" height="50%"></p>
<h4 id="链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱-1"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱-1" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 核心套路篇 ／ 21</span><br><span class="line"></span><br><span class="line">1.1 学习算法和刷题的框架思维 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.1 数据结构的存储方式 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.2 数据结构的基本操作 ／ 23</span><br><span class="line"></span><br><span class="line">1.1.3 算法刷题指南 ／ 25</span><br><span class="line"></span><br><span class="line">1.1.4 最后总结 ／ 30</span><br><span class="line"></span><br><span class="line">1.2 动态规划解题套路框架 ／ 31</span><br><span class="line"></span><br><span class="line">1.2.1 斐波那契数列 ／ 32</span><br><span class="line"></span><br><span class="line">1.2.2 凑零钱问题 ／ 37</span><br><span class="line"></span><br><span class="line">1.2.3 最后总结 ／ 42</span><br><span class="line"></span><br><span class="line">1.3 回溯算法解题套路框架 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.1 全排列问题 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.2 N 皇后问题 ／ 48</span><br><span class="line"></span><br><span class="line">1.3.3 最后总结 ／ 51</span><br><span class="line"></span><br><span class="line">1.4 BFS 算法套路框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.1 算法框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.2 二叉树的最小高度 ／ 54</span><br><span class="line"></span><br><span class="line">1.4.3 解开密码锁的最少次数 ／ 56</span><br><span class="line"></span><br><span class="line">1.5 双指针技巧套路框架 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.1 快、慢指针的常用算法 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.2 左、右指针的常用算法 ／ 68</span><br><span class="line"></span><br><span class="line">1.6 我写了首诗，保你闭着眼睛都能写出二分搜索算法 ／ 71</span><br><span class="line"></span><br><span class="line">1.6.1 二分搜索框架 ／ 72</span><br><span class="line"></span><br><span class="line">1.6.2 寻找一个数（基本的二分搜索） ／ 73</span><br><span class="line"></span><br><span class="line">1.6.3 寻找左侧边界的二分搜索 ／ 75</span><br><span class="line"></span><br><span class="line">1.6.4 寻找右侧边界的二分搜索 ／ 79</span><br><span class="line"></span><br><span class="line">1.6.5 逻辑统一 ／ 82</span><br><span class="line"></span><br><span class="line">1.7 我写了一个模板，把滑动窗口算法变成了默写题 ／ 85</span><br><span class="line"></span><br><span class="line">1.7.1 最小覆盖子串 ／ 87</span><br><span class="line"></span><br><span class="line">1.7.2 字符串排列 ／ 91</span><br><span class="line"></span><br><span class="line">1.7.3 找所有字母异位词 ／ 93</span><br><span class="line"></span><br><span class="line">1.7.4 最长无重复子串 ／ 94</span><br><span class="line"></span><br><span class="line">第2章 动态规划系列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1 动态规划设计：最长递增子序列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1.1 动态规划解法 ／ 97</span><br><span class="line"></span><br><span class="line">2.1.2 二分搜索解法 ／ 100</span><br><span class="line"></span><br><span class="line">2.2 二维递增子序列：信封嵌套问题 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.1 题目概述 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.2 思路分析 ／ 105</span><br><span class="line"></span><br><span class="line">2.2.3 最后总结 ／ 107</span><br><span class="line"></span><br><span class="line">2.3 最大子数组问题 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.1 思路分析 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.2 最后总结 ／ 110</span><br><span class="line"></span><br><span class="line">2.4 动态规划答疑：最优子结构及dp 遍历方向 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.1 最优子结构详解 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.2 dp 数组的遍历方向 ／ 113</span><br><span class="line"></span><br><span class="line">2.5 经典动态规划：最长公共子序列 ／ 117</span><br><span class="line"></span><br><span class="line">2.6 经典动态规划：编辑距离 ／ 123</span><br><span class="line"></span><br><span class="line">2.6.1 思路分析 ／ 124</span><br><span class="line"></span><br><span class="line">2.6.2 代码详解 ／ 125</span><br><span class="line"></span><br><span class="line">2.6.3 动态规划优化 ／ 129</span><br><span class="line"></span><br><span class="line">2.6.4 扩展延伸 ／ 131</span><br><span class="line"></span><br><span class="line">2.7 子序列问题解题模板：最长回文子序列 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.1 两种思路 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.2 最长回文子序列 ／ 137</span><br><span class="line"></span><br><span class="line">2.7.3 代码实现 ／ 139</span><br><span class="line"></span><br><span class="line">2.8 状态压缩：对动态规划进行降维打击 ／ 141</span><br><span class="line"></span><br><span class="line">2.9 以最小插入次数构造回文串 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.1 思路分析 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.2 状态转移方程 ／ 149</span><br><span class="line"></span><br><span class="line">2.9.3 代码实现 ／ 152</span><br><span class="line"></span><br><span class="line">2.10 动态规划之正则表达式 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.1 思路分析 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.2 动态规划解法 ／ 157</span><br><span class="line"></span><br><span class="line">2.11 不同的定义产生不同的解法 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.1 第一种思路 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.2 第二种思路 ／ 165</span><br><span class="line"></span><br><span class="line">2.11.3 最后总结 ／ 167</span><br><span class="line"></span><br><span class="line">2.12 经典动态规划：高楼扔鸡蛋 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.1 解析题目 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.2 思路分析 ／ 169</span><br><span class="line"></span><br><span class="line">2.12.3 疑难解答 ／ 172</span><br><span class="line"></span><br><span class="line">2.13 经典动态规划：高楼扔鸡蛋（进阶） ／ 173</span><br><span class="line"></span><br><span class="line">2.13.1 二分搜索优化 ／ 173</span><br><span class="line"></span><br><span class="line">2.13.2 重新定义状态转移 ／ 176</span><br><span class="line"></span><br><span class="line">2.13.3 还可以再优化 ／ 180</span><br><span class="line"></span><br><span class="line">2.14 经典动态规划：戳气球问题 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.1 回溯思路 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.2 动态规划思路 ／ 182</span><br><span class="line"></span><br><span class="line">2.14.3 写出代码 ／ 185</span><br><span class="line"></span><br><span class="line">2.15 经典动态规划：0-1 背包问题 ／ 188</span><br><span class="line"></span><br><span class="line">2.16 经典动态规划：子集背包问题 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.1 问题分析 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.2 思路分析 ／ 193</span><br><span class="line"></span><br><span class="line">2.16.3 进行状态压缩 ／ 194</span><br><span class="line"></span><br><span class="line">2.17 经典动态规划：完全背包问题 ／ 196</span><br><span class="line"></span><br><span class="line">2.18 题目千百变，套路不会变 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.1 线性排列情况 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.2 环形排列情况 ／ 203</span><br><span class="line"></span><br><span class="line">2.18.3 树形排列情况 ／ 205</span><br><span class="line"></span><br><span class="line">2.19 动态规划和回溯算法，到底是什么关系 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.1 回溯思路 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.2 消除重叠子问题 ／ 210</span><br><span class="line"></span><br><span class="line">2.19.3 动态规划 ／ 211</span><br><span class="line"></span><br><span class="line">第3章 数据结构系列 ／ 216</span><br><span class="line"></span><br><span class="line">3.1 手把手教你写 LRU 缓存淘汰算法 ／ 216</span><br><span class="line"></span><br><span class="line">3.1.1 LRU 算法描述 ／ 218</span><br><span class="line"></span><br><span class="line">3.1.2 LRU 算法设计 ／ 219</span><br><span class="line"></span><br><span class="line">3.1.3 代码实现 ／ 220</span><br><span class="line"></span><br><span class="line">3.2 层层拆解，带你手写LFU 算法 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.1 算法描述 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.2 思路分析 ／ 228</span><br><span class="line"></span><br><span class="line">3.2.3 代码框架 ／ 230</span><br><span class="line"></span><br><span class="line">3.2.4 LFU 核心逻辑 ／ 232</span><br><span class="line"></span><br><span class="line">3.3 二叉搜索树操作集锦 ／ 235</span><br><span class="line"></span><br><span class="line">3.3.1 判断 BST 的合法性 ／ 236</span><br><span class="line"></span><br><span class="line">3.3.2 在 BST 中查找一个数是否存在 ／ 238</span><br><span class="line"></span><br><span class="line">3.3.3 在 BST 中插入一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.3.4 在 BST 中删除一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.4 完全二叉树的节点数为什么那么难算 ／ 243</span><br><span class="line"></span><br><span class="line">3.4.1 思路分析 ／ 244</span><br><span class="line"></span><br><span class="line">3.4.2 复杂度分析 ／ 245</span><br><span class="line"></span><br><span class="line">3.5 用各种遍历框架序列化和反序列化二叉树 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.1 题目描述 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.2 前序遍历解法 ／ 248</span><br><span class="line"></span><br><span class="line">3.5.3 后序遍历解法 ／ 252</span><br><span class="line"></span><br><span class="line">3.5.4 中序遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.5.5 层级遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.6 Git 原理之二叉树最近公共祖先 ／ 260</span><br><span class="line"></span><br><span class="line">3.6.1 二叉树的最近公共祖先 ／ 261</span><br><span class="line"></span><br><span class="line">3.6.2 思路分析 ／ 263</span><br><span class="line"></span><br><span class="line">3.7 特殊数据结构：单调栈 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.1 单调栈解题模板 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.2 题目变形 ／ 268</span><br><span class="line"></span><br><span class="line">3.7.3 如何处理循环数组 ／ 268</span><br><span class="line"></span><br><span class="line">3.8 特殊数据结构：单调队列 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.1 搭建解题框架 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.2 实现单调队列数据结构 ／ 273</span><br><span class="line"></span><br><span class="line">3.8.3 算法复杂度分析 ／ 276</span><br><span class="line"></span><br><span class="line">3.9 如何判断回文链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.1 判断回文单链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.2 优化空间复杂度 ／ 280</span><br><span class="line"></span><br><span class="line">3.9.3 最后总结 ／ 282</span><br><span class="line"></span><br><span class="line">3.10 秀操作之纯递归反转链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.1 递归反转整个链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.2 反转链表前N 个节点 ／ 286</span><br><span class="line"></span><br><span class="line">3.10.3 反转链表的一部分 ／ 287</span><br><span class="line"></span><br><span class="line">3.10.4 最后总结 ／ 288</span><br><span class="line"></span><br><span class="line">3.11 秀操作之k 个一组反转链表 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.1 分析问题 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.2 代码实现 ／ 291</span><br><span class="line"></span><br><span class="line">3.11.3 最后总结 ／ 292</span><br><span class="line"></span><br><span class="line">第4章 算法思维系列 ／ 293</span><br><span class="line"></span><br><span class="line">4.1 回溯算法解决子集、组合、排列问题 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.1 子集 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.2 组合 ／ 297</span><br><span class="line"></span><br><span class="line">4.1.3 排列 ／ 299</span><br><span class="line"></span><br><span class="line">4.2 回溯算法最佳实践：解数独 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.1 直观感受 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.2 代码实现 ／ 301</span><br><span class="line"></span><br><span class="line">4.3 回溯算法最佳实践：括号生成 ／ 306</span><br><span class="line"></span><br><span class="line">4.4 BFS 算法暴力破解各种智力题 ／ 310</span><br><span class="line"></span><br><span class="line">4.4.1 题目解析 ／ 311</span><br><span class="line"></span><br><span class="line">4.4.2 思路分析 ／ 311</span><br><span class="line"></span><br><span class="line">4.5 2Sum 问题的核心思想 ／ 315</span><br><span class="line"></span><br><span class="line">4.5.1 2Sum I ／ 315</span><br><span class="line"></span><br><span class="line">4.5.2 2Sum II ／ 316</span><br><span class="line"></span><br><span class="line">4.5.3 最后总结 ／ 318</span><br><span class="line"></span><br><span class="line">4.6 一个函数解决 nSum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.1 2Sum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.2 3Sum 问题 ／ 322</span><br><span class="line"></span><br><span class="line">4.6.3 4Sum 问题 ／ 324</span><br><span class="line"></span><br><span class="line">4.6.4 100Sum 问题 ／ 325</span><br><span class="line"></span><br><span class="line">4.7 拆解复杂问题：实现计算器 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.1 字符串转整数 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.2 处理加减法 ／ 329</span><br><span class="line"></span><br><span class="line">4.7.3 处理乘除法 ／ 331</span><br><span class="line"></span><br><span class="line">4.7.4 处理括号 ／ 333</span><br><span class="line"></span><br><span class="line">4.7.5 最后总结 ／ 336</span><br><span class="line"></span><br><span class="line">4.8 摊烧饼也得有点递归思维 ／ 337</span><br><span class="line"></span><br><span class="line">4.8.1 思路分析 ／ 338</span><br><span class="line"></span><br><span class="line">4.8.2 代码实现 ／ 339</span><br><span class="line"></span><br><span class="line">4.9 前缀和技巧解决子数组问题 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.1 什么是前缀和 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.2 优化解法 ／ 343</span><br><span class="line"></span><br><span class="line">4.9.3 最后总结 ／ 344</span><br><span class="line"></span><br><span class="line">4.10 扁平化嵌套列表 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.1 题目描述 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.2 解题思路 ／ 346</span><br><span class="line"></span><br><span class="line">4.10.3 进阶思路 ／ 349</span><br><span class="line"></span><br><span class="line">第5章 高频面试系列 ／ 351</span><br><span class="line"></span><br><span class="line">5.1 如何高效寻找素数 ／ 351</span><br><span class="line"></span><br><span class="line">5.2 如何高效进行模幂运算 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.1 如何处理数组指数 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.2 如何处理 mod 运算 ／ 356</span><br><span class="line"></span><br><span class="line">5.2.3 如何高效求幂 ／ 358</span><br><span class="line"></span><br><span class="line">5.3 如何运用二分搜索算法 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.1 问题分析 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.2 扩展延伸 ／ 362</span><br><span class="line"></span><br><span class="line">5.4 如何高效解决接雨水问题 ／ 364</span><br><span class="line"></span><br><span class="line">5.5 如何去除有序数组的重复元素 ／ 371</span><br><span class="line"></span><br><span class="line">5.6 如何寻找最长回文子串 ／ 373</span><br><span class="line"></span><br><span class="line">5.7 如何运用贪心思想玩跳跃游戏 ／ 376</span><br><span class="line"></span><br><span class="line">5.8 如何运用贪心算法做时间管理 ／ 381</span><br><span class="line"></span><br><span class="line">5.9 如何判定括号合法性 ／ 386</span><br><span class="line"></span><br><span class="line">5.10 如何调度考生的座位 ／ 389</span><br><span class="line"></span><br><span class="line">5.11 Union-Find 算法详解 ／ 396</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>labuladong的算法小抄 PDF</title>
    <url>/posts/6e0dfbfe/</url>
    <content><![CDATA[<h4 id="《labuladong的算法小抄》"><a href="#《labuladong的算法小抄》" class="headerlink" title="《labuladong的算法小抄》"></a>《labuladong的算法小抄》</h4><h4 id="本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF"><a href="#本书目前可以手把手带你解决-110-道-LeetCode-算法问题，全部基于-LeetCode-的题目，涵盖了所有题型和技巧-PDF" class="headerlink" title="本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF"></a>本书目前可以手把手带你解决 110 道 LeetCode 算法问题，全部基于 LeetCode 的题目，涵盖了所有题型和技巧 PDF</h4><h4 id="获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#获取链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="获取链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>获取链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><a id="more"></a>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h4 id="获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#获取链接：https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="获取链接：https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>获取链接：<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h4><p>前不久在 GitHub 出现了一个手把手带你刷 LeetCode 的项目：fucking-algorithm。 该项目此前在 GitHub 开源后，连续多次霸榜 GitHub Trending 首页，用了两个月 Star 数便破 50k，受欢迎程度由此可见一斑。</p>
<p><img src="/images/d843bb476879f2544fdbed4cd62fd3211.jpg" width="50%" height="50%"></p>
<h4 id="链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM"><a href="#链接：https-pan-baidu-com-s-1qpL4t6jmZnZgRvGlt8SSxg-提取码：KfGM" class="headerlink" title="链接：https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg 提取码：KfGM"></a>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> 提取码：KfGM</h4><h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱-1"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱-1" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 核心套路篇 ／ 21</span><br><span class="line"></span><br><span class="line">1.1 学习算法和刷题的框架思维 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.1 数据结构的存储方式 ／ 21</span><br><span class="line"></span><br><span class="line">1.1.2 数据结构的基本操作 ／ 23</span><br><span class="line"></span><br><span class="line">1.1.3 算法刷题指南 ／ 25</span><br><span class="line"></span><br><span class="line">1.1.4 最后总结 ／ 30</span><br><span class="line"></span><br><span class="line">1.2 动态规划解题套路框架 ／ 31</span><br><span class="line"></span><br><span class="line">1.2.1 斐波那契数列 ／ 32</span><br><span class="line"></span><br><span class="line">1.2.2 凑零钱问题 ／ 37</span><br><span class="line"></span><br><span class="line">1.2.3 最后总结 ／ 42</span><br><span class="line"></span><br><span class="line">1.3 回溯算法解题套路框架 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.1 全排列问题 ／ 43</span><br><span class="line"></span><br><span class="line">1.3.2 N 皇后问题 ／ 48</span><br><span class="line"></span><br><span class="line">1.3.3 最后总结 ／ 51</span><br><span class="line"></span><br><span class="line">1.4 BFS 算法套路框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.1 算法框架 ／ 53</span><br><span class="line"></span><br><span class="line">1.4.2 二叉树的最小高度 ／ 54</span><br><span class="line"></span><br><span class="line">1.4.3 解开密码锁的最少次数 ／ 56</span><br><span class="line"></span><br><span class="line">1.5 双指针技巧套路框架 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.1 快、慢指针的常用算法 ／ 64</span><br><span class="line"></span><br><span class="line">1.5.2 左、右指针的常用算法 ／ 68</span><br><span class="line"></span><br><span class="line">1.6 我写了首诗，保你闭着眼睛都能写出二分搜索算法 ／ 71</span><br><span class="line"></span><br><span class="line">1.6.1 二分搜索框架 ／ 72</span><br><span class="line"></span><br><span class="line">1.6.2 寻找一个数（基本的二分搜索） ／ 73</span><br><span class="line"></span><br><span class="line">1.6.3 寻找左侧边界的二分搜索 ／ 75</span><br><span class="line"></span><br><span class="line">1.6.4 寻找右侧边界的二分搜索 ／ 79</span><br><span class="line"></span><br><span class="line">1.6.5 逻辑统一 ／ 82</span><br><span class="line"></span><br><span class="line">1.7 我写了一个模板，把滑动窗口算法变成了默写题 ／ 85</span><br><span class="line"></span><br><span class="line">1.7.1 最小覆盖子串 ／ 87</span><br><span class="line"></span><br><span class="line">1.7.2 字符串排列 ／ 91</span><br><span class="line"></span><br><span class="line">1.7.3 找所有字母异位词 ／ 93</span><br><span class="line"></span><br><span class="line">1.7.4 最长无重复子串 ／ 94</span><br><span class="line"></span><br><span class="line">第2章 动态规划系列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1 动态规划设计：最长递增子序列 ／ 96</span><br><span class="line"></span><br><span class="line">2.1.1 动态规划解法 ／ 97</span><br><span class="line"></span><br><span class="line">2.1.2 二分搜索解法 ／ 100</span><br><span class="line"></span><br><span class="line">2.2 二维递增子序列：信封嵌套问题 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.1 题目概述 ／ 104</span><br><span class="line"></span><br><span class="line">2.2.2 思路分析 ／ 105</span><br><span class="line"></span><br><span class="line">2.2.3 最后总结 ／ 107</span><br><span class="line"></span><br><span class="line">2.3 最大子数组问题 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.1 思路分析 ／ 108</span><br><span class="line"></span><br><span class="line">2.3.2 最后总结 ／ 110</span><br><span class="line"></span><br><span class="line">2.4 动态规划答疑：最优子结构及dp 遍历方向 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.1 最优子结构详解 ／ 111</span><br><span class="line"></span><br><span class="line">2.4.2 dp 数组的遍历方向 ／ 113</span><br><span class="line"></span><br><span class="line">2.5 经典动态规划：最长公共子序列 ／ 117</span><br><span class="line"></span><br><span class="line">2.6 经典动态规划：编辑距离 ／ 123</span><br><span class="line"></span><br><span class="line">2.6.1 思路分析 ／ 124</span><br><span class="line"></span><br><span class="line">2.6.2 代码详解 ／ 125</span><br><span class="line"></span><br><span class="line">2.6.3 动态规划优化 ／ 129</span><br><span class="line"></span><br><span class="line">2.6.4 扩展延伸 ／ 131</span><br><span class="line"></span><br><span class="line">2.7 子序列问题解题模板：最长回文子序列 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.1 两种思路 ／ 136</span><br><span class="line"></span><br><span class="line">2.7.2 最长回文子序列 ／ 137</span><br><span class="line"></span><br><span class="line">2.7.3 代码实现 ／ 139</span><br><span class="line"></span><br><span class="line">2.8 状态压缩：对动态规划进行降维打击 ／ 141</span><br><span class="line"></span><br><span class="line">2.9 以最小插入次数构造回文串 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.1 思路分析 ／ 148</span><br><span class="line"></span><br><span class="line">2.9.2 状态转移方程 ／ 149</span><br><span class="line"></span><br><span class="line">2.9.3 代码实现 ／ 152</span><br><span class="line"></span><br><span class="line">2.10 动态规划之正则表达式 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.1 思路分析 ／ 155</span><br><span class="line"></span><br><span class="line">2.10.2 动态规划解法 ／ 157</span><br><span class="line"></span><br><span class="line">2.11 不同的定义产生不同的解法 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.1 第一种思路 ／ 162</span><br><span class="line"></span><br><span class="line">2.11.2 第二种思路 ／ 165</span><br><span class="line"></span><br><span class="line">2.11.3 最后总结 ／ 167</span><br><span class="line"></span><br><span class="line">2.12 经典动态规划：高楼扔鸡蛋 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.1 解析题目 ／ 168</span><br><span class="line"></span><br><span class="line">2.12.2 思路分析 ／ 169</span><br><span class="line"></span><br><span class="line">2.12.3 疑难解答 ／ 172</span><br><span class="line"></span><br><span class="line">2.13 经典动态规划：高楼扔鸡蛋（进阶） ／ 173</span><br><span class="line"></span><br><span class="line">2.13.1 二分搜索优化 ／ 173</span><br><span class="line"></span><br><span class="line">2.13.2 重新定义状态转移 ／ 176</span><br><span class="line"></span><br><span class="line">2.13.3 还可以再优化 ／ 180</span><br><span class="line"></span><br><span class="line">2.14 经典动态规划：戳气球问题 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.1 回溯思路 ／ 181</span><br><span class="line"></span><br><span class="line">2.14.2 动态规划思路 ／ 182</span><br><span class="line"></span><br><span class="line">2.14.3 写出代码 ／ 185</span><br><span class="line"></span><br><span class="line">2.15 经典动态规划：0-1 背包问题 ／ 188</span><br><span class="line"></span><br><span class="line">2.16 经典动态规划：子集背包问题 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.1 问题分析 ／ 192</span><br><span class="line"></span><br><span class="line">2.16.2 思路分析 ／ 193</span><br><span class="line"></span><br><span class="line">2.16.3 进行状态压缩 ／ 194</span><br><span class="line"></span><br><span class="line">2.17 经典动态规划：完全背包问题 ／ 196</span><br><span class="line"></span><br><span class="line">2.18 题目千百变，套路不会变 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.1 线性排列情况 ／ 200</span><br><span class="line"></span><br><span class="line">2.18.2 环形排列情况 ／ 203</span><br><span class="line"></span><br><span class="line">2.18.3 树形排列情况 ／ 205</span><br><span class="line"></span><br><span class="line">2.19 动态规划和回溯算法，到底是什么关系 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.1 回溯思路 ／ 207</span><br><span class="line"></span><br><span class="line">2.19.2 消除重叠子问题 ／ 210</span><br><span class="line"></span><br><span class="line">2.19.3 动态规划 ／ 211</span><br><span class="line"></span><br><span class="line">第3章 数据结构系列 ／ 216</span><br><span class="line"></span><br><span class="line">3.1 手把手教你写 LRU 缓存淘汰算法 ／ 216</span><br><span class="line"></span><br><span class="line">3.1.1 LRU 算法描述 ／ 218</span><br><span class="line"></span><br><span class="line">3.1.2 LRU 算法设计 ／ 219</span><br><span class="line"></span><br><span class="line">3.1.3 代码实现 ／ 220</span><br><span class="line"></span><br><span class="line">3.2 层层拆解，带你手写LFU 算法 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.1 算法描述 ／ 227</span><br><span class="line"></span><br><span class="line">3.2.2 思路分析 ／ 228</span><br><span class="line"></span><br><span class="line">3.2.3 代码框架 ／ 230</span><br><span class="line"></span><br><span class="line">3.2.4 LFU 核心逻辑 ／ 232</span><br><span class="line"></span><br><span class="line">3.3 二叉搜索树操作集锦 ／ 235</span><br><span class="line"></span><br><span class="line">3.3.1 判断 BST 的合法性 ／ 236</span><br><span class="line"></span><br><span class="line">3.3.2 在 BST 中查找一个数是否存在 ／ 238</span><br><span class="line"></span><br><span class="line">3.3.3 在 BST 中插入一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.3.4 在 BST 中删除一个数 ／ 239</span><br><span class="line"></span><br><span class="line">3.4 完全二叉树的节点数为什么那么难算 ／ 243</span><br><span class="line"></span><br><span class="line">3.4.1 思路分析 ／ 244</span><br><span class="line"></span><br><span class="line">3.4.2 复杂度分析 ／ 245</span><br><span class="line"></span><br><span class="line">3.5 用各种遍历框架序列化和反序列化二叉树 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.1 题目描述 ／ 247</span><br><span class="line"></span><br><span class="line">3.5.2 前序遍历解法 ／ 248</span><br><span class="line"></span><br><span class="line">3.5.3 后序遍历解法 ／ 252</span><br><span class="line"></span><br><span class="line">3.5.4 中序遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.5.5 层级遍历解法 ／ 255</span><br><span class="line"></span><br><span class="line">3.6 Git 原理之二叉树最近公共祖先 ／ 260</span><br><span class="line"></span><br><span class="line">3.6.1 二叉树的最近公共祖先 ／ 261</span><br><span class="line"></span><br><span class="line">3.6.2 思路分析 ／ 263</span><br><span class="line"></span><br><span class="line">3.7 特殊数据结构：单调栈 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.1 单调栈解题模板 ／ 266</span><br><span class="line"></span><br><span class="line">3.7.2 题目变形 ／ 268</span><br><span class="line"></span><br><span class="line">3.7.3 如何处理循环数组 ／ 268</span><br><span class="line"></span><br><span class="line">3.8 特殊数据结构：单调队列 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.1 搭建解题框架 ／ 271</span><br><span class="line"></span><br><span class="line">3.8.2 实现单调队列数据结构 ／ 273</span><br><span class="line"></span><br><span class="line">3.8.3 算法复杂度分析 ／ 276</span><br><span class="line"></span><br><span class="line">3.9 如何判断回文链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.1 判断回文单链表 ／ 277</span><br><span class="line"></span><br><span class="line">3.9.2 优化空间复杂度 ／ 280</span><br><span class="line"></span><br><span class="line">3.9.3 最后总结 ／ 282</span><br><span class="line"></span><br><span class="line">3.10 秀操作之纯递归反转链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.1 递归反转整个链表 ／ 283</span><br><span class="line"></span><br><span class="line">3.10.2 反转链表前N 个节点 ／ 286</span><br><span class="line"></span><br><span class="line">3.10.3 反转链表的一部分 ／ 287</span><br><span class="line"></span><br><span class="line">3.10.4 最后总结 ／ 288</span><br><span class="line"></span><br><span class="line">3.11 秀操作之k 个一组反转链表 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.1 分析问题 ／ 289</span><br><span class="line"></span><br><span class="line">3.11.2 代码实现 ／ 291</span><br><span class="line"></span><br><span class="line">3.11.3 最后总结 ／ 292</span><br><span class="line"></span><br><span class="line">第4章 算法思维系列 ／ 293</span><br><span class="line"></span><br><span class="line">4.1 回溯算法解决子集、组合、排列问题 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.1 子集 ／ 293</span><br><span class="line"></span><br><span class="line">4.1.2 组合 ／ 297</span><br><span class="line"></span><br><span class="line">4.1.3 排列 ／ 299</span><br><span class="line"></span><br><span class="line">4.2 回溯算法最佳实践：解数独 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.1 直观感受 ／ 301</span><br><span class="line"></span><br><span class="line">4.2.2 代码实现 ／ 301</span><br><span class="line"></span><br><span class="line">4.3 回溯算法最佳实践：括号生成 ／ 306</span><br><span class="line"></span><br><span class="line">4.4 BFS 算法暴力破解各种智力题 ／ 310</span><br><span class="line"></span><br><span class="line">4.4.1 题目解析 ／ 311</span><br><span class="line"></span><br><span class="line">4.4.2 思路分析 ／ 311</span><br><span class="line"></span><br><span class="line">4.5 2Sum 问题的核心思想 ／ 315</span><br><span class="line"></span><br><span class="line">4.5.1 2Sum I ／ 315</span><br><span class="line"></span><br><span class="line">4.5.2 2Sum II ／ 316</span><br><span class="line"></span><br><span class="line">4.5.3 最后总结 ／ 318</span><br><span class="line"></span><br><span class="line">4.6 一个函数解决 nSum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.1 2Sum 问题 ／ 319</span><br><span class="line"></span><br><span class="line">4.6.2 3Sum 问题 ／ 322</span><br><span class="line"></span><br><span class="line">4.6.3 4Sum 问题 ／ 324</span><br><span class="line"></span><br><span class="line">4.6.4 100Sum 问题 ／ 325</span><br><span class="line"></span><br><span class="line">4.7 拆解复杂问题：实现计算器 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.1 字符串转整数 ／ 328</span><br><span class="line"></span><br><span class="line">4.7.2 处理加减法 ／ 329</span><br><span class="line"></span><br><span class="line">4.7.3 处理乘除法 ／ 331</span><br><span class="line"></span><br><span class="line">4.7.4 处理括号 ／ 333</span><br><span class="line"></span><br><span class="line">4.7.5 最后总结 ／ 336</span><br><span class="line"></span><br><span class="line">4.8 摊烧饼也得有点递归思维 ／ 337</span><br><span class="line"></span><br><span class="line">4.8.1 思路分析 ／ 338</span><br><span class="line"></span><br><span class="line">4.8.2 代码实现 ／ 339</span><br><span class="line"></span><br><span class="line">4.9 前缀和技巧解决子数组问题 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.1 什么是前缀和 ／ 341</span><br><span class="line"></span><br><span class="line">4.9.2 优化解法 ／ 343</span><br><span class="line"></span><br><span class="line">4.9.3 最后总结 ／ 344</span><br><span class="line"></span><br><span class="line">4.10 扁平化嵌套列表 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.1 题目描述 ／ 345</span><br><span class="line"></span><br><span class="line">4.10.2 解题思路 ／ 346</span><br><span class="line"></span><br><span class="line">4.10.3 进阶思路 ／ 349</span><br><span class="line"></span><br><span class="line">第5章 高频面试系列 ／ 351</span><br><span class="line"></span><br><span class="line">5.1 如何高效寻找素数 ／ 351</span><br><span class="line"></span><br><span class="line">5.2 如何高效进行模幂运算 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.1 如何处理数组指数 ／ 355</span><br><span class="line"></span><br><span class="line">5.2.2 如何处理 mod 运算 ／ 356</span><br><span class="line"></span><br><span class="line">5.2.3 如何高效求幂 ／ 358</span><br><span class="line"></span><br><span class="line">5.3 如何运用二分搜索算法 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.1 问题分析 ／ 360</span><br><span class="line"></span><br><span class="line">5.3.2 扩展延伸 ／ 362</span><br><span class="line"></span><br><span class="line">5.4 如何高效解决接雨水问题 ／ 364</span><br><span class="line"></span><br><span class="line">5.5 如何去除有序数组的重复元素 ／ 371</span><br><span class="line"></span><br><span class="line">5.6 如何寻找最长回文子串 ／ 373</span><br><span class="line"></span><br><span class="line">5.7 如何运用贪心思想玩跳跃游戏 ／ 376</span><br><span class="line"></span><br><span class="line">5.8 如何运用贪心算法做时间管理 ／ 381</span><br><span class="line"></span><br><span class="line">5.9 如何判定括号合法性 ／ 386</span><br><span class="line"></span><br><span class="line">5.10 如何调度考生的座位 ／ 389</span><br><span class="line"></span><br><span class="line">5.11 Union-Find 算法详解 ／ 396</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>高等数学同济完整答案 PDF</title>
    <url>/posts/190acb68/</url>
    <content><![CDATA[<h4 id="《高等数学同济完整答案》"><a href="#《高等数学同济完整答案》" class="headerlink" title="《高等数学同济完整答案》"></a>《高等数学同济完整答案》</h4><h4 id="高等数学（同济）第六版课后习题答案完整答案"><a href="#高等数学（同济）第六版课后习题答案完整答案" class="headerlink" title="高等数学（同济）第六版课后习题答案完整答案"></a>高等数学（同济）第六版课后习题答案完整答案</h4><h4 id="高等数学（同济）第七版课后习题答案完整答案"><a href="#高等数学（同济）第七版课后习题答案完整答案" class="headerlink" title="高等数学（同济）第七版课后习题答案完整答案"></a>高等数学（同济）第七版课后习题答案完整答案</h4><a id="more"></a>
<h4 id="答案都在下面了"><a href="#答案都在下面了" class="headerlink" title="答案都在下面了"></a>答案都在下面了</h4><h6 id="链接-https-pan-baidu-com-s-1q6fIHLmYd1pXsewlqfBfUw-密码-xlij"><a href="#链接-https-pan-baidu-com-s-1q6fIHLmYd1pXsewlqfBfUw-密码-xlij" class="headerlink" title="链接:https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw 密码:xlij"></a>链接:<a href="https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw">https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw</a> 密码:xlij</h6><p>《高等数学》第7版在第6版的基础上作了进一步的修订。新版教材在保留原教材结构严谨，逻辑清晰、叙述详细、通俗易懂、例题较多、便于自学等优点的基础上，对教材深广度进行了适度的调整，使其更适合当前教学的需要；同时吸收了国外优秀教材的优点，对习题作了较多调整和充实；对全书内容作了进一步的锤炼和适当的调整，使其能更好满足高等教育进入大众化的新要求。</p>
<p>　　本书是同济大学数学系编《高等数学》的第7版，依据新的“工科类本科数学基础课程教学基本要求”，为高等院校工科类各专业学生修订而成。</p>
<p>　　本次修订时对教材的深广度进行了适度的调整，使学习本课程的学生都能达到合格的要求，并设置部分带*号的内容以适应分层次教学的需要；吸收国内外优秀教材的优点对习题的类型和数量进行了凋整和充实，以帮助学生提高数学素养、培养创新意识、掌握运用数学工具去解决实际问题的能力；对书中内容进一步锤炼和调整，将微分方程作为一元函数微积分的应用移到上册，更有利于学生的学习与掌握。</p>
<p>　　本书分上、下两册出版，上册包括函数与极限、导数与微分、微分中值定理与导数的应用、不定积分、定积分及其应用、微分方程等内容，书末还附有二、三阶行列式简介、几种常用的曲、积分表、习题答案与提示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第一章 函数与极限</span><br><span class="line"></span><br><span class="line">第一节 映射与函数</span><br><span class="line"></span><br><span class="line">第二节 数列的极限</span><br><span class="line"></span><br><span class="line">第三节 函数的极限</span><br><span class="line"></span><br><span class="line">第四节 无穷小与无穷大</span><br><span class="line"></span><br><span class="line">第五节 极限运算法则</span><br><span class="line"></span><br><span class="line">第六节 极限存在准则 两个重要极限</span><br><span class="line"></span><br><span class="line">第七节 无穷小的比较</span><br><span class="line"></span><br><span class="line">第八节 函数的连续性与间断点</span><br><span class="line"></span><br><span class="line">第九节 连续函数的运算与初等函数的连续性</span><br><span class="line"></span><br><span class="line">第十节 闭区间上连续函数的性质</span><br><span class="line"></span><br><span class="line">总习题</span><br><span class="line"></span><br><span class="line">第二章 导数与微分</span><br><span class="line"></span><br><span class="line">第一节 导数概念</span><br><span class="line"></span><br><span class="line">第二节 函数的求导法则</span><br><span class="line"></span><br><span class="line">第三节 高阶导数</span><br><span class="line"></span><br><span class="line">第四节 隐函数及由参数方程所确定的函数的导数 相关变化率</span><br><span class="line"></span><br><span class="line">第五节 函数的微分</span><br><span class="line"></span><br><span class="line">总习题二</span><br><span class="line"></span><br><span class="line">第三章 微分中值定理与导数的应用</span><br><span class="line"></span><br><span class="line">第一节 微分中值定理</span><br><span class="line"></span><br><span class="line">第二节 洛必达法则</span><br><span class="line"></span><br><span class="line">第三节 泰勒公式</span><br><span class="line"></span><br><span class="line">第四节 函数的单调性与曲线的凹凸性</span><br><span class="line"></span><br><span class="line">第五节 函数的极值与最大值最小值</span><br><span class="line"></span><br><span class="line">第六节 函数图形的描绘</span><br><span class="line"></span><br><span class="line">第七节 曲率</span><br><span class="line"></span><br><span class="line">第八节 方程的近似解</span><br><span class="line"></span><br><span class="line">总习题三</span><br><span class="line"></span><br><span class="line">第四章 不定积分</span><br><span class="line"></span><br><span class="line">第一节 不定积分的概念与性质</span><br><span class="line"></span><br><span class="line">第二节 换元积分法</span><br><span class="line"></span><br><span class="line">第三节 分部积分法</span><br><span class="line"></span><br><span class="line">第四节 有理函数的积分</span><br><span class="line"></span><br><span class="line">第五节 积分表的合用</span><br><span class="line"></span><br><span class="line">总习题四</span><br><span class="line"></span><br><span class="line">第五章 定积分的应用</span><br><span class="line"></span><br><span class="line">第一节 定积分的概念与性质</span><br><span class="line"></span><br><span class="line">第二节 微积分基本公式</span><br><span class="line"></span><br><span class="line">第三节 定积分的换元法和分部积分法</span><br><span class="line"></span><br><span class="line">第四节 反常积分</span><br><span class="line"></span><br><span class="line">第五节 反常积分的审敛法 г函数</span><br><span class="line"></span><br><span class="line">总习题五</span><br><span class="line"></span><br><span class="line">第七章 微分方程等</span><br><span class="line"></span><br><span class="line">第一节 定积分的元素法</span><br><span class="line"></span><br><span class="line">第二节 定积分在几何学上的应用</span><br><span class="line"></span><br><span class="line">第三节 定积分在物理学上的应用</span><br><span class="line"></span><br><span class="line">总习题六</span><br><span class="line"></span><br><span class="line">附录I 二阶和三阶行列式简介</span><br><span class="line"></span><br><span class="line">附录II 几种常用的曲线</span><br><span class="line"></span><br><span class="line">附录III 积分表</span><br><span class="line"></span><br><span class="line">习题答案与提示</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Artificial Intelligence_ A Modern PDF</title>
    <url>/posts/89b5d6f9/</url>
    <content><![CDATA[<h4 id="《Artificial-Intelligence-A-Modern》"><a href="#《Artificial-Intelligence-A-Modern》" class="headerlink" title="《Artificial Intelligence_ A Modern》"></a>《Artificial Intelligence_ A Modern》</h4><h5 id="链接-https-pan-baidu-com-s-1q3WActdeURgZ71YYnIRJaQ-密码-2t6s"><a href="#链接-https-pan-baidu-com-s-1q3WActdeURgZ71YYnIRJaQ-密码-2t6s" class="headerlink" title="链接:https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ 密码:2t6s"></a>链接:<a href="https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ">https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ</a> 密码:2t6s</h5><p><img src="/images/2bfd790e28e838ed88cdb99d775b8a431.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p><img src="/images/2bfd790e28e838ed88cdb99d775b8a432.jpg" width="50%" height="50%"></p>
<h5 id="链接-https-pan-baidu-com-s-1q3WActdeURgZ71YYnIRJaQ-密码-2t6s-1"><a href="#链接-https-pan-baidu-com-s-1q3WActdeURgZ71YYnIRJaQ-密码-2t6s-1" class="headerlink" title="链接:https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ 密码:2t6s"></a>链接:<a href="https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ">https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ</a> 密码:2t6s</h5><h5 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h5><p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>北航991复习资料 PDF</title>
    <url>/posts/feb2e66f/</url>
    <content><![CDATA[<h4 id="《北航991复习资料》"><a href="#《北航991复习资料》" class="headerlink" title="《北航991复习资料》"></a>《北航991复习资料》</h4><h3 id="北航991复习资料-PDF"><a href="#北航991复习资料-PDF" class="headerlink" title="北航991复习资料 PDF"></a>北航991复习资料 PDF</h3><h5 id="所有拿到资料的同学必须上岸，加油加油！！！"><a href="#所有拿到资料的同学必须上岸，加油加油！！！" class="headerlink" title="所有拿到资料的同学必须上岸，加油加油！！！"></a>所有拿到资料的同学必须上岸，加油加油！！！</h5><a id="more"></a>
<h5 id="地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17"><a href="#地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17" class="headerlink" title="地址链接: https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg 密码: 7a17"></a>地址链接: <a href="https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg">https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg</a> 密码: 7a17</h5><p><img src="/images/40cfb241d00b9cfdd27cd1e7c4da96351.jpg" width="50%" height="50%"></p>
<p><img src="/images/40cfb241d00b9cfdd27cd1e7c4da96352.jpg" width="50%" height="50%"></p>
<h5 id="地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17-1"><a href="#地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17-1" class="headerlink" title="地址链接: https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg 密码: 7a17"></a>地址链接: <a href="https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg">https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg</a> 密码: 7a17</h5><p><img src="/images/40cfb241d00b9cfdd27cd1e7c4da96353.jpg" width="50%" height="50%"></p>
<p><img src="/images/40cfb241d00b9cfdd27cd1e7c4da96354.jpg" width="50%" height="50%"></p>
<p><img src="/images/40cfb241d00b9cfdd27cd1e7c4da96355.jpg" width="50%" height="50%"></p>
<h5 id="地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17-2"><a href="#地址链接-https-pan-baidu-com-s-14U3R9EdMUzcPaWATwV2-sg-密码-7a17-2" class="headerlink" title="地址链接: https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg 密码: 7a17"></a>地址链接: <a href="https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg">https://pan.baidu.com/s/14U3R9EdMUzcPaWATwV2_sg</a> 密码: 7a17</h5><h5 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h5><hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础教程（第二版） PDF</title>
    <url>/posts/67bbb7d5/</url>
    <content><![CDATA[<h4 id="《Python基础教程（第二版）》"><a href="#《Python基础教程（第二版）》" class="headerlink" title="《Python基础教程（第二版）》"></a>《Python基础教程（第二版）》</h4><h4 id="获取链接-https-pan-baidu-com-s-14XqoV2ZoF5YmYmGjHsY6nw-密码-lam6"><a href="#获取链接-https-pan-baidu-com-s-14XqoV2ZoF5YmYmGjHsY6nw-密码-lam6" class="headerlink" title="获取链接: https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw 密码: lam6"></a>获取链接: <a href="https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw">https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw</a> 密码: lam6</h4><p>本书包括Python程序设计的方方面面：首先从Python的安装开始，随后介绍了Python的基础知识和基本概念，包括列表、元组、字符串、字典以及各种语句；然后循序渐进地介绍了一些相对高级的主题，包括抽象、异常、魔法方法、属性、迭代器；此后探讨了如何将Python与数据库、网络、C语言等工具结合使用，从而发挥出Python的强大功能，同时介绍了Python程序测试、打包、发布等知识；最后，作者结合前面讲述的内容，按照实际项目开发的步骤向读者介绍了10个具有实际意义的Python项目的开发过程。<br><a id="more"></a></p>
<p><img src="/images/6dd97dcc96b9a76ef2a71cf293cb1c241.jpg" width="50%" height="50%"></p>
<p><img src="/images/6dd97dcc96b9a76ef2a71cf293cb1c242.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 1章　快速上手：基础知识 1</span><br><span class="line"></span><br><span class="line">1.1　交互式解释器 1</span><br><span class="line"></span><br><span class="line">1.2　算法是什么 2</span><br><span class="line"></span><br><span class="line">1.3　数和表达式 3</span><br><span class="line"></span><br><span class="line">1.4　变量 5</span><br><span class="line"></span><br><span class="line">1.5　语句 5</span><br><span class="line"></span><br><span class="line">1.6　获取用户输入 7</span><br><span class="line"></span><br><span class="line">1.7　函数 8</span><br><span class="line"></span><br><span class="line">1.8　模块 8</span><br><span class="line"></span><br><span class="line">1.9　保存并执行程序 10</span><br><span class="line"></span><br><span class="line">1.10　字符串 13</span><br><span class="line"></span><br><span class="line">1.11　小结 21</span><br><span class="line"></span><br><span class="line">第 2章　列表和元组 23</span><br><span class="line"></span><br><span class="line">2.1　序列概述 23</span><br><span class="line"></span><br><span class="line">2.2　通用的序列操作 24</span><br><span class="line"></span><br><span class="line">2.3　列表：Python的主力 31</span><br><span class="line"></span><br><span class="line">2.4　元组：不可修改的序列 38</span><br><span class="line"></span><br><span class="line">2.5　小结 39</span><br><span class="line"></span><br><span class="line">第3章　使用字符串 41</span><br><span class="line"></span><br><span class="line">3.1　字符串基本操作 41</span><br><span class="line"></span><br><span class="line">3.2　设置字符串的格式：精简版 41</span><br><span class="line"></span><br><span class="line">3.3　设置字符串的格式：完整版 43</span><br><span class="line"></span><br><span class="line">3.4　字符串方法 48</span><br><span class="line"></span><br><span class="line">3.5　小结 53</span><br><span class="line"></span><br><span class="line">第4章　当索引行不通时 54</span><br><span class="line"></span><br><span class="line">4.1　字典的用途 54</span><br><span class="line"></span><br><span class="line">4.2　创建和使用字典 55</span><br><span class="line"></span><br><span class="line">4.3　小结 63</span><br><span class="line"></span><br><span class="line">第5章　条件、循环及其他语句 64</span><br><span class="line"></span><br><span class="line">5.1　再谈print和import 64</span><br><span class="line"></span><br><span class="line">5.2　赋值魔法 66</span><br><span class="line"></span><br><span class="line">5.3　代码块：缩进的乐趣 68</span><br><span class="line"></span><br><span class="line">5.4　条件和条件语句 69</span><br><span class="line"></span><br><span class="line">5.5　循环 76</span><br><span class="line"></span><br><span class="line">5.6　简单推导 83</span><br><span class="line"></span><br><span class="line">5.7　三人行 84</span><br><span class="line"></span><br><span class="line">5.8　小结 88</span><br><span class="line"></span><br><span class="line">第6章　抽象 90</span><br><span class="line"></span><br><span class="line">6.1　懒惰是一种美德 90</span><br><span class="line"></span><br><span class="line">6.2　抽象和结构 91</span><br><span class="line"></span><br><span class="line">6.3　自定义函数 91</span><br><span class="line"></span><br><span class="line">6.4　参数魔法 93</span><br><span class="line"></span><br><span class="line">6.5　作用域 105</span><br><span class="line"></span><br><span class="line">6.6　递归 107</span><br><span class="line"></span><br><span class="line">6.7　小结 112</span><br><span class="line"></span><br><span class="line">第7章　再谈抽象 114</span><br><span class="line"></span><br><span class="line">7.1　对象魔法 114</span><br><span class="line"></span><br><span class="line">7.2　类 119</span><br><span class="line"></span><br><span class="line">7.3　关于面向对象设计的一些思考 130</span><br><span class="line"></span><br><span class="line">7.4　小结 130</span><br><span class="line"></span><br><span class="line">第8章　异常 132</span><br><span class="line"></span><br><span class="line">8.1　异常是什么 132</span><br><span class="line"></span><br><span class="line">8.2　让事情沿你特定的轨道出错 132</span><br><span class="line"></span><br><span class="line">8.3　捕获异常 134</span><br><span class="line"></span><br><span class="line">8.4　异常和函数 140</span><br><span class="line"></span><br><span class="line">8.5　异常之禅 140</span><br><span class="line"></span><br><span class="line">8.6　不那么异常的情况 142</span><br><span class="line"></span><br><span class="line">8.7　小结 143</span><br><span class="line"></span><br><span class="line">第9章　魔法方法、特性和迭代器 144</span><br><span class="line"></span><br><span class="line">9.1　如果你使用的不是Python 3 144</span><br><span class="line"></span><br><span class="line">9.2　构造函数 145</span><br><span class="line"></span><br><span class="line">9.3　元素访问 149</span><br><span class="line"></span><br><span class="line">9.4　其他魔法方法 153</span><br><span class="line"></span><br><span class="line">9.5　特性 153</span><br><span class="line"></span><br><span class="line">9.6　迭代器 157</span><br><span class="line"></span><br><span class="line">9.7　生成器 159</span><br><span class="line"></span><br><span class="line">9.8　八皇后问题 164</span><br><span class="line"></span><br><span class="line">9.9　小结 170</span><br><span class="line"></span><br><span class="line">第 10章　开箱即用 172</span><br><span class="line"></span><br><span class="line">10.1　模块 172</span><br><span class="line"></span><br><span class="line">10.2　探索模块 178</span><br><span class="line"></span><br><span class="line">10.3　标准库：一些深受欢迎的模块 181</span><br><span class="line"></span><br><span class="line">10.4　小结 211</span><br><span class="line"></span><br><span class="line">第 11章　文件 213</span><br><span class="line"></span><br><span class="line">11.1　打开文件 213</span><br><span class="line"></span><br><span class="line">11.2　文件的基本方法 214</span><br><span class="line"></span><br><span class="line">11.3　迭代文件内容 220</span><br><span class="line"></span><br><span class="line">11.4　小结 223</span><br><span class="line"></span><br><span class="line">第 12章　图形用户界面 225</span><br><span class="line"></span><br><span class="line">12.1　创建GUI示例应用程序 225</span><br><span class="line"></span><br><span class="line">12.2　使用其他GUI工具包 230</span><br><span class="line"></span><br><span class="line">12.3　小结 231</span><br><span class="line"></span><br><span class="line">第 13章　数据库支持 232</span><br><span class="line"></span><br><span class="line">13.1　Python数据库API 232</span><br><span class="line"></span><br><span class="line">13.2　SQLite和PySQLite 236</span><br><span class="line"></span><br><span class="line">13.3　小结 241</span><br><span class="line"></span><br><span class="line">第 14章　网络编程 242</span><br><span class="line"></span><br><span class="line">14.1　几个网络模块 242</span><br><span class="line"></span><br><span class="line">14.2　SocketServer及相关的类 247</span><br><span class="line"></span><br><span class="line">14.3　多个连接 247</span><br><span class="line"></span><br><span class="line">14.4　Twisted 252</span><br><span class="line"></span><br><span class="line">14.5　小结 254</span><br><span class="line"></span><br><span class="line">第 15章　Python和Web 256</span><br><span class="line"></span><br><span class="line">15.1　屏幕抓取 256</span><br><span class="line"></span><br><span class="line">15.2　使用CGI创建动态网页 262</span><br><span class="line"></span><br><span class="line">15.3　使用Web框架 269</span><br><span class="line"></span><br><span class="line">15.4　Web服务：更高-级的抓取 270</span><br><span class="line"></span><br><span class="line">15.5　小结 272</span><br><span class="line"></span><br><span class="line">第 16章　测试基础 273</span><br><span class="line"></span><br><span class="line">16.1　先测试再编码 273</span><br><span class="line"></span><br><span class="line">16.2　测试工具 276</span><br><span class="line"></span><br><span class="line">16.3　超越单元测试 280</span><br><span class="line"></span><br><span class="line">16.4　小结 284</span><br><span class="line"></span><br><span class="line">第 17章　扩展Python 286</span><br><span class="line"></span><br><span class="line">17.1　鱼和熊掌兼得 286</span><br><span class="line"></span><br><span class="line">17.2　简单易行的方式：Jython和IronPython 287</span><br><span class="line"></span><br><span class="line">17.3　编写C语言扩展 289</span><br><span class="line"></span><br><span class="line">17.4　小结 298</span><br><span class="line"></span><br><span class="line">第 18章　程序打包 300</span><br><span class="line"></span><br><span class="line">18.1　Setuptools基础 300</span><br><span class="line"></span><br><span class="line">18.2　打包 302</span><br><span class="line"></span><br><span class="line">18.3　编译扩展 303</span><br><span class="line"></span><br><span class="line">18.4　使用py2exe创建可执行程序 304</span><br><span class="line"></span><br><span class="line">18.5　小结 304</span><br><span class="line"></span><br><span class="line">第 19章　趣味编程 306</span><br><span class="line"></span><br><span class="line">19.1　为何要有趣 306</span><br><span class="line"></span><br><span class="line">19.2　编程柔术 306</span><br><span class="line"></span><br><span class="line">19.3　原型设计 307</span><br><span class="line"></span><br><span class="line">19.4　配置 308</span><br><span class="line"></span><br><span class="line">19.5　日志 311</span><br><span class="line"></span><br><span class="line">19.6　如果你已不胜其烦 312</span><br><span class="line"></span><br><span class="line">19.7　如果你想深入学习 312</span><br><span class="line"></span><br><span class="line">19.8　小结 313</span><br><span class="line"></span><br><span class="line">第 20章　项目1：自动添加标签 315</span><br><span class="line"></span><br><span class="line">20.1　问题描述 315</span><br><span class="line"></span><br><span class="line">20.2　有用的工具 316</span><br><span class="line"></span><br><span class="line">20.3　准备工作 316</span><br><span class="line"></span><br><span class="line">20.4　初次实现 317</span><br><span class="line"></span><br><span class="line">20.5　再次实现 319</span><br><span class="line"></span><br><span class="line">20.6　进一步探索 331</span><br><span class="line"></span><br><span class="line">第 21章　项目2：绘制图表 332</span><br><span class="line"></span><br><span class="line">第 22章　项目3：万-能的XML 340</span><br><span class="line"></span><br><span class="line">第 23章　项目4：新闻汇总 353</span><br><span class="line"></span><br><span class="line">第 24章　项目5：虚拟茶话会 364</span><br><span class="line"></span><br><span class="line">第 25章　项目6：使用CGI进行远程编辑 379</span><br><span class="line"></span><br><span class="line">第 26章　项目7：自建公告板 387</span><br><span class="line"></span><br><span class="line">第 27章　项目8：使用XML-RPC共享文件 401</span><br><span class="line"></span><br><span class="line">第 28章　项目9：使用GUI共享文件 417</span><br><span class="line"></span><br><span class="line">第 29章　项目10：自制街机游戏 423</span><br><span class="line"></span><br><span class="line">附录A　简明教程 440</span><br><span class="line"></span><br><span class="line">附录B　Python参考手册 447</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python核心编程第二版中文 PDF</title>
    <url>/posts/10bc8743/</url>
    <content><![CDATA[<h4 id="《Python核心编程第二版中文》"><a href="#《Python核心编程第二版中文》" class="headerlink" title="《Python核心编程第二版中文》"></a>《Python核心编程第二版中文》</h4><h4 id="获取链接-https-pan-baidu-com-s-1CTA02Y9lOYteSzcXCMD1kQ-密码-hq9b"><a href="#获取链接-https-pan-baidu-com-s-1CTA02Y9lOYteSzcXCMD1kQ-密码-hq9b" class="headerlink" title="获取链接: https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ 密码: hq9b"></a>获取链接: <a href="https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ">https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ</a> 密码: hq9b</h4><p>对Python核心特性系统的专家级讲解；<br><a id="more"></a></p>
<p>为开发复杂的应用程序和软件所需的强大深入的视角；</p>
<p>易用的图表，详细描述了Python 模块、操作符、函数和方法；</p>
<p>大量的专业级的实例代码，从小的代码片段到功能齐全的应用程序一应俱全。</p>
<p><img src="/images/999ade3a75b7fda43a716f883747c8761.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">部分 Python核心 </span><br><span class="line"></span><br><span class="line">第1章 欢迎来到Python世界 </span><br><span class="line"></span><br><span class="line">1.1 什么是Python </span><br><span class="line"></span><br><span class="line">1.2 起源 </span><br><span class="line"></span><br><span class="line">1.3 特点 </span><br><span class="line"></span><br><span class="line">1.3.1 高级 </span><br><span class="line"></span><br><span class="line">1.3.2 面向对象 </span><br><span class="line"></span><br><span class="line">1.3.3 可升级 </span><br><span class="line"></span><br><span class="line">1.3.4 可扩展 </span><br><span class="line"></span><br><span class="line">1.3.5 可移植性 </span><br><span class="line"></span><br><span class="line">1.3.6 易学 </span><br><span class="line"></span><br><span class="line">1.3.7 易读 </span><br><span class="line"></span><br><span class="line">1.3.8 易维护 </span><br><span class="line"></span><br><span class="line">1.3.9 健壮性 </span><br><span class="line"></span><br><span class="line">1.3.10 高效的快速原型开发工具 </span><br><span class="line"></span><br><span class="line">1.3.11 内存管理器 </span><br><span class="line"></span><br><span class="line">1.3.12 解释性和(字节)编译性 </span><br><span class="line"></span><br><span class="line">1.4 下载和安装Python </span><br><span class="line"></span><br><span class="line">1.5 运行Python </span><br><span class="line"></span><br><span class="line">1.5.1 命令行上的交互式解释器 </span><br><span class="line"></span><br><span class="line">1.5.2 从命令行启动脚本 </span><br><span class="line"></span><br><span class="line">1.5.3 集成开发环境 </span><br><span class="line"></span><br><span class="line">1.5.4 其他的集成开发环境和执行环境 </span><br><span class="line"></span><br><span class="line">1.6 Python文档 </span><br><span class="line"></span><br><span class="line">1.7 比较Python(Python与其他语言的比较) </span><br><span class="line"></span><br><span class="line">1.8 其他实现 </span><br><span class="line"></span><br><span class="line">1.9 练习</span><br><span class="line"></span><br><span class="line">第2章 快速入门</span><br><span class="line"></span><br><span class="line">第3章 Python基础</span><br><span class="line"></span><br><span class="line">第5章 数字</span><br><span class="line"></span><br><span class="line">第6章 序列：字符串、列表和元组</span><br><span class="line"></span><br><span class="line">第7章 映像和集合类型</span><br><span class="line"></span><br><span class="line">第8章 条件和循环</span><br><span class="line"></span><br><span class="line">第9章 文件和输入输</span><br><span class="line"></span><br><span class="line">出0章 错误和异</span><br><span class="line"></span><br><span class="line">常1章 函数和函数式编</span><br><span class="line"></span><br><span class="line">程2章 模</span><br><span class="line"></span><br><span class="line">块3章 面向对象编</span><br><span class="line"></span><br><span class="line">程4章 执行环境</span><br><span class="line"></span><br><span class="line">第2部分 高级主题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>剑指offer名企面试官精讲典型编程题 PDF</title>
    <url>/posts/8ed812e0/</url>
    <content><![CDATA[<h4 id="《剑指offer名企面试官精讲典型编程题》"><a href="#《剑指offer名企面试官精讲典型编程题》" class="headerlink" title="《剑指offer名企面试官精讲典型编程题》"></a>《剑指offer名企面试官精讲典型编程题》</h4><h4 id="获取链接-https-pan-baidu-com-s-18vd8-X6sgcrArpHEmjqDxw-密码-jnnl"><a href="#获取链接-https-pan-baidu-com-s-18vd8-X6sgcrArpHEmjqDxw-密码-jnnl" class="headerlink" title="获取链接: https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw 密码: jnnl"></a>获取链接: <a href="https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw">https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw</a> 密码: jnnl</h4><p>　《剑指Offer：名企面试官精讲典型编程题（第2版）》剖析了80个典型的编程面试题，系统整理基础知识、代码质量、解题思路、优化效率和综合能力这5个面试要点。《剑指Offer：名企面试官精讲典型编程题（第2版）》共分7章，主要包括面试的流程，讨论面试每一环节需要注意的问题；面试需要的基础知识，从编程语言、数据结构及算法三方面总结程序员面试知识点；高质量的代码，讨论影响代码质量的3个要素（规范性、完整性和鲁棒性），强调高质量代码除完成基本功能外，还能考虑特殊情况并对非法输入进行合理处理；解决面试题的思路，总结编程面试中解决难题的有效思考模式，如在面试中遇到复杂难题，应聘者可利用画图、举例和分解这3种方法将其化繁为简，先形成清晰思路，再动手编程；优化时间和空间效率，读者将学会优化时间效率及用空间换时间的常用算法，从而在面试中找到至优解；面试中的各项能力，总结应聘者如何充分表现学习和沟通能力，并通过具体面试题讨论如何培养知识迁移、抽象建模和发散思维能力；两个面试案例，总结哪些面试举动是不良行为，而哪些表现又是面试官所期待的行为。第二版重磅升级。<br><a id="more"></a></p>
<p><img src="/images/4a35dae584a62a3a72a84751e63371ff1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 面试的流程 1</span><br><span class="line"></span><br><span class="line">1.1 面试官谈面试 1</span><br><span class="line"></span><br><span class="line">1.2 面试的3种形式 2</span><br><span class="line"></span><br><span class="line">1.2.1 电话面试 2</span><br><span class="line"></span><br><span class="line">1.2.2 共享桌面远程面试 3</span><br><span class="line"></span><br><span class="line">1.2.3 现场面试 4</span><br><span class="line"></span><br><span class="line">1.3 面试的3个环节 5</span><br><span class="line"></span><br><span class="line">1.3.1 行为面试环节 5</span><br><span class="line"></span><br><span class="line">1.3.2 技术面试环节 10</span><br><span class="line"></span><br><span class="line">1.3.3 应聘者提问环节 17</span><br><span class="line"></span><br><span class="line">1.4 本章小结 18</span><br><span class="line"></span><br><span class="line">第2章 面试需要的基础知识 20</span><br><span class="line"></span><br><span class="line">2.1 面试官谈基础知识 20</span><br><span class="line"></span><br><span class="line">2.2 编程语言 21</span><br><span class="line"></span><br><span class="line">2.2.1 C++ 22</span><br><span class="line"></span><br><span class="line">2.2.2 C# 27</span><br><span class="line"></span><br><span class="line">2.3 数据结构 36</span><br><span class="line"></span><br><span class="line">2.3.1 数组 36</span><br><span class="line"></span><br><span class="line">2.3.2 字符串 47</span><br><span class="line"></span><br><span class="line">2.3.3 链表 55</span><br><span class="line"></span><br><span class="line">2.3.4 树 59</span><br><span class="line"></span><br><span class="line">2.3.5 栈和队列 67</span><br><span class="line"></span><br><span class="line">2.4 算法和数据操作 71</span><br><span class="line"></span><br><span class="line">2.4.1 递归和循环 72</span><br><span class="line"></span><br><span class="line">2.4.2 查找和排序 78</span><br><span class="line"></span><br><span class="line">2.4.3 回溯法 87</span><br><span class="line"></span><br><span class="line">2.4.4 动态规划与贪婪算法 93</span><br><span class="line"></span><br><span class="line">2.4.5 位运算 98</span><br><span class="line"></span><br><span class="line">2.5 本章小结 103</span><br><span class="line"></span><br><span class="line">第3章 高质量的代码 104</span><br><span class="line"></span><br><span class="line">3.1 面试官谈代码质量 104</span><br><span class="line"></span><br><span class="line">3.2 代码的规范性 105</span><br><span class="line"></span><br><span class="line">3.3 代码的完整性 106</span><br><span class="line"></span><br><span class="line">3.4 代码的鲁棒性 132</span><br><span class="line"></span><br><span class="line">3.5 本章小结 151</span><br><span class="line"></span><br><span class="line">第4章 解决面试题的思路 153</span><br><span class="line"></span><br><span class="line">4.1 面试官谈面试思路 153</span><br><span class="line"></span><br><span class="line">4.2 画图让抽象问题形象化 154</span><br><span class="line"></span><br><span class="line">4.3 举例让抽象问题具体化 163</span><br><span class="line"></span><br><span class="line">4.4 分解让复杂问题简单化 184</span><br><span class="line"></span><br><span class="line">4.5 本章小结 199</span><br><span class="line"></span><br><span class="line">第5章 优化时间和空间效率 201</span><br><span class="line"></span><br><span class="line">5.1 面试官谈效率 201</span><br><span class="line"></span><br><span class="line">5.2 时间效率 202</span><br><span class="line"></span><br><span class="line">5.3 时间效率与空间效率的平衡 237</span><br><span class="line"></span><br><span class="line">5.4 本章小结 254</span><br><span class="line"></span><br><span class="line">第6章 面试中的各项能力 256</span><br><span class="line"></span><br><span class="line">6.1 面试官谈能力 256</span><br><span class="line"></span><br><span class="line">6.2 沟通能力和学习能力 257</span><br><span class="line"></span><br><span class="line">6.3 知识迁移能力 260</span><br><span class="line"></span><br><span class="line">6.4 抽象建模能力 293</span><br><span class="line"></span><br><span class="line">6.5 发散思维能力 305</span><br><span class="line"></span><br><span class="line">6.6 本章小结 313</span><br><span class="line"></span><br><span class="line">第7章 两个面试案例 315</span><br><span class="line"></span><br><span class="line">7.1 案例一：（面试题67）把字符串转换成整数 316</span><br><span class="line"></span><br><span class="line">7.2 案例二：（面试题68）树中两个节点的最低公共祖先 324</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>算法导论 PDF</title>
    <url>/posts/f9df2276/</url>
    <content><![CDATA[<h4 id="《算法导论》"><a href="#《算法导论》" class="headerlink" title="《算法导论》"></a>《算法导论》</h4><h4 id="获取链接-https-pan-baidu-com-s-1l7BS4GxuQGJE1he-5h0AXw-密码-s3sh"><a href="#获取链接-https-pan-baidu-com-s-1l7BS4GxuQGJE1he-5h0AXw-密码-s3sh" class="headerlink" title="获取链接: https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw 密码: s3sh"></a>获取链接: <a href="https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw">https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw</a> 密码: s3sh</h4><p>本书提供了对当代计算机算法研究的一个全面、综合性的介绍。全书共八部分，内容涵盖基础知识、排序和顺序统计量、数据结构、不错设计和分析技术、不错数据结构、图算法、算法问题选编，以及数学基础知识。书中深入浅出地介绍了大量的算法及相关的数据结构，以及用于解决一些复杂计算问题的不错策略（如动态规划、贪心算法、摊还分析等），重点在于算法的分析与设计。对于每一个专题，作者都试图提供目前新的研究成果及样例解答，并通过清晰的图示来说明算法的执行过程。此外，全书包含957道练习和158道思考题，并且作者在网站上给出<br><a id="more"></a></p>
<p><img src="/images/9c2879ab32af4bf33c1eb5c4ec0f08b61.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目  录</span><br><span class="line"></span><br><span class="line">Introduction to Algorithms，Third Edition</span><br><span class="line"></span><br><span class="line">出版者的话</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">部分  基础知识</span><br><span class="line"></span><br><span class="line">章  算法在计算中的作用3</span><br><span class="line"></span><br><span class="line">  1.1  算法3</span><br><span class="line"></span><br><span class="line">  1.2  作为一种技术的算法6</span><br><span class="line"></span><br><span class="line">  思考题8</span><br><span class="line"></span><br><span class="line">  本章注记8</span><br><span class="line"></span><br><span class="line">第2章  算法基础9</span><br><span class="line"></span><br><span class="line">  2.1  插入排序9</span><br><span class="line"></span><br><span class="line">  2.2  分析算法13</span><br><span class="line"></span><br><span class="line">  2.3  设计算法16</span><br><span class="line"></span><br><span class="line">    2.3.1  分治法16</span><br><span class="line"></span><br><span class="line">    2.3.2  分析分治算法20</span><br><span class="line"></span><br><span class="line">  思考题22</span><br><span class="line"></span><br><span class="line">  本章注记24</span><br><span class="line"></span><br><span class="line">第3章  函数的增长25</span><br><span class="line"></span><br><span class="line">  3.1  渐近记号</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>阿里巴巴Java开发手册 PDF</title>
    <url>/posts/60d673cc/</url>
    <content><![CDATA[<h4 id="《阿里巴巴Java开发手册》"><a href="#《阿里巴巴Java开发手册》" class="headerlink" title="《阿里巴巴Java开发手册》"></a>《阿里巴巴Java开发手册》</h4><h6 id="链接-https-pan-baidu-com-s-1Q9pL5t5XMWDUsiMbMU-KEQ-提取码-w6gc"><a href="#链接-https-pan-baidu-com-s-1Q9pL5t5XMWDUsiMbMU-KEQ-提取码-w6gc" class="headerlink" title="链接: https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ 提取码: w6gc"></a>链接: <a href="https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ">https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ</a> 提取码: w6gc</h6><p>本手册的愿景是码出高效，码出质量。它结合作者的开发经验和架构历程，提炼阿里巴巴集团技术团队的集体编程经验和软件设计智慧，浓缩成为立体的编程规范和最佳实践。众所周知，现代软件行业的高速发展对开发工程师的综合素质要求越来越高，因为不仅是编程相关的知识点，其他维度的知识点也会影响软件的最终交付质量，比如，数据库的表结构和索引设计缺陷可能带来软件的架构缺陷或性能风险；单元测试的失位导致系统集成测试困难；没有鉴权的漏洞代码易被黑客攻击等。所以，本手册以开发工程师为中心视角，划分为编程规约、异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七个维度，每个条目下提供相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长，有助于团队代码规约文化的形成。积小流成大海，积跬步至千里，在第1版基础上，认真倾听读者反馈，学习开源社区的详细建议，增加前后端规约，发布错误码解决方案，修正架构分层图例等相关内容，涉及59条新规约，修正202处原有规约，完善8个示例，是面向业界以来更为完善的版本。从严格意义上讲，本手册超越了Java语言本身，明确了作为一名合格开发工程师应该具备的基本素质，因此本手册适合计算机相关行业的管理者和研发人员、高等院校的计算机专业师生、求职者等阅读，希望成为大家如良师益友般的工作手册、工具书和床头书。<br><a id="more"></a></p>
<p><img src="/images/055540a9e546bd6e43f5d9ae6701c9f61.jpg" width="50%" height="50%"></p>
<p><img src="/images/055540a9e546bd6e43f5d9ae6701c9f62.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">专家语录 III</span><br><span class="line"></span><br><span class="line">第2版序 V</span><br><span class="line"></span><br><span class="line">第2版前言 X</span><br><span class="line"></span><br><span class="line">第1章 编程规约 1</span><br><span class="line"></span><br><span class="line">1．1 命名风格 2</span><br><span class="line"></span><br><span class="line">1．2 常量定义 9</span><br><span class="line"></span><br><span class="line">1．3 代码格式 12</span><br><span class="line"></span><br><span class="line">1．4 OOP规约 17</span><br><span class="line"></span><br><span class="line">1．5 日期时间 26</span><br><span class="line"></span><br><span class="line">1．6 集合处理 29</span><br><span class="line"></span><br><span class="line">1．7 并发处理 39</span><br><span class="line"></span><br><span class="line">1．8 控制语句 48</span><br><span class="line"></span><br><span class="line">1．9 注释规约 55</span><br><span class="line"></span><br><span class="line">1．10 前后端规约 59</span><br><span class="line"></span><br><span class="line">1．11 其他 64</span><br><span class="line"></span><br><span class="line">第2章 异常日志 66</span><br><span class="line"></span><br><span class="line">2．1 错误码 67</span><br><span class="line"></span><br><span class="line">2．2 异常处理 70</span><br><span class="line"></span><br><span class="line">2．3 日志规约 75</span><br><span class="line"></span><br><span class="line">第3章 单元测试 80</span><br><span class="line"></span><br><span class="line">第4章 安全规约 86</span><br><span class="line"></span><br><span class="line">第5章 MySQL数据库 90</span><br><span class="line"></span><br><span class="line">5．1 建表规约 91</span><br><span class="line"></span><br><span class="line">5．2 索引规约 95</span><br><span class="line"></span><br><span class="line">5．3 SQL语句 99</span><br><span class="line"></span><br><span class="line">5．4 ORM映射 103</span><br><span class="line"></span><br><span class="line">第6章 工程结构 106</span><br><span class="line"></span><br><span class="line">6．1 应用分层 107</span><br><span class="line"></span><br><span class="line">6．2 二方库依赖 110</span><br><span class="line"></span><br><span class="line">6．3 服务器 114</span><br><span class="line"></span><br><span class="line">第7章 设计规约 116</span><br><span class="line"></span><br><span class="line">附录A 专有名词 122 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>阿里Java面试问题大全 PDF</title>
    <url>/posts/17d1435a/</url>
    <content><![CDATA[<h4 id="《阿里Java面试问题大全》"><a href="#《阿里Java面试问题大全》" class="headerlink" title="《阿里Java面试问题大全》"></a>《阿里Java面试问题大全》</h4><h6 id="链接-https-pan-baidu-com-s-1hQKvpq9-Nc0kErE4LY6UJQ-提取码-es6v"><a href="#链接-https-pan-baidu-com-s-1hQKvpq9-Nc0kErE4LY6UJQ-提取码-es6v" class="headerlink" title="链接: https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ 提取码: es6v"></a>链接: <a href="https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ">https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ</a> 提取码: es6v</h6><p>　　机械工业出版社本书引入了一批来自于著名高校、就职于明星企业的职场达人的真实求职案例，通过他们的求职经验与教训，将整个求职过程生动形象地展示在读者面前，进而对求职者起到一定的指引作用。同时，为了更具说服力，本书特邀多位IT名企的面试官现身说法，以独特的视角对面试过程中求职者存在的各类问题进行了深度剖析。为了能够让读者对即将投身的工作有一些更加清楚的认识，能够更加有针对性地进行求职准备，本书对各种类型的IT企业的招聘环节进行了庖丁解牛式的分析。<br><a id="more"></a></p>
<p>　　技术性知识的考查是程序员求职中重要的内容，鉴于此，本书除了对传统的计算机相关知识（Java语言基础知识、Web基础知识、数据结构与算法、数据库、设计模式等）以及面试笔试真题进行分析与解答外，还根据当前计算机技术的发展潮流，对面试笔试中常见的海量数据处理问题进行了详细的分析。</p>
<p>　　《Java程序员面试笔试宝典》是一本适合计算机相关专业毕业生阅读的求职指导用书，同时也适合期望在计算机软硬件行业大显身手的计算机爱好者阅读。</p>
<p><img src="/images/df1cbdd23e9f840cfc4672ba62436b581.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">上篇面试笔试经验技巧篇</span><br><span class="line"></span><br><span class="line">第1章面试官箴言</span><br><span class="line"></span><br><span class="line">1.1有道无术，术可求；有术无道，止于术</span><br><span class="line"></span><br><span class="line">1.2求精不求全</span><br><span class="line"></span><br><span class="line">1.3脚踏实地，培养多种技能</span><br><span class="line"></span><br><span class="line">1.4保持空杯心态</span><br><span class="line"></span><br><span class="line">1.5职场是能者的舞台</span><br><span class="line"></span><br><span class="line">1.6学会“纸上谈兵”</span><br><span class="line"></span><br><span class="line">1.7小结</span><br><span class="line"></span><br><span class="line">第2章面试心得交流</span><br><span class="line"></span><br><span class="line">2.1心态决定一切</span><br><span class="line"></span><br><span class="line">2.2假话全不说，真话不全说</span><br><span class="line"></span><br><span class="line">2.3走自己的路，让别人去说吧</span><br><span class="line"></span><br><span class="line">2.4夯实基础谋出路</span><br><span class="line"></span><br><span class="line">2.5书中自有编程法</span><br><span class="line"></span><br><span class="line">2.6笔试成绩好，不会被鄙视</span><br><span class="line"></span><br><span class="line">2.7不要一厢情愿做公司的</span><br><span class="line"></span><br><span class="line">“备胎”</span><br><span class="line"></span><br><span class="line">2.8小结</span><br><span class="line"></span><br><span class="line">第3章企业面试笔试攻略</span><br><span class="line"></span><br><span class="line">3.1互联网企业</span><br><span class="line"></span><br><span class="line">3.2网络设备提供商</span><br><span class="line"></span><br><span class="line">3.3外企</span><br><span class="line"></span><br><span class="line">3.4国企</span><br><span class="line"></span><br><span class="line">3.5研究所</span><br><span class="line"></span><br><span class="line">3.6创业型企业</span><br><span class="line"></span><br><span class="line">3.7如何抉择</span><br><span class="line"></span><br><span class="line">下篇面试笔试技术攻克篇</span><br><span class="line"></span><br><span class="line">第4章Java基础知识</span><br><span class="line"></span><br><span class="line">4.1基本概念</span><br><span class="line"></span><br><span class="line">4.1.1Java语言有哪些优点</span><br><span class="line"></span><br><span class="line">4.1.2Java与C&#x2F;C++有什么异同</span><br><span class="line"></span><br><span class="line">4.1.3为什么需要publicstaticvoidmain（String［］args）这个方法</span><br><span class="line"></span><br><span class="line">4.1.4如何实现在main（）方法执行前输出“HelloWorld”</span><br><span class="line"></span><br><span class="line">4.1.5Java程序初始化的顺序是怎样的</span><br><span class="line"></span><br><span class="line">4.1.6Java中的作用域有哪些</span><br><span class="line"></span><br><span class="line">4.1.7一个Java文件中是否可以定义多个类</span><br><span class="line"></span><br><span class="line">4.1.8什么是构造函数</span><br><span class="line"></span><br><span class="line">4.1.9为什么Java中有些接口没有任何方法</span><br><span class="line"></span><br><span class="line">4.1.10Java中的clone方法有什么作用</span><br><span class="line"></span><br><span class="line">4.1.11什么是反射机制</span><br><span class="line"></span><br><span class="line">4.1.12package有什么作用</span><br><span class="line"></span><br><span class="line">4.1.13如何实现类似于C语言中函数指针的功能</span><br><span class="line"></span><br><span class="line">4.2面向对象技术</span><br><span class="line"></span><br><span class="line">4.2.1面向对象与面向过程有什么区别</span><br><span class="line"></span><br><span class="line">4.2.2面向对象有哪些特征</span><br><span class="line"></span><br><span class="line">4.2.3面向对象的开发方式有什么优点</span><br><span class="line"></span><br><span class="line">4.2.4什么是继承</span><br><span class="line"></span><br><span class="line">4.2.5组合和继承有什么区别</span><br><span class="line"></span><br><span class="line">4.2.6多态的实现机制是什么</span><br><span class="line"></span><br><span class="line">4.2.7重载和覆盖有什么区别</span><br><span class="line"></span><br><span class="line">4.2.8抽象类（abstractclass）与接口（interface）有什么异同</span><br><span class="line"></span><br><span class="line">4.2.9内部类有哪些</span><br><span class="line"></span><br><span class="line">4.2.10如何获取父类的类名</span><br><span class="line"></span><br><span class="line">4.2.11this与super有什么区别</span><br><span class="line"></span><br><span class="line">4.3关键字</span><br><span class="line"></span><br><span class="line">4.3.1变量命名有哪些规则</span><br><span class="line"></span><br><span class="line">4.3.2break、continue以及return有什么区别</span><br><span class="line"></span><br><span class="line">4.3.3final、finally和finalize有什么区别</span><br><span class="line"></span><br><span class="line">4.3.4assert有什么作用</span><br><span class="line"></span><br><span class="line">4.3.5static关键字有哪些作用</span><br><span class="line"></span><br><span class="line">4.3.6使用switch时有哪些注意事项</span><br><span class="line"></span><br><span class="line">4.3.7volatile有什么作用</span><br><span class="line"></span><br><span class="line">4.3.8instanceof有什么作用</span><br><span class="line"></span><br><span class="line">4.3.9strictfp有什么作用</span><br><span class="line"></span><br><span class="line">4.4基本类型与运算</span><br><span class="line"></span><br><span class="line">4.4.1Java提供了哪些基本数据类型</span><br><span class="line"></span><br><span class="line">4.4.2什么是不可变类</span><br><span class="line"></span><br><span class="line">4.4.3值传递与引用传递有哪些区别</span><br><span class="line"></span><br><span class="line">4.4.4不同数据类型的转换有哪些规则</span><br><span class="line"></span><br><span class="line">4.4.5强制类型转换的注意事项有哪些</span><br><span class="line"></span><br><span class="line">4.4.6运算符优先级是什么？</span><br><span class="line"></span><br><span class="line">4.4.7Math类中round、ceil和floor方法的功能各是什么</span><br><span class="line"></span><br><span class="line">4.4.8++i与i++有什么区别</span><br><span class="line"></span><br><span class="line">4.4.9如何实现无符号数的右移操作</span><br><span class="line"></span><br><span class="line">4.4.10char型变量中是否可以存储一个中文汉字</span><br><span class="line"></span><br><span class="line">4.5字符串与数组</span><br><span class="line"></span><br><span class="line">4.5.1字符串创建与存储的机制是什么</span><br><span class="line"></span><br><span class="line">4.5.2“&#x3D;&#x3D;”、equals和hashCode有什么区别</span><br><span class="line"></span><br><span class="line">4.5.3String、StringBuffer、StringBuilder和</span><br><span class="line"></span><br><span class="line">StringTokenizer有什么区别</span><br><span class="line"></span><br><span class="line">4.5.4Java中数组是不是对象</span><br><span class="line"></span><br><span class="line">4.5.5数组的初始化方式有哪几种</span><br><span class="line"></span><br><span class="line">4.5.6length属性与length（）方法有什么区别</span><br><span class="line"></span><br><span class="line">4.6异常处理</span><br><span class="line"></span><br><span class="line">4.6.1finally块中的代码什么时候被执行</span><br><span class="line"></span><br><span class="line">4.6.2异常处理的原理是什么</span><br><span class="line"></span><br><span class="line">4.6.3运行时异常和普通异常有什么区别</span><br><span class="line"></span><br><span class="line">4.7输入输出流</span><br><span class="line"></span><br><span class="line">4.7.1JavaIO流的实现机制是什么</span><br><span class="line"></span><br><span class="line">4.7.2管理文件和目录的类是什么</span><br><span class="line"></span><br><span class="line">4.7.3JavaSocket是什么</span><br><span class="line"></span><br><span class="line">4.7.4JavaNIO是什么</span><br><span class="line"></span><br><span class="line">4.7.5什么是Java序列化</span><br><span class="line"></span><br><span class="line">4.7.6System.out.println（）方法使用需要注意哪些问题</span><br><span class="line"></span><br><span class="line">4.8Java平台与内存管理</span><br><span class="line"></span><br><span class="line">4.8.1为什么说Java是平台独立性语言</span><br><span class="line"></span><br><span class="line">4.8.2Java平台与其他语言平台有哪些区别</span><br><span class="line"></span><br><span class="line">4.8.3JVM加载class文件的原理机制是什么</span><br><span class="line"></span><br><span class="line">4.8.4什么是GC</span><br><span class="line"></span><br><span class="line">4.8.5Java是否存在内存泄露问题</span><br><span class="line"></span><br><span class="line">4.8.6Java中的堆和栈有什么区别</span><br><span class="line"></span><br><span class="line">4.9容器</span><br><span class="line"></span><br><span class="line">4.9.1JavaCollections框架是什么</span><br><span class="line"></span><br><span class="line">4.9.2什么是迭代器</span><br><span class="line"></span><br><span class="line">4.9.3ArrayList、Vector和LinkedList有什么区别</span><br><span class="line"></span><br><span class="line">4.9.4HashMap、HashTable、TreeMap和WeakHashMap有哪些区别</span><br><span class="line"></span><br><span class="line">4.9.5用自定义作为HashMap或HashTable的key需要注意哪些问题</span><br><span class="line"></span><br><span class="line">4.9.6Collection和Collections有什么区别</span><br><span class="line"></span><br><span class="line">4.10多线程</span><br><span class="line"></span><br><span class="line">4.10.1什么是线程？它与进程有什么区别？为什么要使用多线程</span><br><span class="line"></span><br><span class="line">4.10.2同步和异步有什么区别</span><br><span class="line"></span><br><span class="line">4.10.3如何实现Java多线程</span><br><span class="line"></span><br><span class="line">4.10.4run（）方法与start（）方法有什么区别</span><br><span class="line"></span><br><span class="line">4.10.5多线程同步的实现方法有哪些</span><br><span class="line"></span><br><span class="line">4.10.6sleep（）方法与wait（）方法有什么区别</span><br><span class="line"></span><br><span class="line">4.10.7终止线程的方法有哪些</span><br><span class="line"></span><br><span class="line">4.10.8synchronized与Lock有什么异同</span><br><span class="line"></span><br><span class="line">4.10.9什么是守护线程</span><br><span class="line"></span><br><span class="line">4.10.10join（）方法的作用是什么</span><br><span class="line"></span><br><span class="line">4.11Java数据库操作</span><br><span class="line"></span><br><span class="line">4.11.1如何通过JDBC访问数据库</span><br><span class="line"></span><br><span class="line">4.11.2JDBC处理事务采用什么方法</span><br><span class="line"></span><br><span class="line">4.11.3Class.forName的作用是什么</span><br><span class="line"></span><br><span class="line">4.11.4Statement、PreparedStatement和CallableStatement有什么区别</span><br><span class="line"></span><br><span class="line">4.11.5getString（）方法与getObject（）方法有什么区别</span><br><span class="line"></span><br><span class="line">4.11.6使用JDBC时需要注意哪些问题</span><br><span class="line"></span><br><span class="line">4.11.7什么是JDO</span><br><span class="line"></span><br><span class="line">4.11.8JDBC与Hibernate有什么区别</span><br><span class="line"></span><br><span class="line">第5章JavaWeb</span><br><span class="line"></span><br><span class="line">5.1Servlet与JSP</span><br><span class="line"></span><br><span class="line">5.1.1页面请求的工作流程是怎样的</span><br><span class="line"></span><br><span class="line">5.1.2HTTP中GET与POST方法有什么区别</span><br><span class="line"></span><br><span class="line">5.1.3什么是Servlet</span><br><span class="line"></span><br><span class="line">5.1.4doPost（）方法与doGet（）方法怎么选择</span><br><span class="line"></span><br><span class="line">5.1.5什么是Servlet的生命周期</span><br><span class="line"></span><br><span class="line">5.1.6JSP有哪些优点</span><br><span class="line"></span><br><span class="line">5.1.7JSP与Servlet有何异同</span><br><span class="line"></span><br><span class="line">5.1.8如何使用JSP与Servlet实现MVC模型</span><br><span class="line"></span><br><span class="line">5.1.9Servlet中forward和redirect有什么区别</span><br><span class="line"></span><br><span class="line">5.1.10JSP的内置对象有哪些</span><br><span class="line"></span><br><span class="line">5.1.11request对象主要有哪些方法</span><br><span class="line"></span><br><span class="line">5.1.12JSP有哪些动作</span><br><span class="line"></span><br><span class="line">5.1.13JSP中include指令和include动作有什么区别</span><br><span class="line"></span><br><span class="line">5.1.14会话跟踪技术有哪些</span><br><span class="line"></span><br><span class="line">5.1.15Web开发中如何指定字符串的编码</span><br><span class="line"></span><br><span class="line">5.1.16什么是Ajax</span><br><span class="line"></span><br><span class="line">5.1.17cookie和session有什么区别</span><br><span class="line"></span><br><span class="line">5.2J2EE与EJB</span><br><span class="line"></span><br><span class="line">5.2.1什么是J2EE</span><br><span class="line"></span><br><span class="line">5.2.2J2EE中常用的术语有哪些</span><br><span class="line"></span><br><span class="line">5.2.3EJB有哪些不同的类别</span><br><span class="line"></span><br><span class="line">5.2.4EJB与JavaBean有什么异同</span><br><span class="line"></span><br><span class="line">5.2.5EJB有哪些生命周期</span><br><span class="line"></span><br><span class="line">5.2.6EJB的角色有哪几种</span><br><span class="line"></span><br><span class="line">5.2.7EJB的开发流程是怎样的</span><br><span class="line"></span><br><span class="line">5.2.8EJB3.0与EJB2.0有哪些不同之处</span><br><span class="line"></span><br><span class="line">5.2.9EJB容器有哪些作用</span><br><span class="line"></span><br><span class="line">5.2.10EJB规范规定EJB中禁止的操作有哪些</span><br><span class="line"></span><br><span class="line">5.2.11Web服务器与Web应用服务器有什么区别</span><br><span class="line"></span><br><span class="line">5.2.12什么是WebService</span><br><span class="line"></span><br><span class="line">5.2.13SOAP与REST有什么区别</span><br><span class="line"></span><br><span class="line">5.2.14什么是XML</span><br><span class="line"></span><br><span class="line">5.2.15数据库连接池的工作机制是怎样的</span><br><span class="line"></span><br><span class="line">5.2.16J2EE开发有哪些调优的方法</span><br><span class="line"></span><br><span class="line">5.3框架</span><br><span class="line"></span><br><span class="line">5.3.1什么是Struts框架</span><br><span class="line"></span><br><span class="line">5.3.2Struts框架响应客户请求的工作流程是什么</span><br><span class="line"></span><br><span class="line">5.3.3Struts框架的数据验证可分为几种类型</span><br><span class="line"></span><br><span class="line">5.3.4FormBean的表单验证流程是什么</span><br><span class="line"></span><br><span class="line">5.3.5在Struts配置文件中元素包含哪些属性和子元</span><br><span class="line"></span><br><span class="line">5.3.6ActionFormBean的作用有哪些</span><br><span class="line"></span><br><span class="line">5.3.7ActionForm的执行步骤有哪些</span><br><span class="line"></span><br><span class="line">5.3.8forward与global-forward有什么区别</span><br><span class="line"></span><br><span class="line">5.3.9Struts如何实现国际化</span><br><span class="line"></span><br><span class="line">5.3.10Struts1与Struts2有哪些区别</span><br><span class="line"></span><br><span class="line">5.3.11什么是IoC</span><br><span class="line"></span><br><span class="line">5.3.12什么是AOP</span><br><span class="line"></span><br><span class="line">5.3.13什么是Spring框架</span><br><span class="line"></span><br><span class="line">5.3.14什么是Hibernate</span><br><span class="line"></span><br><span class="line">5.3.15什么是Hibernate的二级缓存</span><br><span class="line"></span><br><span class="line">5.3.16Hibernate中session的update（）和saveOrUpdate（）、load（）和get（）有什么区别</span><br><span class="line"></span><br><span class="line">5.3.17Hibernate有哪些主键生成策略</span><br><span class="line"></span><br><span class="line">5.3.18如何实现分页机制</span><br><span class="line"></span><br><span class="line">5.3.19什么是SSH</span><br><span class="line"></span><br><span class="line">第6章数据库原理</span><br><span class="line"></span><br><span class="line">6.1SQL语言的功能有哪些</span><br><span class="line"></span><br><span class="line">6.2内连接与外连接有什么区别</span><br><span class="line"></span><br><span class="line">6.3什么是事务</span><br><span class="line"></span><br><span class="line">6.4什么是存储过程？它与函数有什么区别与联系</span><br><span class="line"></span><br><span class="line">6.5各种范式有什么区别</span><br><span class="line"></span><br><span class="line">6.6什么是触发器</span><br><span class="line"></span><br><span class="line">6.7什么是游标</span><br><span class="line"></span><br><span class="line">6.8如果数据库日志满了，会出现什么情况</span><br><span class="line"></span><br><span class="line">6.9union和unionall有什么区别</span><br><span class="line"></span><br><span class="line">6.10什么是视图</span><br><span class="line"></span><br><span class="line">第7章设计模式</span><br><span class="line"></span><br><span class="line">7.1什么是单例模式</span><br><span class="line"></span><br><span class="line">7.2什么是工厂模式</span><br><span class="line"></span><br><span class="line">7.3什么是适配器模式</span><br><span class="line"></span><br><span class="line">7.4什么是观察者模式</span><br><span class="line"></span><br><span class="line">第8章数据结构与算法</span><br><span class="line"></span><br><span class="line">8.1链表</span><br><span class="line"></span><br><span class="line">8.1.1如何实现单链表的增删操作</span><br><span class="line"></span><br><span class="line">8.1.2如何从链表中删除重复数据</span><br><span class="line"></span><br><span class="line">8.1.3如何找出单链表中的倒数第k个元素</span><br><span class="line"></span><br><span class="line">8.1.4如何实现链表的反转</span><br><span class="line"></span><br><span class="line">8.1.5如何从尾到头输出单链表</span><br><span class="line"></span><br><span class="line">8.1.6如何寻找单链表的中间结点</span><br><span class="line"></span><br><span class="line">8.1.7如何检测一个链表是否有环</span><br><span class="line"></span><br><span class="line">8.1.8如何在不知道头指针的情况下删除指定结点</span><br><span class="line"></span><br><span class="line">8.1.9如何判断两个链表是否相交</span><br><span class="line"></span><br><span class="line">8.2栈与队列</span><br><span class="line"></span><br><span class="line">8.2.1栈与队列有哪些区别</span><br><span class="line"></span><br><span class="line">8.2.2如何实现栈</span><br><span class="line"></span><br><span class="line">8.2.3如何用O（1）的时间复杂度求栈中最小元素</span><br><span class="line"></span><br><span class="line">8.2.4如何实现队列</span><br><span class="line"></span><br><span class="line">8.2.5如何用两个栈模拟队列操作</span><br><span class="line"></span><br><span class="line">8.3排序</span><br><span class="line"></span><br><span class="line">8.3.1如何进行选择排序</span><br><span class="line"></span><br><span class="line">8.3.2如何进行插入排序</span><br><span class="line"></span><br><span class="line">8.3.3如何进行冒泡排序</span><br><span class="line"></span><br><span class="line">8.3.4如何进行归并排序</span><br><span class="line"></span><br><span class="line">8.3.5如何进行快速排序</span><br><span class="line"></span><br><span class="line">8.3.6如何进行希尔排序</span><br><span class="line"></span><br><span class="line">8.3.7如何进行堆排序</span><br><span class="line"></span><br><span class="line">8.3.8各种排序算法有什么优劣</span><br><span class="line"></span><br><span class="line">8.4位运算</span><br><span class="line"></span><br><span class="line">8.4.1如何用移位操作实现乘法运算</span><br><span class="line"></span><br><span class="line">8.4.2如何判断一个数是否为2的n次方</span><br><span class="line"></span><br><span class="line">8.4.3如何求二进制数中1的个数</span><br><span class="line"></span><br><span class="line">8.5数组</span><br><span class="line"></span><br><span class="line">8.5.1如何寻找数组中的最小值与最大值</span><br><span class="line"></span><br><span class="line">8.5.2如何找出数组中第二大的数</span><br><span class="line"></span><br><span class="line">8.5.3如何求最大子数组之和</span><br><span class="line"></span><br><span class="line">8.5.4如何找出数组中重复元素最多的数</span><br><span class="line"></span><br><span class="line">8.5.5如何求数组中两两相加等于20的组合种数</span><br><span class="line"></span><br><span class="line">8.5.6如何把一个数组循环右移k位</span><br><span class="line"></span><br><span class="line">8.5.7如何找出数组中第k个最小的数</span><br><span class="line"></span><br><span class="line">8.5.8如何找出数组中只出现次的数字</span><br><span class="line"></span><br><span class="line">8.5.9如何找出数组中唯一的重复元素</span><br><span class="line"></span><br><span class="line">8.5.10如何用递归方法求一个整数数组的最大元素</span><br><span class="line"></span><br><span class="line">8.5.11如何求数对之差的最大值</span><br><span class="line"></span><br><span class="line">8.5.12如何求绝对值最小的数</span><br><span class="line"></span><br><span class="line">8.5.13如何求数组中两个元素的最小距离</span><br><span class="line"></span><br><span class="line">8.5.14如何求指定数字在数组中第一次出现的位置</span><br><span class="line"></span><br><span class="line">8.5.15如何对数组的两个子有序段进行合并</span><br><span class="line"></span><br><span class="line">8.5.16如何计算两个有序整型数组的交集</span><br><span class="line"></span><br><span class="line">8.5.17如何判断一个数组中数值是否连续相邻</span><br><span class="line"></span><br><span class="line">8.5.18如何求解数组中反序对的个数</span><br><span class="line"></span><br><span class="line">8.5.19如何求解最小三元组距离</span><br><span class="line"></span><br><span class="line">8.6字符串</span><br><span class="line"></span><br><span class="line">8.6.1如何实现字符串的反转</span><br><span class="line"></span><br><span class="line">8.6.2如何判断两个字符串是否由相同的字符组成</span><br><span class="line"></span><br><span class="line">8.6.3如何删除字符串中重复的字符</span><br><span class="line"></span><br><span class="line">8.6.4如何统计一行字符中有多少个单词</span><br><span class="line"></span><br><span class="line">8.6.5如何按要求打印数组的排列情况</span><br><span class="line"></span><br><span class="line">8.6.6如何输出字符串的所有组合</span><br><span class="line"></span><br><span class="line">8.7二叉树</span><br><span class="line"></span><br><span class="line">8.7.1二叉树基本概念</span><br><span class="line"></span><br><span class="line">8.7.2如何实现二叉排序树</span><br><span class="line"></span><br><span class="line">8.7.3如何层序遍历二叉树</span><br><span class="line"></span><br><span class="line">8.7.4已知先序遍历和中序遍历，如何求后序遍历</span><br><span class="line"></span><br><span class="line">8.7.5如何求二叉树中结点的最大距离</span><br><span class="line"></span><br><span class="line">8.8其他</span><br><span class="line"></span><br><span class="line">8.8.1如何消除嵌套的括号</span><br><span class="line"></span><br><span class="line">8.8.2如何不使用比较运算就可以求出两个数的最大值与最小值</span><br><span class="line"></span><br><span class="line">第9章海量数据处理</span><br><span class="line"></span><br><span class="line">9.1问题分析</span><br><span class="line"></span><br><span class="line">9.2基本方法</span><br><span class="line"></span><br><span class="line">9.3经典实例分析</span><br><span class="line"></span><br><span class="line">9.3.1topK问题</span><br><span class="line"></span><br><span class="line">9.3.2重复问题</span><br><span class="line"></span><br><span class="line">9.3.3排序问题</span><br><span class="line"></span><br><span class="line">附录</span><br><span class="line"></span><br><span class="line">附录A软件企业Java笔试真题1</span><br><span class="line"></span><br><span class="line">附录B软件企业Java笔试真题2</span><br><span class="line"></span><br><span class="line">附录C软件企业Java笔试真题3</span><br><span class="line"></span><br><span class="line">附录D求职有用网站及QQ群</span><br><span class="line"></span><br><span class="line">一览表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>啊哈算法 PDF</title>
    <url>/posts/7716cabf/</url>
    <content><![CDATA[<h4 id="《啊哈算法》"><a href="#《啊哈算法》" class="headerlink" title="《啊哈算法》"></a>《啊哈算法》</h4><h6 id="链接-https-pan-baidu-com-s-1U726iEp6WADu4ZQ5fRZyzA-提取码-ymvg"><a href="#链接-https-pan-baidu-com-s-1U726iEp6WADu4ZQ5fRZyzA-提取码-ymvg" class="headerlink" title="链接: https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA 提取码: ymvg"></a>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> 提取码: ymvg</h6><p>啊哈算法<br><a id="more"></a></p>
<p>我当初是因为啊哈磊写的另外一本书《啊哈！C》而认识啊哈磊的。啊哈磊还有个网站，也叫啊哈磊，这个啊哈磊网站中有个论坛，叫啊哈论坛。论坛建立短短一年半时间，就聚集了15000多个啊哈小伙伴，都是萌物。我对他的写作风格很欣赏，那是一种因热爱和探究而产生的纯粹的快乐，因此，当啊哈磊率领着他的一大波萌物开开心心地攻城略地，浩浩荡荡地兵临城下，跟我说他想写一本通俗易懂的算法书，不知是否能出版时，我的回答是：“必须出版！”</p>
<p>这本书出版意向的达成就是这么简单。</p>
<p>啊哈C语言 逻辑的挑战</p>
<p>这是一本非常有趣的编程启蒙书，全书从中小学生的角度来讲述，没有生涩的内容，取而代之的是生动活泼的漫画和风趣幽默的文字。并配合超萌的编程软件，从开始学习与计算机对话到自己独立制作一个游戏，由浅入深地讲述编程的思维。同时，与计算机展开的逻辑较量一定会让你觉得很有意思。你可以在茶余饭后阅读本书，甚至蹲在马桶上时也可以看得津津有味。编程将会改变我们的思维，教会我们如何思考，让我们的思维插上计算机的翅膀，以一种全新的方式来看世界。现在就让我们一起走进计算机编程的神奇世界，探索和发现计算机编程的魔力吧！</p>
<p><img src="/images/815d6dce85a8489f4a33b2d2adee739f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 一大波数正在靠近——排序 1</span><br><span class="line"></span><br><span class="line">第1节 快简单的排序——桶排序 2</span><br><span class="line"></span><br><span class="line">第2节 邻居好说话——冒泡排序 7</span><br><span class="line"></span><br><span class="line">第3节 常用的排序——快速排序 12</span><br><span class="line"></span><br><span class="line">第4节 小哼买书 20</span><br><span class="line"></span><br><span class="line">第2章 栈、队列、链表 25</span><br><span class="line"></span><br><span class="line">第1节 解密号——队列 26</span><br><span class="line"></span><br><span class="line">第2节 解密回文——栈 32</span><br><span class="line"></span><br><span class="line">第3节 纸牌游戏——小猫钓鱼 35</span><br><span class="line"></span><br><span class="line">第4节 链表 44</span><br><span class="line"></span><br><span class="line">第5节 模拟链表 54</span><br><span class="line"></span><br><span class="line">第3章 枚举！很暴力 57</span><br><span class="line"></span><br><span class="line">第1节 坑爹的奥数 58</span><br><span class="line"></span><br><span class="line">第2节 炸弹人 61</span><br><span class="line"></span><br><span class="line">第3节 火柴棍等式 67</span><br><span class="line"></span><br><span class="line">第4节 数的全排列 70</span><br><span class="line"></span><br><span class="line">第4章 的搜索 72</span><br><span class="line"></span><br><span class="line">第1节 不撞南墙不回头——深度优先搜索 73</span><br><span class="line"></span><br><span class="line">第2节 解救小哈 81</span><br><span class="line"></span><br><span class="line">第3节 层层递进——广度优先搜索 88</span><br><span class="line"></span><br><span class="line">第4节 再解炸弹人 95</span><br><span class="line"></span><br><span class="line">第5节 宝岛探险 106</span><br><span class="line"></span><br><span class="line">第6节 水管工游戏 117</span><br><span class="line"></span><br><span class="line">第5章 图的遍历 128</span><br><span class="line"></span><br><span class="line">第1节 深度和广度优先究竟是指啥 129</span><br><span class="line"></span><br><span class="line">第2节 城市地图——图的深度优先遍历 136</span><br><span class="line"></span><br><span class="line">第3节 少转机——图的广度优先遍历 142</span><br><span class="line"></span><br><span class="line">第6章 短路径 147</span><br><span class="line"></span><br><span class="line">第1节 只有五行的算法——Floyd-Warshall 148</span><br><span class="line"></span><br><span class="line">第2节 Dijkstra算法——通过边实现松弛 155</span><br><span class="line"></span><br><span class="line">第3节 Bellman-Ford——解决负权边 163</span><br><span class="line"></span><br><span class="line">第4节 Bellman-Ford的队列优化 171</span><br><span class="line"></span><br><span class="line">第5节 短路径算法对比分析 177</span><br><span class="line"></span><br><span class="line">第7章 神奇的树 178</span><br><span class="line"></span><br><span class="line">第1节 开启“树”之旅 179</span><br><span class="line"></span><br><span class="line">第2节 二叉树 183</span><br><span class="line"></span><br><span class="line">第3节 堆——神奇的优先队列 185</span><br><span class="line"></span><br><span class="line">第4节 擒贼先擒王——并查集 200</span><br><span class="line"></span><br><span class="line">第8章 更多精彩算法 211</span><br><span class="line"></span><br><span class="line">第1节 镖局运镖——图的小生成树 212</span><br><span class="line"></span><br><span class="line">第2节 再谈小生成树 219</span><br><span class="line"></span><br><span class="line">第3节 重要城市——图的割点 229</span><br><span class="line"></span><br><span class="line">第4节 关键道路——图的割边 234</span><br><span class="line"></span><br><span class="line">第5节 我要做月老——二分图大匹配 237</span><br><span class="line"></span><br><span class="line">第9章 还能更好吗——微软亚洲研究院面试 243</span><br><span class="line"></span><br><span class="line">学C也可以很卡通</span><br><span class="line"></span><br><span class="line">第1章 变量 &#x2F; 001</span><br><span class="line"></span><br><span class="line">1.1 变量的由来 &#x2F; 001</span><br><span class="line"></span><br><span class="line">1.2 创建变量 &#x2F; 003</span><br><span class="line"></span><br><span class="line">1.3 变量赋值 &#x2F; 004</span><br><span class="line"></span><br><span class="line">1.4 变量运算 &#x2F; 005</span><br><span class="line"></span><br><span class="line">1.5 定义变量的技巧 &#x2F; 006</span><br><span class="line"></span><br><span class="line">1.6 代码与程序的关系 &#x2F; 007</span><br><span class="line"></span><br><span class="line">1.7 变量的类型 &#x2F; 010</span><br><span class="line"></span><br><span class="line">第2章 变量与内存的关系 &#x2F; 012</span><br><span class="line"></span><br><span class="line">2.1 变量与内存的关系 &#x2F; 012</span><br><span class="line"></span><br><span class="line">第3章 输入与输出 &#x2F; 025</span><br><span class="line"></span><br><span class="line">3.1 程序的输入输出 &#x2F; 025</span><br><span class="line"></span><br><span class="line">3.2 输入的详细说明 &#x2F; 032</span><br><span class="line"></span><br><span class="line">3.3 输出的详细说明 &#x2F; 034</span><br><span class="line"></span><br><span class="line">第4章 编译 &#x2F; 036</span><br><span class="line"></span><br><span class="line">4.1 如何选择编程软件 &#x2F; 036</span><br><span class="line"></span><br><span class="line">4.2 编译是什么(这是一篇水贴) &#x2F; 041</span><br><span class="line"></span><br><span class="line">4.3 个完整的程序 &#x2F; 043</span><br><span class="line"></span><br><span class="line">第5章 函数 &#x2F; 045</span><br><span class="line"></span><br><span class="line">5.1 函数的介绍 &#x2F; 045</span><br><span class="line"></span><br><span class="line">5.2 头文件和函数库 &#x2F; 049</span><br><span class="line"></span><br><span class="line">第6章 判断语句 &#x2F; 052</span><br><span class="line"></span><br><span class="line">6.1 关系预算符 &#x2F; 052</span><br><span class="line"></span><br><span class="line">6.2 布尔变量 &#x2F; 060</span><br><span class="line"></span><br><span class="line">6.3 if语句-卖瓜的老汉 &#x2F; 063</span><br><span class="line"></span><br><span class="line">6.4 if语句-卖冰棍的逻辑 &#x2F; 071</span><br><span class="line"></span><br><span class="line">6.5 习题答案 &#x2F; 080</span><br><span class="line"></span><br><span class="line">第7章 循环语句 &#x2F; 081</span><br><span class="line"></span><br><span class="line">7.1 for循环 &#x2F; 083</span><br><span class="line"></span><br><span class="line">7.2 while循环-邪恶的计划 &#x2F; 094</span><br><span class="line"></span><br><span class="line">7.3 while循环-宝藏 &#x2F; 104</span><br><span class="line"></span><br><span class="line">7.4 习题答案 &#x2F; 110</span><br><span class="line"></span><br><span class="line">第8章 数组 &#x2F; 112</span><br><span class="line"></span><br><span class="line">8.1 数组的定义 &#x2F; 112</span><br><span class="line"></span><br><span class="line">8.2 数组的序号 &#x2F; 115</span><br><span class="line"></span><br><span class="line">8.3 数组的操作 &#x2F; 118</span><br><span class="line"></span><br><span class="line">8.4 数组与循环 &#x2F; 124</span><br><span class="line"></span><br><span class="line">8.5 二维数组和多维数组 &#x2F; 126</span><br><span class="line"></span><br><span class="line">第9章 编程语言介绍 &#x2F; 133</span><br><span class="line"></span><br><span class="line">9.1 编程语言，我将如何选择 &#x2F; 133</span><br><span class="line"></span><br><span class="line">9.2 上部分结束 &#x2F; 145</span><br><span class="line"></span><br><span class="line">第10章 指针 &#x2F; 146</span><br><span class="line"></span><br><span class="line">10.1 指针变量简介 &#x2F; 146</span><br><span class="line"></span><br><span class="line">10.2 指针—的指针 &#x2F; 151</span><br><span class="line"></span><br><span class="line">10.3 指针变量的作用 &#x2F; 154</span><br><span class="line"></span><br><span class="line">10.4 指针的操作 &#x2F; 156</span><br><span class="line"></span><br><span class="line">10.5 指针与数组 &#x2F; 160</span><br><span class="line"></span><br><span class="line">第11章 内存与变量 &#x2F; 166</span><br><span class="line"></span><br><span class="line">11.1 动态变量 &#x2F; 166</span><br><span class="line"></span><br><span class="line">11.2 动态变量产生的原因 &#x2F; 177</span><br><span class="line"></span><br><span class="line">11.3 动态变量的例子 &#x2F; 178</span><br><span class="line"></span><br><span class="line">第12章 结构体 &#x2F; 180</span><br><span class="line"></span><br><span class="line">12.1 结构体的由来 &#x2F; 180</span><br><span class="line"></span><br><span class="line">12.2 结构体介绍 &#x2F; 184</span><br><span class="line"></span><br><span class="line">12.3 链表的实现 &#x2F; 185</span><br><span class="line"></span><br><span class="line">12.4 结构体与面向对象 &#x2F; 194</span><br><span class="line"></span><br><span class="line">谢幕 &#x2F; 198</span><br><span class="line"></span><br><span class="line">啊哈算法</span><br><span class="line"></span><br><span class="line">目 录</span><br><span class="line"></span><br><span class="line">第1章 编程改变思维 1</span><br><span class="line"></span><br><span class="line">第1节 为什么要学习编程 1</span><br><span class="line"></span><br><span class="line">第2节 本书是讲什么的，写给谁看的 4</span><br><span class="line"></span><br><span class="line">第2章 梦想启航 7</span><br><span class="line"></span><br><span class="line">第1节 编程的魔力 7</span><br><span class="line"></span><br><span class="line">第2节 让计算机开口说话 9</span><br><span class="line"></span><br><span class="line">第3节 多彩一点 18</span><br><span class="line"></span><br><span class="line">第4节 让计算机做加法 21</span><br><span class="line"></span><br><span class="line">第5节 数字的家――变量 26</span><br><span class="line"></span><br><span class="line">第6节 数据输出――我说咋地就咋地 31</span><br><span class="line"></span><br><span class="line">第7节 数据输入――我说算啥就算啥 33</span><br><span class="line"></span><br><span class="line">第8节 究竟有多少种小房子 37</span><br><span class="line"></span><br><span class="line">第9节 拨开云雾见月明 40</span><br><span class="line"></span><br><span class="line">第10节 逻辑挑战1：交换小房子中的数 42</span><br><span class="line"></span><br><span class="line">第11节 天啊！这怎么能看懂 45</span><br><span class="line"></span><br><span class="line">第3章 较量才刚刚开始 49</span><br><span class="line"></span><br><span class="line">第1节 大于、小于还是相等 49</span><br><span class="line"></span><br><span class="line">第2节 判断正数 50</span><br><span class="line"></span><br><span class="line">第3节 偶数判断 54</span><br><span class="line"></span><br><span class="line">第4节 神器else 56</span><br><span class="line"></span><br><span class="line">第5节 请告诉我谁大 59</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战2：3个数怎么办 61</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战3：我要排序 66</span><br><span class="line"></span><br><span class="line">第8节 运算符总结 71</span><br><span class="line"></span><br><span class="line">第9节 1＞2究竟对不对 71</span><br><span class="line"></span><br><span class="line">第10节 讨厌的嵌套 74</span><br><span class="line"></span><br><span class="line">第11节 if-else语法总结 78</span><br><span class="line"></span><br><span class="line">第4章 重量级选手登场 79</span><br><span class="line"></span><br><span class="line">第1节 停止的哭声 79</span><br><span class="line"></span><br><span class="line">第2节 我说几遍就几遍 83</span><br><span class="line"></span><br><span class="line">第3节 if对while说：我对你很重要 88</span><br><span class="line"></span><br><span class="line">第4节 求和！求和！！求和！！！ 90</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战4：60秒开始 95</span><br><span class="line"></span><br><span class="line">第6节 这个有点晕――循环嵌套来了 99</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战5：奔跑的字母 104</span><br><span class="line"></span><br><span class="line">第8节 究竟循环了多少次 108</span><br><span class="line"></span><br><span class="line">第9节 逻辑挑战6：奔跑的小人 110</span><br><span class="line"></span><br><span class="line">第10节 for隆重登场 114</span><br><span class="line"></span><br><span class="line">第5章 好戏在后面 118</span><br><span class="line"></span><br><span class="line">第1节 程序的3种结构 118</span><br><span class="line"></span><br><span class="line">第2节 �1�7嗦一下 119</span><br><span class="line"></span><br><span class="line">第3节 逻辑挑战7：判读质数很简单 120</span><br><span class="line"></span><br><span class="line">第4节 更快一点：break 125</span><br><span class="line"></span><br><span class="line">第5节 continue 126</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战8：验证哥德巴赫猜想 127</span><br><span class="line"></span><br><span class="line">第7节 逻辑挑战9：水仙花数 130</span><br><span class="line"></span><br><span class="line">第8节 逻辑挑战10：解决奥数难题 135</span><br><span class="line"></span><br><span class="line">第9节 逻辑挑战11：猜数游戏 138</span><br><span class="line"></span><br><span class="line">第10节 逻辑挑战12：你好坏，关机啦 142</span><br><span class="line"></span><br><span class="line">第6章 天啊！一大串数正在接近 144</span><br><span class="line"></span><br><span class="line">第1节 逆序输出 144</span><br><span class="line"></span><br><span class="line">第2节 申请100个小房子怎么办 145</span><br><span class="line"></span><br><span class="line">第3节 100个数的逆序 147</span><br><span class="line"></span><br><span class="line">第4节 逻辑挑战13：陶陶摘苹果 148</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战14：一个萝卜一个坑 151</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战15：选择排序 156</span><br><span class="line"></span><br><span class="line">第7节 二维数组 159</span><br><span class="line"></span><br><span class="line">第8节 剩下的一些东西 161</span><br><span class="line"></span><br><span class="line">第7章 有了它你能做更多的事 165</span><br><span class="line"></span><br><span class="line">第1节 字符的妙用 165</span><br><span class="line"></span><br><span class="line">第2节 多余的回车键 167</span><br><span class="line"></span><br><span class="line">第3节 字符的本质 169</span><br><span class="line"></span><br><span class="line">第4节 人名怎么存储呢 171</span><br><span class="line"></span><br><span class="line">第5节 逻辑挑战16：字母的排序 176</span><br><span class="line"></span><br><span class="line">第6节 逻辑挑战17：字典序 177</span><br><span class="line"></span><br><span class="line">第7节 多行字符 179</span><br><span class="line"></span><br><span class="line">第8节 存储一个迷宫 182</span><br><span class="line"></span><br><span class="line">第8章 游戏时间到了 184</span><br><span class="line"></span><br><span class="line">第1节 走迷宫 184</span><br><span class="line"></span><br><span class="line">第2节 推箱子 194</span><br><span class="line"></span><br><span class="line">附录A 标识符命名规则 197</span><br><span class="line"></span><br><span class="line">附录B 运算符的优先级和结合性 199</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>贝叶斯思维统计建模的PYTHON学习法 PDF</title>
    <url>/posts/11fa29/</url>
    <content><![CDATA[<h4 id="《贝叶斯思维统计建模的PYTHON学习法》"><a href="#《贝叶斯思维统计建模的PYTHON学习法》" class="headerlink" title="《贝叶斯思维统计建模的PYTHON学习法》"></a>《贝叶斯思维统计建模的PYTHON学习法》</h4><h6 id="链接-https-pan-baidu-com-s-102PeKZTCcz7POpfF20Vv0g-提取码-7t7x"><a href="#链接-https-pan-baidu-com-s-102PeKZTCcz7POpfF20Vv0g-提取码-7t7x" class="headerlink" title="链接: https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g 提取码: 7t7x"></a>链接: <a href="https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g">https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g</a> 提取码: 7t7x</h6><p>　　《贝叶斯思维 统计建模的Python学习法》帮助那些希望用数学工具解决实际问题的人们，仅有的要求可能就是懂一点概率知识和程序设计。而贝叶斯方法是一种常见的利用概率学知识去解决不确定性问题的数学方法，对于一个计算机专业的人士，应当熟悉其应用在诸如机器翻译，语音识别，垃圾邮件检测等常见的计算机问题领域。<br><a id="more"></a></p>
<p>　　可是《贝叶斯思维 统计建模的Python学习法》实际上会远远扩大你的视野，即使不是一个计算机专业的人士，你也可以看到在战争环境下（二战德军坦克问题），法律问题上（肾肿瘤的假设验证），体育博彩领域（棕熊队和加人队NFL比赛问题）贝叶斯方法的威力。怎么从有限的信息判断德军装甲部队的规模，你所支持的球队有多大可能赢得冠军，在《龙与地下城》勇士中，你应当对游戏角色属性的很大值有什么样的期望，甚至在普通的彩弹射击游戏中，拥有一些贝叶斯思维也能帮助到你提高游戏水平。</p>
<p>　　除此以外，《贝叶斯思维 统计建模的Python学习法》在共计15章的篇幅中讨论了怎样解决十几个现实生活中的实际问题。在这些问题的解决过程中，作者还潜移默化的帮助读者形成了建模决策的方法论，建模误差和数值误差怎么取舍，怎样为具体问题建立数学模型，如何抓住问题中的主要矛盾（模型中的关键参数），再一步一步的优化或者验证模型的有效性或者局限性。在这个意义上，这本书又是一本关于数学建模的成功样本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 贝叶斯定理 1</span><br><span class="line"></span><br><span class="line">1.1 条件概率 1</span><br><span class="line"></span><br><span class="line">1.2 联合概率 2</span><br><span class="line"></span><br><span class="line">1.3 曲奇饼问题 2</span><br><span class="line"></span><br><span class="line">1.4 贝叶斯定理 3</span><br><span class="line"></span><br><span class="line">1.5 历时诠释 4</span><br><span class="line"></span><br><span class="line">1.6 M&amp;M豆问题 5</span><br><span class="line"></span><br><span class="line">1.7 Monty Hall难题 6</span><br><span class="line"></span><br><span class="line">1.8 讨论 8</span><br><span class="line"></span><br><span class="line">第2章 统计计算 9</span><br><span class="line"></span><br><span class="line">2.1 分布 9</span><br><span class="line"></span><br><span class="line">2.2 曲奇饼问题 10</span><br><span class="line"></span><br><span class="line">2.3 贝叶斯框架 11</span><br><span class="line"></span><br><span class="line">2.4 Monty Hall难题 12</span><br><span class="line"></span><br><span class="line">2.5 封装框架 13</span><br><span class="line"></span><br><span class="line">2.6 M&amp;M豆问题 14</span><br><span class="line"></span><br><span class="line">2.7 讨论 15</span><br><span class="line"></span><br><span class="line">2.8 练习 16</span><br><span class="line"></span><br><span class="line">第3章 估计 17</span><br><span class="line"></span><br><span class="line">3.1 骰子问题 17</span><br><span class="line"></span><br><span class="line">3.2 火车头问题 18</span><br><span class="line"></span><br><span class="line">3.3 怎样看待先验概率？ 20</span><br><span class="line"></span><br><span class="line">3.4 其他先验概率 21</span><br><span class="line"></span><br><span class="line">3.5 置信区间 23</span><br><span class="line"></span><br><span class="line">3.6 累积分布函数 23</span><br><span class="line"></span><br><span class="line">3.7 德军坦克问题 24</span><br><span class="line"></span><br><span class="line">3.8 讨论 24</span><br><span class="line"></span><br><span class="line">3.9 练习 25</span><br><span class="line"></span><br><span class="line">第4章 估计进阶 27</span><br><span class="line"></span><br><span class="line">4.1　欧元问题 27</span><br><span class="line"></span><br><span class="line">4.2　后验概率的概述 28</span><br><span class="line"></span><br><span class="line">4.3　先验概率的湮没 29</span><br><span class="line"></span><br><span class="line">4.4　优化 31</span><br><span class="line"></span><br><span class="line">4.5　Beta分布 32</span><br><span class="line"></span><br><span class="line">4.6　讨论 34</span><br><span class="line"></span><br><span class="line">4.7　练习 34</span><br><span class="line"></span><br><span class="line">第5章 胜率和加数 37</span><br><span class="line"></span><br><span class="line">5.1 胜率 37</span><br><span class="line"></span><br><span class="line">5.2 贝叶斯定理的胜率形式 38</span><br><span class="line"></span><br><span class="line">5.3 奥利弗的血迹 39</span><br><span class="line"></span><br><span class="line">5.4 加数 40</span><br><span class="line"></span><br><span class="line">5.5 最大化 42</span><br><span class="line"></span><br><span class="line">5.6 混合分布 45</span><br><span class="line"></span><br><span class="line">5.7 讨论 47</span><br><span class="line"></span><br><span class="line">第6章 决策分析 49</span><br><span class="line"></span><br><span class="line">6.1 “正确的价格”问题 49</span><br><span class="line"></span><br><span class="line">6.2 先验概率 50</span><br><span class="line"></span><br><span class="line">6.3 概率密度函数 50</span><br><span class="line"></span><br><span class="line">6.4 PDF的表示 51</span><br><span class="line"></span><br><span class="line">6.5 选手建模 53</span><br><span class="line"></span><br><span class="line">6.6 似然度 55</span><br><span class="line"></span><br><span class="line">6.7 更新 55</span><br><span class="line"></span><br><span class="line">6.8 最优出价 57</span><br><span class="line"></span><br><span class="line">6.9 讨论 59</span><br><span class="line"></span><br><span class="line">第7章 预测 61</span><br><span class="line"></span><br><span class="line">7.1　波士顿棕熊队问题 61</span><br><span class="line"></span><br><span class="line">7.2　泊松过程 62</span><br><span class="line"></span><br><span class="line">7.3　后验 63</span><br><span class="line"></span><br><span class="line">7.4　进球分布 64</span><br><span class="line"></span><br><span class="line">7.5　获胜的概率 66</span><br><span class="line"></span><br><span class="line">7.6　突然死亡法则 66</span><br><span class="line"></span><br><span class="line">7.7　讨论 68</span><br><span class="line"></span><br><span class="line">7.8　练习 69</span><br><span class="line"></span><br><span class="line">第8章 观察者的偏差 71</span><br><span class="line"></span><br><span class="line">8.1　红线问题 71</span><br><span class="line"></span><br><span class="line">8.2　模型 71</span><br><span class="line"></span><br><span class="line">8.3　等待时间 73</span><br><span class="line"></span><br><span class="line">8.4　预测等待时间 75</span><br><span class="line"></span><br><span class="line">8.5　估计到达率 78</span><br><span class="line"></span><br><span class="line">8.6　消除不确定性 80</span><br><span class="line"></span><br><span class="line">8.7　决策分析 81</span><br><span class="line"></span><br><span class="line">8.8　讨论 83</span><br><span class="line"></span><br><span class="line">8.9　练习 84</span><br><span class="line"></span><br><span class="line">第9章 二维问题 85</span><br><span class="line"></span><br><span class="line">9.1 彩弹 85</span><br><span class="line"></span><br><span class="line">9.2 Suite对象 85</span><br><span class="line"></span><br><span class="line">9.3 三角学 87</span><br><span class="line"></span><br><span class="line">9.4 似然度 88</span><br><span class="line"></span><br><span class="line">9.5 联合分布 89</span><br><span class="line"></span><br><span class="line">9.6 条件分布 90</span><br><span class="line"></span><br><span class="line">9.7 置信区间 91</span><br><span class="line"></span><br><span class="line">9.8 讨论 93</span><br><span class="line"></span><br><span class="line">9.9 练习 94</span><br><span class="line"></span><br><span class="line">第10章 贝叶斯近似计算 95</span><br><span class="line"></span><br><span class="line">10.1 变异性假说 95</span><br><span class="line"></span><br><span class="line">10.2 均值和标准差 96</span><br><span class="line"></span><br><span class="line">10.3 更新 98</span><br><span class="line"></span><br><span class="line">10.4 CV的后验分布 98</span><br><span class="line"></span><br><span class="line">10.5 数据下溢 99</span><br><span class="line"></span><br><span class="line">10.6 对数似然 100</span><br><span class="line"></span><br><span class="line">10.7 一个小的优化 101</span><br><span class="line"></span><br><span class="line">10.8 ABC（近似贝叶斯计算） 102</span><br><span class="line"></span><br><span class="line">10.9 估计的可靠性 104</span><br><span class="line"></span><br><span class="line">10.10 谁的变异性更大？ 105</span><br><span class="line"></span><br><span class="line">10.11 讨论 107</span><br><span class="line"></span><br><span class="line">10.12 练习 108</span><br><span class="line"></span><br><span class="line">第11章 假设检验 109</span><br><span class="line"></span><br><span class="line">11.1 回到欧元问题 109</span><br><span class="line"></span><br><span class="line">11.2 来一个公平的对比 110</span><br><span class="line"></span><br><span class="line">11.3 三角前验 111</span><br><span class="line"></span><br><span class="line">11.4 讨论 112</span><br><span class="line"></span><br><span class="line">11.5 练习 113</span><br><span class="line"></span><br><span class="line">第12章 证据 115</span><br><span class="line"></span><br><span class="line">12.1 解读SAT成绩 115</span><br><span class="line"></span><br><span class="line">12.2 比例得分SAT 115</span><br><span class="line"></span><br><span class="line">12.3 先验 116</span><br><span class="line"></span><br><span class="line">12.4 后验 117</span><br><span class="line"></span><br><span class="line">12.5 一个更好的模型 119</span><br><span class="line"></span><br><span class="line">12.6 校准 121</span><br><span class="line"></span><br><span class="line">12.7 效率的后验分布 122</span><br><span class="line"></span><br><span class="line">12.8 预测分布 123</span><br><span class="line"></span><br><span class="line">12.9 讨论 124</span><br><span class="line"></span><br><span class="line">第13章 模拟 127</span><br><span class="line"></span><br><span class="line">13.1 肾肿瘤的问题 127</span><br><span class="line"></span><br><span class="line">13.2 一个简化模型 128</span><br><span class="line"></span><br><span class="line">13.3 更普遍的模型 130</span><br><span class="line"></span><br><span class="line">13.4 实现 131</span><br><span class="line"></span><br><span class="line">13.5 缓存联合分布 132</span><br><span class="line"></span><br><span class="line">13.6 条件分布 133</span><br><span class="line"></span><br><span class="line">13.7 序列相关性 135</span><br><span class="line"></span><br><span class="line">13.8 讨论 138</span><br><span class="line"></span><br><span class="line">第14章 层次化模型 139</span><br><span class="line"></span><br><span class="line">14.1 盖革计数器问题 139</span><br><span class="line"></span><br><span class="line">14.2 从简单的开始 140</span><br><span class="line"></span><br><span class="line">14.3 分层模型 141</span><br><span class="line"></span><br><span class="line">14.4 一个小优化 142</span><br><span class="line"></span><br><span class="line">14.5 抽取后验 142</span><br><span class="line"></span><br><span class="line">14.6 讨论 144</span><br><span class="line"></span><br><span class="line">14.7 练习 144</span><br><span class="line"></span><br><span class="line">第15章 处理多维问题 145</span><br><span class="line"></span><br><span class="line">15.1 脐部细菌 145</span><br><span class="line"></span><br><span class="line">15.2 狮子，老虎和熊 145</span><br><span class="line"></span><br><span class="line">15.3 分层版本 148</span><br><span class="line"></span><br><span class="line">15.4 随机抽样 149</span><br><span class="line"></span><br><span class="line">15.5 优化 150</span><br><span class="line"></span><br><span class="line">15.6 堆叠的层次结构 151</span><br><span class="line"></span><br><span class="line">15.7 另一个问题 153</span><br><span class="line"></span><br><span class="line">15.8 还有工作要做 154</span><br><span class="line"></span><br><span class="line">15.9 肚脐数据 156</span><br><span class="line"></span><br><span class="line">15.10 预测分布 158</span><br><span class="line"></span><br><span class="line">15.11 联合后验 161</span><br><span class="line"></span><br><span class="line">15.12 覆盖 162</span><br><span class="line"></span><br><span class="line">15.13 讨论 164</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>编程之美完整版 PDF</title>
    <url>/posts/90aee7b8/</url>
    <content><![CDATA[<h4 id="《编程之美完整版》"><a href="#《编程之美完整版》" class="headerlink" title="《编程之美完整版》"></a>《编程之美完整版》</h4><h6 id="链接-https-pan-baidu-com-s-1V43LWw7OIqMRNv7QP7nm-A-提取码-rbc4"><a href="#链接-https-pan-baidu-com-s-1V43LWw7OIqMRNv7QP7nm-A-提取码-rbc4" class="headerlink" title="链接: https://pan.baidu.com/s/1V43LWw7OIqMRNv7QP7nm_A 提取码: rbc4"></a>链接: <a href="https://pan.baidu.com/s/1V43LWw7OIqMRNv7QP7nm_A">https://pan.baidu.com/s/1V43LWw7OIqMRNv7QP7nm_A</a> 提取码: rbc4</h6><p>　《编程之美：微软技术面试心得》收集了约60道算法和程序设计题目。作者试图从书中各种有趣的问题出发，引导读者发现问题，分析问题，解决问题，寻找更优的解法。《编程之美：微软技术面试心得》的内容分为下面几个部分：<br><a id="more"></a></p>
<p>　　游戏之乐：从游戏和其他有趣问题出发，化繁为简，分析总结。</p>
<p>　　数字之魅：编程的过程实际上就是和数字及字符打交道的过程。这一部分收集了一些好玩的对数字进行处理的题目。</p>
<p>　　结构之法：汇集了常见的对字符串、链表、队列，以及树等进行操作的题目。</p>
<p>　　数学之趣：列举了一些不需要写具体程序的数学问题，锻炼读者的抽象思维能力。书中绝大部分题目都提供了详细的解说。 每道题目后面还有一至两道扩展问题，供读者进一步钻研。书中还回答了读者关于IT业面试，招聘，职业发展的疑问。这《编程之美：微软技术面试心得》的很多题目会出现在IT 行业的各种笔试、面试中，但这《编程之美：微软技术面试心得》更深层的意义在于引导读者思考，和读者共享思考之乐，编程之美。</p>
<p><img src="/images/377a98ddc01bcc1e2ca3314d544b50151.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">面试杂谈XVII</span><br><span class="line"></span><br><span class="line">第1章游戏之乐——游戏中碰到的题目1</span><br><span class="line"></span><br><span class="line">1.1让CPU占用率曲线听你指挥4</span><br><span class="line"></span><br><span class="line">1.2中国象棋将帅问题13</span><br><span class="line"></span><br><span class="line">1.3一摞烙饼的排序19</span><br><span class="line"></span><br><span class="line">1.4买书问题29</span><br><span class="line"></span><br><span class="line">1.5快速找出故障机器38</span><br><span class="line"></span><br><span class="line">1.6饮料供货43</span><br><span class="line"></span><br><span class="line">1.7光影切割问题48</span><br><span class="line"></span><br><span class="line">1.8小飞的电梯调度算法53</span><br><span class="line"></span><br><span class="line">1.9高效率地安排见面会57</span><br><span class="line"></span><br><span class="line">1.10双线程高效下载62</span><br><span class="line"></span><br><span class="line">1.11NIM（1）一排石头的游戏67</span><br><span class="line"></span><br><span class="line">1.12NIM（2）“拈”游戏分析70</span><br><span class="line"></span><br><span class="line">1.13NIM（3）两堆石头的游戏75</span><br><span class="line"></span><br><span class="line">1.14连连看游戏设计88</span><br><span class="line"></span><br><span class="line">1.15构造数独93</span><br><span class="line"></span><br><span class="line">1.1624点游戏100</span><br><span class="line"></span><br><span class="line">1.17俄罗斯方块游戏108</span><br><span class="line"></span><br><span class="line">1.18挖雷游戏115</span><br><span class="line"></span><br><span class="line">第2章数字之魅——数字中的技巧117</span><br><span class="line"></span><br><span class="line">2.1求二进制数中1的个数119</span><br><span class="line"></span><br><span class="line">2.2不要被阶乘吓倒125</span><br><span class="line"></span><br><span class="line">2.3寻找发帖“水王”129</span><br><span class="line"></span><br><span class="line">2.41的数目132</span><br><span class="line"></span><br><span class="line">2.5寻找最大的K个数139</span><br><span class="line"></span><br><span class="line">2.6精确表达浮点数147</span><br><span class="line"></span><br><span class="line">2.7最大公约数问题150</span><br><span class="line"></span><br><span class="line">2.8找符合条件的整数155</span><br><span class="line"></span><br><span class="line">2.9斐波那契（Fibonacci）数列160</span><br><span class="line"></span><br><span class="line">2.10寻找数组中的最大值和最小值165</span><br><span class="line"></span><br><span class="line">2.11寻找最近点对170</span><br><span class="line"></span><br><span class="line">2.12快速寻找满足条件的两个数176</span><br><span class="line"></span><br><span class="line">2.13子数组的最大乘积180</span><br><span class="line"></span><br><span class="line">2.14求数组的子数组之和的最大值183</span><br><span class="line"></span><br><span class="line">2.15子数组之和的最大值（二维）189</span><br><span class="line"></span><br><span class="line">2.16求数组中最长递增子序列194</span><br><span class="line"></span><br><span class="line">2.17数组循环移位199</span><br><span class="line"></span><br><span class="line">2.18数组分割202</span><br><span class="line"></span><br><span class="line">2.19区间重合判断205</span><br><span class="line"></span><br><span class="line">2.20程序理解和时间分析209</span><br><span class="line"></span><br><span class="line">2.21只考加法的面试题211</span><br><span class="line"></span><br><span class="line">第3章结构之法——字符串及链表的探索213</span><br><span class="line"></span><br><span class="line">3.1字符串移位包含的问题215</span><br><span class="line"></span><br><span class="line">3.2电话号码对应英语单词218</span><br><span class="line"></span><br><span class="line">3.3计算字符串的相似度223</span><br><span class="line"></span><br><span class="line">3.4从无头单链表中删除节点226</span><br><span class="line"></span><br><span class="line">3.5最短摘要的生成229</span><br><span class="line"></span><br><span class="line">3.6编程判断两个链表是否相交233</span><br><span class="line"></span><br><span class="line">3.7队列中取最大值操作问题236</span><br><span class="line"></span><br><span class="line">3.8求二叉树中节点的最大距离241</span><br><span class="line"></span><br><span class="line">3.9重建二叉树246</span><br><span class="line"></span><br><span class="line">3.10分层遍历二叉树252</span><br><span class="line"></span><br><span class="line">3.11程序改错258</span><br><span class="line"></span><br><span class="line">第4章数学之趣——数学游戏的乐趣263</span><br><span class="line"></span><br><span class="line">4.1金刚坐飞机问题265</span><br><span class="line"></span><br><span class="line">4.2瓷砖覆盖地板269</span><br><span class="line"></span><br><span class="line">4.3买票找零272</span><br><span class="line"></span><br><span class="line">4.4点是否在三角形内276</span><br><span class="line"></span><br><span class="line">4.5磁带文件存放优化281</span><br><span class="line"></span><br><span class="line">4.6桶中取黑白球284</span><br><span class="line"></span><br><span class="line">4.7蚂蚁爬杆288</span><br><span class="line"></span><br><span class="line">4.8三角形测试用例292</span><br><span class="line"></span><br><span class="line">4.9数独知多少296</span><br><span class="line"></span><br><span class="line">4.10数字哑谜和回文303</span><br><span class="line"></span><br><span class="line">4.11挖雷游戏的概率310</span><br><span class="line"></span><br><span class="line">索引311</span><br><span class="line"></span><br><span class="line">创作后记315</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>编程珠玑第二版 PDF</title>
    <url>/posts/e7a9d72e/</url>
    <content><![CDATA[<h4 id="《编程珠玑第二版》"><a href="#《编程珠玑第二版》" class="headerlink" title="《编程珠玑第二版》"></a>《编程珠玑第二版》</h4><h6 id="链接-https-pan-baidu-com-s-14QpDmfr8sIlFZVtmXW1Wjw-提取码-t8vj"><a href="#链接-https-pan-baidu-com-s-14QpDmfr8sIlFZVtmXW1Wjw-提取码-t8vj" class="headerlink" title="链接: https://pan.baidu.com/s/14QpDmfr8sIlFZVtmXW1Wjw 提取码: t8vj"></a>链接: <a href="https://pan.baidu.com/s/14QpDmfr8sIlFZVtmXW1Wjw">https://pan.baidu.com/s/14QpDmfr8sIlFZVtmXW1Wjw</a> 提取码: t8vj</h6><p>本书是计算机科学方面的经典名著。书的内容围绕程序设计人员面对的一系列实际问题展开。作者Jon Bentley 以其独有的洞察力和创造力，引导读者理解这些问题并学会解决方法，而这些正是程序员实际编程生涯中至关重要的。本书的特色是通过一些精心设计的有趣而又颇具指导意义的程序，对实用程序设计技巧及基本设计原则进行了透彻而睿智的描述，为复杂的编程问题提供了清晰而完备的解决思路。本书对各个层次的程序员都具有很高的阅读价值。<br><a id="more"></a></p>
<p><img src="/images/0a93fbae2849939e93f1e8c479a2db0a1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 一部分　基础</span><br><span class="line"></span><br><span class="line">第 1章　开　篇 3</span><br><span class="line"></span><br><span class="line">1．1　一次友好的对话 3</span><br><span class="line"></span><br><span class="line">1．2　准确的问题描述 4</span><br><span class="line"></span><br><span class="line">1．3　程序设计 4</span><br><span class="line"></span><br><span class="line">1．4　实现概要 6</span><br><span class="line"></span><br><span class="line">1．5　原理 7</span><br><span class="line"></span><br><span class="line">1．6　习题 8</span><br><span class="line"></span><br><span class="line">1．7　深入阅读 9</span><br><span class="line"></span><br><span class="line">第 2章　啊哈！算法 11</span><br><span class="line"></span><br><span class="line">2．1　三个问题 11</span><br><span class="line"></span><br><span class="line">2．2　无处不在的二分搜索 12</span><br><span class="line"></span><br><span class="line">2．3　基本操作的威力 14</span><br><span class="line"></span><br><span class="line">2．4　排序 16</span><br><span class="line"></span><br><span class="line">2．5　原理 17</span><br><span class="line"></span><br><span class="line">2．6　习题 18</span><br><span class="line"></span><br><span class="line">2．7　深入阅读 20</span><br><span class="line"></span><br><span class="line">2．8　变位词程序的实现（边栏） 20</span><br><span class="line"></span><br><span class="line">第3章　数据决定程序结构 23</span><br><span class="line"></span><br><span class="line">3．1　一个调查程序 23</span><br><span class="line"></span><br><span class="line">3．2　格式信函编程 26</span><br><span class="line"></span><br><span class="line">3．3　一组示例 28</span><br><span class="line"></span><br><span class="line">3．4　结构化数据 29</span><br><span class="line"></span><br><span class="line">3．5　用于特殊数据的强大工具 30</span><br><span class="line"></span><br><span class="line">3．6　原理 32</span><br><span class="line"></span><br><span class="line">3．7　习题 33</span><br><span class="line"></span><br><span class="line">3．8　深入阅读 34</span><br><span class="line"></span><br><span class="line">第4章　编写正确的程序 37</span><br><span class="line"></span><br><span class="line">4．1　二分搜索的挑战 37</span><br><span class="line"></span><br><span class="line">4．2　编写程序 38</span><br><span class="line"></span><br><span class="line">4．3　理解程序 40</span><br><span class="line"></span><br><span class="line">4．4　原理 43</span><br><span class="line"></span><br><span class="line">4．5　程序验证的角色 44</span><br><span class="line"></span><br><span class="line">4．6　习题 45</span><br><span class="line"></span><br><span class="line">4．7　深入阅读 48</span><br><span class="line"></span><br><span class="line">第5章　编程小事 49</span><br><span class="line"></span><br><span class="line">5．1　从伪代码到C程序 49</span><br><span class="line"></span><br><span class="line">5．2　测试工具 51</span><br><span class="line"></span><br><span class="line">5．3　断言的艺术 53</span><br><span class="line"></span><br><span class="line">5．4　自动测试 55</span><br><span class="line"></span><br><span class="line">5．5　计时 56</span><br><span class="line"></span><br><span class="line">5．6　完整的程序 58</span><br><span class="line"></span><br><span class="line">5．7　原理 59</span><br><span class="line"></span><br><span class="line">5．8　习题 59</span><br><span class="line"></span><br><span class="line">5．9　深入阅读 61</span><br><span class="line"></span><br><span class="line">5．10　调试（边栏） 61</span><br><span class="line"></span><br><span class="line">第二部分　性能</span><br><span class="line"></span><br><span class="line">第6章　程序性能分析 65</span><br><span class="line"></span><br><span class="line">6．1　实例研究 65</span><br><span class="line"></span><br><span class="line">6．2　设计层面 67</span><br><span class="line"></span><br><span class="line">6．3　原理 69</span><br><span class="line"></span><br><span class="line">6．4　习题 69</span><br><span class="line"></span><br><span class="line">6．5　深入阅读 70</span><br><span class="line"></span><br><span class="line">第7章　粗略估算 71</span><br><span class="line"></span><br><span class="line">7．1　基本技巧 72</span><br><span class="line"></span><br><span class="line">7．2　性能估计 74</span><br><span class="line"></span><br><span class="line">7．3　安全系数 76</span><br><span class="line"></span><br><span class="line">7．4　Little定律 78</span><br><span class="line"></span><br><span class="line">7．5　原理 79</span><br><span class="line"></span><br><span class="line">7．6　习题 79</span><br><span class="line"></span><br><span class="line">7．7　深入阅读 80</span><br><span class="line"></span><br><span class="line">7．8　日常生活中的速算（边栏） 81</span><br><span class="line"></span><br><span class="line">第8章　算法设计技术 83</span><br><span class="line"></span><br><span class="line">8．1　问题及简单算法 83</span><br><span class="line"></span><br><span class="line">8．2　两个平方算法 84</span><br><span class="line"></span><br><span class="line">8．3　分治算法 86</span><br><span class="line"></span><br><span class="line">8．4　扫描算法 87</span><br><span class="line"></span><br><span class="line">8．5　实际运行时间 88</span><br><span class="line"></span><br><span class="line">8．6　原理 90</span><br><span class="line"></span><br><span class="line">8．7　习题 91</span><br><span class="line"></span><br><span class="line">8．8　深入阅读 92</span><br><span class="line"></span><br><span class="line">第9章　代码调优 95</span><br><span class="line"></span><br><span class="line">9．1　典型的故事 95</span><br><span class="line"></span><br><span class="line">9．2　急救方案集锦 96</span><br><span class="line"></span><br><span class="line">9．3　大手术——二分搜索 101</span><br><span class="line"></span><br><span class="line">9．4　原理 105</span><br><span class="line"></span><br><span class="line">9．5　习题 106</span><br><span class="line"></span><br><span class="line">9．6　深入阅读 108</span><br><span class="line"></span><br><span class="line">第 10章　节省空间 109</span><br><span class="line"></span><br><span class="line">10．1　关键在于简单 109</span><br><span class="line"></span><br><span class="line">10．2　示例问题 110</span><br><span class="line"></span><br><span class="line">10．3　数据空间技术 113</span><br><span class="line"></span><br><span class="line">10．4　代码空间技术 116</span><br><span class="line"></span><br><span class="line">10．5　原理 118</span><br><span class="line"></span><br><span class="line">10．6　习题 119</span><br><span class="line"></span><br><span class="line">10．7　深入阅读 120</span><br><span class="line"></span><br><span class="line">10．8　巨大的节省（边栏） 121</span><br><span class="line"></span><br><span class="line">第三部分　应用</span><br><span class="line"></span><br><span class="line">第 11章　排　序 125</span><br><span class="line"></span><br><span class="line">11．1　插入排序 125</span><br><span class="line"></span><br><span class="line">11．2　一种简单的快速排序 127</span><br><span class="line"></span><br><span class="line">11．3　更好的几种快速排序 130</span><br><span class="line"></span><br><span class="line">11．4　原理 133</span><br><span class="line"></span><br><span class="line">11．5　习题 133</span><br><span class="line"></span><br><span class="line">11．6　深入阅读 135</span><br><span class="line"></span><br><span class="line">第 12章　取样问题 137</span><br><span class="line"></span><br><span class="line">12．1　问题 137</span><br><span class="line"></span><br><span class="line">12．2　一种解决方案 138</span><br><span class="line"></span><br><span class="line">12．3　设计空间 139</span><br><span class="line"></span><br><span class="line">12．4　原理 142</span><br><span class="line"></span><br><span class="line">12．5　习题 143</span><br><span class="line"></span><br><span class="line">12．6　深入阅读 144</span><br><span class="line"></span><br><span class="line">第 13章　搜　索 145</span><br><span class="line"></span><br><span class="line">13．1　接口 145</span><br><span class="line"></span><br><span class="line">13．2　线性结构 147</span><br><span class="line"></span><br><span class="line">13．3　二分搜索树 151</span><br><span class="line"></span><br><span class="line">13．4　用于整数的结构 153</span><br><span class="line"></span><br><span class="line">13．5　原理 155</span><br><span class="line"></span><br><span class="line">13．6　习题 156</span><br><span class="line"></span><br><span class="line">13．7　深入阅读 157</span><br><span class="line"></span><br><span class="line">13．8　一个实际搜索问题（边栏） 157</span><br><span class="line"></span><br><span class="line">第 14章　堆 161</span><br><span class="line"></span><br><span class="line">14．1　数据结构 161</span><br><span class="line"></span><br><span class="line">14．2　两个关键函数 163</span><br><span class="line"></span><br><span class="line">14．3　优先级队列 166</span><br><span class="line"></span><br><span class="line">14．4　一种排序算法 169</span><br><span class="line"></span><br><span class="line">14．5　原理 171</span><br><span class="line"></span><br><span class="line">14．6　习题 172</span><br><span class="line"></span><br><span class="line">14．7　深入阅读 174</span><br><span class="line"></span><br><span class="line">第 15章　字符串 175</span><br><span class="line"></span><br><span class="line">15．1　单词 175</span><br><span class="line"></span><br><span class="line">15．2　短语 179</span><br><span class="line"></span><br><span class="line">15．3　生成文本 182</span><br><span class="line"></span><br><span class="line">15．4　原理 187</span><br><span class="line"></span><br><span class="line">15．5　习题 188</span><br><span class="line"></span><br><span class="line">15．6　深入阅读 189</span><br><span class="line"></span><br><span class="line">第 1版跋 191</span><br><span class="line"></span><br><span class="line">第 2版跋 195</span><br><span class="line"></span><br><span class="line">附录A　算法分类 197</span><br><span class="line"></span><br><span class="line">附录B　估算测试 203</span><br><span class="line"></span><br><span class="line">附录C　时空开销模型 205</span><br><span class="line"></span><br><span class="line">附录D　代码调优法则 211</span><br><span class="line"></span><br><span class="line">附录E　用于搜索的C++类 217</span><br><span class="line"></span><br><span class="line">部分习题提示 223</span><br><span class="line"></span><br><span class="line">部分习题答案 229</span><br><span class="line"></span><br><span class="line">索引 259</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>常用的数据分析方法 PDF</title>
    <url>/posts/7ea08694/</url>
    <content><![CDATA[<h4 id="《常用的数据分析方法》"><a href="#《常用的数据分析方法》" class="headerlink" title="《常用的数据分析方法》"></a>《常用的数据分析方法》</h4><h6 id="链接-https-pan-baidu-com-s-1Rj9XvBp-PdazA9I-zDYp2g-提取码-u8p6"><a href="#链接-https-pan-baidu-com-s-1Rj9XvBp-PdazA9I-zDYp2g-提取码-u8p6" class="headerlink" title="链接: https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g 提取码: u8p6"></a>链接: <a href="https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g">https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g</a> 提取码: u8p6</h6><p><img src="/images/1a04f73484e794707ba5ae20a9abf2831.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">章 以智取胜：营销策划概论</span><br><span class="line"></span><br><span class="line"> 节 营销本质：提供和创造顾客价值</span><br><span class="line"></span><br><span class="line"> 一、顾客：企业市场制胜的法宝</span><br><span class="line"></span><br><span class="line"> 二、营销：企业活动的中心</span><br><span class="line"></span><br><span class="line"> 三、价值营销攻略</span><br><span class="line"></span><br><span class="line"> 第二节 商战无情策划是金</span><br><span class="line"></span><br><span class="line"> 一、策划的重要性：智力就是财富</span><br><span class="line"></span><br><span class="line"> 二、营销策划的演变情况</span><br><span class="line"></span><br><span class="line"> 三、营销策划的核心内涵</span><br><span class="line"></span><br><span class="line"> 第三节 营销策划的作用</span><br><span class="line"></span><br><span class="line"> 一、营销策划与计划、决策、点子的区别</span><br><span class="line"></span><br><span class="line"> 二、营销策划的作用</span><br><span class="line"></span><br><span class="line">第二章 心智历程：营销策划的程序</span><br><span class="line"></span><br><span class="line"> 节 营销策划的步骤</span><br><span class="line"></span><br><span class="line"> 一、市场分析</span><br><span class="line"></span><br><span class="line"> 二、营销目标与问题设定</span><br><span class="line"></span><br><span class="line"> 三、营销战略与策略构想</span><br><span class="line"></span><br><span class="line"> 四、营销预算</span><br><span class="line"></span><br><span class="line"> 五、方案沟通与调整</span><br><span class="line"></span><br><span class="line"> 六、制订策划方案的执行计划</span><br><span class="line"></span><br><span class="line"> 第二节 营销策划书的写作</span><br><span class="line"></span><br><span class="line"> 一、营销策划书的基本结构与内容</span><br><span class="line"></span><br><span class="line"> 二、营销策划书的框架模式</span><br><span class="line"></span><br><span class="line"> 第三节 企业年度营销计划书的编制</span><br><span class="line"></span><br><span class="line"> 一、年度营销计划书编制的重要性</span><br><span class="line"></span><br><span class="line"> 二、企业年度营销计划书范本</span><br><span class="line"></span><br><span class="line">第三章 理在事先：营销策划的基本原理</span><br><span class="line"></span><br><span class="line"> 节 营销策划的主要理论依据</span><br><span class="line"></span><br><span class="line"> 一、4P营销理论</span><br><span class="line"></span><br><span class="line"> 二、4C理论</span><br><span class="line"></span><br><span class="line"> 三、二八法则</span><br><span class="line"></span><br><span class="line"> 四、CIS理论</span><br><span class="line"></span><br><span class="line"> 五、USP理论</span><br><span class="line"></span><br><span class="line"> 六、SWOT分析法</span><br><span class="line"></span><br><span class="line"> 七、5W2H法</span><br><span class="line"></span><br><span class="line"> 八、马斯洛需求层次论</span><br><span class="line"></span><br><span class="line"> 九、迈克尔·波特竞争理论</span><br><span class="line"></span><br><span class="line"> 十、蓝海战略</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>程序员面试宝典 PDF</title>
    <url>/posts/9a7b602/</url>
    <content><![CDATA[<h4 id="《程序员面试宝典》"><a href="#《程序员面试宝典》" class="headerlink" title="《程序员面试宝典》"></a>《程序员面试宝典》</h4><h6 id="链接-https-pan-baidu-com-s-1vWpQopsZviWI8c7WuDEeOQ-提取码-aske"><a href="#链接-https-pan-baidu-com-s-1vWpQopsZviWI8c7WuDEeOQ-提取码-aske" class="headerlink" title="链接: https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ 提取码: aske"></a>链接: <a href="https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ">https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ</a> 提取码: aske</h6><p>　　《程序员面试宝典（第5版）》是《程序员面试宝典》的第5 版，在保留第4 版的数据结构、面向对象、程序设计等主干的基础上，修正了前4 版近40 处错误，解释清楚一些读者提出的问题，并使用各大IT 公司及相关企业全新面试题（2014-2015）替换和补充原内容，以反映自第4 版以来两年多的时间内所发生的变化。<br><a id="more"></a></p>
<p>　　《程序员面试宝典（第5版）》取材于各大公司面试真题（笔试、口试、电话面试、英语面试，以及逻辑测试和智商测试），详细分析了应聘程序员（含网络、测试等）职位的常见考点。《程序员面试宝典（第5版）》不仅对传统的C 系语言考点做了详尽解释，还根据外企出题全新特点，新增加了对友元、Static、图形/音频、树、栈、ERP 等问题的深入讲解。最后《程序员面试宝典（第5版）》着力讲述了如何进行英语面试和电话面试，并对求职中签约、毁约的注意事项及群体面试进行了解析。</p>
<p>　　《程序员面试宝典（第5版）》的面试题除了有详细解析和答案外，对相关知识点还有扩展说明。真正做到了由点成线，举一反三，对读者从求职就业到提升计算机专业知识都有显著帮助。</p>
<p>　　《程序员面试宝典（第5版）》适合计算机相关专业应届毕业生阅读，也适合作为正在应聘软件行业的相关就业人员和计算机爱好者的参考书。</p>
<p><img src="/images/e5ee82b80a10bb141cb3be34ee788a8e1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1部分求职过程</span><br><span class="line"></span><br><span class="line">第1章应聘求职 2</span><br><span class="line"></span><br><span class="line">1.1 渠道 2</span><br><span class="line"></span><br><span class="line">1.2 流程 3</span><br><span class="line"></span><br><span class="line">第2章简历书写 4</span><br><span class="line"></span><br><span class="line">2.1 简历注意事项 4</span><br><span class="line"></span><br><span class="line">2.2 简历模板 8</span><br><span class="line"></span><br><span class="line">第3章求职五步曲 11</span><br><span class="line"></span><br><span class="line">3.1 笔试 11</span><br><span class="line"></span><br><span class="line">3.2 电话面试 14</span><br><span class="line"></span><br><span class="line">3.3 面试 15</span><br><span class="line"></span><br><span class="line">3.4 签约 16</span><br><span class="line"></span><br><span class="line">3.5 违约 20</span><br><span class="line"></span><br><span class="line">第4章职业生涯发展规划 22</span><br><span class="line"></span><br><span class="line">4.1 缺乏工作经验的应届毕业生 22</span><br><span class="line"></span><br><span class="line">4.2 更换工作的程序员们 24</span><br><span class="line"></span><br><span class="line">4.3 快乐地工作 25</span><br><span class="line"></span><br><span class="line">第2部分 C&#x2F;C++程序设计</span><br><span class="line"></span><br><span class="line">第5章程序设计基本概念 30</span><br><span class="line"></span><br><span class="line">5.1 赋值语句 30</span><br><span class="line"></span><br><span class="line">5.2 i++ 32</span><br><span class="line"></span><br><span class="line">5.3 编程风格 34</span><br><span class="line"></span><br><span class="line">5.4 类型转换 35</span><br><span class="line"></span><br><span class="line">5.5 运算符问题 40</span><br><span class="line"></span><br><span class="line">5.6 a、b交换与比较 42</span><br><span class="line"></span><br><span class="line">5.7 C和C++的关系 43</span><br><span class="line"></span><br><span class="line">5.8 程序设计的其他问题 44</span><br><span class="line"></span><br><span class="line">第6章预处理、const与sizeof 46</span><br><span class="line"></span><br><span class="line">6.1 宏定义 46</span><br><span class="line"></span><br><span class="line">6.2 const 47</span><br><span class="line"></span><br><span class="line">6.3 sizeof 52</span><br><span class="line"></span><br><span class="line">6.4 内联函数和宏定义 63</span><br><span class="line"></span><br><span class="line">第7章指针与引用 65</span><br><span class="line"></span><br><span class="line">7.1 指针基本问题 65</span><br><span class="line"></span><br><span class="line">7.2 传递动态内存 67</span><br><span class="line"></span><br><span class="line">7.3 函数指针 76</span><br><span class="line"></span><br><span class="line">7.4 指针数组和数组指针 78</span><br><span class="line"></span><br><span class="line">7.5 迷途指针 82</span><br><span class="line"></span><br><span class="line">7.6 指针和句柄 84</span><br><span class="line"></span><br><span class="line">7.7 this指针 86</span><br><span class="line"></span><br><span class="line">第8章循环、递归与概率 89</span><br><span class="line"></span><br><span class="line">8.1 递归基础知识 89</span><br><span class="line"></span><br><span class="line">8.2 典型递归问题 92</span><br><span class="line"></span><br><span class="line">8.3 循环与数组问题 94</span><br><span class="line"></span><br><span class="line">8.4 螺旋队列问题 98</span><br><span class="line"></span><br><span class="line">8.5 概率 101</span><br><span class="line"></span><br><span class="line">第9章STL模板与容器 103</span><br><span class="line"></span><br><span class="line">9.1 向量容器 104</span><br><span class="line"></span><br><span class="line">9.2 泛型编程 108</span><br><span class="line"></span><br><span class="line">9.3 模板 109</span><br><span class="line"></span><br><span class="line">第10章面向对象 113</span><br><span class="line"></span><br><span class="line">10.1 面向对象的基本概念 113</span><br><span class="line"></span><br><span class="line">10.2 类和结构 116</span><br><span class="line"></span><br><span class="line">10.3 成员变量 117</span><br><span class="line"></span><br><span class="line">10.4 构造函数和析构函数 120</span><br><span class="line"></span><br><span class="line">10.5 拷贝构造函数和赋值函数 122</span><br><span class="line"></span><br><span class="line">10.6 多态的概念 128</span><br><span class="line"></span><br><span class="line">10.7 友元 131</span><br><span class="line"></span><br><span class="line">10.8 异常 132</span><br><span class="line"></span><br><span class="line">第11章继承与接口 136</span><br><span class="line"></span><br><span class="line">11.1 覆盖 137</span><br><span class="line"></span><br><span class="line">11.2 私有继承 139</span><br><span class="line"></span><br><span class="line">11.3 虚函数继承和虚继承 144</span><br><span class="line"></span><br><span class="line">11.4 多重继承 147</span><br><span class="line"></span><br><span class="line">11.5 检测并修改不适合的继承 151</span><br><span class="line"></span><br><span class="line">11.6 纯虚函数 153</span><br><span class="line"></span><br><span class="line">11.7 运算符重载与RTTI 155</span><br><span class="line"></span><br><span class="line">第12章位运算与嵌入式编程 164</span><br><span class="line"></span><br><span class="line">12.1 位制转换 164</span><br><span class="line"></span><br><span class="line">12.2 嵌入式编程 174</span><br><span class="line"></span><br><span class="line">12.3 static 181</span><br><span class="line"></span><br><span class="line">第3部分数据结构和设计模式</span><br><span class="line"></span><br><span class="line">第13章数据结构基础 184</span><br><span class="line"></span><br><span class="line">13.1 单链表 184</span><br><span class="line"></span><br><span class="line">13.2 双链表 189</span><br><span class="line"></span><br><span class="line">13.3 循环链表 191</span><br><span class="line"></span><br><span class="line">13.4 队列 192</span><br><span class="line"></span><br><span class="line">13.5 栈 193</span><br><span class="line"></span><br><span class="line">13.6 堆 196</span><br><span class="line"></span><br><span class="line">13.7 树、图、哈希表 207</span><br><span class="line"></span><br><span class="line">13.8 排序 215</span><br><span class="line"></span><br><span class="line">13.9 时间复杂度 228</span><br><span class="line"></span><br><span class="line">第14章字符串 237</span><br><span class="line"></span><br><span class="line">14.1 整数字符串转化 237</span><br><span class="line"></span><br><span class="line">14.2 字符数组和strcpy 238</span><br><span class="line"></span><br><span class="line">14.3 数组初始化和数组越界 242</span><br><span class="line"></span><br><span class="line">14.4 数字流和数组声明 245</span><br><span class="line"></span><br><span class="line">14.5 字符串其他问题 245</span><br><span class="line"></span><br><span class="line">14.6 字符子串问题 250</span><br><span class="line"></span><br><span class="line">第15章设计模式与软件测试 253</span><br><span class="line"></span><br><span class="line">15.1 设计模式 254</span><br><span class="line"></span><br><span class="line">15.2 软件测试基础 261</span><br><span class="line"></span><br><span class="line">15.3 黑盒测试 262</span><br><span class="line"></span><br><span class="line">15.4 白盒测试 268</span><br><span class="line"></span><br><span class="line">第4部分操作系统、数据库和网络</span><br><span class="line"></span><br><span class="line">第16章操作系统 276</span><br><span class="line"></span><br><span class="line">16.1 进程 276</span><br><span class="line"></span><br><span class="line">16.2 线程 281</span><br><span class="line"></span><br><span class="line">16.3 内存管理 286</span><br><span class="line"></span><br><span class="line">第17章数据库与SQL语言 290</span><br><span class="line"></span><br><span class="line">17.1 数据库理论 290</span><br><span class="line"></span><br><span class="line">17.2 SQL语言 294</span><br><span class="line"></span><br><span class="line">17.3 SQL语言客观题 296</span><br><span class="line"></span><br><span class="line">17.4SQL语言主观题 299</span><br><span class="line"></span><br><span class="line">第18章计算机网络及分布式系统 305</span><br><span class="line"></span><br><span class="line">18.1 网络结构 305</span><br><span class="line"></span><br><span class="line">18.2 网络协议问题 307</span><br><span class="line"></span><br><span class="line">18.3 网络安全问题 309</span><br><span class="line"></span><br><span class="line">18.4 网络其他问题 311</span><br><span class="line"></span><br><span class="line">第5部分综合面试题</span><br><span class="line"></span><br><span class="line">第19章英语面试 316</span><br><span class="line"></span><br><span class="line">19.1 面试过程和技巧 316</span><br><span class="line"></span><br><span class="line">19.2 关于工作（About Job） 318</span><br><span class="line"></span><br><span class="line">19.3 关于个人（About Person） 321</span><br><span class="line"></span><br><span class="line">19.4 关于未来（About Future） 323</span><br><span class="line"></span><br><span class="line">第20章电话面试 325</span><br><span class="line"></span><br><span class="line">20.1 电话面试之前的准备工作 325</span><br><span class="line"></span><br><span class="line">20.2 电话面试交流常见的问题 326</span><br><span class="line"></span><br><span class="line">第21章数字类题目分析 334</span><br><span class="line"></span><br><span class="line">21.1 数字规律类题目 334</span><br><span class="line"></span><br><span class="line">21.2 数字填充类题目 337</span><br><span class="line"></span><br><span class="line">21.3 数字运算类题目 338</span><br><span class="line"></span><br><span class="line">21.4 应用数学类题目 339</span><br><span class="line"></span><br><span class="line">第22章图表类题目分析 346</span><br><span class="line"></span><br><span class="line">22.1 图形变换类题目 346</span><br><span class="line"></span><br><span class="line">22.2 表格分析类题目 352</span><br><span class="line"></span><br><span class="line">第23章智力类题目分析 354</span><br><span class="line"></span><br><span class="line">23.1 推理类题目 354</span><br><span class="line"></span><br><span class="line">23.2 博弈论 356</span><br><span class="line"></span><br><span class="line">23.3 概率 358</span><br><span class="line"></span><br><span class="line">第24章无领导小组讨论题目分析 361</span><br><span class="line"></span><br><span class="line">24.1 题目介绍 361</span><br><span class="line"></span><br><span class="line">24.2 无领导小组讨论特点 361</span><br><span class="line"></span><br><span class="line">24.3 无领导小组阶段分析 363</span><br><span class="line"></span><br><span class="line">24.4 无领导小组角色分析 367</span><br><span class="line"></span><br><span class="line">24.5 无领导小组评分标准分析 371</span><br><span class="line"></span><br><span class="line">24.6 群面实录 373</span><br><span class="line"></span><br><span class="line">附录A面试经历总结 377</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>大话数据结构 PDF</title>
    <url>/posts/97c323a1/</url>
    <content><![CDATA[<h4 id="《大话数据结构》"><a href="#《大话数据结构》" class="headerlink" title="《大话数据结构》"></a>《大话数据结构》</h4><h6 id="链接-https-pan-baidu-com-s-1S9lZPNA-qydJKHn21ydThA-提取码-8i5k"><a href="#链接-https-pan-baidu-com-s-1S9lZPNA-qydJKHn21ydThA-提取码-8i5k" class="headerlink" title="链接: https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA 提取码: 8i5k"></a>链接: <a href="https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA">https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA</a> 提取码: 8i5k</h6><p>《大话数据结构》为超级畅销书《大话设计模式》作者程杰潜心三年推出的扛鼎之作！以一个计算机教师教学为场景，讲解数据结构和相关算法的知识。通篇以一种趣味方式来叙述，大量引用了各种各样的生活知识来类比，并充分运用图形语言来体现抽象内容，对数据结构所涉及到的一些经典算法做到逐行分析、多算法比较。与市场上的同类数据结构图书相比，本书内容趣味易读，算法讲解细致深刻，是一本非常适合自学的读物。<br><a id="more"></a></p>
<p><img src="/images/a26aab90d85a7528bbb26e194aa2c09c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 数据结构绪论</span><br><span class="line"></span><br><span class="line">1.1 开场白</span><br><span class="line"></span><br><span class="line">1.2 你数据结构怎么学的？</span><br><span class="line"></span><br><span class="line">1.3 数据结构起源</span><br><span class="line"></span><br><span class="line">1.4 基本概念和术语</span><br><span class="line"></span><br><span class="line">1.4.1 数据</span><br><span class="line"></span><br><span class="line">1.4.2 数据元素</span><br><span class="line"></span><br><span class="line">1.4.3 数据项</span><br><span class="line"></span><br><span class="line">1.4.4 数据对象</span><br><span class="line"></span><br><span class="line">1.4.5 数据结构</span><br><span class="line"></span><br><span class="line">1.5 逻辑结构与物理结构</span><br><span class="line"></span><br><span class="line">1.5.1 逻辑结构</span><br><span class="line"></span><br><span class="line">1.5.2 物理结构</span><br><span class="line"></span><br><span class="line">1.6 抽象数据类型</span><br><span class="line"></span><br><span class="line">1.6.1 数据类型</span><br><span class="line"></span><br><span class="line">1.6.2 抽象数据类型</span><br><span class="line"></span><br><span class="line">1.7 总结回顾</span><br><span class="line"></span><br><span class="line">1.8 结尾语</span><br><span class="line"></span><br><span class="line">第2章 算法</span><br><span class="line"></span><br><span class="line">2.1 开场白</span><br><span class="line"></span><br><span class="line">2.2 数据结构与算法关系</span><br><span class="line"></span><br><span class="line">2.3 两种算法的比较</span><br><span class="line"></span><br><span class="line">2.4 算法定义</span><br><span class="line"></span><br><span class="line">2.5 算法的特性</span><br><span class="line"></span><br><span class="line">2.5.1 输入输出</span><br><span class="line"></span><br><span class="line">2.5.2 有穷性</span><br><span class="line"></span><br><span class="line">2.5.3 确定性</span><br><span class="line"></span><br><span class="line">2.5.4 可行性</span><br><span class="line"></span><br><span class="line">2.6 算法设计的要求</span><br><span class="line"></span><br><span class="line">2.6.1 正确性</span><br><span class="line"></span><br><span class="line">2.6.2 可读性</span><br><span class="line"></span><br><span class="line">2.6.3 健壮性</span><br><span class="line"></span><br><span class="line">2.6.4 时间效率高和存储量低</span><br><span class="line"></span><br><span class="line">2.7 算法效率的度量方法</span><br><span class="line"></span><br><span class="line">2.7.1 事后统计方法</span><br><span class="line"></span><br><span class="line">2.7.2 事前分析估算方法</span><br><span class="line"></span><br><span class="line">2.8 函数的渐近增长</span><br><span class="line"></span><br><span class="line">2.9 算法时间复杂度</span><br><span class="line"></span><br><span class="line">2.9.1 算法时间复杂度定义</span><br><span class="line"></span><br><span class="line">2.9.2 推导大O阶方法</span><br><span class="line"></span><br><span class="line">2.9.3 常数阶</span><br><span class="line"></span><br><span class="line">2.9.4 线性阶</span><br><span class="line"></span><br><span class="line">2.9.5 对数阶</span><br><span class="line"></span><br><span class="line">2.9.6 平方阶</span><br><span class="line"></span><br><span class="line">2.10 常见的时间复杂度</span><br><span class="line"></span><br><span class="line">2.11 最坏情况与平均情况</span><br><span class="line"></span><br><span class="line">2.12 算法空间复杂度</span><br><span class="line"></span><br><span class="line">2.13 总结回顾</span><br><span class="line"></span><br><span class="line">2.14 结尾语</span><br><span class="line"></span><br><span class="line">第3章 线性表</span><br><span class="line"></span><br><span class="line">3.1 开场白</span><br><span class="line"></span><br><span class="line">3.2 线性表的定义</span><br><span class="line"></span><br><span class="line">3.3 线性表的抽象数据类型</span><br><span class="line"></span><br><span class="line">3.4 线性表的顺序存储结构</span><br><span class="line"></span><br><span class="line">3.4.1 顺序存储定义</span><br><span class="line"></span><br><span class="line">3.4.2 顺序存储方式</span><br><span class="line"></span><br><span class="line">3.4.3 数据长度与线性表长度区别</span><br><span class="line"></span><br><span class="line">3.4.4 地址计算方法</span><br><span class="line"></span><br><span class="line">3.5 顺序存储结构的插入与删除</span><br><span class="line"></span><br><span class="line">3.5.1 获得元素操作</span><br><span class="line"></span><br><span class="line">3.5.2 插入操作</span><br><span class="line"></span><br><span class="line">3.5.3 删除操作</span><br><span class="line"></span><br><span class="line">3.5.4 线性表顺序存储结构的优缺点</span><br><span class="line"></span><br><span class="line">3.6 线性表的链式存储结构</span><br><span class="line"></span><br><span class="line">3.6.1 顺序存储结构不足的解决办法</span><br><span class="line"></span><br><span class="line">3.6.2 线性表链式存储结构定义</span><br><span class="line"></span><br><span class="line">3.6.3 头指针与头结点的异同</span><br><span class="line"></span><br><span class="line">3.6.4 线性表链式存储结构代码描述</span><br><span class="line"></span><br><span class="line">3.7 单链表的读取</span><br><span class="line"></span><br><span class="line">3.8 单链表的插入与删除</span><br><span class="line"></span><br><span class="line">3.8.1 单链表的插入</span><br><span class="line"></span><br><span class="line">3.8.2 单链表的删除</span><br><span class="line"></span><br><span class="line">3.9 单链表的整表创建</span><br><span class="line"></span><br><span class="line">3.10 单链表的整表删除</span><br><span class="line"></span><br><span class="line">3.11 单链表结构与顺序存储结构优缺点</span><br><span class="line"></span><br><span class="line">3.12 静态链表</span><br><span class="line"></span><br><span class="line">3.12.1 静态链表的插入操作</span><br><span class="line"></span><br><span class="line">3.12.2 静态链表的删除操作</span><br><span class="line"></span><br><span class="line">3.12.3 静态链表优缺点</span><br><span class="line"></span><br><span class="line">3.13 循环链表</span><br><span class="line"></span><br><span class="line">3.14 双向链表</span><br><span class="line"></span><br><span class="line">3.15 总结回顾</span><br><span class="line"></span><br><span class="line">3.16 结尾语</span><br><span class="line"></span><br><span class="line">第4章 栈与队列</span><br><span class="line"></span><br><span class="line">4.1 开场白</span><br><span class="line"></span><br><span class="line">4.2 栈的定义</span><br><span class="line"></span><br><span class="line">4.2.1 栈的定义</span><br><span class="line"></span><br><span class="line">4.2.2 进栈出栈变化形式</span><br><span class="line"></span><br><span class="line">4.3 栈的抽象数据类型</span><br><span class="line"></span><br><span class="line">4.4 栈的顺序存储结构及实现</span><br><span class="line"></span><br><span class="line">4.4.1 栈的顺序存储结构</span><br><span class="line"></span><br><span class="line">4.4.2 栈的顺序存储结构进栈操作</span><br><span class="line"></span><br><span class="line">4.4.3 栈的顺序存储结构出栈操作</span><br><span class="line"></span><br><span class="line">4.5 两栈共享空间</span><br><span class="line"></span><br><span class="line">4.6 栈的链式存储结构及实现</span><br><span class="line"></span><br><span class="line">4.6.1 栈的链式存储结构</span><br><span class="line"></span><br><span class="line">4.6.2 栈的链式存储结构进栈操作</span><br><span class="line"></span><br><span class="line">4.6.3 栈的链式存储结构出栈操作</span><br><span class="line"></span><br><span class="line">4.7 栈的作用</span><br><span class="line"></span><br><span class="line">4.8 栈的应用--递归</span><br><span class="line"></span><br><span class="line">4.8.1 斐波那契数列实现</span><br><span class="line"></span><br><span class="line">4.8.2 递归定义</span><br><span class="line"></span><br><span class="line">4.9 栈的应用--四则运算表达式求值</span><br><span class="line"></span><br><span class="line">4.9.1 后缀（逆波兰）表示法定义</span><br><span class="line"></span><br><span class="line">4.9.2 后缀表达式计算结果</span><br><span class="line"></span><br><span class="line">4.9.3 中缀表达式转后缀表达式</span><br><span class="line"></span><br><span class="line">4.10 队列的定义</span><br><span class="line"></span><br><span class="line">4.11 队列的抽象数据类型</span><br><span class="line"></span><br><span class="line">4.12 循环队列</span><br><span class="line"></span><br><span class="line">4.12.1 队列顺序存储的不足</span><br><span class="line"></span><br><span class="line">4.12.2 循环队列定义</span><br><span class="line"></span><br><span class="line">4.13 队列的链式存储结构及实现</span><br><span class="line"></span><br><span class="line">4.13.1 队列链式存储结构入队操作</span><br><span class="line"></span><br><span class="line">4.13.2 队列链式存储结构出队操作</span><br><span class="line"></span><br><span class="line">4.14 总结回顾</span><br><span class="line"></span><br><span class="line">4.15 结尾语</span><br><span class="line"></span><br><span class="line">第5章 串</span><br><span class="line"></span><br><span class="line">5.1开场白</span><br><span class="line"></span><br><span class="line">05.2 串的定义</span><br><span class="line"></span><br><span class="line">5.3 串的比较</span><br><span class="line"></span><br><span class="line">5.4 串的抽象数据类型</span><br><span class="line"></span><br><span class="line">5.5 串的存储结构</span><br><span class="line"></span><br><span class="line">5.5.1 串的顺序存储结构</span><br><span class="line"></span><br><span class="line">5.5.2 串的链式存储结构</span><br><span class="line"></span><br><span class="line">5.6 朴素的模式匹配算法</span><br><span class="line"></span><br><span class="line">5.7 KMP模式匹配算法</span><br><span class="line"></span><br><span class="line">5.7.1 KMP模式匹配算法原理</span><br><span class="line"></span><br><span class="line">5.7.2 next数组值推导</span><br><span class="line"></span><br><span class="line">5.7.3 KMP模式匹配算法实现</span><br><span class="line"></span><br><span class="line">5.7.4 KMP模式匹配算法改进</span><br><span class="line"></span><br><span class="line">5.7.5 nextval数组值推导</span><br><span class="line"></span><br><span class="line">5.8 总结回顾</span><br><span class="line"></span><br><span class="line">5.9 结尾语</span><br><span class="line"></span><br><span class="line">第6章 树</span><br><span class="line"></span><br><span class="line">6.1 开场白</span><br><span class="line"></span><br><span class="line">6.2 树的定义</span><br><span class="line"></span><br><span class="line">6.2.1 结点分类</span><br><span class="line"></span><br><span class="line">6.2.2 结点间关系</span><br><span class="line"></span><br><span class="line">6.2.3 树的其他相关概念</span><br><span class="line"></span><br><span class="line">6.3 树的抽象数据类型</span><br><span class="line"></span><br><span class="line">6.4 树的存储结构</span><br><span class="line"></span><br><span class="line">6.4.1 双亲表示法</span><br><span class="line"></span><br><span class="line">6.4.2 孩子表示法</span><br><span class="line"></span><br><span class="line">6.4.3 孩子兄弟表示法</span><br><span class="line"></span><br><span class="line">6.5 二叉树的定义</span><br><span class="line"></span><br><span class="line">6.5.1 二叉树特点</span><br><span class="line"></span><br><span class="line">6.5.2 特殊二叉树</span><br><span class="line"></span><br><span class="line">6.6 二叉树的性质</span><br><span class="line"></span><br><span class="line">6.6.1 二叉树性质1</span><br><span class="line"></span><br><span class="line">6.6.2 二叉树性质2</span><br><span class="line"></span><br><span class="line">6.6.3 二叉树性质3</span><br><span class="line"></span><br><span class="line">6.6.4 二叉树性质4</span><br><span class="line"></span><br><span class="line">6.6.5 二叉树性质5</span><br><span class="line"></span><br><span class="line">6.7 二叉树的存储结构</span><br><span class="line"></span><br><span class="line">6.7.1 二叉树顺序存储结构</span><br><span class="line"></span><br><span class="line">6.7.2 二叉链表</span><br><span class="line"></span><br><span class="line">6.8 遍历二叉树</span><br><span class="line"></span><br><span class="line">6.8.1 二叉树遍历原理</span><br><span class="line"></span><br><span class="line">6.8.2 二叉树遍历方法</span><br><span class="line"></span><br><span class="line">6.8.3 前序遍历算法</span><br><span class="line"></span><br><span class="line">6.8.4 中序遍历算法</span><br><span class="line"></span><br><span class="line">6.8.5 后序遍历算法</span><br><span class="line"></span><br><span class="line">6.8.6 推导遍历结果</span><br><span class="line"></span><br><span class="line">6.9 二叉树的建立</span><br><span class="line"></span><br><span class="line">6.10 线索二叉树</span><br><span class="line"></span><br><span class="line">6.10.1 线索二叉树原理</span><br><span class="line"></span><br><span class="line">6.10.2 线索二叉树结构实现</span><br><span class="line"></span><br><span class="line">6.11 树、森林与二叉树的转换</span><br><span class="line"></span><br><span class="line">6.11.1 树转换为二叉树</span><br><span class="line"></span><br><span class="line">6.11.2 森林转换为二叉树</span><br><span class="line"></span><br><span class="line">6.11.3 二叉树转换为树</span><br><span class="line"></span><br><span class="line">6.11.4 二叉树转换为森林</span><br><span class="line"></span><br><span class="line">6.11.5 树与森林的遍历</span><br><span class="line"></span><br><span class="line">6.12 赫夫曼树及其应用</span><br><span class="line"></span><br><span class="line">6.12.1 赫夫曼树</span><br><span class="line"></span><br><span class="line">6.12.2 赫夫曼树定义与原理</span><br><span class="line"></span><br><span class="line">6.12.3 赫夫曼编码</span><br><span class="line"></span><br><span class="line">6.13 总结回顾</span><br><span class="line"></span><br><span class="line">6.14 结尾语</span><br><span class="line"></span><br><span class="line">第7章 图</span><br><span class="line"></span><br><span class="line">7.1 开场白</span><br><span class="line"></span><br><span class="line">7.2 图的定义</span><br><span class="line"></span><br><span class="line">7.2.1 各种图定义</span><br><span class="line"></span><br><span class="line">7.2.2 图的顶点与边间关系</span><br><span class="line"></span><br><span class="line">7.2.3 连通图相关术语</span><br><span class="line"></span><br><span class="line">7.2.4 图的定义与术语总结</span><br><span class="line"></span><br><span class="line">7.3 图的抽象数据类型</span><br><span class="line"></span><br><span class="line">7.4 图的存储结构</span><br><span class="line"></span><br><span class="line">7.4.1 邻接矩阵</span><br><span class="line"></span><br><span class="line">7.4.2 邻接表</span><br><span class="line"></span><br><span class="line">7.4.3 十字链表</span><br><span class="line"></span><br><span class="line">7.4.4 邻接多重表</span><br><span class="line"></span><br><span class="line">7.4.5 边集数组</span><br><span class="line"></span><br><span class="line">7.5 图的遍历</span><br><span class="line"></span><br><span class="line">7.5.1 深度优先遍历</span><br><span class="line"></span><br><span class="line">7.5.2 广度优先遍历</span><br><span class="line"></span><br><span class="line">7.6 最小生成树</span><br><span class="line"></span><br><span class="line">7.6.1 普里姆（Prim）算法</span><br><span class="line"></span><br><span class="line">7.6.2 克鲁斯卡尔（Kruskal）算法</span><br><span class="line"></span><br><span class="line">7.7 最短路径</span><br><span class="line"></span><br><span class="line">7.7.1 迪杰斯特拉（Dijkstra）算法</span><br><span class="line"></span><br><span class="line">7.7.2 弗洛伊德（Floyd）算法</span><br><span class="line"></span><br><span class="line">7.8 拓扑排序</span><br><span class="line"></span><br><span class="line">7.8.1 拓扑排序介绍</span><br><span class="line"></span><br><span class="line">7.8.2 拓扑排序算法</span><br><span class="line"></span><br><span class="line">7.9 关键路径</span><br><span class="line"></span><br><span class="line">7.9.1 关键路径算法原理</span><br><span class="line"></span><br><span class="line">7.9.2 关键路径算法</span><br><span class="line"></span><br><span class="line">7.10 总结回顾</span><br><span class="line"></span><br><span class="line">7.11 结尾语</span><br><span class="line"></span><br><span class="line">第8章 查找</span><br><span class="line"></span><br><span class="line">8.1 开场白</span><br><span class="line"></span><br><span class="line">8.2 查找概论</span><br><span class="line"></span><br><span class="line">8.3 顺序表查找</span><br><span class="line"></span><br><span class="line">8.3.1 顺序表查找算法</span><br><span class="line"></span><br><span class="line">8.3.2 顺序表查找优化</span><br><span class="line"></span><br><span class="line">8.4 有序表查找</span><br><span class="line"></span><br><span class="line">8.4.1 折半查找</span><br><span class="line"></span><br><span class="line">8.4.2 插值查找</span><br><span class="line"></span><br><span class="line">8.4.3 斐波那契查找</span><br><span class="line"></span><br><span class="line">8.5 线性索引查找</span><br><span class="line"></span><br><span class="line">8.5.1 稠密索引</span><br><span class="line"></span><br><span class="line">8.5.2 分块索引</span><br><span class="line"></span><br><span class="line">8.5.3 倒排索引</span><br><span class="line"></span><br><span class="line">8.6 二叉排序树</span><br><span class="line"></span><br><span class="line">8.6.1 二叉排序树查找操作</span><br><span class="line"></span><br><span class="line">8.6.2 二叉排序树插入操作</span><br><span class="line"></span><br><span class="line">8.6.3 二叉排序树删除操作</span><br><span class="line"></span><br><span class="line">8.6.4 二叉排序树总结</span><br><span class="line"></span><br><span class="line">8.7 平衡二叉树（AVL树）</span><br><span class="line"></span><br><span class="line">8.7.1 平衡二叉树实现原理</span><br><span class="line"></span><br><span class="line">8.7.2 平衡二叉树实现算法</span><br><span class="line"></span><br><span class="line">8.8 多路查找树（B树）</span><br><span class="line"></span><br><span class="line">8.8.1 2-3树</span><br><span class="line"></span><br><span class="line">8.8.2 2-3-4树</span><br><span class="line"></span><br><span class="line">8.8.3 B树</span><br><span class="line"></span><br><span class="line">8.8.4 B+树</span><br><span class="line"></span><br><span class="line">8.9 散列表查找（哈希表）概述</span><br><span class="line"></span><br><span class="line">8.9.1 散列表查找定义</span><br><span class="line"></span><br><span class="line">8.9.2 散列表查找步骤</span><br><span class="line"></span><br><span class="line">8.10 散列函数的构造方法</span><br><span class="line"></span><br><span class="line">8.10.1 直接定址法</span><br><span class="line"></span><br><span class="line">8.10.2 数字分析法</span><br><span class="line"></span><br><span class="line">8.10.3 平方取中法</span><br><span class="line"></span><br><span class="line">8.10.4 折叠法</span><br><span class="line"></span><br><span class="line">8.10.5 除留余数法</span><br><span class="line"></span><br><span class="line">8.10.6 随机数法</span><br><span class="line"></span><br><span class="line">8.11 处理散列冲突的方法</span><br><span class="line"></span><br><span class="line">8.11.1 开放定址法</span><br><span class="line"></span><br><span class="line">8.11.2 再散列函数法</span><br><span class="line"></span><br><span class="line">8.11.3 链地址法</span><br><span class="line"></span><br><span class="line">8.11.4 公共溢出区法</span><br><span class="line"></span><br><span class="line">8.12 散列表查找实现</span><br><span class="line"></span><br><span class="line">8.12.1 散列表查找算法实现</span><br><span class="line"></span><br><span class="line">8.12.2 散列表查找性能分析</span><br><span class="line"></span><br><span class="line">8.13 总结回顾</span><br><span class="line"></span><br><span class="line">8.14 结尾语</span><br><span class="line"></span><br><span class="line">第9章 排序</span><br><span class="line"></span><br><span class="line">9.1 开场白</span><br><span class="line"></span><br><span class="line">9.2 排序的基本概念与分类</span><br><span class="line"></span><br><span class="line">9.2.1 排序的稳定性</span><br><span class="line"></span><br><span class="line">9.2.2 内排序与外排序</span><br><span class="line"></span><br><span class="line">9.2.3 排序用到的结构与函数</span><br><span class="line"></span><br><span class="line">9.3 冒泡排序</span><br><span class="line"></span><br><span class="line">9.3.1 最简单排序实现</span><br><span class="line"></span><br><span class="line">9.3.2 冒泡排序算法</span><br><span class="line"></span><br><span class="line">9.3.3 冒泡排序优化</span><br><span class="line"></span><br><span class="line">9.3.4 冒泡排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.4 简单选择排序</span><br><span class="line"></span><br><span class="line">9.4.1 简单选择排序算法</span><br><span class="line"></span><br><span class="line">9.4.2 简单选择排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.5 直接插入排序</span><br><span class="line"></span><br><span class="line">9.5.1 直接插入排序算法</span><br><span class="line"></span><br><span class="line">9.5.2 直接插入排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.6 希尔排序</span><br><span class="line"></span><br><span class="line">9.6.1 希尔排序原理</span><br><span class="line"></span><br><span class="line">9.6.2 希尔排序算法</span><br><span class="line"></span><br><span class="line">9.6.3 希尔排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.7 堆 排 序</span><br><span class="line"></span><br><span class="line">9.7.1 堆排序算法</span><br><span class="line"></span><br><span class="line">9.7.2 堆排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.8 归并排序</span><br><span class="line"></span><br><span class="line">9.8.1 归并排序算法</span><br><span class="line"></span><br><span class="line">9.8.2 归并排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.8.3 非递归实现归并排序</span><br><span class="line"></span><br><span class="line">9.9 快速排序</span><br><span class="line"></span><br><span class="line">9.9.1 快速排序算法</span><br><span class="line"></span><br><span class="line">9.9.2 快速排序复杂度分析</span><br><span class="line"></span><br><span class="line">9.9.3 快速排序优化</span><br><span class="line"></span><br><span class="line">1．优化选取枢轴</span><br><span class="line"></span><br><span class="line">2．优化不必要的交换</span><br><span class="line"></span><br><span class="line">3．优化小数组时的排序方案</span><br><span class="line"></span><br><span class="line">4．优化递归操作</span><br><span class="line"></span><br><span class="line">9.10 总结回顾</span><br><span class="line"></span><br><span class="line">9.11 结尾语</span><br><span class="line"></span><br><span class="line">附录 参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>代码大全2中文版 PDF</title>
    <url>/posts/e0c41337/</url>
    <content><![CDATA[<h4 id="《代码大全2中文版》"><a href="#《代码大全2中文版》" class="headerlink" title="《代码大全2中文版》"></a>《代码大全2中文版》</h4><h6 id="链接-https-pan-baidu-com-s-1plrFrYNY4hyVr6wPV7ppKg-提取码-ag4d"><a href="#链接-https-pan-baidu-com-s-1plrFrYNY4hyVr6wPV7ppKg-提取码-ag4d" class="headerlink" title="链接: https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg 提取码: ag4d"></a>链接: <a href="https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg">https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg</a> 提取码: ag4d</h6><p>第2版的《代码大全》是著名IT畅销书作者史蒂夫·迈克康奈尔11年前的经典著作的全新演绎：第2版不是第一版的简单修订增补，而是完全进行了重写；增加了很多与时俱进的内容。这也是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。<br><a id="more"></a></p>
<p><img src="/images/4aac3c997ed2445de9429497637befa91.jpg" width="50%" height="50%"></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>代码整洁之道 PDF</title>
    <url>/posts/79cd428d/</url>
    <content><![CDATA[<h4 id="《代码整洁之道》"><a href="#《代码整洁之道》" class="headerlink" title="《代码整洁之道》"></a>《代码整洁之道》</h4><h6 id="链接-https-pan-baidu-com-s-1b6e2CgZ0GMvvwJykjMJ2RQ-提取码-5d2v"><a href="#链接-https-pan-baidu-com-s-1b6e2CgZ0GMvvwJykjMJ2RQ-提取码-5d2v" class="headerlink" title="链接: https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ 提取码: 5d2v"></a>链接: <a href="https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ">https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ</a> 提取码: 5d2v</h6><p>“阅读这本书有两种原因：第一，你是个程序员；第二，你想成为更好的程序员。很好，IT行业需要更好的程序员！”——罗伯特·C. 马丁（Robert C. Martin）<br><a id="more"></a></p>
<p>尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，写得不好的代码每年都要耗费难以计数的时间和资源。但是，这种情况并非无法避免。</p>
<p>著名软件专家罗伯特·C. 马丁（Robert C. Martin） 在本书中为你呈现了革命性的视野。他携同Object Mentor公司的同事，从他们有关整洁代码的*佳敏捷实践中提炼出软件技艺的价值观，以飨读者，让你成为更优秀的程序员——只要你着手研读本书。</p>
<p>阅读本书需要你做些什么呢？你将阅读代码——大量代码。本书会促使你思考何谓正确的代码，何谓错误的代码。更重要的是，本书将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。</p>
<p>书中的具体内容包括：</p>
<p>·好代码和糟糕的代码之间的区别；</p>
<p>·如何编写好代码，如何将糟糕的代码转化为好代码；</p>
<p>·如何创建好名称、好函数、好对象和好类；</p>
<p>·如何格式化代码以实现其可读性的*大化；</p>
<p>·如何在不妨碍代码逻辑的前提下充分实现错误处理；</p>
<p>·如何进行单元测试和测试驱动开发。</p>
<p><img src="/images/936c32dcbec42432ef0a45e2f9a1ae8d1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目　录</span><br><span class="line"></span><br><span class="line">第1章　整洁代码　1</span><br><span class="line"></span><br><span class="line">1．1 要有代码　2</span><br><span class="line"></span><br><span class="line">1．2 糟糕的代码　2</span><br><span class="line"></span><br><span class="line">1．3 混乱的代价　3</span><br><span class="line"></span><br><span class="line">1．3．1 华丽新设计　4</span><br><span class="line"></span><br><span class="line">1．3．2 态度　4</span><br><span class="line"></span><br><span class="line">1．3．3 谜题　5</span><br><span class="line"></span><br><span class="line">1．3．4 整洁代码的艺术　5</span><br><span class="line"></span><br><span class="line">1．3．5 什么是整洁代码　6</span><br><span class="line"></span><br><span class="line">1．4 思想流派　10</span><br><span class="line"></span><br><span class="line">1．5 我们是作者　11</span><br><span class="line"></span><br><span class="line">1．6 童子军军规　12</span><br><span class="line"></span><br><span class="line">1．7 前传与原则　12</span><br><span class="line"></span><br><span class="line">1．8 小结　13</span><br><span class="line"></span><br><span class="line">1．9 文献　13</span><br><span class="line"></span><br><span class="line">第2章　有意义的命名　14</span><br><span class="line"></span><br><span class="line">2．1 介绍　14</span><br><span class="line"></span><br><span class="line">2．2 名副其实　15</span><br><span class="line"></span><br><span class="line">2．3 避免误导　16</span><br><span class="line"></span><br><span class="line">2．4 做有意义的区分　17</span><br><span class="line"></span><br><span class="line">2．5 使用读得出来的名称　18</span><br><span class="line"></span><br><span class="line">2．6 使用可搜索的名称　19</span><br><span class="line"></span><br><span class="line">2．7 避免使用编码　20</span><br><span class="line"></span><br><span class="line">2．7．1　匈牙利语标记法　20</span><br><span class="line"></span><br><span class="line">2．7．2 成员前缀　21</span><br><span class="line"></span><br><span class="line">2．7．3 接口和实现　21</span><br><span class="line"></span><br><span class="line">2．8 避免思维映射　21</span><br><span class="line"></span><br><span class="line">2．9 类名　22</span><br><span class="line"></span><br><span class="line">2．10 方法名　22</span><br><span class="line"></span><br><span class="line">2．11 别抖机灵　22</span><br><span class="line"></span><br><span class="line">2．12 每个概念对应一个词　23</span><br><span class="line"></span><br><span class="line">2．13 别用双关语　23</span><br><span class="line"></span><br><span class="line">2．14 使用解决方案领域名称　24</span><br><span class="line"></span><br><span class="line">2．15 使用源自所涉问题领域的名称　24</span><br><span class="line"></span><br><span class="line">2．16 添加有意义的语境　24</span><br><span class="line"></span><br><span class="line">2．17 不要添加没用的语境　26</span><br><span class="line"></span><br><span class="line">2．18 最后的话　27</span><br><span class="line"></span><br><span class="line">第3章　函数　28</span><br><span class="line"></span><br><span class="line">3．1 短小　31</span><br><span class="line"></span><br><span class="line">3．2 只做一件事　32</span><br><span class="line"></span><br><span class="line">3．3 每个函数一个抽象层级　33</span><br><span class="line"></span><br><span class="line">3．4 switch语句　34</span><br><span class="line"></span><br><span class="line">3．5 使用具有描述性的名称　35</span><br><span class="line"></span><br><span class="line">3．6 函数参数　36</span><br><span class="line"></span><br><span class="line">3．6．1 单参数函数的普遍形式　37</span><br><span class="line"></span><br><span class="line">3．6．2 标识参数　37</span><br><span class="line"></span><br><span class="line">3．6．3 双参数函数　38</span><br><span class="line"></span><br><span class="line">3．6．4 三参数函数　38</span><br><span class="line"></span><br><span class="line">3．6．5 参数对象　39</span><br><span class="line"></span><br><span class="line">3．6．6 参数列表　39</span><br><span class="line"></span><br><span class="line">3．6．7 动词与关键字　39</span><br><span class="line"></span><br><span class="line">3．7 无副作用　40</span><br><span class="line"></span><br><span class="line">3．8 分隔指令与询问　41</span><br><span class="line"></span><br><span class="line">3．9 使用异常替代返回错误码　42</span><br><span class="line"></span><br><span class="line">3．9．1 抽离try&#x2F;catch代码块　42</span><br><span class="line"></span><br><span class="line">3．9．2 错误处理就是一件事　43</span><br><span class="line"></span><br><span class="line">3．9．3 Error．java依赖磁铁　43</span><br><span class="line"></span><br><span class="line">3．10 别重复自己　44</span><br><span class="line"></span><br><span class="line">3．11 结构化编程　44</span><br><span class="line"></span><br><span class="line">3．12 如何写出这样的函数　45</span><br><span class="line"></span><br><span class="line">3．13 小结　45</span><br><span class="line"></span><br><span class="line">3．14 SetupTeardownIncluder程序　45</span><br><span class="line"></span><br><span class="line">3．15 文献　48</span><br><span class="line"></span><br><span class="line">第4章　注释　49</span><br><span class="line"></span><br><span class="line">4．1 注释不能美化糟糕的代码　50</span><br><span class="line"></span><br><span class="line">4．2 用代码来阐述　51</span><br><span class="line"></span><br><span class="line">4．3 好注释　51</span><br><span class="line"></span><br><span class="line">4．3．1 法律信息　51</span><br><span class="line"></span><br><span class="line">4．3．2 提供信息的注释　51</span><br><span class="line"></span><br><span class="line">4．3．3 对意图的解释　52</span><br><span class="line"></span><br><span class="line">4．3．4 阐释　53</span><br><span class="line"></span><br><span class="line">4．3．5 警示　53</span><br><span class="line"></span><br><span class="line">4．3．6 TODO注释　54</span><br><span class="line"></span><br><span class="line">4．3．7 放大　55</span><br><span class="line"></span><br><span class="line">4．3．8 公共API中的Javadoc　55</span><br><span class="line"></span><br><span class="line">4．4 坏注释　55</span><br><span class="line"></span><br><span class="line">4．4．1 喃喃自语　55</span><br><span class="line"></span><br><span class="line">4．4．2 多余的注释　56</span><br><span class="line"></span><br><span class="line">4．4．3 误导性注释　58</span><br><span class="line"></span><br><span class="line">4．4．4 循规式注释　59</span><br><span class="line"></span><br><span class="line">4．4．5 日志式注释　59</span><br><span class="line"></span><br><span class="line">4．4．6 废话注释　60</span><br><span class="line"></span><br><span class="line">4．4．7 可怕的废话　62</span><br><span class="line"></span><br><span class="line">4．4．8 能用函数或变量时就别用注释　62</span><br><span class="line"></span><br><span class="line">4．4．9 位置标记　62</span><br><span class="line"></span><br><span class="line">4．4．10 括号后面的注释　63</span><br><span class="line"></span><br><span class="line">4．4．11 归属与署名　63</span><br><span class="line"></span><br><span class="line">4．4．12 注释掉的代码　64</span><br><span class="line"></span><br><span class="line">4．4．13 HTML注释　64</span><br><span class="line"></span><br><span class="line">4．4．14 非本地信息　65</span><br><span class="line"></span><br><span class="line">4．4．15 信息过多　65</span><br><span class="line"></span><br><span class="line">4．4．16 不明显的联系　66</span><br><span class="line"></span><br><span class="line">4．4．17 函数头　66</span><br><span class="line"></span><br><span class="line">4．4．18 非公共代码中的Javadoc　66</span><br><span class="line"></span><br><span class="line">4．4．19 范例　66</span><br><span class="line"></span><br><span class="line">4．5 文献　70</span><br><span class="line"></span><br><span class="line">第5章　格式　71</span><br><span class="line"></span><br><span class="line">5．1 格式的目的　72</span><br><span class="line"></span><br><span class="line">5．2 垂直格式　72</span><br><span class="line"></span><br><span class="line">5．2．1 向报纸学习　73</span><br><span class="line"></span><br><span class="line">5．2．2 概念间垂直方向上的区隔　73</span><br><span class="line"></span><br><span class="line">5．2．3 垂直方向上的靠近　74</span><br><span class="line"></span><br><span class="line">5．2．4 垂直距离　75</span><br><span class="line"></span><br><span class="line">5．2．5 垂直顺序　79</span><br><span class="line"></span><br><span class="line">5．3 横向格式　80</span><br><span class="line"></span><br><span class="line">5．3．1 水平方向上的区隔与靠近　81</span><br><span class="line"></span><br><span class="line">5．3．2 水平对齐　82</span><br><span class="line"></span><br><span class="line">5．3．3 缩进　83</span><br><span class="line"></span><br><span class="line">5．3．4 空范围　84</span><br><span class="line"></span><br><span class="line">5．4 团队规则　85</span><br><span class="line"></span><br><span class="line">5．5 “鲍勃大叔”的格式规则　85</span><br><span class="line"></span><br><span class="line">第6章　对象和数据结构　88</span><br><span class="line"></span><br><span class="line">6．1 数据抽象　88</span><br><span class="line"></span><br><span class="line">6．2 数据、对象的反对称性　90</span><br><span class="line"></span><br><span class="line">6．3 得墨忒耳律　92</span><br><span class="line"></span><br><span class="line">6．3．1 火车失事　92</span><br><span class="line"></span><br><span class="line">6．3．2 混杂　93</span><br><span class="line"></span><br><span class="line">6．3．3 隐藏结构　93</span><br><span class="line"></span><br><span class="line">6．4 数据传送对象　94</span><br><span class="line"></span><br><span class="line">6．5 小结　95</span><br><span class="line"></span><br><span class="line">6．6 文献　96</span><br><span class="line"></span><br><span class="line">第7章　错误处理　97</span><br><span class="line"></span><br><span class="line">7．1 使用异常而非返回码　98</span><br><span class="line"></span><br><span class="line">7．2 先写try-catch-finally语句　99</span><br><span class="line"></span><br><span class="line">7．3 使用未检异常　100</span><br><span class="line"></span><br><span class="line">7．4 给出异常发生的环境说明　101</span><br><span class="line"></span><br><span class="line">7．5 依调用者需要定义异常类　101</span><br><span class="line"></span><br><span class="line">7．6 定义常规流程　103</span><br><span class="line"></span><br><span class="line">7．7 别返回null值　104</span><br><span class="line"></span><br><span class="line">7．8 别传递null值　105</span><br><span class="line"></span><br><span class="line">7．9 小结　106</span><br><span class="line"></span><br><span class="line">7．10 文献　106</span><br><span class="line"></span><br><span class="line">第8章　边界　107</span><br><span class="line"></span><br><span class="line">8．1 使用第三方代码　108</span><br><span class="line"></span><br><span class="line">8．2 浏览和学习边界　109</span><br><span class="line"></span><br><span class="line">8．3 学习log4j　110</span><br><span class="line"></span><br><span class="line">8．4 学习性测试的好处不只是免费　112</span><br><span class="line"></span><br><span class="line">8．5 使用尚不存在的代码　112</span><br><span class="line"></span><br><span class="line">8．6 整洁的边界　113</span><br><span class="line"></span><br><span class="line">8．7 文献　114</span><br><span class="line"></span><br><span class="line">第9章　单元测试　115</span><br><span class="line"></span><br><span class="line">9．1 TDD三定律　116</span><br><span class="line"></span><br><span class="line">9．2 保持测试整洁　117</span><br><span class="line"></span><br><span class="line">9．3 整洁的测试　118</span><br><span class="line"></span><br><span class="line">9．3．1 面向特定领域的测试语言　120</span><br><span class="line"></span><br><span class="line">9．3．2 双重标准　121</span><br><span class="line"></span><br><span class="line">9．4 每个测试一个断言　123</span><br><span class="line"></span><br><span class="line">9．5 F．I．R．S．T．　125</span><br><span class="line"></span><br><span class="line">9．6 小结　125</span><br><span class="line"></span><br><span class="line">9．7 文献　126</span><br><span class="line"></span><br><span class="line">第10章　类　127</span><br><span class="line"></span><br><span class="line">10．1 类的组织　128</span><br><span class="line"></span><br><span class="line">10．2 类应该短小　128</span><br><span class="line"></span><br><span class="line">10．2．1 单一权责原则　130</span><br><span class="line"></span><br><span class="line">10．2．2 内聚　131</span><br><span class="line"></span><br><span class="line">10．2．3 保持内聚性就会得到许多短小的类　132</span><br><span class="line"></span><br><span class="line">10．3 为了修改而组织　138</span><br><span class="line"></span><br><span class="line">10．4 文献　141</span><br><span class="line"></span><br><span class="line">第11章　系统　142</span><br><span class="line"></span><br><span class="line">11．1 如何建造一个城市　143</span><br><span class="line"></span><br><span class="line">11．2 将系统的构造与使用分开　143</span><br><span class="line"></span><br><span class="line">11．2．1 分解main　144</span><br><span class="line"></span><br><span class="line">11．2．2 工厂　145</span><br><span class="line"></span><br><span class="line">11．2．3 依赖注入　145</span><br><span class="line"></span><br><span class="line">11．3 扩容　146</span><br><span class="line"></span><br><span class="line">11．4 Java代理　149</span><br><span class="line"></span><br><span class="line">11．5 纯Java AOP框架　151</span><br><span class="line"></span><br><span class="line">11．6 AspectJ的方面　154</span><br><span class="line"></span><br><span class="line">11．7 测试驱动系统架构　154</span><br><span class="line"></span><br><span class="line">11．8 优化决策　155</span><br><span class="line"></span><br><span class="line">11．9 明智使用添加了可论证价值的标准　155</span><br><span class="line"></span><br><span class="line">11．10 系统需要领域特定语言　156</span><br><span class="line"></span><br><span class="line">11．11 小结　156</span><br><span class="line"></span><br><span class="line">11．12 文献　156</span><br><span class="line"></span><br><span class="line">第12章　迭进　158</span><br><span class="line"></span><br><span class="line">12．1 通过迭进设计达到整洁目的　158</span><br><span class="line"></span><br><span class="line">12．2 简单设计规则1：运行所有测试　159</span><br><span class="line"></span><br><span class="line">12．3 简单设计规则2～4：重构　159</span><br><span class="line"></span><br><span class="line">12．4 不可重复　160</span><br><span class="line"></span><br><span class="line">12．5 表达力　162</span><br><span class="line"></span><br><span class="line">12．6 尽可能少的类和方法　163</span><br><span class="line"></span><br><span class="line">12．7 小结　163</span><br><span class="line"></span><br><span class="line">12．8 文献　163</span><br><span class="line"></span><br><span class="line">第13章　并发编程　164</span><br><span class="line"></span><br><span class="line">13．1 为什么要并发　165</span><br><span class="line"></span><br><span class="line">13．2 挑战　166</span><br><span class="line"></span><br><span class="line">13．3 并发防御原则　167</span><br><span class="line"></span><br><span class="line">13．3．1 单一权责原则　167</span><br><span class="line"></span><br><span class="line">13．3．2 推论：限制数据作用域　167</span><br><span class="line"></span><br><span class="line">13．3．3 推论：使用数据副本　168</span><br><span class="line"></span><br><span class="line">13．3．4 推论：线程应尽可能地独立　168</span><br><span class="line"></span><br><span class="line">13．4 了解Java库　168</span><br><span class="line"></span><br><span class="line">13．5 了解执行模型　169</span><br><span class="line"></span><br><span class="line">13．5．1 生产者-消费者模型　170</span><br><span class="line"></span><br><span class="line">13．5．2 读者-作者模型　170</span><br><span class="line"></span><br><span class="line">13．5．3 宴席哲学家　170</span><br><span class="line"></span><br><span class="line">13．6 警惕同步方法之间的依赖　170</span><br><span class="line"></span><br><span class="line">13．7 保持同步区域微小　171</span><br><span class="line"></span><br><span class="line">13．8 很难编写正确的关闭代码　171</span><br><span class="line"></span><br><span class="line">13．9 测试线程代码　172</span><br><span class="line"></span><br><span class="line">13．9．1 将伪失败看作可能的线程问题　172</span><br><span class="line"></span><br><span class="line">13．9．2 先使非线程代码可工作　172</span><br><span class="line"></span><br><span class="line">13．9．3 编写可插拔的线程代码　173</span><br><span class="line"></span><br><span class="line">13．9．4 编写可调整的线程代码　173</span><br><span class="line"></span><br><span class="line">13．9．5 运行多于处理器数量的线程　173</span><br><span class="line"></span><br><span class="line">13．9．6 在不同平台上运行　173</span><br><span class="line"></span><br><span class="line">13．9．7　装置试错代码　174</span><br><span class="line"></span><br><span class="line">13．9．8 硬编码　174</span><br><span class="line"></span><br><span class="line">13．9．9 自动化　175</span><br><span class="line"></span><br><span class="line">13．10 小结　176</span><br><span class="line"></span><br><span class="line">13．11 文献　176</span><br><span class="line"></span><br><span class="line">第14章　逐步改进　177</span><br><span class="line"></span><br><span class="line">14．1 Args的实现　178</span><br><span class="line"></span><br><span class="line">14．2 Args：草稿　185</span><br><span class="line"></span><br><span class="line">14．2．1 所以我暂停了　196</span><br><span class="line"></span><br><span class="line">14．2．2 渐进　197</span><br><span class="line"></span><br><span class="line">14．3 字符串类型参数　199</span><br><span class="line"></span><br><span class="line">14．4 小结　236</span><br><span class="line"></span><br><span class="line">第15章　JUnit内幕　237</span><br><span class="line"></span><br><span class="line">15．1 JUnit框架　238</span><br><span class="line"></span><br><span class="line">15．2 小结　251</span><br><span class="line"></span><br><span class="line">第16章　重构SerialDate　252</span><br><span class="line"></span><br><span class="line">16．1 首先，让它能工作　253</span><br><span class="line"></span><br><span class="line">16．2 让它做对　255</span><br><span class="line"></span><br><span class="line">16．3 小结　268</span><br><span class="line"></span><br><span class="line">16．4 文献　268</span><br><span class="line"></span><br><span class="line">第17章　味道与启发　269</span><br><span class="line"></span><br><span class="line">17．1 注释　270</span><br><span class="line"></span><br><span class="line">17．2 环境　271</span><br><span class="line"></span><br><span class="line">17．3 函数　271</span><br><span class="line"></span><br><span class="line">17．4 一般性问题　272</span><br><span class="line"></span><br><span class="line">17．5 Java　288</span><br><span class="line"></span><br><span class="line">17．6 名称　291</span><br><span class="line"></span><br><span class="line">17．7 测试　295</span><br><span class="line"></span><br><span class="line">17．8 小结　296</span><br><span class="line"></span><br><span class="line">17．9 文献　296</span><br><span class="line"></span><br><span class="line">附录A　并发编程II　297</span><br><span class="line"></span><br><span class="line">附录B　org．jfree．date．SerialDate　326</span><br><span class="line"></span><br><span class="line">结束语　388</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>高性能mysql第三版 PDF</title>
    <url>/posts/eca721b/</url>
    <content><![CDATA[<h4 id="《高性能mysql第三版》"><a href="#《高性能mysql第三版》" class="headerlink" title="《高性能mysql第三版》"></a>《高性能mysql第三版》</h4><h6 id="链接-https-pan-baidu-com-s-1LNq9hI-Of7ogAidF1r3mqA-提取码-imjb"><a href="#链接-https-pan-baidu-com-s-1LNq9hI-Of7ogAidF1r3mqA-提取码-imjb" class="headerlink" title="链接: https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA 提取码: imjb"></a>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> 提取码: imjb</h6><p>　　《高性能MySQL（第3版）》是MySQL 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了MySQL5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16章和6 个附录，内容涵盖MySQL架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的MySQL和MySQL相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。<br><a id="more"></a></p>
<p>　　《高性能MySQL（第3版）》不但适合数据库管理员（DBA）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</p>
<p>　每一章均别具匠心，力求理论与实践的精确平衡，且布满无价之宝，有时甚至越过MySQL舞台，完全适用于任一数据库。其中第二章“MySQL基准测试”及第3章“服务器性能剖析”是非常必要的基础，推荐提前阅读。</p>
<p>　　纵观全书，作者推荐的工具、实战案例及经验过的诊断技术，可大大提高你的性能急救技能，以及加深对MySQL本质的理解。然而，本书值得推崇的，还是其在探讨性能的同时，将数据库结构的客观方面纳入思考，这是其他书里难以看到的。此外，增补的MySQL高可用性及云特性，也让人更加欣喜。</p>
<p>　　相信不少人会因为找不到某些书中引用的资料或工具而苦恼，但从本书中按图索骥，会发现这些东西正是作者对MySQL社区的杰出贡献，也就是说，你可以直接用这些工具！</p>
<p>　　很多年前我就是这本书的“粉丝”了，这是一本伟大的书，第三版尤其如此。这些世界*的专家不仅仅分享他们的专业知识，也花了很多时间来更新和添加新的章节，且都是高品质的内容。本书有大量关于如何获得MySQL高性能的细节信息，并且关注的是提升性能的过程，而不仅仅是描述事实结果和琐碎的细枝末节。这本书将告诉读者如何将事情做得更好，不管MySQL在不同版本中的行为有多么大的改变。</p>
<p>　　毫无疑问，本书的作者是有资格来写这么一本书的人，他们经验丰富，有合理的方法，关注效率，并且精益求精。说到经验丰富，本书的作者已经在MySQL性能领域工作多年，从MySQL还没有什么可扩展性和可测量性的时代，直到现在这些方面已经有了长足的进步。而说到合理的方法，他们简直把这件事情当成了科学，首先定义需要解决的问题，然后通过合理的猜测和精确的测量来解决问题。</p>
<p>　　我对作者在效率方面的关注尤其印象深刻。作为顾问，他们时间宝贵。客户是按照他们的时间付费的，所以都希望能更快地解决问题。所以本书作者定义了一整套的流程，开发了很多的工具，让事情变得正确和高效。在本书中，作者详细描述了这些流程，并且发布了工具的源代码。</p>
<p>　　最后，本书作者在工作上一直精益求精。比如从吞吐量到响应时间的关注，致力于了解MySQL在新硬件上的性能表现，追求新的技能如排队理论对性能的影响，等等。我相信本书预示了MySQL的光明前景。MySQL已经支持高要求的工作负载，本书作者也在努力提升MySQL社区内对性能的认识。同时，他们还直接为性能提升做出了贡献，包括XtraDB和XtraBackup。一直以来我从他们身上学到了不少东西，也希望读者多花点时间读读本书，一定会同样有所收益。</p>
<p>　　——MarkCallaghan，Facebook软件工程师</p>
<p><img src="/images/05de24d720359e66345b4fde283f37b01.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">推荐序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第1章 MySQL 架构与历史</span><br><span class="line"></span><br><span class="line">1.1 MySQL 逻辑架构</span><br><span class="line"></span><br><span class="line">1.1.1 连接管理与安全性</span><br><span class="line"></span><br><span class="line">1.1.2 优化与执行</span><br><span class="line"></span><br><span class="line">1.2 并发控制</span><br><span class="line"></span><br><span class="line">1.2.1 读写锁</span><br><span class="line"></span><br><span class="line">1.2.2 锁粒度</span><br><span class="line"></span><br><span class="line">1.3 事务</span><br><span class="line"></span><br><span class="line">1.3.1 隔离级别</span><br><span class="line"></span><br><span class="line">1.3.2 死锁</span><br><span class="line"></span><br><span class="line">1.3.3 事务日志</span><br><span class="line"></span><br><span class="line">1.3.4 MySQL 中的事务</span><br><span class="line"></span><br><span class="line">1.4 多版本并发控制</span><br><span class="line"></span><br><span class="line">1.5 MySQL 的存储引擎</span><br><span class="line"></span><br><span class="line">1.5.1 InnoDB 存储引擎</span><br><span class="line"></span><br><span class="line">1.5.2 MyISAM 存储引擎</span><br><span class="line"></span><br><span class="line">1.5.3 MySQL 内建的其他存储引擎</span><br><span class="line"></span><br><span class="line">1.5.4 第三方存储引擎</span><br><span class="line"></span><br><span class="line">1.5.5 选择合适的引擎</span><br><span class="line"></span><br><span class="line">1.5.6 转换表的引擎</span><br><span class="line"></span><br><span class="line">1.6 MySQL 时间线（Timeline）</span><br><span class="line"></span><br><span class="line">1.7 MySQL 的开发模式</span><br><span class="line"></span><br><span class="line">1.8 总结</span><br><span class="line"></span><br><span class="line">第2章 MySQL 基准测试</span><br><span class="line"></span><br><span class="line">2.1 为什么需要基准测试</span><br><span class="line"></span><br><span class="line">2.2 基准测试的策略</span><br><span class="line"></span><br><span class="line">2.2.1 测试何种指标</span><br><span class="line"></span><br><span class="line">2.3 基准测试方法</span><br><span class="line"></span><br><span class="line">2.3.1 设计和规划基准测试</span><br><span class="line"></span><br><span class="line">2.3.2 基准测试应该运行多长时间</span><br><span class="line"></span><br><span class="line">2.3.3 获取系统性能和状态</span><br><span class="line"></span><br><span class="line">2.3.4 获得准确的测试结果</span><br><span class="line"></span><br><span class="line">2.3.5 运行基准测试并分析结果</span><br><span class="line"></span><br><span class="line">2.3.6 绘图的重要性</span><br><span class="line"></span><br><span class="line">2.4 基准测试工具</span><br><span class="line"></span><br><span class="line">2.4.1 集成式测试工具</span><br><span class="line"></span><br><span class="line">2.4.2 单组件式测试工具</span><br><span class="line"></span><br><span class="line">2.5 基准测试案例</span><br><span class="line"></span><br><span class="line">2.5.1 http_load</span><br><span class="line"></span><br><span class="line">2.5.2 MySQL 基准测试套件 .</span><br><span class="line"></span><br><span class="line">2.5.3 sysbench</span><br><span class="line"></span><br><span class="line">2.5.4 数据库测试套件中的dbt2 TPC-C 测试</span><br><span class="line"></span><br><span class="line">2.5.5 Percona 的TPCC-MySQL 测试工具</span><br><span class="line"></span><br><span class="line">2.6 总结</span><br><span class="line"></span><br><span class="line">第3章 服务器性能剖析</span><br><span class="line"></span><br><span class="line">3.1 性能优化简介</span><br><span class="line"></span><br><span class="line">3.1.1 通过性能剖析进行优化</span><br><span class="line"></span><br><span class="line">3.1.2 理解性能剖析</span><br><span class="line"></span><br><span class="line">3.2 对应用程序进行性能剖析</span><br><span class="line"></span><br><span class="line">3.2.1 测量PHP 应用程序</span><br><span class="line"></span><br><span class="line">3.3 剖析MySQL 查询</span><br><span class="line"></span><br><span class="line">3.3.1 剖析服务器负载</span><br><span class="line"></span><br><span class="line">3.3.2 剖析单条查询</span><br><span class="line"></span><br><span class="line">3.3.3 使用性能剖析</span><br><span class="line"></span><br><span class="line">3.4 诊断间歇性问题</span><br><span class="line"></span><br><span class="line">3.4.1 单条查询问题还是服务器问题</span><br><span class="line"></span><br><span class="line">3.4.2 捕获诊断数据</span><br><span class="line"></span><br><span class="line">3.4.3 一个诊断案例</span><br><span class="line"></span><br><span class="line">3.5 其他剖析工具</span><br><span class="line"></span><br><span class="line">3.5.1 使用USER_STATISTICS 表</span><br><span class="line"></span><br><span class="line">3.5.2 使用strace</span><br><span class="line"></span><br><span class="line">3.6 总结</span><br><span class="line"></span><br><span class="line">第4章 Schema 与数据类型优化</span><br><span class="line"></span><br><span class="line">4.1 选择优化的数据类型</span><br><span class="line"></span><br><span class="line">4.1.1 整数类型</span><br><span class="line"></span><br><span class="line">4.1.2 实数类型</span><br><span class="line"></span><br><span class="line">4.1.3 字符串类型</span><br><span class="line"></span><br><span class="line">4.1.4 日期和时间类型</span><br><span class="line"></span><br><span class="line">4.1.5 位数据类型</span><br><span class="line"></span><br><span class="line">4.1.6 选择标识符（identifier）</span><br><span class="line"></span><br><span class="line">4.1.7 特殊类型数据</span><br><span class="line"></span><br><span class="line">4.2 MySQL schema 设计中的陷阱</span><br><span class="line"></span><br><span class="line">4.3 范式和反范式</span><br><span class="line"></span><br><span class="line">4.3.1 范式的优点和缺点</span><br><span class="line"></span><br><span class="line">4.3.2 反范式的优点和缺点 .</span><br><span class="line"></span><br><span class="line">4.3.3 混用范式化和反范式化</span><br><span class="line"></span><br><span class="line">4.4 缓存表和汇总表</span><br><span class="line"></span><br><span class="line">4.4.1 物化视图</span><br><span class="line"></span><br><span class="line">4.4.2 计数器表</span><br><span class="line"></span><br><span class="line">4.5 加快ALTER TABLE 操作的速度</span><br><span class="line"></span><br><span class="line">4.5.1 只修改.frm 文件</span><br><span class="line"></span><br><span class="line">4.5.2 快速创建MyISAM 索引</span><br><span class="line"></span><br><span class="line">4.6 总结</span><br><span class="line"></span><br><span class="line">第5章 创建高性能的索引</span><br><span class="line"></span><br><span class="line">5.1 索引基础</span><br><span class="line"></span><br><span class="line">5.1.1 索引的类型</span><br><span class="line"></span><br><span class="line">5.2 索引的优点</span><br><span class="line"></span><br><span class="line">5.3 高性能的索引策略</span><br><span class="line"></span><br><span class="line">5.3.1 独立的列</span><br><span class="line"></span><br><span class="line">5.3.2 前缀索引和索引选择性</span><br><span class="line"></span><br><span class="line">5.3.3 多列索引</span><br><span class="line"></span><br><span class="line">5.3.4 选择合适的索引列顺序</span><br><span class="line"></span><br><span class="line">5.3.5 聚簇索引</span><br><span class="line"></span><br><span class="line">5.3.6 覆盖索引</span><br><span class="line"></span><br><span class="line">5.3.7 使用索引扫描来做排序</span><br><span class="line"></span><br><span class="line">5.3.8 压缩（前缀压缩）索引</span><br><span class="line"></span><br><span class="line">5.3.9 冗余和重复索引</span><br><span class="line"></span><br><span class="line">5.3.10 未使用的索引</span><br><span class="line"></span><br><span class="line">5.3.11 索引和锁</span><br><span class="line"></span><br><span class="line">5.4 索引案例学习</span><br><span class="line"></span><br><span class="line">5.4.1 支持多种过滤条件</span><br><span class="line"></span><br><span class="line">5.4.2 避免多个范围条件</span><br><span class="line"></span><br><span class="line">5.4.3 优化排序</span><br><span class="line"></span><br><span class="line">5.5 维护索引和表</span><br><span class="line"></span><br><span class="line">5.5.1 找到并修复损坏的表 .</span><br><span class="line"></span><br><span class="line">5.5.2 更新索引统计信息</span><br><span class="line"></span><br><span class="line">5.5.3 减少索引和数据的碎片</span><br><span class="line"></span><br><span class="line">5.6 总结</span><br><span class="line"></span><br><span class="line">第6章 查询性能优化</span><br><span class="line"></span><br><span class="line">6.1 为什么查询速度会慢</span><br><span class="line"></span><br><span class="line">6.2 慢查询基础：优化数据访问</span><br><span class="line"></span><br><span class="line">6.2.1 是否向服务器请求了不需要的数据</span><br><span class="line"></span><br><span class="line">6.2.2 MySQL 是否在扫描额外的记录</span><br><span class="line"></span><br><span class="line">6.3 重构查询的方式</span><br><span class="line"></span><br><span class="line">6.3.1 一个复杂查询还是多个简单查询</span><br><span class="line"></span><br><span class="line">6.3.2 切分查询</span><br><span class="line"></span><br><span class="line">6.3.3 分解关联查询</span><br><span class="line"></span><br><span class="line">6.4 查询执行的基础</span><br><span class="line"></span><br><span class="line">6.4.1 MySQL 客户端&#x2F; 服务器通信协议</span><br><span class="line"></span><br><span class="line">6.4.2 查询缓存</span><br><span class="line"></span><br><span class="line">6.4.3 查询优化处理</span><br><span class="line"></span><br><span class="line">6.4.4 查询执行引擎</span><br><span class="line"></span><br><span class="line">6.4.5 返回结果给客户端</span><br><span class="line"></span><br><span class="line">6.5 MySQL 查询优化器的局限性</span><br><span class="line"></span><br><span class="line">6.5.1 关联子查询</span><br><span class="line"></span><br><span class="line">6.5.2 UNION 的限制</span><br><span class="line"></span><br><span class="line">6.5.3 索引合并优化</span><br><span class="line"></span><br><span class="line">6.5.4 等值传递</span><br><span class="line"></span><br><span class="line">6.5.5 并行执行</span><br><span class="line"></span><br><span class="line">6.5.6 哈希关联</span><br><span class="line"></span><br><span class="line">6.5.7 松散索引扫描</span><br><span class="line"></span><br><span class="line">6.5.8 最大值和最小值优化 .</span><br><span class="line"></span><br><span class="line">6.5.9 在同一个表上查询和更新</span><br><span class="line"></span><br><span class="line">6.6 查询优化器的提示（hint）</span><br><span class="line"></span><br><span class="line">6.7 优化特定类型的查询</span><br><span class="line"></span><br><span class="line">6.7.1 优化COUNT（） 查询</span><br><span class="line"></span><br><span class="line">6.7.2 优化关联查询</span><br><span class="line"></span><br><span class="line">6.7.3 优化子查询</span><br><span class="line"></span><br><span class="line">6.7.4 优化GROUP BY 和DISTINCT</span><br><span class="line"></span><br><span class="line">6.7.5 优化LIMIT 分页</span><br><span class="line"></span><br><span class="line">6.7.6 优化SQL_CALC_FOUND_ROWS</span><br><span class="line"></span><br><span class="line">6.7.7 优化UNION 查询</span><br><span class="line"></span><br><span class="line">6.7.8 静态查询分析</span><br><span class="line"></span><br><span class="line">6.7.9 使用用户自定义变量 .</span><br><span class="line"></span><br><span class="line">6.8 案例学习</span><br><span class="line"></span><br><span class="line">6.8.1 使用MySQL 构建一个队列表</span><br><span class="line"></span><br><span class="line">6.8.2 计算两点之间的距离 .</span><br><span class="line"></span><br><span class="line">6.8.3 使用用户自定义函数 .</span><br><span class="line"></span><br><span class="line">6.9 总结</span><br><span class="line"></span><br><span class="line">第7章 MySQL 高级特性</span><br><span class="line"></span><br><span class="line">7.1 分区表</span><br><span class="line"></span><br><span class="line">7.1.1 分区表的原理</span><br><span class="line"></span><br><span class="line">7.1.2 分区表的类型</span><br><span class="line"></span><br><span class="line">7.1.3 如何使用分区表</span><br><span class="line"></span><br><span class="line">7.1.4 什么情况下会出问题 .</span><br><span class="line"></span><br><span class="line">7.1.5 查询优化</span><br><span class="line"></span><br><span class="line">7.1.6 合并表</span><br><span class="line"></span><br><span class="line">7.2 视图</span><br><span class="line"></span><br><span class="line">7.2.1 可更新视图</span><br><span class="line"></span><br><span class="line">7.2.2 视图对性能的影响</span><br><span class="line"></span><br><span class="line">7.2.3 视图的限制</span><br><span class="line"></span><br><span class="line">7.3 外键约束</span><br><span class="line"></span><br><span class="line">7.4 在MySQL 内部存储代码</span><br><span class="line"></span><br><span class="line">7.4.1 存储过程和函数</span><br><span class="line"></span><br><span class="line">7.4.2 触发器</span><br><span class="line"></span><br><span class="line">7.4.3 事件</span><br><span class="line"></span><br><span class="line">7.4.4 在存储程序中保留注释</span><br><span class="line"></span><br><span class="line">7.5 游标</span><br><span class="line"></span><br><span class="line">7.6 绑定变量</span><br><span class="line"></span><br><span class="line">7.6.1 绑定变量的优化</span><br><span class="line"></span><br><span class="line">7.6.2 SQL 接口的绑定变量</span><br><span class="line"></span><br><span class="line">7.6.3 绑定变量的限制</span><br><span class="line"></span><br><span class="line">7.7 用户自定义函数</span><br><span class="line"></span><br><span class="line">7.8 插件</span><br><span class="line"></span><br><span class="line">7.9 字符集和校对</span><br><span class="line"></span><br><span class="line">7.9.1 MySQL 如何使用字符集</span><br><span class="line"></span><br><span class="line">7.9.2 选择字符集和校对规则</span><br><span class="line"></span><br><span class="line">7.9.3 字符集和校对规则如何影响查询</span><br><span class="line"></span><br><span class="line">7.10 全文索引</span><br><span class="line"></span><br><span class="line">7.10.1 自然语言的全文索引</span><br><span class="line"></span><br><span class="line">7.10.2 布尔全文索引</span><br><span class="line"></span><br><span class="line">7.10.3 MySQL5.1 中全文索引的变化</span><br><span class="line"></span><br><span class="line">7.10.4 全文索引的限制和替代方案</span><br><span class="line"></span><br><span class="line">7.10.5 全文索引的配置和优化</span><br><span class="line"></span><br><span class="line">7.11 分布式（XA）事务</span><br><span class="line"></span><br><span class="line">7.11.1 内部XA 事务</span><br><span class="line"></span><br><span class="line">7.11.2 外部XA 事务</span><br><span class="line"></span><br><span class="line">7.12 查询缓存</span><br><span class="line"></span><br><span class="line">7.12.1 MySQL 如何判断缓存命中</span><br><span class="line"></span><br><span class="line">7.12.2 查询缓存如何使用内存</span><br><span class="line"></span><br><span class="line">7.12.3 什么情况下查询缓存能发挥作用</span><br><span class="line"></span><br><span class="line">7.12.4 如何配置和维护查询缓存</span><br><span class="line"></span><br><span class="line">7.12.5 InnoDB 和查询缓存 .</span><br><span class="line"></span><br><span class="line">7.12.6 通用查询缓存优化</span><br><span class="line"></span><br><span class="line">7.12.7 查询缓存的替代方案</span><br><span class="line"></span><br><span class="line">7.13 总结</span><br><span class="line"></span><br><span class="line">第8章 优化服务器设置</span><br><span class="line"></span><br><span class="line">8.1 MySQL 配置的工作原理</span><br><span class="line"></span><br><span class="line">8.1.1 语法、作用域和动态性</span><br><span class="line"></span><br><span class="line">8.1.2 设置变量的副作用</span><br><span class="line"></span><br><span class="line">8.1.3 入门</span><br><span class="line"></span><br><span class="line">8.1.4 通过基准测试迭代优化</span><br><span class="line"></span><br><span class="line">8.2 什么不该做</span><br><span class="line"></span><br><span class="line">8.3 创建MySQL 配置文件</span><br><span class="line"></span><br><span class="line">8.3.1 检查MySQL 服务器状态变量</span><br><span class="line"></span><br><span class="line">8.4 配置内存使用</span><br><span class="line"></span><br><span class="line">8.4.1 MySQL 可以使用多少内存？</span><br><span class="line"></span><br><span class="line">8.4.2 每个连接需要的内存 .</span><br><span class="line"></span><br><span class="line">8.4.3 为操作系统保留内存 .</span><br><span class="line"></span><br><span class="line">8.4.4 为缓存分配内存</span><br><span class="line"></span><br><span class="line">8.4.5 InnoDB 缓冲池（Buffer Pool）</span><br><span class="line"></span><br><span class="line">8.4.6 MyISAM 键缓存（Key Caches）</span><br><span class="line"></span><br><span class="line">8.4.7 线程缓存</span><br><span class="line"></span><br><span class="line">8.4.8 表缓存（Table Cache）</span><br><span class="line"></span><br><span class="line">8.4.9 InnoDB 数据字典（Data Dictionary）</span><br><span class="line"></span><br><span class="line">8.5 配置MySQL 的I&#x2F;O 行为</span><br><span class="line"></span><br><span class="line">8.5.1 InnoDB I&#x2F;O 配置</span><br><span class="line"></span><br><span class="line">8.5.2 MyISAM 的I&#x2F;O 配置 .</span><br><span class="line"></span><br><span class="line">8.6 配置MySQL 并发 .</span><br><span class="line"></span><br><span class="line">8.6.1 InnoDB 并发配置</span><br><span class="line"></span><br><span class="line">8.6.2 MyISAM 并发配置</span><br><span class="line"></span><br><span class="line">8.7 基于工作负载的配置</span><br><span class="line"></span><br><span class="line">8.7.1 优化BLOB 和TEXT 的场景</span><br><span class="line"></span><br><span class="line">8.7.2 优化排序（Filesorts）.</span><br><span class="line"></span><br><span class="line">8.8 完成基本配置</span><br><span class="line"></span><br><span class="line">8.9 安全和稳定的设置</span><br><span class="line"></span><br><span class="line">8.10 高级InnoDB 设置</span><br><span class="line"></span><br><span class="line">8.11 总结</span><br><span class="line"></span><br><span class="line">第9章 操作系统和硬件优化</span><br><span class="line"></span><br><span class="line">9.1 什么限制了MySQL 的性能</span><br><span class="line"></span><br><span class="line">9.2 如何为MySQL 选择CPU</span><br><span class="line"></span><br><span class="line">9.2.1 哪个更好：更快的CPU 还是更多的CPU</span><br><span class="line"></span><br><span class="line">9.2.2 CPU 架构</span><br><span class="line"></span><br><span class="line">9.2.3 扩展到多个CPU 和核心</span><br><span class="line"></span><br><span class="line">9.3 平衡内存和磁盘资源</span><br><span class="line"></span><br><span class="line">9.3.1 随机I&#x2F;O 和顺序I&#x2F;O</span><br><span class="line"></span><br><span class="line">9.3.2 缓存，读和写</span><br><span class="line"></span><br><span class="line">9.3.3 工作集是什么</span><br><span class="line"></span><br><span class="line">9.3.4 找到有效的内存&#x2F; 磁盘比例</span><br><span class="line"></span><br><span class="line">9.3.5 选择硬盘</span><br><span class="line"></span><br><span class="line">9.4 固态存储</span><br><span class="line"></span><br><span class="line">9.4.1 闪存概述</span><br><span class="line"></span><br><span class="line">9.4.2 闪存技术</span><br><span class="line"></span><br><span class="line">9.4.3 闪存的基准测试</span><br><span class="line"></span><br><span class="line">9.4.4 固态硬盘驱动器（SSD）</span><br><span class="line"></span><br><span class="line">9.4.5 PCIe 存储设备</span><br><span class="line"></span><br><span class="line">9.4.6 其他类型的固态存储 .</span><br><span class="line"></span><br><span class="line">9.4.7 什么时候应该使用闪存</span><br><span class="line"></span><br><span class="line">9.4.8 使用Flashcache</span><br><span class="line"></span><br><span class="line">9.4.9 优化固态存储上的MySQL</span><br><span class="line"></span><br><span class="line">9.5 为备库选择硬件</span><br><span class="line"></span><br><span class="line">9.6 RAID 性能优化</span><br><span class="line"></span><br><span class="line">9.6.1 RAID 的故障转移、恢复和镜像</span><br><span class="line"></span><br><span class="line">9.6.2 平衡硬件RAID 和软件RAID</span><br><span class="line"></span><br><span class="line">9.6.3 RAID 配置和缓存</span><br><span class="line"></span><br><span class="line">9.7 SAN 和NAS</span><br><span class="line"></span><br><span class="line">9.7.1 SAN 基准测试</span><br><span class="line"></span><br><span class="line">9.7.2 使用基于NFS 或SMB 的SAN</span><br><span class="line"></span><br><span class="line">9.7.3 MySQL 在SAN 上的性能</span><br><span class="line"></span><br><span class="line">9.7.4 应该用SAN 吗</span><br><span class="line"></span><br><span class="line">9.8 使用多磁盘卷</span><br><span class="line"></span><br><span class="line">9.9 网络配置</span><br><span class="line"></span><br><span class="line">9.10 选择操作系统</span><br><span class="line"></span><br><span class="line">9.11 选择文件系统</span><br><span class="line"></span><br><span class="line">9.12 选择磁盘队列调度策略</span><br><span class="line"></span><br><span class="line">9.13 线程</span><br><span class="line"></span><br><span class="line">9.14 内存交换区</span><br><span class="line"></span><br><span class="line">9.15 操作系统状态</span><br><span class="line"></span><br><span class="line">9.15.1 如何阅读vmstat 的输出</span><br><span class="line"></span><br><span class="line">9.15.2 如何阅读iostat 的输出</span><br><span class="line"></span><br><span class="line">9.15.3 其他有用的工具</span><br><span class="line"></span><br><span class="line">9.15.4 CPU 密集型的机器</span><br><span class="line"></span><br><span class="line">9.15.5 I&#x2F;O 密集型的机器</span><br><span class="line"></span><br><span class="line">9.15.6 发生内存交换的机器</span><br><span class="line"></span><br><span class="line">9.15.7 空闲的机器</span><br><span class="line"></span><br><span class="line">9.16 总结</span><br><span class="line"></span><br><span class="line">第10章 复制</span><br><span class="line"></span><br><span class="line">10.1 复制概述</span><br><span class="line"></span><br><span class="line">10.1.1 复制解决的问题</span><br><span class="line"></span><br><span class="line">10.1.2 复制如何工作</span><br><span class="line"></span><br><span class="line">10.2 配置复制</span><br><span class="line"></span><br><span class="line">10.2.1 创建复制账号</span><br><span class="line"></span><br><span class="line">10.2.2 配置主库和备库</span><br><span class="line"></span><br><span class="line">10.2.3 启动复制</span><br><span class="line"></span><br><span class="line">10.2.4 从另一个服务器开始复制</span><br><span class="line"></span><br><span class="line">10.2.5 推荐的复制配置</span><br><span class="line"></span><br><span class="line">10.3 复制的原理</span><br><span class="line"></span><br><span class="line">10.3.1 基于语句的复制</span><br><span class="line"></span><br><span class="line">10.3.2 基于行的复制</span><br><span class="line"></span><br><span class="line">10.3.3 基于行或基于语句：哪种更优</span><br><span class="line"></span><br><span class="line">10.3.4 复制文件</span><br><span class="line"></span><br><span class="line">10.3.5 发送复制事件到其他备库</span><br><span class="line"></span><br><span class="line">10.3.6 复制过滤器</span><br><span class="line"></span><br><span class="line">10.4 复制拓扑</span><br><span class="line"></span><br><span class="line">10.4.1 一主库多备库</span><br><span class="line"></span><br><span class="line">10.4.2 主动- 主动模式下的主- 主复制</span><br><span class="line"></span><br><span class="line">10.4.3 主动- 被动模式下的主- 主复制</span><br><span class="line"></span><br><span class="line">10.4.4 拥有备库的主- 主结构</span><br><span class="line"></span><br><span class="line">10.4.5 环形复制</span><br><span class="line"></span><br><span class="line">10.4.6 主库、分发主库以及备库</span><br><span class="line"></span><br><span class="line">10.4.7 树或金字塔形</span><br><span class="line"></span><br><span class="line">10.4.8 定制的复制方案</span><br><span class="line"></span><br><span class="line">10.5 复制和容量规划</span><br><span class="line"></span><br><span class="line">10.5.1 为什么复制无法扩展写操作</span><br><span class="line"></span><br><span class="line">10.5.2 备库什么时候开始延迟</span><br><span class="line"></span><br><span class="line">10.5.3 规划冗余容量</span><br><span class="line"></span><br><span class="line">10.6 复制管理和维护</span><br><span class="line"></span><br><span class="line">10.6.1 监控复制</span><br><span class="line"></span><br><span class="line">10.6.2 测量备库延迟</span><br><span class="line"></span><br><span class="line">10.6.3 确定主备是否一致</span><br><span class="line"></span><br><span class="line">10.6.4 从主库重新同步备库</span><br><span class="line"></span><br><span class="line">10.6.5 改变主库</span><br><span class="line"></span><br><span class="line">10.6.6 在一个主- 主配置中交换角色</span><br><span class="line"></span><br><span class="line">10.7 复制的问题和解决方案</span><br><span class="line"></span><br><span class="line">10.7.1 数据损坏或丢失的错误</span><br><span class="line"></span><br><span class="line">10.7.2 使用非事务型表</span><br><span class="line"></span><br><span class="line">10.7.3 混合事务型和非事务型表</span><br><span class="line"></span><br><span class="line">10.7.4 不确定语句</span><br><span class="line"></span><br><span class="line">10.7.5 主库和备库使用不同的存储引擎</span><br><span class="line"></span><br><span class="line">10.7.6 备库发生数据改变</span><br><span class="line"></span><br><span class="line">10.7.7 不唯一的服务器ID .</span><br><span class="line"></span><br><span class="line">10.7.8 未定义的服务器ID .</span><br><span class="line"></span><br><span class="line">10.7.9 对未复制数据的依赖性</span><br><span class="line"></span><br><span class="line">10.7.10 丢失的临时表</span><br><span class="line"></span><br><span class="line">10.7.11 不复制所有的更新 .</span><br><span class="line"></span><br><span class="line">10.7.12 InnoDB 加锁读引起的锁争用</span><br><span class="line"></span><br><span class="line">10.7.13 在主- 主复制结构中写入两台主库</span><br><span class="line"></span><br><span class="line">10.7.14 过大的复制延迟</span><br><span class="line"></span><br><span class="line">10.7.15 来自主库的过大的包</span><br><span class="line"></span><br><span class="line">10.7.16 受限制的复制带宽 .</span><br><span class="line"></span><br><span class="line">10.7.17 磁盘空间不足</span><br><span class="line"></span><br><span class="line">10.7.18 复制的局限性</span><br><span class="line"></span><br><span class="line">10.8 复制有多快</span><br><span class="line"></span><br><span class="line">10.9 MySQL 复制的高级特性</span><br><span class="line"></span><br><span class="line">10.10 其他复制技术</span><br><span class="line"></span><br><span class="line">10.11 总结</span><br><span class="line"></span><br><span class="line">第11章 可扩展的MySQL</span><br><span class="line"></span><br><span class="line">11.1 什么是可扩展性</span><br><span class="line"></span><br><span class="line">11.1.1 正式的可扩展性定义</span><br><span class="line"></span><br><span class="line">11.2 扩展MySQL</span><br><span class="line"></span><br><span class="line">11.2.1 规划可扩展性</span><br><span class="line"></span><br><span class="line">11.2.2 为扩展赢得时间</span><br><span class="line"></span><br><span class="line">11.2.3 向上扩展</span><br><span class="line"></span><br><span class="line">11.2.4 向外扩展</span><br><span class="line"></span><br><span class="line">11.2.5 通过多实例扩展</span><br><span class="line"></span><br><span class="line">11.2.6 通过集群扩展</span><br><span class="line"></span><br><span class="line">11.2.7 向内扩展</span><br><span class="line"></span><br><span class="line">11.3 负载均衡</span><br><span class="line"></span><br><span class="line">11.3.1 直接连接</span><br><span class="line"></span><br><span class="line">11.3.2 引入中间件</span><br><span class="line"></span><br><span class="line">11.3.3 一主多备间的负载均衡</span><br><span class="line"></span><br><span class="line">11.4 总结</span><br><span class="line"></span><br><span class="line">第12章 高可用性</span><br><span class="line"></span><br><span class="line">12.1 什么是高可用性</span><br><span class="line"></span><br><span class="line">12.2 导致宕机的原因</span><br><span class="line"></span><br><span class="line">12.3 如何实现高可用性</span><br><span class="line"></span><br><span class="line">12.3.1 提升平均失效时间（MTBF）</span><br><span class="line"></span><br><span class="line">12.3.2 降低平均恢复时间（MTTR）</span><br><span class="line"></span><br><span class="line">12.4 避免单点失效</span><br><span class="line"></span><br><span class="line">12.4.1 共享存储或磁盘复制</span><br><span class="line"></span><br><span class="line">12.4.2 MySQL 同步复制</span><br><span class="line"></span><br><span class="line">12.4.3 基于复制的冗余</span><br><span class="line"></span><br><span class="line">12.5 故障转移和故障恢复</span><br><span class="line"></span><br><span class="line">12.5.1 提升备库或切换角色</span><br><span class="line"></span><br><span class="line">12.5.2 虚拟IP 地址或IP 接管</span><br><span class="line"></span><br><span class="line">12.5.3 中间件解决方案</span><br><span class="line"></span><br><span class="line">12.5.4 在应用中处理故障转移</span><br><span class="line"></span><br><span class="line">12.6 总结</span><br><span class="line"></span><br><span class="line">第13章 云端的MySQL</span><br><span class="line"></span><br><span class="line">13.1 云的优点、缺点和相关误解</span><br><span class="line"></span><br><span class="line">13.2 MySQL 在云端的经济价值</span><br><span class="line"></span><br><span class="line">13.3 云中的MySQL 的可扩展性和高可用性</span><br><span class="line"></span><br><span class="line">13.4 四种基础资源</span><br><span class="line"></span><br><span class="line">13.5 MySQL 在云主机上的性能</span><br><span class="line"></span><br><span class="line">13.5.1 在云端的MySQL 基准测试</span><br><span class="line"></span><br><span class="line">13.6 MySQL 数据库即服务（DBaaS）</span><br><span class="line"></span><br><span class="line">13.6.1 Amazon RDS</span><br><span class="line"></span><br><span class="line">13.6.2 其他DBaaS 解决方案</span><br><span class="line"></span><br><span class="line">13.7 总结</span><br><span class="line"></span><br><span class="line">第14章 应用层优化</span><br><span class="line"></span><br><span class="line">14.1 常见问题</span><br><span class="line"></span><br><span class="line">14.2 Web 服务器问题</span><br><span class="line"></span><br><span class="line">14.2.1 寻找最优并发度</span><br><span class="line"></span><br><span class="line">14.3 缓存</span><br><span class="line"></span><br><span class="line">14.3.1 应用层以下的缓存</span><br><span class="line"></span><br><span class="line">14.3.2 应用层缓存</span><br><span class="line"></span><br><span class="line">14.3.3 缓存控制策略</span><br><span class="line"></span><br><span class="line">14.3.4 缓存对象分层</span><br><span class="line"></span><br><span class="line">14.3.5 预生成内容</span><br><span class="line"></span><br><span class="line">14.3.6 作为基础组件的缓存</span><br><span class="line"></span><br><span class="line">14.3.7 使用HandlerSocket 和memcached</span><br><span class="line"></span><br><span class="line">14.4 拓展MySQL</span><br><span class="line"></span><br><span class="line">14.5 MySQL 的替代品</span><br><span class="line"></span><br><span class="line">14.6 总结</span><br><span class="line"></span><br><span class="line">第15章 备份与恢复</span><br><span class="line"></span><br><span class="line">15.1 为什么要备份</span><br><span class="line"></span><br><span class="line">15.2 定义恢复需求</span><br><span class="line"></span><br><span class="line">15.3 设计MySQL 备份方案</span><br><span class="line"></span><br><span class="line">15.3.1 在线备份还是离线备份</span><br><span class="line"></span><br><span class="line">15.3.2 逻辑备份还是物理备份</span><br><span class="line"></span><br><span class="line">15.3.3 备份什么</span><br><span class="line"></span><br><span class="line">15.3.4 存储引擎和一致性</span><br><span class="line"></span><br><span class="line">15.4 管理和备份二进制日志</span><br><span class="line"></span><br><span class="line">15.4.1 二进制日志格式</span><br><span class="line"></span><br><span class="line">15.4.2 安全地清除老的二进制日志</span><br><span class="line"></span><br><span class="line">15.5 备份数据</span><br><span class="line"></span><br><span class="line">15.5.1 生成逻辑备份</span><br><span class="line"></span><br><span class="line">15.5.2 文件系统快照</span><br><span class="line"></span><br><span class="line">15.6 从备份中恢复</span><br><span class="line"></span><br><span class="line">15.6.1 恢复物理备份</span><br><span class="line"></span><br><span class="line">15.6.2 还原逻辑备份</span><br><span class="line"></span><br><span class="line">15.6.3 基于时间点的恢复</span><br><span class="line"></span><br><span class="line">15.6.4 更高级的恢复技术</span><br><span class="line"></span><br><span class="line">15.6.5 InnoDB 崩溃恢复</span><br><span class="line"></span><br><span class="line">15.7 备份和恢复工具</span><br><span class="line"></span><br><span class="line">15.7.1 MySQL Enterprise Backup</span><br><span class="line"></span><br><span class="line">15.7.2 Percona XtraBackup .</span><br><span class="line"></span><br><span class="line">15.7.3 mylvmbackup</span><br><span class="line"></span><br><span class="line">15.7.4 Zmanda Recovery Manager</span><br><span class="line"></span><br><span class="line">15.7.5 mydumper</span><br><span class="line"></span><br><span class="line">15.7.6 mysqldump.</span><br><span class="line"></span><br><span class="line">15.8 备份脚本化</span><br><span class="line"></span><br><span class="line">15.9 总结</span><br><span class="line"></span><br><span class="line">第16章 MySQL 用户工具</span><br><span class="line"></span><br><span class="line">16.1 接口工具</span><br><span class="line"></span><br><span class="line">16.2 命令行工具集</span><br><span class="line"></span><br><span class="line">16.3 SQL 实用集</span><br><span class="line"></span><br><span class="line">16.4 监测工具</span><br><span class="line"></span><br><span class="line">16.4.1 开源的监控工具</span><br><span class="line"></span><br><span class="line">16.4.2 商业监控系统</span><br><span class="line"></span><br><span class="line">16.4.3 Innotop 的命令行监控</span><br><span class="line"></span><br><span class="line">16.5 总结</span><br><span class="line"></span><br><span class="line">附录A MySQL 分支与变种</span><br><span class="line"></span><br><span class="line">附录B MySQL 服务器状态</span><br><span class="line"></span><br><span class="line">附录C 大文件传输</span><br><span class="line"></span><br><span class="line">附录D EXPLAIN</span><br><span class="line"></span><br><span class="line">附录E 锁的调试</span><br><span class="line"></span><br><span class="line">附录F 在MySQL 上使用Sphinx</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>黑客与画家 PDF</title>
    <url>/posts/af956bb2/</url>
    <content><![CDATA[<h4 id="《黑客与画家》"><a href="#《黑客与画家》" class="headerlink" title="《黑客与画家》"></a>《黑客与画家》</h4><h6 id="链接-https-pan-baidu-com-s-1UcPMzHEOm1I-pPS37Jz-dg-提取码-rqem"><a href="#链接-https-pan-baidu-com-s-1UcPMzHEOm1I-pPS37Jz-dg-提取码-rqem" class="headerlink" title="链接: https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg 提取码: rqem"></a>链接: <a href="https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg">https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg</a> 提取码: rqem</h6><p>世界上个互联网应用程序Viaweb开发者<br><a id="more"></a></p>
<p>举世认可的互联网创业Paul Graham的文集！</p>
<p>Paul Graham带领我们探究黑客的世界，了解黑客的爱好和动机</p>
<p>Paul Graham旁征博引历史事件，妙笔生花</p>
<p>《黑客与画家》是硅谷创业之父Paul Graham的文集，主要介绍黑客即程序员的爱好和动机，讨论黑客成长、黑客对世界的贡献以及编程语言和黑客工作方法等所有对计算机时代感兴趣的人的一些话题。书中的内容不但有助于了解计算机编程的本质、互联网行业的规则，还会帮助读者了解我们这个时代，迫使读者独立思考。</p>
<p>《黑客与画家》适合所有程序员和互联网创业者，也适合一切对计算机行业感兴趣的读者。</p>
<p>黑客的看法其实比语言设计者的更重要。编程语言不是数学定理，而是一种工具，为了便于使用，它们才被设计出来。所以，设计编程语言的时候必须考虑到人类的长处和短处，就像设计鞋子的时候必须符合人类的脚型。如果鞋子穿上去不舒服，无论它的外形多么优美，多么像一件艺术品，你也只能把它当作一双坏鞋。</p>
<p>大多数程序员也许无法分辨语言的好坏。但是，这不代表的编程语言会被埋没，专家级黑客一眼就能认出它们，并且会拿来使用。虽然他们人数很少，但就是这样一小群人写出了人类所有软件。他们有着巨大的影响力，他们使用什么语言，其他程序员往往就会跟着使用。老实说，很多时候这种影响力更像是一种命令，对于其他程序员来说，专家级黑客就像自己的老板或导师，他们说哪种语言好用，自己就会乖乖地跟进。</p>
<p><img src="/images/0c1d5e032cec8e233013e087032231b61.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1  为什么书呆子不受欢迎</span><br><span class="line"></span><br><span class="line">2  黑客与画家</span><br><span class="line"></span><br><span class="line">3  不能说的话</span><br><span class="line"></span><br><span class="line">4  良好的坏习惯</span><br><span class="line"></span><br><span class="line">5  另一条路</span><br><span class="line"></span><br><span class="line">6  如何创造财富</span><br><span class="line"></span><br><span class="line">7  关注贫富分化</span><br><span class="line"></span><br><span class="line">8  防止垃圾邮件的一种方法</span><br><span class="line"></span><br><span class="line">9  设计者的品味</span><br><span class="line"></span><br><span class="line">10  编程语言解析</span><br><span class="line"></span><br><span class="line">11  一百年后的编程语言</span><br><span class="line"></span><br><span class="line">12  拒绝平庸</span><br><span class="line"></span><br><span class="line">13  书呆子的复仇</span><br><span class="line"></span><br><span class="line">14  梦寐以求的编程语言</span><br><span class="line"></span><br><span class="line">15  设计与研究</span><br><span class="line"></span><br><span class="line">志谢</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言 PDF</title>
    <url>/posts/d8925b24/</url>
    <content><![CDATA[<h4 id="《汇编语言》"><a href="#《汇编语言》" class="headerlink" title="《汇编语言》"></a>《汇编语言》</h4><h6 id="第3版-王爽著"><a href="#第3版-王爽著" class="headerlink" title="(第3版)王爽著"></a>(第3版)王爽著</h6><h6 id="链接-https-pan-baidu-com-s-1VYJzDko9B8RsIwGKCK7xHg-提取码-9au5"><a href="#链接-https-pan-baidu-com-s-1VYJzDko9B8RsIwGKCK7xHg-提取码-9au5" class="headerlink" title="链接: https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg 提取码: 9au5"></a>链接: <a href="https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg">https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg</a> 提取码: 9au5</h6><a id="more"></a>
<p>汇编语言是各种CPU提供的机器指令的助记符的集合，人们可以用汇编语言直接控制硬件系统进行工作。汇编语言是很多相关课程(如数据结构、操作系统、微机原理等)的重要基础。为了更好地引导、帮助读者学习汇编语言，作者以循序渐进的思想精心创作了这本书。《汇编语言（第4版）》具有如下特点：采用了全新的结构对课程的内容进行组织，对知识进行z小化分割，为读者构造了循序渐进的学习线索；在深入本质的层面上对汇编语言进行讲解；对关键环节进行深入的剖析。</p>
<p>《汇编语言（第4版）》可用作大学计算机专业本科生的汇编语言教材及希望深入学习计算机科学的读者的自学教材</p>
<p><img src="/images/9eb4d7923ce8f2f558892f460ca309941.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">目 录</span><br><span class="line"></span><br><span class="line">第1章 基础知识 1</span><br><span class="line"></span><br><span class="line">1.1 机器语言 1</span><br><span class="line"></span><br><span class="line">1.2 汇编语言的产生 3</span><br><span class="line"></span><br><span class="line">1.3 汇编语言的组成 3</span><br><span class="line"></span><br><span class="line">1.4 存储器 4</span><br><span class="line"></span><br><span class="line">1.5 指令和数据 4</span><br><span class="line"></span><br><span class="line">1.6 存储单元 4</span><br><span class="line"></span><br><span class="line">1.7 CPU对存储器的读写 5</span><br><span class="line"></span><br><span class="line">1.8 地址总线 6</span><br><span class="line"></span><br><span class="line">1.9 数据总线 7</span><br><span class="line"></span><br><span class="line">1.10 控制总线 8</span><br><span class="line"></span><br><span class="line">1.11 内存地址空间(概述) 9</span><br><span class="line"></span><br><span class="line">1.12 主板 9</span><br><span class="line"></span><br><span class="line">1.13 接口卡 9</span><br><span class="line"></span><br><span class="line">1.14 各类存储器芯片 10</span><br><span class="line"></span><br><span class="line">1.15 内存地址空间 11</span><br><span class="line"></span><br><span class="line">第2章 寄存器 14</span><br><span class="line"></span><br><span class="line">2.1 通用寄存器 14</span><br><span class="line"></span><br><span class="line">2.2 字在寄存器中的存储 16</span><br><span class="line"></span><br><span class="line">2.3 几条汇编指令 17</span><br><span class="line"></span><br><span class="line">2.4 物理地址 20</span><br><span class="line"></span><br><span class="line">2.5 16位结构的CPU 20</span><br><span class="line"></span><br><span class="line">2.6 8086CPU给出物理地址的方法 20</span><br><span class="line"></span><br><span class="line">2.7 “段地址?16+偏移地址&#x3D;物理地址”</span><br><span class="line"></span><br><span class="line">的本质含义 22</span><br><span class="line"></span><br><span class="line">2.8 段的概念 23</span><br><span class="line"></span><br><span class="line">2.9 段寄存器 25</span><br><span class="line"></span><br><span class="line">2.10 CS和IP 25</span><br><span class="line"></span><br><span class="line">2.11 修改CS、IP的指令 32</span><br><span class="line"></span><br><span class="line">2.12 代码段 34</span><br><span class="line"></span><br><span class="line">实验1 查看CPU和内存，用机器指令</span><br><span class="line"></span><br><span class="line">和汇编指令编程 35</span><br><span class="line"></span><br><span class="line">第3章 寄存器(内存访问) 47</span><br><span class="line"></span><br><span class="line">3.1 内存中字的存储 47</span><br><span class="line"></span><br><span class="line">3.2 DS和[address] 48</span><br><span class="line"></span><br><span class="line">3.3 字的传送 49</span><br><span class="line"></span><br><span class="line">3.4 mov、add、sub指令 51</span><br><span class="line"></span><br><span class="line">3.5 数据段 53</span><br><span class="line"></span><br><span class="line">3.6 栈 56</span><br><span class="line"></span><br><span class="line">3.7 CPU提供的栈机制 57</span><br><span class="line"></span><br><span class="line">3.8 栈顶超界的问题 61</span><br><span class="line"></span><br><span class="line">3.9 push、pop指令 63</span><br><span class="line"></span><br><span class="line">3.10 栈段 68</span><br><span class="line"></span><br><span class="line">实验2 用机器指令和汇编指令编程 71</span><br><span class="line"></span><br><span class="line">第4章 第一个程序 76</span><br><span class="line"></span><br><span class="line">4.1 一个源程序从写出到执行的过程 76</span><br><span class="line"></span><br><span class="line">4.2 源程序 77</span><br><span class="line"></span><br><span class="line">4.3 编辑源程序 82</span><br><span class="line"></span><br><span class="line">4.4 编译 83</span><br><span class="line"></span><br><span class="line">4.5 连接 85</span><br><span class="line"></span><br><span class="line">4.6 以简化的方式进行编译和连接 88</span><br><span class="line"></span><br><span class="line">4.7 1.exe的执行 89</span><br><span class="line"></span><br><span class="line">4.8 谁将可执行文件中的程序装载进入</span><br><span class="line"></span><br><span class="line">内存并使它运行？ 89</span><br><span class="line"></span><br><span class="line">4.9 程序执行过程的跟踪 91</span><br><span class="line"></span><br><span class="line">实验3 编程、编译、连接、跟踪 94</span><br><span class="line"></span><br><span class="line">第5章 [BX]和loop指令 95</span><br><span class="line"></span><br><span class="line">5.1 [BX] 97</span><br><span class="line"></span><br><span class="line">5.2 Loop指令 99</span><br><span class="line"></span><br><span class="line">5.3 在Debug中跟踪用loop指令实现的</span><br><span class="line"></span><br><span class="line">循环程序 103</span><br><span class="line"></span><br><span class="line">5.4 Debug和汇编编译器masm对指令的</span><br><span class="line"></span><br><span class="line">不同处理 110</span><br><span class="line"></span><br><span class="line">5.5 loop和[bx]的联合应用 112</span><br><span class="line"></span><br><span class="line">5.6 段前缀 116</span><br><span class="line"></span><br><span class="line">5.7 一段安全的空间 117</span><br><span class="line"></span><br><span class="line">5.8 段前缀的使用 120</span><br><span class="line"></span><br><span class="line">实验4 [bx]和loop的使用 121</span><br><span class="line"></span><br><span class="line">第6章 包含多个段的程序 123</span><br><span class="line"></span><br><span class="line">6.1 在代码段中使用数据 123</span><br><span class="line"></span><br><span class="line">6.2 在代码段中使用栈 127</span><br><span class="line"></span><br><span class="line">6.3 将数据、代码、栈放入不同的段 130</span><br><span class="line"></span><br><span class="line">实验5 编写、调试具有多个段的程序 133</span><br><span class="line"></span><br><span class="line">第7章 更灵活的定位内存地址的</span><br><span class="line"></span><br><span class="line">方法 138</span><br><span class="line"></span><br><span class="line">7.1 and和or指令 138</span><br><span class="line"></span><br><span class="line">7.2 关于ASCII码 139</span><br><span class="line"></span><br><span class="line">7.3 以字符形式给出的数据 139</span><br><span class="line"></span><br><span class="line">7.4 大小写转换的问题 140</span><br><span class="line"></span><br><span class="line">7.5 [bx+idata] 143</span><br><span class="line"></span><br><span class="line">7.6 用[bx+idata]的方式进行数组的</span><br><span class="line"></span><br><span class="line">处理 144</span><br><span class="line"></span><br><span class="line">7.7 SI和DI 147</span><br><span class="line"></span><br><span class="line">7.8 [bx+si]和[bx+di] 149</span><br><span class="line"></span><br><span class="line">7.9 [bx+si+idata]和[bx+di+idata] 150</span><br><span class="line"></span><br><span class="line">7.10 不同的寻址方式的灵活应用 152</span><br><span class="line"></span><br><span class="line">实验6 实践课程中的程序 160</span><br><span class="line"></span><br><span class="line">第8章 数据处理的两个基本问题 161</span><br><span class="line"></span><br><span class="line">8.1 bx、si、di和bp 161</span><br><span class="line"></span><br><span class="line">8.2 机器指令处理的数据在什么地方 162</span><br><span class="line"></span><br><span class="line">8.3 汇编语言中数据位置的表达 162</span><br><span class="line"></span><br><span class="line">8.4 寻址方式 164</span><br><span class="line"></span><br><span class="line">8.5 指令要处理的数据有多长 165</span><br><span class="line"></span><br><span class="line">8.6 寻址方式的综合应用 166</span><br><span class="line"></span><br><span class="line">8.7 div指令 169</span><br><span class="line"></span><br><span class="line">8.8 伪指令dd 170</span><br><span class="line"></span><br><span class="line">8.9 dup 171</span><br><span class="line"></span><br><span class="line">实验7 寻址方式在结构化数据访问中</span><br><span class="line"></span><br><span class="line">的应用 172</span><br><span class="line"></span><br><span class="line">第9章 转移指令的原理 175</span><br><span class="line"></span><br><span class="line">9.1 操作符offset 175</span><br><span class="line"></span><br><span class="line">9.2 jmp 指令 176</span><br><span class="line"></span><br><span class="line">9.3 依据位移进行转移的jmp指令 177</span><br><span class="line"></span><br><span class="line">9.4 转移的目的地址在指令中的jmp</span><br><span class="line"></span><br><span class="line">指令 180</span><br><span class="line"></span><br><span class="line">9.5 转移地址在寄存器中的jmp指令 181</span><br><span class="line"></span><br><span class="line">9.6 转移地址在内存中的jmp指令 182</span><br><span class="line"></span><br><span class="line">9.7 jcxz指令 184</span><br><span class="line"></span><br><span class="line">9.8 loop指令 185</span><br><span class="line"></span><br><span class="line">9.9 根据位移进行转移的意义 186</span><br><span class="line"></span><br><span class="line">9.10 编译器对转移位移超界的检测 186</span><br><span class="line"></span><br><span class="line">实验8 分析一个奇怪的程序 187</span><br><span class="line"></span><br><span class="line">实验9 根据材料编程 187</span><br><span class="line"></span><br><span class="line">第10章 CALL和RET指令 190</span><br><span class="line"></span><br><span class="line">10.1 ret和retf 190</span><br><span class="line"></span><br><span class="line">10.2 call指令 192</span><br><span class="line"></span><br><span class="line">10.3 依据位移进行转移的call指令 192</span><br><span class="line"></span><br><span class="line">10.4 转移的目的地址在指令中的call</span><br><span class="line"></span><br><span class="line">指令 193</span><br><span class="line"></span><br><span class="line">10.5 转移地址在寄存器中的call指令 194</span><br><span class="line"></span><br><span class="line">10.6 转移地址在内存中的call指令 194</span><br><span class="line"></span><br><span class="line">10.7 call和ret的配合使用 196</span><br><span class="line"></span><br><span class="line">10.8 mul指令 199</span><br><span class="line"></span><br><span class="line">10.9 模块化程序设计 200</span><br><span class="line"></span><br><span class="line">10.10 参数和结果传递的问题 200</span><br><span class="line"></span><br><span class="line">10.11 批量数据的传递 201</span><br><span class="line"></span><br><span class="line">10.12 寄存器冲突的问题 203</span><br><span class="line"></span><br><span class="line">实验10 编写子程序 206</span><br><span class="line"></span><br><span class="line">课程设计1 211</span><br><span class="line"></span><br><span class="line">第11章 标志寄存器 213</span><br><span class="line"></span><br><span class="line">11.1 ZF标志 213</span><br><span class="line"></span><br><span class="line">11.2 PF 标志 214</span><br><span class="line"></span><br><span class="line">11.3 SF 标志 215</span><br><span class="line"></span><br><span class="line">11.4 CF 标志 216</span><br><span class="line"></span><br><span class="line">11.5 OF 标志 217</span><br><span class="line"></span><br><span class="line">11.6 adc 指令 219</span><br><span class="line"></span><br><span class="line">11.7 sbb指令 222</span><br><span class="line"></span><br><span class="line">11.8 cmp指令 222</span><br><span class="line"></span><br><span class="line">11.9 检测比较结果的条件转移指令 225</span><br><span class="line"></span><br><span class="line">11.10 DF标志和串传送指令 230</span><br><span class="line"></span><br><span class="line">11.11 pushf和popf 233</span><br><span class="line"></span><br><span class="line">11.12 标志寄存器在Debug中的表示 234</span><br><span class="line"></span><br><span class="line">实验11 编写子程序 234</span><br><span class="line"></span><br><span class="line">第12章 内中断 236</span><br><span class="line"></span><br><span class="line">12.1 内中断的产生 236</span><br><span class="line"></span><br><span class="line">12.2 中断处理程序 237</span><br><span class="line"></span><br><span class="line">12.3 中断向量表 237</span><br><span class="line"></span><br><span class="line">12.4 中断过程 238</span><br><span class="line"></span><br><span class="line">12.5 中断处理程序和iret指令 239</span><br><span class="line"></span><br><span class="line">12.6 除法错误中断的处理 240</span><br><span class="line"></span><br><span class="line">12.7 编程处理0号中断 240</span><br><span class="line"></span><br><span class="line">12.8 安装 244</span><br><span class="line"></span><br><span class="line">12.9 do0 246</span><br><span class="line"></span><br><span class="line">12.10 设置中断向量 249</span><br><span class="line"></span><br><span class="line">12.11 单步中断 249</span><br><span class="line"></span><br><span class="line">12.12 响应中断的特殊情况 250</span><br><span class="line"></span><br><span class="line">实验12 编写0号中断的处理程序 251</span><br><span class="line"></span><br><span class="line">第13章 int指令 252</span><br><span class="line"></span><br><span class="line">13.1 int指令 252</span><br><span class="line"></span><br><span class="line">13.2 编写供应用程序调用的中断例程 253</span><br><span class="line"></span><br><span class="line">13.3 对int、iret和栈的深入理解 256</span><br><span class="line"></span><br><span class="line">13.4 BIOS和DOS所提供的中断例程 258</span><br><span class="line"></span><br><span class="line">13.5 BIOS和DOS中断例程的安装</span><br><span class="line"></span><br><span class="line">过程 258</span><br><span class="line"></span><br><span class="line">13.6 BIOS中断例程应用 259</span><br><span class="line"></span><br><span class="line">13.7 DOS中断例程应用 261</span><br><span class="line"></span><br><span class="line">实验13 编写、应用中断例程 262</span><br><span class="line"></span><br><span class="line">第14章 端口 265</span><br><span class="line"></span><br><span class="line">14.1 端口的读写 265</span><br><span class="line"></span><br><span class="line">14.2 CMOS RAM芯片 266</span><br><span class="line"></span><br><span class="line">14.3 shl和shr指令 267</span><br><span class="line"></span><br><span class="line">14.4 CMOS RAM中存储的时间信息 269</span><br><span class="line"></span><br><span class="line">实验14 访问CMOS RAM 271</span><br><span class="line"></span><br><span class="line">第15章 外中断 272</span><br><span class="line"></span><br><span class="line">15.1 接口芯片和端口 272</span><br><span class="line"></span><br><span class="line">15.2 外中断信息 272</span><br><span class="line"></span><br><span class="line">15.3 PC机键盘的处理过程 274</span><br><span class="line"></span><br><span class="line">15.4 编写int 9中断例程 276</span><br><span class="line"></span><br><span class="line">15.5 安装新的int 9中断例程 282</span><br><span class="line"></span><br><span class="line">实验15 安装新的int 9中断例程 285</span><br><span class="line"></span><br><span class="line">第16章 直接定址表 287</span><br><span class="line"></span><br><span class="line">16.1 描述了单元长度的标号 287</span><br><span class="line"></span><br><span class="line">16.2 在其他段中使用数据标号 289</span><br><span class="line"></span><br><span class="line">16.3 直接定址表 292</span><br><span class="line"></span><br><span class="line">16.4 程序入口地址的直接定址表 296</span><br><span class="line"></span><br><span class="line">实验16 编写包含多个功能子程序的</span><br><span class="line"></span><br><span class="line">中断例程 299</span><br><span class="line"></span><br><span class="line">第17章 使用BIOS进行键盘输入</span><br><span class="line"></span><br><span class="line">和磁盘读写 300</span><br><span class="line"></span><br><span class="line">17.1 int 9中断例程对键盘输入的处理 300</span><br><span class="line"></span><br><span class="line">17.2 使用int 16h中断例程读取键盘</span><br><span class="line"></span><br><span class="line">缓冲区 301</span><br><span class="line"></span><br><span class="line">17.3 字符串的输入 304</span><br><span class="line"></span><br><span class="line">17.4 应用int 13h中断例程对磁盘进行</span><br><span class="line"></span><br><span class="line">读写 308</span><br><span class="line"></span><br><span class="line">实验17 编写包含多个功能子程序的</span><br><span class="line"></span><br><span class="line">中断例程 310</span><br><span class="line"></span><br><span class="line">课程设计2 312</span><br><span class="line"></span><br><span class="line">综合研究 314</span><br><span class="line"></span><br><span class="line">研究试验1 搭建一个精简的C语言</span><br><span class="line"></span><br><span class="line">开发环境 315</span><br><span class="line"></span><br><span class="line">研究试验2 使用寄存器 318</span><br><span class="line"></span><br><span class="line">研究试验3 使用内存空间 319</span><br><span class="line"></span><br><span class="line">研究试验4 不用main函数编程 322</span><br><span class="line"></span><br><span class="line">研究试验5 函数如何接收不定数量的</span><br><span class="line"></span><br><span class="line">参数 326</span><br><span class="line"></span><br><span class="line">附注 327</span><br><span class="line"></span><br><span class="line">附注1 Intel系列微处理器的3种工作</span><br><span class="line"></span><br><span class="line">模式 327</span><br><span class="line"></span><br><span class="line">附注2 补码 329</span><br><span class="line"></span><br><span class="line">附注3 汇编编译器(masm.exe)对jmp的</span><br><span class="line"></span><br><span class="line">相关处理 330</span><br><span class="line"></span><br><span class="line">附注4 用栈传递参数 333</span><br><span class="line"></span><br><span class="line">附注5 公式证明 336</span><br><span class="line"></span><br><span class="line">　　</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习实战 PDF</title>
    <url>/posts/482d46b5/</url>
    <content><![CDATA[<h4 id="《机器学习实战》"><a href="#《机器学习实战》" class="headerlink" title="《机器学习实战》"></a>《机器学习实战》</h4><h6 id="链接-https-pan-baidu-com-s-1-s7UYnjADjtj6N0I-oiVPA-提取码-b9hw"><a href="#链接-https-pan-baidu-com-s-1-s7UYnjADjtj6N0I-oiVPA-提取码-b9hw" class="headerlink" title="链接: https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA 提取码: b9hw"></a>链接: <a href="https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA">https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA</a> 提取码: b9hw</h6><p>机器学习是人工智能研究领域中一个极其重要的研究方向，在现今的大数据时代背景下，捕获数据并从中萃取有价值的信息或模式，成为各行业求生存、谋发展的决定性手段，这使得这一过去为分析师和数学家所专属的研究领域越来越为人们所瞩目。<br><a id="more"></a></p>
<p>　　《机器学习实战》主要介绍机器学习基础，以及如何利用算法进行分类，并逐步介绍了多种经典的监督学习算法，如k近邻算法、朴素贝叶斯算法、Logistic回归算法、支持向量机、AdaBoost集成方法、基于树的回归算法和分类回归树（CART）算法等。第三部分则重点介绍无监督学习及其一些主要算法：k均值聚类算法、Apriori算法、FP-Growth算法。第四部分介绍了机器学习算法的一些附属工具。</p>
<p>　　《机器学习实战》通过精心编排的实例，切入日常工作任务，摒弃学术化语言，利用高效的可复用Python代码来阐释如何处理统计数据，进行数据分析及可视化。通过各种实例，读者可从中学会机器学习的核心算法，并能将其运用于一些策略性任务中，如分类、预测、推荐。另外，还可用它们来实现一些更高级的功能，如汇总和简化等。</p>
<p><img src="/images/aac3394469b96d5a86260bb11aa729f11.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第一部分　分类</span><br><span class="line"></span><br><span class="line">第1章　机器学习基础　　</span><br><span class="line"></span><br><span class="line">1.1 　何谓机器学习　　</span><br><span class="line"></span><br><span class="line">1.1.1 　传感器和海量数据　　</span><br><span class="line"></span><br><span class="line">1.1.2 　机器学习非常重要　　</span><br><span class="line"></span><br><span class="line">1.2 　关键术语　　</span><br><span class="line"></span><br><span class="line">1.3 　机器学习的主要任务　　</span><br><span class="line"></span><br><span class="line">1.4 　如何选择合适的算法　　</span><br><span class="line"></span><br><span class="line">1.5 　开发机器学习应用程序的步骤　　</span><br><span class="line"></span><br><span class="line">1.6 　Python语言的优势　　</span><br><span class="line"></span><br><span class="line">1.6.1 　可执行伪代码　　</span><br><span class="line"></span><br><span class="line">1.6.2 　Python比较流行　　</span><br><span class="line"></span><br><span class="line">1.6.3 　Python语言的特色　　</span><br><span class="line"></span><br><span class="line">1.6.4 　Python语言的缺点　　</span><br><span class="line"></span><br><span class="line">1.7 　NumPy函数库基础　　</span><br><span class="line"></span><br><span class="line">1.8 　本章小结　　</span><br><span class="line"></span><br><span class="line">第2章　k-近邻算法 　　</span><br><span class="line"></span><br><span class="line">2.1 　k-近邻算法概述　　</span><br><span class="line"></span><br><span class="line">2.1.1 　准备：使用Python导入数据　　</span><br><span class="line"></span><br><span class="line">2.1.2 　从文本文件中解析数据　　</span><br><span class="line"></span><br><span class="line">2.1.3 　如何测试分类器　　</span><br><span class="line"></span><br><span class="line">2.2 　示例：使用k-近邻算法改进约会网站的配对效果　　</span><br><span class="line"></span><br><span class="line">2.2.1 　准备数据：从文本文件中解析数据　　</span><br><span class="line"></span><br><span class="line">2.2.2 　分析数据：使用Matplotlib创建散点图　　</span><br><span class="line"></span><br><span class="line">2.2.3 　准备数据：归一化数值　　</span><br><span class="line"></span><br><span class="line">2.2.4 　测试算法：作为完整程序验证分类器　　</span><br><span class="line"></span><br><span class="line">2.2.5 　使用算法：构建完整可用系统　　</span><br><span class="line"></span><br><span class="line">2.3 　示例：手写识别系统　　</span><br><span class="line"></span><br><span class="line">2.3.1 　准备数据：将图像转换为测试向量　　</span><br><span class="line"></span><br><span class="line">2.3.2 　测试算法：使用k-近邻算法识别手写数字　　</span><br><span class="line"></span><br><span class="line">2.4 　本章小结　　</span><br><span class="line"></span><br><span class="line">第3章　决策树 　　</span><br><span class="line"></span><br><span class="line">3.1 　决策树的构造　　</span><br><span class="line"></span><br><span class="line">3.1.1 　信息增益　　</span><br><span class="line"></span><br><span class="line">3.1.2 　划分数据集　　</span><br><span class="line"></span><br><span class="line">3.1.3 　递归构建决策树　　</span><br><span class="line"></span><br><span class="line">3.2 　在Python中使用Matplotlib注解绘制树形图　　</span><br><span class="line"></span><br><span class="line">3.2.1 　Matplotlib注解　　</span><br><span class="line"></span><br><span class="line">3.2.2 　构造注解树　　</span><br><span class="line"></span><br><span class="line">3.3 　测试和存储分类器　　</span><br><span class="line"></span><br><span class="line">3.3.1 　测试算法：使用决策树执行分类　　</span><br><span class="line"></span><br><span class="line">3.3.2 　使用算法：决策树的存储　　</span><br><span class="line"></span><br><span class="line">3.4 　示例：使用决策树预测隐形眼镜类型　　</span><br><span class="line"></span><br><span class="line">3.5 　本章小结　　</span><br><span class="line"></span><br><span class="line">第4章　基于概率论的分类方法：朴素贝叶斯 　　</span><br><span class="line"></span><br><span class="line">4.1 　基于贝叶斯决策理论的分类方法　　</span><br><span class="line"></span><br><span class="line">4.2 　条件概率　　</span><br><span class="line"></span><br><span class="line">4.3 　使用条件概率来分类　　</span><br><span class="line"></span><br><span class="line">4.4 　使用朴素贝叶斯进行文档分类　　</span><br><span class="line"></span><br><span class="line">4.5 　使用Python进行文本分类　　</span><br><span class="line"></span><br><span class="line">4.5.1 　准备数据：从文本中构建词向量　　</span><br><span class="line"></span><br><span class="line">4.5.2 　训练算法：从词向量计算概率　　</span><br><span class="line"></span><br><span class="line">4.5.3 　测试算法：根据现实情况修改分类器　　</span><br><span class="line"></span><br><span class="line">4.5.4 　准备数据：文档词袋模型　　</span><br><span class="line"></span><br><span class="line">4.6 　示例：使用朴素贝叶斯过滤垃圾邮件　　</span><br><span class="line"></span><br><span class="line">4.6.1 　准备数据：切分文本　　</span><br><span class="line"></span><br><span class="line">4.6.2 　测试算法：使用朴素贝叶斯进行交叉验证　　</span><br><span class="line"></span><br><span class="line">4.7 　示例：使用朴素贝叶斯分类器从个人广告中获取区域倾向　　</span><br><span class="line"></span><br><span class="line">4.7.1 　收集数据：导入RSS源　　</span><br><span class="line"></span><br><span class="line">4.7.2 　分析数据：显示地域相关的用词　　</span><br><span class="line"></span><br><span class="line">4.8 　本章小结　　</span><br><span class="line"></span><br><span class="line">第5章　Logistic回归 　　</span><br><span class="line"></span><br><span class="line">5.1 　基于Logistic回归和Sigmoid函数的分类　　</span><br><span class="line"></span><br><span class="line">5.2 　基于最优化方法的最佳回归系数确定　　</span><br><span class="line"></span><br><span class="line">5.2.1 　梯度上升法　　</span><br><span class="line"></span><br><span class="line">5.2.2 　训练算法：使用梯度上升找到最佳参数　　</span><br><span class="line"></span><br><span class="line">5.2.3 　分析数据：画出决策边界　　</span><br><span class="line"></span><br><span class="line">5.2.4 　训练算法：随机梯度上升　　</span><br><span class="line"></span><br><span class="line">5.3 　示例：从疝气病症预测病马的死亡率　　</span><br><span class="line"></span><br><span class="line">5.3.1 　准备数据：处理数据中的缺失值　　</span><br><span class="line"></span><br><span class="line">5.3.2 　测试算法：用Logistic回归进行分类　　</span><br><span class="line"></span><br><span class="line">5.4 　本章小结　　</span><br><span class="line"></span><br><span class="line">第6章　支持向量机　　</span><br><span class="line"></span><br><span class="line">6.1 　基于最大间隔分隔数据　　</span><br><span class="line"></span><br><span class="line">6.2 　寻找最大间隔　　</span><br><span class="line"></span><br><span class="line">6.2.1 　分类器求解的优化问题　　</span><br><span class="line"></span><br><span class="line">6.2.2 　SVM应用的一般框架　　</span><br><span class="line"></span><br><span class="line">6.3 　SMO高效优化算法　　</span><br><span class="line"></span><br><span class="line">6.3.1 　Platt的SMO算法　　</span><br><span class="line"></span><br><span class="line">6.3.2 　应用简化版SMO算法处理小规模数据集　　</span><br><span class="line"></span><br><span class="line">6.4 　利用完整Platt SMO算法加速优化　　</span><br><span class="line"></span><br><span class="line">6.5 　在复杂数据上应用核函数　　</span><br><span class="line"></span><br><span class="line">6.5.1 　利用核函数将数据映射到高维空间　　</span><br><span class="line"></span><br><span class="line">6.5.2 　径向基核函数　　</span><br><span class="line"></span><br><span class="line">6.5.3 　在测试中使用核函数　　</span><br><span class="line"></span><br><span class="line">6.6 　示例：手写识别问题回顾　　</span><br><span class="line"></span><br><span class="line">6.7 　本章小结　　</span><br><span class="line"></span><br><span class="line">第7章　利用AdaBoost元算法提高分类</span><br><span class="line"></span><br><span class="line">性能 　　</span><br><span class="line"></span><br><span class="line">7.1 　基于数据集多重抽样的分类器　　</span><br><span class="line"></span><br><span class="line">7.1.1 　bagging：基于数据随机重抽样的分类器构建方法　　</span><br><span class="line"></span><br><span class="line">7.1.2 　boosting　　</span><br><span class="line"></span><br><span class="line">7.2 　训练算法：基于错误提升分类器的性能　　</span><br><span class="line"></span><br><span class="line">7.3 　基于单层决策树构建弱分类器　　</span><br><span class="line"></span><br><span class="line">7.4 　完整AdaBoost算法的实现　　</span><br><span class="line"></span><br><span class="line">7.5 　测试算法：基于AdaBoost的分类　　</span><br><span class="line"></span><br><span class="line">7.6 　示例：在一个难数据集上应用AdaBoost　　</span><br><span class="line"></span><br><span class="line">7.7 　非均衡分类问题　　</span><br><span class="line"></span><br><span class="line">7.7.1 　其他分类性能度量指标：正确率、召回率及ROC曲线　　</span><br><span class="line"></span><br><span class="line">7.7.2 　基于代价函数的分类器决策控制　　</span><br><span class="line"></span><br><span class="line">7.7.3 　处理非均衡问题的数据抽样方法　　</span><br><span class="line"></span><br><span class="line">7.8 　本章小结　　</span><br><span class="line"></span><br><span class="line">第二部分　利用回归预测数值型数据</span><br><span class="line"></span><br><span class="line">第8章　预测数值型数据：回归 　　</span><br><span class="line"></span><br><span class="line">8.1 　用线性回归找到最佳拟合直线　　</span><br><span class="line"></span><br><span class="line">8.2 　局部加权线性回归　　</span><br><span class="line"></span><br><span class="line">8.3 　示例：预测鲍鱼的年龄　　</span><br><span class="line"></span><br><span class="line">8.4 　缩减系数来“理解”数据　　</span><br><span class="line"></span><br><span class="line">8.4.1 　岭回归　　</span><br><span class="line"></span><br><span class="line">8.4.2 　lasso　　</span><br><span class="line"></span><br><span class="line">8.4.3 　前向逐步回归　　</span><br><span class="line"></span><br><span class="line">8.5 　权衡偏差与方差　　</span><br><span class="line"></span><br><span class="line">8.6 　示例：预测乐高玩具套装的价格　　</span><br><span class="line"></span><br><span class="line">8.6.1 　收集数据：使用Google购物的API　　</span><br><span class="line"></span><br><span class="line">8.6.2 　训练算法：建立模型　　</span><br><span class="line"></span><br><span class="line">8.7 　本章小结　　</span><br><span class="line"></span><br><span class="line">第9章　树回归　　</span><br><span class="line"></span><br><span class="line">9.1 　复杂数据的局部性建模　　</span><br><span class="line"></span><br><span class="line">9.2 　连续和离散型特征的树的构建　　</span><br><span class="line"></span><br><span class="line">9.3 　将CART算法用于回归　　</span><br><span class="line"></span><br><span class="line">9.3.1 　构建树　　</span><br><span class="line"></span><br><span class="line">9.3.2 　运行代码　　</span><br><span class="line"></span><br><span class="line">9.4 　树剪枝　　</span><br><span class="line"></span><br><span class="line">9.4.1 　预剪枝　　</span><br><span class="line"></span><br><span class="line">9.4.2 　后剪枝　　</span><br><span class="line"></span><br><span class="line">9.5 　模型树　　</span><br><span class="line"></span><br><span class="line">9.6 　示例：树回归与标准回归的比较　　</span><br><span class="line"></span><br><span class="line">9.7 　使用Python的Tkinter库创建GUI　　</span><br><span class="line"></span><br><span class="line">9.7.1 　用Tkinter创建GUI　　</span><br><span class="line"></span><br><span class="line">9.7.2 　集成Matplotlib和Tkinter　　</span><br><span class="line"></span><br><span class="line">9.8 　本章小结　　</span><br><span class="line"></span><br><span class="line">第三部分　无监督学习</span><br><span class="line"></span><br><span class="line">第10章　利用K-均值聚类算法对未标注数据分组　　</span><br><span class="line"></span><br><span class="line">10.1 　K-均值聚类算法　　</span><br><span class="line"></span><br><span class="line">10.2 　使用后处理来提高聚类性能　　</span><br><span class="line"></span><br><span class="line">10.3 　二分K-均值算法　　</span><br><span class="line"></span><br><span class="line">10.4 　示例：对地图上的点进行聚类　　</span><br><span class="line"></span><br><span class="line">10.4.1 　Yahoo！ PlaceFinder API　　</span><br><span class="line"></span><br><span class="line">10.4.2 　对地理坐标进行聚类　　</span><br><span class="line"></span><br><span class="line">10.5 　本章小结　　</span><br><span class="line"></span><br><span class="line">第11章　使用Apriori算法进行关联分析　　</span><br><span class="line"></span><br><span class="line">11.1 　关联分析　　</span><br><span class="line"></span><br><span class="line">11.2 　Apriori原理　　</span><br><span class="line"></span><br><span class="line">11.3 　使用Apriori算法来发现频繁集　　</span><br><span class="line"></span><br><span class="line">11.3.1 　生成候选项集　　</span><br><span class="line"></span><br><span class="line">11.3.2 　组织完整的Apriori算法　　</span><br><span class="line"></span><br><span class="line">11.4 　从频繁项集中挖掘关联规则　　</span><br><span class="line"></span><br><span class="line">11.5 　示例：发现国会投票中的模式　　</span><br><span class="line"></span><br><span class="line">11.5.1 　收集数据：构建美国国会投票记录的事务数据集　　</span><br><span class="line"></span><br><span class="line">11.5.2 　测试算法：基于美国国会投票记录挖掘关联规则　　</span><br><span class="line"></span><br><span class="line">11.6 　示例：发现毒蘑菇的相似特征　　</span><br><span class="line"></span><br><span class="line">11.7 　本章小结　　</span><br><span class="line"></span><br><span class="line">第12章　使用FP-growth算法来高效发现频繁项集　　</span><br><span class="line"></span><br><span class="line">12.1 　FP树：用于编码数据集的有效方式　　</span><br><span class="line"></span><br><span class="line">12.2 　构建FP树　　</span><br><span class="line"></span><br><span class="line">12.2.1 　创建FP树的数据结构　　</span><br><span class="line"></span><br><span class="line">12.2.2 　构建FP树　　</span><br><span class="line"></span><br><span class="line">12.3 　从一棵FP树中挖掘频繁项集　　</span><br><span class="line"></span><br><span class="line">12.3.1 　抽取条件模式基　　</span><br><span class="line"></span><br><span class="line">12.3.2 　创建条件FP树　　</span><br><span class="line"></span><br><span class="line">12.4 　示例：在Twitter源中发现一些共现词　　</span><br><span class="line"></span><br><span class="line">12.5 　示例：从新闻网站点击流中挖掘　　</span><br><span class="line"></span><br><span class="line">12.6 　本章小结　　</span><br><span class="line"></span><br><span class="line">第四部分　其他工具</span><br><span class="line"></span><br><span class="line">第13章　利用PCA来简化数据　　</span><br><span class="line"></span><br><span class="line">13.1 　降维技术　　</span><br><span class="line"></span><br><span class="line">13.2 　PCA　　</span><br><span class="line"></span><br><span class="line">13.2.1 　移动坐标轴　　</span><br><span class="line"></span><br><span class="line">13.2.2 　在NumPy中实现PCA　　</span><br><span class="line"></span><br><span class="line">13.3 　示例：利用PCA对半导体制造数据降维　　</span><br><span class="line"></span><br><span class="line">13.4 　本章小结　　</span><br><span class="line"></span><br><span class="line">第14章　利用SVD简化数据　　</span><br><span class="line"></span><br><span class="line">14.1 　SVD的应用　　</span><br><span class="line"></span><br><span class="line">14.1.1 　隐性语义索引　　</span><br><span class="line"></span><br><span class="line">14.1.2 　推荐系统　　</span><br><span class="line"></span><br><span class="line">14.2 　矩阵分解　　</span><br><span class="line"></span><br><span class="line">14.3 　利用Python实现SVD　　</span><br><span class="line"></span><br><span class="line">14.4 　基于协同过滤的推荐引擎　　</span><br><span class="line"></span><br><span class="line">14.4.1 　相似度计算　　</span><br><span class="line"></span><br><span class="line">14.4.2 　基于物品的相似度还是基于用户的相似度？　　</span><br><span class="line"></span><br><span class="line">14.4.3 　推荐引擎的评价　　</span><br><span class="line"></span><br><span class="line">14.5 　示例：餐馆菜肴推荐引擎　　</span><br><span class="line"></span><br><span class="line">14.5.1 　推荐未尝过的菜肴　　</span><br><span class="line"></span><br><span class="line">14.5.2 　利用SVD提高推荐的效果　　</span><br><span class="line"></span><br><span class="line">14.5.3 　构建推荐引擎面临的挑战　　</span><br><span class="line"></span><br><span class="line">14.6 　基于SVD的图像压缩　　</span><br><span class="line"></span><br><span class="line">14.7 　本章小结　　</span><br><span class="line"></span><br><span class="line">第15章　大数据与MapReduce　　</span><br><span class="line"></span><br><span class="line">15.1 　MapReduce：分布式计算的框架　　</span><br><span class="line"></span><br><span class="line">15.2 　Hadoop流　　</span><br><span class="line"></span><br><span class="line">15.2.1 　分布式计算均值和方差的mapper　　</span><br><span class="line"></span><br><span class="line">15.2.2 　分布式计算均值和方差的reducer　　</span><br><span class="line"></span><br><span class="line">15.3 　在Amazon网络服务上运行Hadoop程序　　</span><br><span class="line"></span><br><span class="line">15.3.1 　AWS上的可用服务　　</span><br><span class="line"></span><br><span class="line">15.3.2 　开启Amazon网络服务之旅　　</span><br><span class="line"></span><br><span class="line">15.3.3 　在EMR上运行Hadoop作业　　</span><br><span class="line"></span><br><span class="line">15.4 　MapReduce上的机器学习　　</span><br><span class="line"></span><br><span class="line">15.5 　在Python中使用mrjob来自动化MapReduce　　</span><br><span class="line"></span><br><span class="line">15.5.1 　mrjob与EMR的无缝集成　　</span><br><span class="line"></span><br><span class="line">15.5.2 　mrjob的一个MapReduce脚本剖析　　</span><br><span class="line"></span><br><span class="line">15.6 　示例：分布式SVM的Pegasos算法　　</span><br><span class="line"></span><br><span class="line">15.6.1 　Pegasos算法　　</span><br><span class="line"></span><br><span class="line">15.6.2 　训练算法：用mrjob实现MapReduce版本的SVM　　</span><br><span class="line"></span><br><span class="line">15.7 　你真的需要MapReduce吗？　　</span><br><span class="line"></span><br><span class="line">15.8 　本章小结　　</span><br><span class="line"></span><br><span class="line">附录A 　Python入门　　</span><br><span class="line"></span><br><span class="line">附录B 　线性代数　　</span><br><span class="line"></span><br><span class="line">附录C 　概率论复习　　</span><br><span class="line"></span><br><span class="line">附录D 　资源　　</span><br><span class="line"></span><br><span class="line">索引　　</span><br><span class="line"></span><br><span class="line">版权声明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习与数据挖掘方法和应用 PDF</title>
    <url>/posts/3f2a7623/</url>
    <content><![CDATA[<h4 id="《机器学习与数据挖掘方法和应用》"><a href="#《机器学习与数据挖掘方法和应用》" class="headerlink" title="《机器学习与数据挖掘方法和应用》"></a>《机器学习与数据挖掘方法和应用》</h4><h6 id="链接-https-pan-baidu-com-s-13b9k90a3-w6a0DlZGJCHlw-提取码-rw5q"><a href="#链接-https-pan-baidu-com-s-13b9k90a3-w6a0DlZGJCHlw-提取码-rw5q" class="headerlink" title="链接: https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw 提取码: rw5q"></a>链接: <a href="https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw">https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw</a> 提取码: rw5q</h6><p>本书分为5个部分，共18章，较为全面地介绍了机器学习的基本概念，并讨论了数据挖掘和知识发现中的有关问题及多策略学习方法，具体地阐述了机器学习与数据挖掘在工程设计，文本、图像和音乐，网页分析、计算机病毒和计算机控制，医疗诊断、生物医疗信号分析和水质分析中的生物信号处理等方面的应用情况。\n 本书收集众多不同领域中数据挖掘的实际案例，以此来说明数据挖掘的具体解决方法，以期为广大读者提供一个更为广阔的数据挖掘应用视角。\n 本书的读者，可以是任何对机器学习与数据挖掘感兴趣的工程技术人员、业务管理人员，或是从事具体技术工作的其他人员。本书也可作为大专院校相关课程的重要辅导教材。<br><a id="more"></a></p>
<p><img src="/images/a74e446252dbf89beffa0a7f16e388731.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">部分 基 本 概 念</span><br><span class="line"></span><br><span class="line">章 机器学习方法概述（2）</span><br><span class="line"></span><br><span class="line">1.1 导论（2）</span><br><span class="line"></span><br><span class="line">1.2 机器学习任务（4）</span><br><span class="line"></span><br><span class="line">1.2.1 认知观点（5）</span><br><span class="line"></span><br><span class="line">1.2.2 表示问题（7）</span><br><span class="line"></span><br><span class="line">1.3 泛化空间的搜索（11）</span><br><span class="line"></span><br><span class="line">1.3.1 学习的归纳本质（11）</span><br><span class="line"></span><br><span class="line">1.3.2 穷尽搜索（13）</span><br><span class="line"></span><br><span class="line">1.3.3 启发式搜索（14）</span><br><span class="line"></span><br><span class="line">1.4 学习经典任务（16）</span><br><span class="line"></span><br><span class="line">1.4.1 分而治之学习法（16）</span><br><span class="line"></span><br><span class="line">1.4.2 主动覆盖：AQ学习（24）</span><br><span class="line"></span><br><span class="line">1.4.3 学习算法评估（27）</span><br><span class="line"></span><br><span class="line">1.5 如何利用谓词逻辑（29）</span><br><span class="line"></span><br><span class="line">1.5.1 从关系中学习Horn子句（30）</span><br><span class="line"></span><br><span class="line">1.5.2 反转归并（34）</span><br><span class="line"></span><br><span class="line">1.5.3 理论修正（36）</span><br><span class="line"></span><br><span class="line">1.5.4 构造归纳（38）</span><br><span class="line"></span><br><span class="line">1.6 人工发现（40）</span><br><span class="line"></span><br><span class="line">1.6.1 概念形成（41）</span><br><span class="line"></span><br><span class="line">1.6.2 寻找自然定律（46）</span><br><span class="line"></span><br><span class="line">1.6.3 动态系统的发现（49）</span><br><span class="line"></span><br><span class="line">1.7 如何处理搜索空间过大（50）</span><br><span class="line"></span><br><span class="line">1.7.1 类比提供搜索启发（50）</span><br><span class="line"></span><br><span class="line">1.7.2 基于示例学习（51）</span><br><span class="line"></span><br><span class="line">1.8 机器学习的近邻（53）</span><br><span class="line"></span><br><span class="line">1.8.1 人工神经网络（53）</span><br><span class="line"></span><br><span class="line">1.8.2 遗传算法（55）</span><br><span class="line"></span><br><span class="line">1.9 混合系统与多策略学习（57）</span><br><span class="line"></span><br><span class="line">1.9.1 熵网络（58）</span><br><span class="line"></span><br><span class="line">1.9.2 基于知识的神经网络（59）</span><br><span class="line"></span><br><span class="line">1.9.3 AQ泛化中的遗传搜索（60）</span><br><span class="line"></span><br><span class="line">1.9.4 GA与神经网络的结合（61）</span><br><span class="line"></span><br><span class="line">1.10 展望（61）</span><br><span class="line"></span><br><span class="line">参考文献（62）</span><br><span class="line"></span><br><span class="line">第2章 数据挖掘与知识发现：对问题和多策略方法的回顾（65）</span><br><span class="line"></span><br><span class="line">2.1 前言（65）</span><br><span class="line"></span><br><span class="line">2.2 机器学习与多策略数据分析（67）</span><br><span class="line"></span><br><span class="line">2.2.1 从具体实例中抽取通用规则（68）</span><br><span class="line"></span><br><span class="line">2.2.2 概念聚类（72）</span><br><span class="line"></span><br><span class="line">2.2.3 构造性归纳（73）</span><br><span class="line"></span><br><span class="line">2.2.4 选择有性的样本（74）</span><br><span class="line"></span><br><span class="line">2.2.5 定性与定量结合的发现（75）</span><br><span class="line"></span><br><span class="line">2.2.6 定性预测（75）</span><br><span class="line"></span><br><span class="line">2.2.7 基于机器学习方法的总结（77）</span><br><span class="line"></span><br><span class="line">2.3 数据分析任务中的分类（78）</span><br><span class="line"></span><br><span class="line">2.4 INLEN中各操作的集成（81）</span><br><span class="line"></span><br><span class="line">2.5 聚类和学习操作的说明（84）</span><br><span class="line"></span><br><span class="line">2.6 数据与规则的可视化（86）</span><br><span class="line"></span><br><span class="line">2.7 结构属性的规则学习（89）</span><br><span class="line"></span><br><span class="line">2.8 从决策规则中学习决策结构（91）</span><br><span class="line"></span><br><span class="line">2.9 表示空间的自动改善（93）</span><br><span class="line"></span><br><span class="line">2.9.1 确定相关的属性（93）</span><br><span class="line"></span><br><span class="line">2.9.2 新属性的产生（94）</span><br><span class="line"></span><br><span class="line">2.10 应用展示：经济与人口统计数据中的发现（94）</span><br><span class="line"></span><br><span class="line">2.10.1 背景（94）</span><br><span class="line"></span><br><span class="line">2.10.2 实验1：多操作的集成（95）</span><br><span class="line"></span><br><span class="line">2.10.3 实验2：子群中的异常识别（96）</span><br><span class="line"></span><br><span class="line">2.10.4 实验3：利用结构属性（97）</span><br><span class="line"></span><br><span class="line">2.10.5 实验4：利用构造性归纳运算操作（99）</span><br><span class="line"></span><br><span class="line">2.11 总结（100）</span><br><span class="line"></span><br><span class="line">参考文献 （101）</span><br><span class="line"></span><br><span class="line">第3章 机器学习在多个领域的应用（102）</span><br><span class="line"></span><br><span class="line">第4章 归纳逻辑编程的应用（120）</span><br><span class="line"></span><br><span class="line">第2部分 设计与工程</span><br><span class="line"></span><br><span class="line">第5章 机器学习在有限元计算中的应用（134）</span><br><span class="line"></span><br><span class="line">第6章 归纳学习和基于事例的推理在工业机器故障检测方面的应用（159）</span><br><span class="line"></span><br><span class="line">第7章 经验装配序列规划：多策略构造学习方法（170）</span><br><span class="line"></span><br><span class="line">第8章 归纳学习设计入门：关于防摩擦轴承系统的</span><br><span class="line"></span><br><span class="line">第3部分 文本、图像和音乐模式的测定</span><br><span class="line"></span><br><span class="line">第9章 找出文本之间的关联（202）</span><br><span class="line"></span><br><span class="line">0章 学习图像中的模式（220）</span><br><span class="line"></span><br><span class="line">1章 机器学习在音乐研究领域的应用：深入音乐表达现象的经验调查（246）</span><br><span class="line"></span><br><span class="line">第4部分 计算机系统和控制系统</span><br><span class="line"></span><br><span class="line">2章 网页哨兵：万维网页学习者（274）</span><br><span class="line"></span><br><span class="line">3章 计算机病毒的生物启发式防御（288）</span><br><span class="line"></span><br><span class="line">4章 控制技术的行为（308）</span><br><span class="line"></span><br><span class="line">5章 空中交通控制一阶知识的获取（327）</span><br><span class="line"></span><br><span class="line">第5部分 医学和生物学</span><br><span class="line"></span><br><span class="line">6章 机器学习在医学诊断中的应用（366）</span><br><span class="line"></span><br><span class="line">7章 学习对生物医学信号进行分类（383）</span><br><span class="line"></span><br><span class="line">8章 机器学习在河流水质的生物分类中的应用（402）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>计算机程序设计艺术(第一卷) PDF</title>
    <url>/posts/a6232799/</url>
    <content><![CDATA[<h4 id="《计算机程序设计艺术-第一卷-》"><a href="#《计算机程序设计艺术-第一卷-》" class="headerlink" title="《计算机程序设计艺术(第一卷)》"></a>《计算机程序设计艺术(第一卷)》</h4><h6 id="链接-https-pan-baidu-com-s-1NMrn-qijPaLsuCiNUUF5Kw-提取码-5qgb"><a href="#链接-https-pan-baidu-com-s-1NMrn-qijPaLsuCiNUUF5Kw-提取码-5qgb" class="headerlink" title="链接: https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw 提取码: 5qgb"></a>链接: <a href="https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw">https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw</a> 提取码: 5qgb</h6><p>《计算机程序设计艺术》系列是认可的计算机科学领域经典之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。本书是该系列的 卷，讲解基本算法，其中包含了其他各卷都需用到的基本内容。本卷从基本概念开始，然后讲述信息结构，并辅以大量的习题及答案。<br><a id="more"></a></p>
<p><img src="/images/d1951ba2479d2de11eafe0112721d47c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">●章基本概念1</span><br><span class="line"></span><br><span class="line">1.1算法.1</span><br><span class="line"></span><br><span class="line">1.2数学准备.8</span><br><span class="line"></span><br><span class="line">1.2.1数学归纳法.8</span><br><span class="line"></span><br><span class="line">1.2.2数、幂和对数16</span><br><span class="line"></span><br><span class="line">1.2.3和与积.21</span><br><span class="line"></span><br><span class="line">1.2.4整数函数与初等数论30</span><br><span class="line"></span><br><span class="line">1.2.5排列与阶乘.35</span><br><span class="line"></span><br><span class="line">1.2.6二项式系数.41</span><br><span class="line"></span><br><span class="line">1.2.7调和数.59</span><br><span class="line"></span><br><span class="line">1.2.8斐波那契数.62</span><br><span class="line"></span><br><span class="line">1.2.9生成函数69</span><br><span class="line"></span><br><span class="line">1.2.10典型算法分析76</span><br><span class="line"></span><br><span class="line">*1.2.11渐近表示85</span><br><span class="line"></span><br><span class="line">*1.2.11.1大O记号85</span><br><span class="line"></span><br><span class="line">*1.2.11.2欧拉求和公式.88</span><br><span class="line"></span><br><span class="line">*1.2.11.3若干渐近计算式92</span><br><span class="line"></span><br><span class="line">1.3MIX99</span><br><span class="line"></span><br><span class="line">1.3.1MIX的描述99</span><br><span class="line"></span><br><span class="line">1.3.2MIX汇编语言.116</span><br><span class="line"></span><br><span class="line">1.3.3排列的应用.131</span><br><span class="line"></span><br><span class="line">1.4若干基本程序设计技术150</span><br><span class="line"></span><br><span class="line">1.4.1子程序.150</span><br><span class="line"></span><br><span class="line">1.4.2协同程序155</span><br><span class="line"></span><br><span class="line">1.4.3解释程序161</span><br><span class="line"></span><br><span class="line">1.4.3.1MIX模拟程序.162</span><br><span class="line"></span><br><span class="line">*1.4.3.2追踪程序171</span><br><span class="line"></span><br><span class="line">1.4.4输入与输出.173</span><br><span class="line"></span><br><span class="line">1.4.5历史和参考文献.184</span><br><span class="line"></span><br><span class="line">第2章信息结构187</span><br><span class="line"></span><br><span class="line">2.1引论.187</span><br><span class="line"></span><br><span class="line">2.2线性表191</span><br><span class="line"></span><br><span class="line">2.2.1栈、队列和双端队列191</span><br><span class="line"></span><br><span class="line">2.2.2顺序分配195</span><br><span class="line"></span><br><span class="line">2.2.3链接分配203</span><br><span class="line"></span><br><span class="line">2.2.4循环链表217</span><br><span class="line"></span><br><span class="line">2.2.5双链表.222</span><br><span class="line"></span><br><span class="line">2.2.6数组与正交表237</span><br><span class="line"></span><br><span class="line">2.3树245</span><br><span class="line"></span><br><span class="line">2.3.1遍历二树.253</span><br><span class="line"></span><br><span class="line">2.3.2树的二树表示.265</span><br><span class="line"></span><br><span class="line">2.3.3树的其他表示276</span><br><span class="line"></span><br><span class="line">2.3.4树的基本数学性质.287</span><br><span class="line"></span><br><span class="line">2.3.4.1自由树.287</span><br><span class="line"></span><br><span class="line">2.3.4.2定向树.294</span><br><span class="line"></span><br><span class="line">*2.3.4.3无限性引理.301</span><br><span class="line"></span><br><span class="line">*2.3.4.4树的枚举304</span><br><span class="line"></span><br><span class="line">2.3.4.5路径长度314</span><br><span class="line"></span><br><span class="line">*2.3.4.6历史和参考文献320</span><br><span class="line"></span><br><span class="line">2.3.5表和垃圾回收322</span><br><span class="line"></span><br><span class="line">2.4多链结构.333</span><br><span class="line"></span><br><span class="line">2.5动态存储分配.342</span><br><span class="line"></span><br><span class="line">2.6历史和参考文献358</span><br><span class="line"></span><br><span class="line">习题答案.3</span><br><span class="line"></span><br><span class="line">附录A数值表494</span><br><span class="line"></span><br><span class="line">附录B记号索引.498</span><br><span class="line"></span><br><span class="line">附录C算法和定理索引.502</span><br><span class="line"></span><br><span class="line">人名索引.503</span><br><span class="line"></span><br><span class="line">索引.508</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>计算机程序设计艺术(第二卷) PDF</title>
    <url>/posts/d124170f/</url>
    <content><![CDATA[<h4 id="《计算机程序设计艺术-第二卷-》"><a href="#《计算机程序设计艺术-第二卷-》" class="headerlink" title="《计算机程序设计艺术(第二卷)》"></a>《计算机程序设计艺术(第二卷)》</h4><h6 id="链接-https-pan-baidu-com-s-1cFeVVtNOWGbriu8-qcL-zQ-提取码-8rsz"><a href="#链接-https-pan-baidu-com-s-1cFeVVtNOWGbriu8-qcL-zQ-提取码-8rsz" class="headerlink" title="链接: https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ 提取码: 8rsz"></a>链接: <a href="https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ">https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ</a> 提取码: 8rsz</h6><p>　《计算机程序设计艺术》系列被公认为计算机科学领域的杰出之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。本卷为系列的第2卷，全面讲解了半数值算法，分“随机数”和“算术”两章。书中总结了主要算法范例及这些算法的基本理论，广泛剖析了计算机程序设计与数值分析间的相互联系。<br><a id="more"></a></p>
<p><img src="/images/9ad65d24234ea86d578e7b034719f06e1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第3 章随机数 1</span><br><span class="line"></span><br><span class="line">3．1．　引言　1</span><br><span class="line"></span><br><span class="line">3．2．　生成均匀的随机数　8</span><br><span class="line"></span><br><span class="line">3．2．1．　线性同余法　8</span><br><span class="line"></span><br><span class="line">3．2．1．1．　模的选择　9</span><br><span class="line"></span><br><span class="line">3．2．1．2．　乘数的选择　13</span><br><span class="line"></span><br><span class="line">3．2．1．3．　势　18</span><br><span class="line"></span><br><span class="line">3．2．2．　其他方法　20</span><br><span class="line"></span><br><span class="line">3．3．　统计检验　32</span><br><span class="line"></span><br><span class="line">3．3．1．　研究随机数据的一般检验过程　32</span><br><span class="line"></span><br><span class="line">3．3．2．　经验检验　46</span><br><span class="line"></span><br><span class="line">*3．3．3．　理论检验　60</span><br><span class="line"></span><br><span class="line">3．3．4．　谱检验　70</span><br><span class="line"></span><br><span class="line">3．4．　其他类型的随机量　90</span><br><span class="line"></span><br><span class="line">3．4．1．　数值分布　90</span><br><span class="line"></span><br><span class="line">3．4．2．　随机抽样和洗牌　107</span><br><span class="line"></span><br><span class="line">*3．5．　什么是随机序列？　113</span><br><span class="line"></span><br><span class="line">3．6．　小结　139</span><br><span class="line"></span><br><span class="line">第4　章算术　147</span><br><span class="line"></span><br><span class="line">4．1．　按位记数系统　147</span><br><span class="line"></span><br><span class="line">4．2．　浮点算术　163</span><br><span class="line"></span><br><span class="line">4．2．1．　单精度计算　163</span><br><span class="line"></span><br><span class="line">4．2．2．　浮点算术的精度　175</span><br><span class="line"></span><br><span class="line">*4．2．3．　双精度计算　188</span><br><span class="line"></span><br><span class="line">4．2．4．　浮点数的分布　194</span><br><span class="line"></span><br><span class="line">4．3．　多精度算术　203</span><br><span class="line"></span><br><span class="line">4．3．1．　经典算法　203</span><br><span class="line"></span><br><span class="line">*4．3．2．　模算术　218</span><br><span class="line"></span><br><span class="line">*4．3．3．　乘法有多快？　225</span><br><span class="line"></span><br><span class="line">4．4．　进制转换　245</span><br><span class="line"></span><br><span class="line">4．5．　有理数算术　254</span><br><span class="line"></span><br><span class="line">4．5．1．　分数　254</span><br><span class="line"></span><br><span class="line">4．5．2．　最大公因数　256</span><br><span class="line"></span><br><span class="line">*4．5．3．　对欧几里得算法的分析 ． ．　274</span><br><span class="line"></span><br><span class="line">4．5．4．　分解素因数　293</span><br><span class="line"></span><br><span class="line">4．6．　多项式算术　324</span><br><span class="line"></span><br><span class="line">4．6．1．　多项式除法　325</span><br><span class="line"></span><br><span class="line">*4．6．2．　多项式的因子分解　340</span><br><span class="line"></span><br><span class="line">4．6．3．　幂的计算　358</span><br><span class="line"></span><br><span class="line">4．6．4．　多项式求值　378</span><br><span class="line"></span><br><span class="line">*4．7．　对幂级数的操作　409</span><br><span class="line"></span><br><span class="line">习题答案　420</span><br><span class="line"></span><br><span class="line">附录A　数值表　572</span><br><span class="line"></span><br><span class="line">附录B　记号索引　576</span><br><span class="line"></span><br><span class="line">附录C　算法和定理索引　580</span><br><span class="line"></span><br><span class="line">人名索引　582</span><br><span class="line"></span><br><span class="line">索引　592</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>计算机程序设计艺术(第三卷) PDF</title>
    <url>/posts/4f4082ac/</url>
    <content><![CDATA[<h4 id="《计算机程序设计艺术-第三卷-》"><a href="#《计算机程序设计艺术-第三卷-》" class="headerlink" title="《计算机程序设计艺术(第三卷)》"></a>《计算机程序设计艺术(第三卷)》</h4><h6 id="链接-https-pan-baidu-com-s-1cA-niupvuzgQzTLVtsLI3w-提取码-dtwr"><a href="#链接-https-pan-baidu-com-s-1cA-niupvuzgQzTLVtsLI3w-提取码-dtwr" class="headerlink" title="链接: https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w 提取码: dtwr"></a>链接: <a href="https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w">https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w</a> 提取码: dtwr</h6><p>《计算机程序设计艺术》系列被公认为计算机科学领域的权威之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。MMIX 是新一代的以 RISC 为基础的计算机，比其前身 MIX 更加精简。《计算机程序设计艺术 MMIX增补(图灵出品）》本书由两本小册子合并而成，第一部分描述了 MMIX 的内存、寄存器、指令、加载与存储等基础概念，并介绍了关于 MMIX 的一些基本编程技术；第二部分使用该语言重新实现了 TAOCP 前 3 卷中的所有算法。<br><a id="more"></a></p>
<p>《计算机程序设计艺术》系列深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。《计算机程序设计艺术 卷4A：组合算法（一）(图灵出品) 》本书是该系列的第4卷A，书中主要介绍了组合算法，内容涉及布尔函数、按位操作技巧、元组和排列、组合和分区以及所有的树等。</p>
<p>本书适合从事计算机科学、计算数学等各方面工作的人员阅读，也适合高等院校相关专业的师生作为教学参考书，对于想深入理解计算机算法的读者，是一份必不可少的珍品。</p>
<p>《计算机程序设计艺术》系列被公认为计算机科学领域的经典之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。计算机程序设计艺术 卷3 排序与查找（第2版）(图灵出品)本书为该系列的第3卷，全面讲述了排序和查找算法。书中扩展了卷1中数据结构的处理方法，并对各种算法的效率进行了大量的分析。</p>
<p>　　《计算机程序设计艺术》系列被公认为计算机科学领域的杰出之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。计算机程序设计艺术 卷2 半数值算法（第3版）(图灵出品)本卷为系列的第2卷，全面讲解了半数值算法，分“随机数”和“算术”两章。书中总结了主要算法范例及这些算法的基本理论，广泛剖析了计算机程序设计与数值分析间的相互联系。</p>
<p>　　《计算机程序设计艺术》系列是公认的计算机科学领域经典之作，深入阐述了程序设计理论，对计算机领域的发展有着极为深远的影响。《计算机程序设计艺术（卷1）：基本算法（第3版）(图灵出品)》本书是该系列的第1卷，讲解基本算法，其中包含了其他各卷都需用到的基本内容。本卷从基本概念开始，然后讲述信息结构，并辅以大量的习题及答案。</p>
<p><img src="/images/d6db3fe0c445c86d47b50b4dfa9bcb821.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《计算机程序设计艺术 MMIX增补(图灵出品）》</span><br><span class="line"></span><br><span class="line">第 一部分 计算机程序设计艺术——MMIX： 新千年的精简指令集计算机 1</span><br><span class="line"></span><br><span class="line">致中国读者 2</span><br><span class="line"></span><br><span class="line">前言 3</span><br><span class="line"></span><br><span class="line">第 1章 基本概念 5</span><br><span class="line"></span><br><span class="line">1．3&#39; MMIX 5</span><br><span class="line"></span><br><span class="line">1．3．1&#39; MMIX 概述 5</span><br><span class="line"></span><br><span class="line">1．3．2&#39; MMIX 汇编语言 26</span><br><span class="line"></span><br><span class="line">1．3．3&#39; 排列的应用 46</span><br><span class="line"></span><br><span class="line">1．4&#39; 若干基本程序设计技术 47</span><br><span class="line"></span><br><span class="line">1．4．1&#39; 子程序．47</span><br><span class="line"></span><br><span class="line">1．4．2&#39; 协同程序 58</span><br><span class="line"></span><br><span class="line">1．4．3&#39; 解释程序 63</span><br><span class="line"></span><br><span class="line">习题答案 81</span><br><span class="line"></span><br><span class="line">人名索引 112</span><br><span class="line"></span><br><span class="line">索引 113</span><br><span class="line"></span><br><span class="line">第二部分 MMIX 增补——对高德纳《计算机程序设计艺术》卷1~3的增补 119</span><br><span class="line"></span><br><span class="line">中文版前言 120</span><br><span class="line"></span><br><span class="line">序 121</span><br><span class="line"></span><br><span class="line">前言 122</span><br><span class="line"></span><br><span class="line">风格指南 124</span><br><span class="line"></span><br><span class="line">程序设计技术 127</span><br><span class="line"></span><br><span class="line">第 1章 基本概念 133</span><br><span class="line"></span><br><span class="line">1．3．3 排列的应用 133</span><br><span class="line"></span><br><span class="line">1．4．4 输入与输出 139</span><br><span class="line"></span><br><span class="line">第 2章 信息结构 145</span><br><span class="line"></span><br><span class="line">2．1 引论 145</span><br><span class="line"></span><br><span class="line">2．2．2 顺序分配 147</span><br><span class="line"></span><br><span class="line">2．2．3 链接分配 147</span><br><span class="line"></span><br><span class="line">2．2．4 循环链表 153</span><br><span class="line"></span><br><span class="line">2．2．5 双向链表 155</span><br><span class="line"></span><br><span class="line">2．2．6 数组与正交表 163</span><br><span class="line"></span><br><span class="line">2．3．1 遍历二叉树 164</span><br><span class="line"></span><br><span class="line">2．3．2 树的二叉树表示． 166</span><br><span class="line"></span><br><span class="line">2．3．3 树的其他表示 170</span><br><span class="line"></span><br><span class="line">2．3．5 表和垃圾回收 170</span><br><span class="line"></span><br><span class="line">2．5 动态存储分配 171</span><br><span class="line"></span><br><span class="line">第3章 随机数 174</span><br><span class="line"></span><br><span class="line">3．2．1．1 模的选择 174</span><br><span class="line"></span><br><span class="line">3．2．1．3 势 175</span><br><span class="line"></span><br><span class="line">3．2．2 其他方法 175</span><br><span class="line"></span><br><span class="line">3．4．1 数值分布 177</span><br><span class="line"></span><br><span class="line">3．6 小结 177</span><br><span class="line"></span><br><span class="line">第4章 算术 178</span><br><span class="line"></span><br><span class="line">4．1 按位计数系统 178</span><br><span class="line"></span><br><span class="line">4．2．1 单精度计算 178</span><br><span class="line"></span><br><span class="line">4．2．2 浮点算术的精度 182</span><br><span class="line"></span><br><span class="line">4．2．3 双精度计算 182</span><br><span class="line"></span><br><span class="line">4．3．1 经典算法 186</span><br><span class="line"></span><br><span class="line">4．4 进制转换 191</span><br><span class="line"></span><br><span class="line">4．5．2 最大公因数 193</span><br><span class="line"></span><br><span class="line">4．5．3 对欧几里得算法的分析 194</span><br><span class="line"></span><br><span class="line">4．5．4 分解素因数 194</span><br><span class="line"></span><br><span class="line">4．6．3 幂的计算 195</span><br><span class="line"></span><br><span class="line">4．6．4 多项式求值 195</span><br><span class="line"></span><br><span class="line">第5章 排序 196</span><br><span class="line"></span><br><span class="line">5．2 内部排序 196</span><br><span class="line"></span><br><span class="line">5．2．1 插入排序 197</span><br><span class="line"></span><br><span class="line">5．2．2 交换排序 202</span><br><span class="line"></span><br><span class="line">5．2．3 选择排序 207</span><br><span class="line"></span><br><span class="line">5．2．4 合并排序 210</span><br><span class="line"></span><br><span class="line">5．2．5 分布排序 213</span><br><span class="line"></span><br><span class="line">5．3．1 比较次数最少的排序 215</span><br><span class="line"></span><br><span class="line">5．5 小结、历史与文献 215</span><br><span class="line"></span><br><span class="line">第6章 查找 217</span><br><span class="line"></span><br><span class="line">6．1 顺序查找 217</span><br><span class="line"></span><br><span class="line">6．2．1 查找有序表 219</span><br><span class="line"></span><br><span class="line">6．2．2 二叉树查找 221</span><br><span class="line"></span><br><span class="line">6．2．3 平衡树 222</span><br><span class="line"></span><br><span class="line">6．3 数字查找 225</span><br><span class="line"></span><br><span class="line">6．4 散列 227</span><br><span class="line"></span><br><span class="line">习题答案 235</span><br><span class="line"></span><br><span class="line">1．3．2 MMIX 汇编语言 235</span><br><span class="line"></span><br><span class="line">1．3．3 排列的应用 238</span><br><span class="line"></span><br><span class="line">1．4．4 输入与输出 238</span><br><span class="line"></span><br><span class="line">2．1 引论 240</span><br><span class="line"></span><br><span class="line">2．2．2 顺序分配 241</span><br><span class="line"></span><br><span class="line">2．2．3 链接分配 242</span><br><span class="line"></span><br><span class="line">2．2．4 循环链表 245</span><br><span class="line"></span><br><span class="line">2．2．5 双向链表 247</span><br><span class="line"></span><br><span class="line">2．2．6 数组与正交表 249</span><br><span class="line"></span><br><span class="line">2．3．1 遍历二叉树 251</span><br><span class="line"></span><br><span class="line">2．3．2 树的二叉树表示 253</span><br><span class="line"></span><br><span class="line">2．3．5 表和垃圾回收 256</span><br><span class="line"></span><br><span class="line">2．5 动态存储分配 257</span><br><span class="line"></span><br><span class="line">3．2．1．1 模的选择 264</span><br><span class="line"></span><br><span class="line">3．2．1．3 势 265</span><br><span class="line"></span><br><span class="line">3．2．2 其他方法 265</span><br><span class="line"></span><br><span class="line">3．4．1 数值分布 266</span><br><span class="line"></span><br><span class="line">3．6 小结 266</span><br><span class="line"></span><br><span class="line">4．1 按位计数系统 267</span><br><span class="line"></span><br><span class="line">4．2．1 单精度计算 267</span><br><span class="line"></span><br><span class="line">4．2．2 浮点算术的精度 269</span><br><span class="line"></span><br><span class="line">4．2．3 双精度计算 270</span><br><span class="line"></span><br><span class="line">4．3．1 经典算法 272</span><br><span class="line"></span><br><span class="line">4．4 进制转换 274</span><br><span class="line"></span><br><span class="line">4．5．2 最大公因数 276</span><br><span class="line"></span><br><span class="line">4．5．3 对欧几里得算法的分析 276</span><br><span class="line"></span><br><span class="line">4．6．3 幂的计算 277</span><br><span class="line"></span><br><span class="line">4．6．4 多项式求值 277</span><br><span class="line"></span><br><span class="line">5 排序 278</span><br><span class="line"></span><br><span class="line">5．2 内部排序 278</span><br><span class="line"></span><br><span class="line">5．2．1 插入排序 281</span><br><span class="line"></span><br><span class="line">5．2．2 交换排序 284</span><br><span class="line"></span><br><span class="line">5．2．3 选择排序 289</span><br><span class="line"></span><br><span class="line">5．2．4 合并排序 290</span><br><span class="line"></span><br><span class="line">5．2．5 分布排序 294</span><br><span class="line"></span><br><span class="line">5．3．1 比较次数最少的排序 295</span><br><span class="line"></span><br><span class="line">5．5 小结、历史与文献 298</span><br><span class="line"></span><br><span class="line">6．1 顺序查找 298</span><br><span class="line"></span><br><span class="line">6．2．1 查找有序表 299</span><br><span class="line"></span><br><span class="line">6．2．2 二叉树查找 299</span><br><span class="line"></span><br><span class="line">6．2．3 平衡树 300</span><br><span class="line"></span><br><span class="line">6．3 数字查找 300</span><br><span class="line"></span><br><span class="line">6．4 散列 300</span><br><span class="line"></span><br><span class="line">致谢 302</span><br><span class="line"></span><br><span class="line">人名索引 303</span><br><span class="line"></span><br><span class="line">索引 304</span><br><span class="line"></span><br><span class="line">《计算机程序设计艺术 卷4A：组合算法（一）(图灵出品) 》</span><br><span class="line"></span><br><span class="line">第7 章组合查找 1</span><br><span class="line"></span><br><span class="line">7．1 0 与1 38</span><br><span class="line"></span><br><span class="line">7．1．1 布尔代数基础 38</span><br><span class="line"></span><br><span class="line">7．1．2 布尔函数求值 79</span><br><span class="line"></span><br><span class="line">7．1．3 按位运算的技巧与方法 110</span><br><span class="line"></span><br><span class="line">7．1．4 二元决策图 170</span><br><span class="line"></span><br><span class="line">7．2 生成所有可能的组合对象 237</span><br><span class="line"></span><br><span class="line">7．2．1 生成基本组合模式 237</span><br><span class="line"></span><br><span class="line">7．2．1．1 生成所有n 元组 237</span><br><span class="line"></span><br><span class="line">7．2．1．2 生成所有排列 268</span><br><span class="line"></span><br><span class="line">7．2．1．3 生成所有组合 297</span><br><span class="line"></span><br><span class="line">7．2．1．4 生成所有分划 327</span><br><span class="line"></span><br><span class="line">7．2．1．5 生成所有集合分划 349</span><br><span class="line"></span><br><span class="line">7．2．1．6 生成所有树 370</span><br><span class="line"></span><br><span class="line">7．2．1．7 历史与扩展文献 408</span><br><span class="line"></span><br><span class="line">习题答案 427</span><br><span class="line"></span><br><span class="line">附录A 数值表 686</span><br><span class="line"></span><br><span class="line">附录B 记号索引 690</span><br><span class="line"></span><br><span class="line">附录C 算法和定理索引 695</span><br><span class="line"></span><br><span class="line">附录D 组合问题索引 696</span><br><span class="line"></span><br><span class="line">人名索引 700</span><br><span class="line"></span><br><span class="line">索引 716</span><br><span class="line"></span><br><span class="line">计算机程序设计艺术（卷1）：基本算法（第3版）(图灵出品)</span><br><span class="line"></span><br><span class="line">计算机程序设计艺术 卷2 半数值算法（第3版）(图灵出品)</span><br><span class="line"></span><br><span class="line">计算机程序设计艺术 卷3 排序与查找（第2版）(图灵出品)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>精通正则表达式 PDF</title>
    <url>/posts/3847b23a/</url>
    <content><![CDATA[<h4 id="《精通正则表达式》"><a href="#《精通正则表达式》" class="headerlink" title="《精通正则表达式》"></a>《精通正则表达式》</h4><h6 id="链接-https-pan-baidu-com-s-18NhdlOz7r8ICwTfsKWp7Rw-提取码-d762"><a href="#链接-https-pan-baidu-com-s-18NhdlOz7r8ICwTfsKWp7Rw-提取码-d762" class="headerlink" title="链接: https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw 提取码: d762"></a>链接: <a href="https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw">https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw</a> 提取码: d762</h6><p>随着互联网的迅速发展，几乎所有工具软件和程序语言都支持的正则表达式也变得越来越强大和易于使用。《精通正则表达式（第3版）》是讲解正则表达式的经典之作。《精通正则表达式（第3版）》主要讲解了正则表达式的特性和流派、匹配原理、优化原则、实用诀窍以及调校措施，并详细介绍了在Perl、Java、.NET、PHP中正则表达式的用法。<br><a id="more"></a></p>
<p>　　《精通正则表达式（第3版）》自版开始着力于教会读者 “以正则表达式来思考”，来让读者真正“精通”正则表达式。该版对PHP的相关内容、Java1.5和Java1.6的新特性作了可观的扩充讲解。任何有机会使用正则表达式的读者都将因《精通正则表达式（第3版）》而受益匪浅。</p>
<p><img src="/images/e8071d77a5b70846d317989c67d5b03a1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言章 正则表达式入门</span><br><span class="line"></span><br><span class="line">第2章 入门示例拓展</span><br><span class="line"></span><br><span class="line">第3章 正则表达式的特性和流派概览</span><br><span class="line"></span><br><span class="line">第4章 表达式的匹配原理</span><br><span class="line"></span><br><span class="line">第5章 正则表达式实用技巧</span><br><span class="line"></span><br><span class="line">第6章 打造高效正则表达式</span><br><span class="line"></span><br><span class="line">第7章 Perl</span><br><span class="line"></span><br><span class="line">第8章 Java</span><br><span class="line"></span><br><span class="line">第9章 .NET0章 PHP索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>浪潮之巅(完整版) PDF</title>
    <url>/posts/a14ee380/</url>
    <content><![CDATA[<h4 id="《浪潮之巅-完整版-》"><a href="#《浪潮之巅-完整版-》" class="headerlink" title="《浪潮之巅(完整版)》"></a>《浪潮之巅(完整版)》</h4><h6 id="链接-https-pan-baidu-com-s-1d2F7DJYZobwXbBAIBX2JFA-提取码-r5y2"><a href="#链接-https-pan-baidu-com-s-1d2F7DJYZobwXbBAIBX2JFA-提取码-r5y2" class="headerlink" title="链接: https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA 提取码: r5y2"></a>链接: <a href="https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA">https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA</a> 提取码: r5y2</h6><p>一本颠覆人们对信息时代的认识、对创新和创业的理解的好书。作者吴军通过介绍硅谷成功的秘诀，揭示了信息时代的特点和方法论。<br><a id="more"></a></p>
<p>　　近年来，吴军从技术和管理人员变成了投资人，他对IT领域，尤其是对科技创新因而有了更深入的了解。他根据这些年在硅谷所获得的一手资料，结合自己的思考，回答了长期以来令大家深感困惑的一个不解之谜，那就是——为什么硅谷在全世界其他地区难以复制？</p>
<p>　　在《硅谷之谜》中，吴军站在一个更高的层次，仔细分析了硅谷的起源和发展，对硅谷的创新力进行了深刻剖析，把硅谷的经验提升到了理论高度，并且解释了为什么只有硅谷真正做到了宽容叛逆、宽容失败、多元文化和拒绝平庸。这些特点造就了硅谷几十年的长盛不衰。</p>
<p><img src="/images/f397a25fdd8b0fc9b0270864bbd339421.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">I 序 言 为什么硅谷难以复制？</span><br><span class="line"></span><br><span class="line">VIII 前 言 从《浪潮之巅》到《硅谷之谜》</span><br><span class="line"></span><br><span class="line">1 第一章 硅谷的奇迹</span><br><span class="line"></span><br><span class="line">硅谷地区面积狭小，人口只占美国总人口的1.5%。但是，就是这样一个地区却创造出了人类科技史和工业史上的奇迹。这些传奇故事每天都在发生，那些传奇人物每天都在不断地涌现。硅谷始终不竭的创新活力，吸引着世界的目光，让人渴望探知“庐山真面目”。</span><br><span class="line"></span><br><span class="line">第一节　硅谷的明星公司</span><br><span class="line"></span><br><span class="line">第二节　硅谷的顶尖大学</span><br><span class="line"></span><br><span class="line">第三节　硅谷的风险投资</span><br><span class="line"></span><br><span class="line">第四节　硅谷的产业变迁</span><br><span class="line"></span><br><span class="line">36 第二章 宛若似真的分析</span><br><span class="line"></span><br><span class="line">为什么硅谷会出现在旧金山湾区？为什么全世界其他的地方难以复制它的模式，或者说没有出现一个可以和它匹敌的创新中心？目前，各种媒体在分析硅谷时，都做了一些人为的取舍和缩放，故意放大那些冠冕堂皇却并非关键的原因，却又把一些非常重要而拿不上台面的原因给回避掉了，这便产生了误导，以至于很多科技园在试图复制硅谷时都难以成功。</span><br><span class="line"></span><br><span class="line">第一节　硅谷成功的气候说</span><br><span class="line"></span><br><span class="line">第二节　斯坦福之说</span><br><span class="line"></span><br><span class="line">第三节　风险投资说</span><br><span class="line"></span><br><span class="line">第四节　政府扶持说</span><br><span class="line"></span><br><span class="line">第五节　知识产权保护说</span><br><span class="line"></span><br><span class="line">第六节　波士顿地区并没有出现硅谷</span><br><span class="line"></span><br><span class="line">61 第三章 硅谷的起源</span><br><span class="line"></span><br><span class="line">IBM公司恰巧在计算机技术刚刚起步时就在美国西海岸开设了研发中心，从而让旧金山湾区占到了天时；而当时在世界气候最好的地方居然空着几十平方公里的土地，可以提供给未来的新技术公司使用，因此又占到了地利；一个诺贝尔奖获得者靠自己的名气聚拢了一批世界上最优秀的技术人才，然后又把他们赶出去办了公司，这件事为湾区日后成为硅谷准备好了人的因素。</span><br><span class="line"></span><br><span class="line">第一节　硅谷前传</span><br><span class="line"></span><br><span class="line">第二节　天时与地利</span><br><span class="line"></span><br><span class="line">第三节　怪才和叛徒</span><br><span class="line"></span><br><span class="line">第四节　仙童公司</span><br><span class="line"></span><br><span class="line">84 第四章 硅谷的发展</span><br><span class="line"></span><br><span class="line">硅谷在3.0时代比以往任何时候都更繁荣，以至于在2008—2009年全球金融危机时它可以独善其身，这似乎已经跳出了世界各地区都难以避免的“从兴起，到繁荣，再到衰落”的周期律。在硅谷3.0时代，创业不再是一件难事，创业者们只要做好两件事即可：第一，想出真正有创新的点子，并拥有过硬的技术；第二，以最快的速度去实现它。</span><br><span class="line"></span><br><span class="line">第一节　硅谷1.0 ——信息革命的前夜</span><br><span class="line"></span><br><span class="line">第二节　硅谷2.0 ——信息时代</span><br><span class="line"></span><br><span class="line">第三节　硅谷风险投资自身的发展</span><br><span class="line"></span><br><span class="line">第四节　硅谷3.0 — 后互联网时代</span><br><span class="line"></span><br><span class="line">126 第五章 硅谷的奥秘（上）—— 硅谷的独特之处</span><br><span class="line"></span><br><span class="line">外界谈论硅谷时，总是会提到“车库文化”这样一个名词，因为在早期一些介绍硅谷的文章和书中是这样宣传的。其大意是，一些辞职的员工（或尚未全职工作过的年轻人），为了节省办公成本，租下一户人家的车库作为办公室来创业，最后获得了成功。这个说法颇具误导性，是关于硅谷的几个大谎言之一，因为大部分从硅谷走出的伟大公司都不是这样办起来的。</span><br><span class="line"></span><br><span class="line">第一节　叛逆和宽容</span><br><span class="line"></span><br><span class="line">第二节　多元文化</span><br><span class="line"></span><br><span class="line">第三节　拒绝平庸</span><br><span class="line"></span><br><span class="line">168 第六章 硅谷的奥秘（下）— 硅谷的企业文化和情怀</span><br><span class="line"></span><br><span class="line">硅谷的人们常常会用一种试错法来尝试新的东西，那里的人们常常开动脑子把很多可能性都想到后，不断尝试，直到成功。采用这种方法去创新，需要有人为失败买单，这些买单者通常是大公司、风险投资机构和做事情的那些人。宽容失败带来的好处是，创新者会走通其他人不敢走的路。</span><br><span class="line"></span><br><span class="line">第一节　宽容失败的文化</span><br><span class="line"></span><br><span class="line">第二节　工程师文化</span><br><span class="line"></span><br><span class="line">第三节　不迷信权威</span><br><span class="line"></span><br><span class="line">第四节　扁平式管理</span><br><span class="line"></span><br><span class="line">第五节　世界的情怀</span><br><span class="line"></span><br><span class="line">201 第七章 工业时代的科学基础</span><br><span class="line"></span><br><span class="line">思维的形成需要时间，摆脱对一种思维的依赖同样需要时间。虽然现在已经是信息时代，很多人也言必称信息时代，但是其思维和行为方式依然难以摆脱工业时代形成的拥有生产资料的那种优越感。比如很多地方政府在创办科技园时以提供免费场地作为吸引人才的诱饵，骨子里便还是认定场地这种生产资料在经营活动中会起决定性作用，而真正伟大的公司却不是这样扶植出来的。</span><br><span class="line"></span><br><span class="line">第一节　牛顿和机械思维</span><br><span class="line"></span><br><span class="line">第二节　泰勒管理理论</span><br><span class="line"></span><br><span class="line">第三节　现代工业企业管理制度剖析</span><br><span class="line"></span><br><span class="line">229 第八章 信息时代的科学基础</span><br><span class="line"></span><br><span class="line">对于信息时代企业和商业出现的各种现象，很容易用系统论、信息论和控制论解释清楚。硅谷有幸诞生在三论被提出之后，因此它采用了一种全新的方法论来指导其发展，这是硅谷成功的根本原因。硅谷成功的奥秘对于中国的借鉴意义在于，我们需要需要承认各种不确定性，需要利用数据和信息消除它们，而不是采用过去那种顶层设计的方式去解决问题。</span><br><span class="line"></span><br><span class="line">第一节　三论与管理</span><br><span class="line"></span><br><span class="line">第二节　 从预测到反应，从局部到整体，从控制到通信</span><br><span class="line"></span><br><span class="line">第三节　信息时代的企业制度剖析</span><br><span class="line"></span><br><span class="line">第四节　大数据思维和互联网思维的本质</span><br><span class="line"></span><br><span class="line">279 索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>码出高效Java开发手册 PDF</title>
    <url>/posts/d649d316/</url>
    <content><![CDATA[<h4 id="《码出高效Java开发手册》"><a href="#《码出高效Java开发手册》" class="headerlink" title="《码出高效Java开发手册》"></a>《码出高效Java开发手册》</h4><h6 id="链接-https-pan-baidu-com-s-1j0R1BBAhdW4kaXQhrpo7jg-提取码-sqhe"><a href="#链接-https-pan-baidu-com-s-1j0R1BBAhdW4kaXQhrpo7jg-提取码-sqhe" class="headerlink" title="链接: https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg 提取码: sqhe"></a>链接: <a href="https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg">https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg</a> 提取码: sqhe</h6><p>《码出高效：Java 开发手册》源于影响了全球250万名开发工程师的《阿里巴巴Java开发手册》，作者静心沉淀，对Java规约的来龙去脉进行了全面而彻底的内容梳理。《码出高效：Java 开发手册》以实战为中心，以新颖的角度全面阐述面向对象理论，逐步深入地探索怎样成为一位优秀开发工程师。比如：如何驾轻就熟地使用各类集合框架；如何得心应手地处理高并发多线程问题；如何顺其自然地写出可读性强、可维护性好的优雅代码。<br><a id="more"></a></p>
<p>《码出高效：Java 开发手册》旁征博引、文风轻松，秉持“图胜于表，表胜于言”的理念，深入浅出地将计算机基础、面向对象思想、JVM探源、数据结构与集合、并发与多线程、单元测试等知识客观、立体地呈现出来。紧扣学以致用、学以精进的目标，结合阿里巴巴实践经验和故障案例，与底层源码解析融会贯通，娓娓道来。</p>
<p>《码出高效：Java 开发手册》以打造民族标杆图书为己任，打磨精品，在技术广度和深度上兼具极强的参考性，适合计算机相关行业的管理者和研发人员、高等院校的计算机专业师生等阅读。无论是初学者入门，或是中、高级程序员的进阶提升，《码出高效：Java 开发手册》均为不容置疑的选择。</p>
<p><img src="/images/c550acc4e995998bab3e534f753df90c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1 章 计算机基础</span><br><span class="line"></span><br><span class="line">1.1 走进0 与1 的世界</span><br><span class="line"></span><br><span class="line">1.2 浮点数</span><br><span class="line"></span><br><span class="line">1.2.1 科学计数法</span><br><span class="line"></span><br><span class="line">1.2.2 浮点数表示</span><br><span class="line"></span><br><span class="line">1.2.3 加减运算</span><br><span class="line"></span><br><span class="line">1.2.4 浮点数使用</span><br><span class="line"></span><br><span class="line">1.3 字符集与乱码</span><br><span class="line"></span><br><span class="line">1.4 CPU 与内存</span><br><span class="line"></span><br><span class="line">1.5 TCP&#x2F;IP</span><br><span class="line"></span><br><span class="line">1.5.1 网络协议</span><br><span class="line"></span><br><span class="line">1.5.2 IP</span><br><span class="line"></span><br><span class="line">1.5.3 TCP 建立连接</span><br><span class="line"></span><br><span class="line">1.5.4 TCP 断开连接</span><br><span class="line"></span><br><span class="line">1.5.5 连接池</span><br><span class="line"></span><br><span class="line">1.6 信息安全</span><br><span class="line"></span><br><span class="line">1.6.1 黑客与安全</span><br><span class="line"></span><br><span class="line">1.6.2 SQL 注入</span><br><span class="line"></span><br><span class="line">1.6.3 XSS 与CSRF</span><br><span class="line"></span><br><span class="line">1.6.4 CSRF</span><br><span class="line"></span><br><span class="line">1.6.5 HTTPS</span><br><span class="line"></span><br><span class="line">1.7 编程语言的发展</span><br><span class="line"></span><br><span class="line">第2 章 面向对象</span><br><span class="line"></span><br><span class="line">2.1 OOP 理念</span><br><span class="line"></span><br><span class="line">2.2 初识Java</span><br><span class="line"></span><br><span class="line">2.3 类</span><br><span class="line"></span><br><span class="line">2.3.1 类的定义</span><br><span class="line"></span><br><span class="line">2.3.2 接口与抽象类</span><br><span class="line"></span><br><span class="line">2.3.3 内部类</span><br><span class="line"></span><br><span class="line">2.3.4 访问权限控制</span><br><span class="line"></span><br><span class="line">2.3.5 this 与 super</span><br><span class="line"></span><br><span class="line">2.3.6 类关系</span><br><span class="line"></span><br><span class="line">2.3.7 序列化</span><br><span class="line"></span><br><span class="line">2.4 方法</span><br><span class="line"></span><br><span class="line">2.4.1 方法签名</span><br><span class="line"></span><br><span class="line">2.4.2 参数</span><br><span class="line"></span><br><span class="line">2.4.3 构造方法</span><br><span class="line"></span><br><span class="line">2.4.4 类内方法</span><br><span class="line"></span><br><span class="line">2.4.5 getter 与setter</span><br><span class="line"></span><br><span class="line">2.4.6 同步与异步</span><br><span class="line"></span><br><span class="line">2.4.7 覆写</span><br><span class="line"></span><br><span class="line">2.5 重载</span><br><span class="line"></span><br><span class="line">2.6 泛型</span><br><span class="line"></span><br><span class="line">2.7 数据类型</span><br><span class="line"></span><br><span class="line">2.7.1 基本数据类型</span><br><span class="line"></span><br><span class="line">2.7.2 包装类型</span><br><span class="line"></span><br><span class="line">2.7.3 字符串</span><br><span class="line"></span><br><span class="line">第3 章 代码风格</span><br><span class="line"></span><br><span class="line">3.1 命名规约</span><br><span class="line"></span><br><span class="line">3.1.1 常量</span><br><span class="line"></span><br><span class="line">3.1.2 变量</span><br><span class="line"></span><br><span class="line">3.2 代码展示风格</span><br><span class="line"></span><br><span class="line">3.2.1 缩进、空格与空行</span><br><span class="line"></span><br><span class="line">3.2.2 换行与高度</span><br><span class="line"></span><br><span class="line">3.2.3 控制语句</span><br><span class="line"></span><br><span class="line">3.3 代码注释</span><br><span class="line"></span><br><span class="line">3.3.1 注释三要素</span><br><span class="line"></span><br><span class="line">3.3.2 注释格式</span><br><span class="line"></span><br><span class="line">第4 章 走进JVM</span><br><span class="line"></span><br><span class="line">4.1 字节码</span><br><span class="line"></span><br><span class="line">4.2 类加载过程</span><br><span class="line"></span><br><span class="line">4.3 内存布局</span><br><span class="line"></span><br><span class="line">4.4 对象实例化</span><br><span class="line"></span><br><span class="line">4.5 垃圾回收</span><br><span class="line"></span><br><span class="line">第5 章 异常与日志</span><br><span class="line"></span><br><span class="line">5.1 异常分类</span><br><span class="line"></span><br><span class="line">5.2 try 代码块</span><br><span class="line"></span><br><span class="line">5.3 异常的抛与接</span><br><span class="line"></span><br><span class="line">5.4 日志</span><br><span class="line"></span><br><span class="line">5.4.1 日志规范</span><br><span class="line"></span><br><span class="line">5.4.2 日志框架</span><br><span class="line"></span><br><span class="line">第6 章 数据结构与集合</span><br><span class="line"></span><br><span class="line">6.1 数据结构</span><br><span class="line"></span><br><span class="line">6.2 集合框架图</span><br><span class="line"></span><br><span class="line">6.2.1 List 集合</span><br><span class="line"></span><br><span class="line">6.2.2 Queue 集合</span><br><span class="line"></span><br><span class="line">6.2.3 Map 集合</span><br><span class="line"></span><br><span class="line">6.2.4 Set</span><br><span class="line"></span><br><span class="line">6.3 集合初始化</span><br><span class="line"></span><br><span class="line">6.4 数组与集合</span><br><span class="line"></span><br><span class="line">6.5 集合与泛型</span><br><span class="line"></span><br><span class="line">6.6 元素的比较</span><br><span class="line"></span><br><span class="line">6.6.1 Comparable 和Comparator</span><br><span class="line"></span><br><span class="line">6.6.2 hashCode 和equals</span><br><span class="line"></span><br><span class="line">6.7 fail-fast 机制</span><br><span class="line"></span><br><span class="line">6.8 Map 类集合</span><br><span class="line"></span><br><span class="line">6.8.1 红黑树</span><br><span class="line"></span><br><span class="line">6.8.2 TreeMap</span><br><span class="line"></span><br><span class="line">6.8.3 HashMap</span><br><span class="line"></span><br><span class="line">6.8.4 ConcurrentHashMap</span><br><span class="line"></span><br><span class="line">第7 章 并发与多线程</span><br><span class="line"></span><br><span class="line">7.1 线程安全</span><br><span class="line"></span><br><span class="line">7.2 什么是锁</span><br><span class="line"></span><br><span class="line">7.3 线程同步</span><br><span class="line"></span><br><span class="line">7.3.1 同步是什么</span><br><span class="line"></span><br><span class="line">7.3.2 volatile</span><br><span class="line"></span><br><span class="line">7.3.3 信号量同步</span><br><span class="line"></span><br><span class="line">7.4 线程池</span><br><span class="line"></span><br><span class="line">7.4.1 线程池的好处</span><br><span class="line"></span><br><span class="line">7.4.2 线程池源码详解</span><br><span class="line"></span><br><span class="line">7.5 ThreadLocal</span><br><span class="line"></span><br><span class="line">7.5.1 引用类型</span><br><span class="line"></span><br><span class="line">7.5.2 ThreadLocal 价值</span><br><span class="line"></span><br><span class="line">7.5.3 ThreadLocal 副作用</span><br><span class="line"></span><br><span class="line">第8 章 单元测试</span><br><span class="line"></span><br><span class="line">8.1 单元测试的基本原则</span><br><span class="line"></span><br><span class="line">8.2 单元测试覆盖率</span><br><span class="line"></span><br><span class="line">8.3 单元测试编写</span><br><span class="line"></span><br><span class="line">8.3.1 JUnit 单元测试框架</span><br><span class="line"></span><br><span class="line">8.3.2 命名</span><br><span class="line"></span><br><span class="line">8.3.3 断言与假设</span><br><span class="line"></span><br><span class="line">第9 章 代码规约</span><br><span class="line"></span><br><span class="line">9.1 代码规约的意义</span><br><span class="line"></span><br><span class="line">9.2 如何推动落地</span><br><span class="line"></span><br><span class="line">9.3 手册纵览</span><br><span class="line"></span><br><span class="line">9.4 聊聊成长</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>鸟哥的LINUX私房菜_基础学习篇(第三版) PDF</title>
    <url>/posts/b68e5af3/</url>
    <content><![CDATA[<h4 id="《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h4><h6 id="链接-https-pan-baidu-com-s-1Qbwa0iB0PMwpTdg3RGpPSA-提取码-c276"><a href="#链接-https-pan-baidu-com-s-1Qbwa0iB0PMwpTdg3RGpPSA-提取码-c276" class="headerlink" title="链接: https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA 提取码: c276"></a>链接: <a href="https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA">https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA</a> 提取码: c276</h6><p>本书是具度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全很好重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。<br><a id="more"></a></p>
<p>本书内容丰富全面，基本概念的讲解很好细致，深入浅出。各种功能和命令的介绍，都配等</p>
<p><img src="/images/c86f47824e459e11d87980ba35d5931c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">●部分  Linux的规则与安装</span><br><span class="line"></span><br><span class="line">  第0章  计算机概论</span><br><span class="line"></span><br><span class="line">  章  Linux是什么</span><br><span class="line"></span><br><span class="line">  第2章  Linux如何学习</span><br><span class="line"></span><br><span class="line">  第3章  主机规划与磁盘分区</span><br><span class="line"></span><br><span class="line">  第4章  安装CentOS 5.x与多重引导小技巧</span><br><span class="line"></span><br><span class="line">  第5章  首次登录与在线求助man page</span><br><span class="line"></span><br><span class="line">第二部分  Linux文件、目录与磁盘格式</span><br><span class="line"></span><br><span class="line">  第6章  Linux的文件权限与目录配置</span><br><span class="line"></span><br><span class="line">  第7章  Linux文件与目录管理</span><br><span class="line"></span><br><span class="line">  第8章  Linux磁盘与文件系统管理</span><br><span class="line"></span><br><span class="line">  第9章  文件与文件系统的压缩与打包</span><br><span class="line"></span><br><span class="line">第三部分  学习shell与shell script</span><br><span class="line"></span><br><span class="line">  0章  vim程序编辑器</span><br><span class="line"></span><br><span class="line">  1章  认识与学习bash</span><br><span class="line"></span><br><span class="line">  2章  正则表达式与文件格式化处理</span><br><span class="line"></span><br><span class="line">  3章  学习shell script</span><br><span class="line"></span><br><span class="line">第四部分  Linux使用者管理</span><br><span class="line"></span><br><span class="line">  4章  Linux账号管理与ACL权限设置</span><br><span class="line"></span><br><span class="line">  5章  磁盘配额(Quota)与不错文件系统管理</span><br><span class="line"></span><br><span class="line">  6章  例行性工作(crontab)</span><br><span class="line"></span><br><span class="line">  7章  程序管理与SELinux初探</span><br><span class="line"></span><br><span class="line">  8章  认识系统服务(daemons)</span><br><span class="line"></span><br><span class="line">  9章  认识与分析日志文件</span><br><span class="line"></span><br><span class="line">第五部分  Linux系统管理员</span><br><span class="line"></span><br><span class="line">  第20章  启动流程、模块管理与Loader</span><br><span class="line"></span><br><span class="line">  第21章  系统设置工具(网络与打印机)与硬件检测</span><br><span class="line"></span><br><span class="line">  第22章  ：源码与Tarball</span><br><span class="line"></span><br><span class="line">  第23章  ：RPM、SRPM与YUM功能</span><br><span class="line"></span><br><span class="line">  第24章  X Window设置介绍</span><br><span class="line"></span><br><span class="line">  第25章  Linux备份策略</span><br><span class="line"></span><br><span class="line">  第26章  Linux内核编译与管理</span><br><span class="line"></span><br><span class="line">附录A  快速索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>鸟哥的Linux私房菜-基础学习篇-第四版 PDF</title>
    <url>/posts/c1896a65/</url>
    <content><![CDATA[<h4 id="《鸟哥的Linux私房菜-基础学习篇-第四版》"><a href="#《鸟哥的Linux私房菜-基础学习篇-第四版》" class="headerlink" title="《鸟哥的Linux私房菜-基础学习篇-第四版》"></a>《鸟哥的Linux私房菜-基础学习篇-第四版》</h4><h6 id="链接-https-pan-baidu-com-s-1ZX-VTrvla6VzrHwI7tRaNg-提取码-x4ej"><a href="#链接-https-pan-baidu-com-s-1ZX-VTrvla6VzrHwI7tRaNg-提取码-x4ej" class="headerlink" title="链接: https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg 提取码: x4ej"></a>链接: <a href="https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg">https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg</a> 提取码: x4ej</h6><p>本书是知名度颇高的Linux入门书《鸟哥的Linux私房菜基础学习篇》的新版，全面而详细地介绍了Linux操作系统。 全书分为五bu分：<em>bu分着重说明计算机的基础知识、Linux的学习方法，如何规划和安装Linux主机以及CentOS 7.x的安装、登录与求助方法；</em>bu分介绍Linux的文件系统、文件、目录与磁盘的管理；第三bu分介绍文字模式接口shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四bu分介绍了对于系统安全非常重要的Linux账号的管理、磁盘配额、<em>文件系统管理、计划任务以及进程管理；第五bu分介绍了系统管理员（root）的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。 本书内容丰富全面，基本概念的讲解非常细致，深入浅出。各种功能和命令的介绍，都配以大量的实例操作和详尽的解析。本书是初学者学习Linux</em>的一本入门好书。<br><a id="more"></a></p>
<p><img src="/images/40215c73b784af7a332114c959b6da6c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 一bu分 Linux的规则与安装  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第0章 计算机概论 2  </span><br><span class="line"></span><br><span class="line">0.1 电脑：辅助人脑的好工具 3  </span><br><span class="line"></span><br><span class="line">0.1.1 电脑硬件的五大单元 3  </span><br><span class="line"></span><br><span class="line">0.1.2 *设计的起点：CPU的架构 5  </span><br><span class="line"></span><br><span class="line">0.1.3 其他单元的设备 6  </span><br><span class="line"></span><br><span class="line">0.1.4 运作流程 6  </span><br><span class="line"></span><br><span class="line">0.1.5 电脑的分类 7  </span><br><span class="line"></span><br><span class="line">0.1.6 电脑上面常用的计算单位（容量、速度等） 8  </span><br><span class="line"></span><br><span class="line">0.2 个人电脑架构与相关设备组件 9  </span><br><span class="line"></span><br><span class="line">0.2.1 执行脑袋运算与判断的CPU 10  </span><br><span class="line"></span><br><span class="line">0.2.2 内存 12  </span><br><span class="line"></span><br><span class="line">0.2.3 显卡 15  </span><br><span class="line"></span><br><span class="line">0.2.4 硬盘与存储设备 16  </span><br><span class="line"></span><br><span class="line">0.2.5 扩展卡与接口 20  </span><br><span class="line"></span><br><span class="line">0.2.6 主板 21  </span><br><span class="line"></span><br><span class="line">0.2.7 主机电源 22  </span><br><span class="line"></span><br><span class="line">0.2.8 选购须知 22  </span><br><span class="line"></span><br><span class="line">0.3 数据表示方式 23  </span><br><span class="line"></span><br><span class="line">0.3.1 数字系统 24  </span><br><span class="line"></span><br><span class="line">0.3.2 字符编码系统 24  </span><br><span class="line"></span><br><span class="line">0.4 软件程序运行 25  </span><br><span class="line"></span><br><span class="line">0.4.1 机器语言程序与编译型程序 25  </span><br><span class="line"></span><br><span class="line">0.4.2 操作系统 26  </span><br><span class="line"></span><br><span class="line">0.4.3 应用程序 28  </span><br><span class="line"></span><br><span class="line">0.5 重点回顾 29  </span><br><span class="line"></span><br><span class="line">0.6 本章习题 29  </span><br><span class="line"></span><br><span class="line">0.7 参考资料与扩展阅读 30  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 1章 Linux是什么与如何学习 32  </span><br><span class="line"></span><br><span class="line">1.1 Linux是什么 33  </span><br><span class="line"></span><br><span class="line">1.1.1 Linux是什么？操作系统 应用程序？ 33  </span><br><span class="line"></span><br><span class="line">1.1.2 Linux之前，UNIX的历史 34  </span><br><span class="line"></span><br><span class="line">1.1.3 关于GNU计划、自由软件与开放源代码 40  </span><br><span class="line"></span><br><span class="line">1.2 托瓦兹的Linux的发展 43  </span><br><span class="line"></span><br><span class="line">1.2.1 与Minix之间 43  </span><br><span class="line"></span><br><span class="line">1.2.2 对386硬件的多任务测试 44  </span><br><span class="line"></span><br><span class="line">1.2.3 初次发布Linux 0.02 45  </span><br><span class="line"></span><br><span class="line">1.2.4 Linux的发展：虚拟团队的产生 46  </span><br><span class="line"></span><br><span class="line">1.2.5 Linux的内核版本 47  </span><br><span class="line"></span><br><span class="line">1.2.6 Linux发行版 48  </span><br><span class="line"></span><br><span class="line">1.3 Linux当前应用的角色 51  </span><br><span class="line"></span><br><span class="line">1.3.1 企业环境的使用 52  </span><br><span class="line"></span><br><span class="line">1.3.2 个人环境的使用 53  </span><br><span class="line"></span><br><span class="line">1.3.3 云端应用 54  </span><br><span class="line"></span><br><span class="line">1.4 Linux该如何学习 55  </span><br><span class="line"></span><br><span class="line">1.4.1 从头学习Linux基础 56  </span><br><span class="line"></span><br><span class="line">1.4.2 选择一本易读的工具书 57  </span><br><span class="line"></span><br><span class="line">1.4.3 实践再实践 58  </span><br><span class="line"></span><br><span class="line">1.4.4 发生问题怎么处理 58  </span><br><span class="line"></span><br><span class="line">1.4.5 鸟哥的建议（重点在solution的学习） 59  </span><br><span class="line"></span><br><span class="line">1.5 重点回顾 60  </span><br><span class="line"></span><br><span class="line">1.6 本章习题 61  </span><br><span class="line"></span><br><span class="line">1.7 参考资料与扩展阅读 62  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 2章 主机规划与磁盘分区 63  </span><br><span class="line"></span><br><span class="line">2.1 Linux与硬件的搭配 64  </span><br><span class="line"></span><br><span class="line">2.1.1 认识计算机的硬件设备 64  </span><br><span class="line"></span><br><span class="line">2.1.2 选择与Linux搭配的主机设备 65  </span><br><span class="line"></span><br><span class="line">2.1.3 各硬件设备在Linux中的文件名 67  </span><br><span class="line"></span><br><span class="line">2.1.4 使用虚拟机学习 68  </span><br><span class="line"></span><br><span class="line">2.2 磁盘分区 69  </span><br><span class="line"></span><br><span class="line">2.2.1 磁盘连接方式与设备文件名的关系 69  </span><br><span class="line"></span><br><span class="line">2.2.2 MBR（MS-DOS）与GPT磁盘分区表（partition table） 70  </span><br><span class="line"></span><br><span class="line">2.2.3 启动流程中的BIOS与UEFI启动检测程序 76  </span><br><span class="line"></span><br><span class="line">2.2.4 Linux安装模式下，磁盘分区的选择（极重要） 79  </span><br><span class="line"></span><br><span class="line">2.3 安装Linux前的规划 82  </span><br><span class="line"></span><br><span class="line">2.3.1 选择适当的Linux发行版 82  </span><br><span class="line"></span><br><span class="line">2.3.2 主机的服务规划与硬件的关系 83  </span><br><span class="line"></span><br><span class="line">2.3.3 主机硬盘的主要规划 84  </span><br><span class="line"></span><br><span class="line">2.3.4 鸟哥的两个实际案例 85  </span><br><span class="line"></span><br><span class="line">2.4 重点回顾 86  </span><br><span class="line"></span><br><span class="line">2.5 本章习题 87  </span><br><span class="line"></span><br><span class="line">2.6 参考资料与扩展阅读 87  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第3章 安装CentOS 7.x 88  </span><br><span class="line"></span><br><span class="line">3.1 本练习机的规划（尤其是分区参数） 89  </span><br><span class="line"></span><br><span class="line">3.2 开始安装 CentOS 7 91  </span><br><span class="line"></span><br><span class="line">3.2.1 调整BIOS与虚拟机创建流程 91  </span><br><span class="line"></span><br><span class="line">3.2.2 选择安装模式与启动（inst.gpt） 94  </span><br><span class="line"></span><br><span class="line">3.2.3 设置时区、语言与键盘布ju 96  </span><br><span class="line"></span><br><span class="line">3.2.4 安装源设置与软件选择 97  </span><br><span class="line"></span><br><span class="line">3.2.5 磁盘分区与文件系统设置 99  </span><br><span class="line"></span><br><span class="line">3.2.6 内核管理与网络设置 104  </span><br><span class="line"></span><br><span class="line">3.2.7 开始安装、设置root密码与新增可切换身份之一般用户 106  </span><br><span class="line"></span><br><span class="line">3.2.8 准备使用系统前的授权同意 108  </span><br><span class="line"></span><br><span class="line">3.2.9 其他功能：RAM测试，安装笔记本电脑的内核参数（可选） 110  </span><br><span class="line"></span><br><span class="line">3.3 多重引导安装步骤与管理（可选） 111  </span><br><span class="line"></span><br><span class="line">3.3.1 安装 CentOS 7.x Windows 7的规划 111  </span><br><span class="line"></span><br><span class="line">3.3.2 *安装 CentOS 7.x与Windows 7 112  </span><br><span class="line"></span><br><span class="line">3.3.3 恢复MBR内的启动引导程序与设置多重引导选项 113  </span><br><span class="line"></span><br><span class="line">3.4 重点回顾 114  </span><br><span class="line"></span><br><span class="line">3.5 本章习题 115  </span><br><span class="line"></span><br><span class="line">3.6 参考资料与扩展阅读 115  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第4章 *次登录与在线求助 116  </span><br><span class="line"></span><br><span class="line">4.1 *次登录系统 117  </span><br><span class="line"></span><br><span class="line">4.1.1 *次登录CentOS 7.x图形用户界面模式 117  </span><br><span class="line"></span><br><span class="line">4.1.2 GNOME的操作与注销 118  </span><br><span class="line"></span><br><span class="line">4.1.3 X Window与命令行模式的切换 124  </span><br><span class="line"></span><br><span class="line">4.1.4 在终端登录Linux 125  </span><br><span class="line"></span><br><span class="line">4.2 命令行模式下命令的执行 127  </span><br><span class="line"></span><br><span class="line">4.2.1 开始执行命令 127  </span><br><span class="line"></span><br><span class="line">4.2.2 基础命令的操作 128  </span><br><span class="line"></span><br><span class="line">4.2.3 重要的几个热键[Tab]、[Ctrl]-c、[Ctrl]-d 131  </span><br><span class="line"></span><br><span class="line">4.2.4 错误信息的查看 133  </span><br><span class="line"></span><br><span class="line">4.3 Linux系统的在线求助man page与info page 133  </span><br><span class="line"></span><br><span class="line">4.3.1 命令的 --help求助说明 134  </span><br><span class="line"></span><br><span class="line">4.3.2 man page 135  </span><br><span class="line"></span><br><span class="line">4.3.3 info page 139  </span><br><span class="line"></span><br><span class="line">4.3.4 其他有用的文件（documents） 141  </span><br><span class="line"></span><br><span class="line">4.4 超简单的文本编辑器：nano 142  </span><br><span class="line"></span><br><span class="line">4.5 正确的关机方法 143  </span><br><span class="line"></span><br><span class="line">4.6 重点回顾 146  </span><br><span class="line"></span><br><span class="line">4.7 本章习题 146  </span><br><span class="line"></span><br><span class="line">4.8 参考资料与扩展阅读 147  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">*bu分 Linux文件、目录与磁盘格式  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第5章 Linux的文件权限与目录配置 149  </span><br><span class="line"></span><br><span class="line">5.1 用户与用户组 150  </span><br><span class="line"></span><br><span class="line">5.2 Linux文件权限概念 152  </span><br><span class="line"></span><br><span class="line">5.2.1 Linux文件属性 152  </span><br><span class="line"></span><br><span class="line">5.2.2 如何修改文件属性与权限 156  </span><br><span class="line"></span><br><span class="line">5.2.3 目录与文件的权限意义 159  </span><br><span class="line"></span><br><span class="line">5.2.4 Linux文件种类与扩展名 162  </span><br><span class="line"></span><br><span class="line">5.3 Linux目录配置 165  </span><br><span class="line"></span><br><span class="line">5.3.1 Linux目录配置的依据——FHS 165  </span><br><span class="line"></span><br><span class="line">5.3.2 目录树（directory tree） 169  </span><br><span class="line"></span><br><span class="line">5.3.3 *路径与相对路径 170  </span><br><span class="line"></span><br><span class="line">5.3.4 CentOS的观察 172  </span><br><span class="line"></span><br><span class="line">5.4 重点回顾 173  </span><br><span class="line"></span><br><span class="line">5.5 本章练习 174  </span><br><span class="line"></span><br><span class="line">5.6 参考资料与扩展阅读 174  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第6章 Linux文件与目录管理 175  </span><br><span class="line"></span><br><span class="line">6.1 目录与路径 176  </span><br><span class="line"></span><br><span class="line">6.1.1 相对路径与*路径 176  </span><br><span class="line"></span><br><span class="line">6.1.2 目录的相关操作 176  </span><br><span class="line"></span><br><span class="line">6.1.3 关于执行文件路径的变量：$PATH 179  </span><br><span class="line"></span><br><span class="line">6.2 文件与目录管理 181  </span><br><span class="line"></span><br><span class="line">6.2.1 文件与目录的查看：ls 181  </span><br><span class="line"></span><br><span class="line">6.2.2 复制、删除与移动：cp、rm、mv 183  </span><br><span class="line"></span><br><span class="line">6.2.3 获取路径的文件名与目录名称 186  </span><br><span class="line"></span><br><span class="line">6.3 文件内容查看 186  </span><br><span class="line"></span><br><span class="line">6.3.1 直接查看文件内容 187  </span><br><span class="line"></span><br><span class="line">6.3.2 可翻页查看 188  </span><br><span class="line"></span><br><span class="line">6.3.3 数据截取 190  </span><br><span class="line"></span><br><span class="line">6.3.4 非纯文本文件：od 191  </span><br><span class="line"></span><br><span class="line">6.3.5 修改文件时间或创建新文件：touch 192  </span><br><span class="line"></span><br><span class="line">6.4 文件与目录的默认权限与隐藏权限 194  </span><br><span class="line"></span><br><span class="line">6.4.1 文件默认权限：umask 195  </span><br><span class="line"></span><br><span class="line">6.4.2 文件隐藏属性 196  </span><br><span class="line"></span><br><span class="line">6.4.3 文件特殊权限：SUID、SGID、SBIT 198  </span><br><span class="line"></span><br><span class="line">6.4.4 观察文件类型：file 200  </span><br><span class="line"></span><br><span class="line">6.5 命令与文件的查找 201  </span><br><span class="line"></span><br><span class="line">6.5.1 脚本文件的查找 201  </span><br><span class="line"></span><br><span class="line">6.5.2 文件的查找 201  </span><br><span class="line"></span><br><span class="line">6.6 极重要的复习，权限与命令间的关系 205  </span><br><span class="line"></span><br><span class="line">6.7 重点回顾 206  </span><br><span class="line"></span><br><span class="line">6.8 本章习题 207  </span><br><span class="line"></span><br><span class="line">6.9 参考资料与扩展阅读 208  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第7章 Linux磁盘与文件系统管理 209  </span><br><span class="line"></span><br><span class="line">7.1 认识Linux文件系统 210  </span><br><span class="line"></span><br><span class="line">7.1.1 磁盘组成与分区的复习 210  </span><br><span class="line"></span><br><span class="line">7.1.2 文件系统特性 211  </span><br><span class="line"></span><br><span class="line">7.1.3 Linux的ext2文件系统（inode） 212  </span><br><span class="line"></span><br><span class="line">7.1.4 与目录树的关系 217  </span><br><span class="line"></span><br><span class="line">7.1.5 ext2 ext3 ext4文件的存取与日志式文件系统的功能 219  </span><br><span class="line"></span><br><span class="line">7.1.6 Linux文件系统的运行 220  </span><br><span class="line"></span><br><span class="line">7.1.7 挂载点的意义（mount point） 221  </span><br><span class="line"></span><br><span class="line">7.1.8 其他Linux支持的文件系统与VFS 221  </span><br><span class="line"></span><br><span class="line">7.1.9 XFS文件系统简介 222  </span><br><span class="line"></span><br><span class="line">7.2 文件系统的简单操作 224  </span><br><span class="line"></span><br><span class="line">7.2.1 磁盘与目录的容量 224  </span><br><span class="line"></span><br><span class="line">7.2.2 硬链接与符号链接：ln 227  </span><br><span class="line"></span><br><span class="line">7.3 磁盘的分区、格式化、检验与挂载 231  </span><br><span class="line"></span><br><span class="line">7.3.1 观察磁盘分区状态 232  </span><br><span class="line"></span><br><span class="line">7.3.2 磁盘分区：gdisk fdisk 233  </span><br><span class="line"></span><br><span class="line">7.3.3 磁盘格式化（创建文件系统） 238  </span><br><span class="line"></span><br><span class="line">7.3.4 文件系统检验 241  </span><br><span class="line"></span><br><span class="line">7.3.5 文件系统挂载与卸载 243  </span><br><span class="line"></span><br><span class="line">7.3.6 磁盘 文件系统参数自定义 246  </span><br><span class="line"></span><br><span class="line">7.4 设置启动挂载 248  </span><br><span class="line"></span><br><span class="line">7.4.1 启动挂载 etc fstab及 etc mtab 248  </span><br><span class="line"></span><br><span class="line">7.4.2 特殊设备loop挂载（镜像文件不刻录就挂载使用） 251  </span><br><span class="line"></span><br><span class="line">7.5 内存交换分区（swap）之创建 252  </span><br><span class="line"></span><br><span class="line">7.5.1 使用物理分区创建内存交换分区 253  </span><br><span class="line"></span><br><span class="line">7.5.2 使用文件创建内存交换文件 254  </span><br><span class="line"></span><br><span class="line">7.6 文件系统的特殊观察与操作 255  </span><br><span class="line"></span><br><span class="line">7.6.1 磁盘空间之浪费问题 255  </span><br><span class="line"></span><br><span class="line">7.6.2 利用GNU的parted 进行分区操作（可选） 256  </span><br><span class="line"></span><br><span class="line">7.7 重点回顾 257  </span><br><span class="line"></span><br><span class="line">7.8 本章习题 258  </span><br><span class="line"></span><br><span class="line">7.9 参考资料与扩展阅读 259  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第8章 文件与文件系统的压缩 261  </span><br><span class="line"></span><br><span class="line">8.1 压缩文件的用途与技术 262  </span><br><span class="line"></span><br><span class="line">8.2 Linux系统常见的压缩命令 263  </span><br><span class="line"></span><br><span class="line">8.2.1 gzip，zcat zmore zless zgrep 263  </span><br><span class="line"></span><br><span class="line">8.2.2 bzip2，bzcat bzmore bzless bzgrep 265  </span><br><span class="line"></span><br><span class="line">8.2.3 xz，xzcat xzmore xzless xzgrep 265  </span><br><span class="line"></span><br><span class="line">8.3 打包命令：tar 266  </span><br><span class="line"></span><br><span class="line">8.4 XFS文件系统的备份与还原 272  </span><br><span class="line"></span><br><span class="line">8.4.1 XFS文件系统备份xfsdump 272  </span><br><span class="line"></span><br><span class="line">8.4.2 XFS文件系统还原xfsrestore 275  </span><br><span class="line"></span><br><span class="line">8.5 光盘写入工具 277  </span><br><span class="line"></span><br><span class="line">8.5.1 mkisofs：建立镜像文件 277  </span><br><span class="line"></span><br><span class="line">8.5.2 cdrecord：光盘刻录工具 280  </span><br><span class="line"></span><br><span class="line">8.6 其他常见的压缩与备份工具 282  </span><br><span class="line"></span><br><span class="line">8.6.1 dd 282  </span><br><span class="line"></span><br><span class="line">8.6.2 cpio 284  </span><br><span class="line"></span><br><span class="line">8.7 重点回顾 285  </span><br><span class="line"></span><br><span class="line">8.8 本章习题 286  </span><br><span class="line"></span><br><span class="line">8.9 参考资料与扩展阅读 287  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第三bu分 学习shell与shell script  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第9章 vim程序编辑器 289  </span><br><span class="line"></span><br><span class="line">9.1 vi与vim 290  </span><br><span class="line"></span><br><span class="line">9.2 vi的使用 291  </span><br><span class="line"></span><br><span class="line">9.2.1 简易执行范例 292  </span><br><span class="line"></span><br><span class="line">9.2.2 按键说明 293  </span><br><span class="line"></span><br><span class="line">9.2.3 一个案例练习 296  </span><br><span class="line"></span><br><span class="line">9.2.4 vim的缓存、恢复与打开时的警告信息 297  </span><br><span class="line"></span><br><span class="line">9.3 vim的额外功能 299  </span><br><span class="line"></span><br><span class="line">9.3.1 可视区块（Visual Block） 300  </span><br><span class="line"></span><br><span class="line">9.3.2 多文件编辑 301  </span><br><span class="line"></span><br><span class="line">9.3.3 多窗口功能 302  </span><br><span class="line"></span><br><span class="line">9.3.4 vim的关键词补全功能 303  </span><br><span class="line"></span><br><span class="line">9.3.5 vim环境设置与记录：~ .vimrc、~ .viminfo 304  </span><br><span class="line"></span><br><span class="line">9.3.6 vim常用命令示意图 305  </span><br><span class="line"></span><br><span class="line">9.4 其他vim使用注意事项 305  </span><br><span class="line"></span><br><span class="line">9.4.1 中文编码的问题 306  </span><br><span class="line"></span><br><span class="line">9.4.2 DOS与Linux的换行符 306  </span><br><span class="line"></span><br><span class="line">9.4.3 语系编码转换 307  </span><br><span class="line"></span><br><span class="line">9.5 重点回顾 308  </span><br><span class="line"></span><br><span class="line">9.6 本章练习 308  </span><br><span class="line"></span><br><span class="line">9.7 参考资料与扩展阅读 309  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 10章 认识与学习BASH 310  </span><br><span class="line"></span><br><span class="line">10.1 认识BASH这个Shell 311  </span><br><span class="line"></span><br><span class="line">10.1.1 硬件、内核与Shell 311  </span><br><span class="line"></span><br><span class="line">10.1.2 为何要学命令行模式的Shell？ 312  </span><br><span class="line"></span><br><span class="line">10.1.3 系统的合法shell与 etc shells功能 313  </span><br><span class="line"></span><br><span class="line">10.1.4 Bash shell的功能 314  </span><br><span class="line"></span><br><span class="line">10.1.5 查询命令是否为Bash shell的内置命令：type 315  </span><br><span class="line"></span><br><span class="line">10.1.6 命令的执行与快速编辑按钮 316  </span><br><span class="line"></span><br><span class="line">10.2 Shell的变量功能 316  </span><br><span class="line"></span><br><span class="line">10.2.1 什么是变量？ 317  </span><br><span class="line"></span><br><span class="line">10.2.2 变量的使用与设置：echo、变量设置规则、unset 318  </span><br><span class="line"></span><br><span class="line">10.2.3 环境变量的功能 322  </span><br><span class="line"></span><br><span class="line">10.2.4 影响显示结果的语系变量（locale） 325  </span><br><span class="line"></span><br><span class="line">10.2.5 变量的有效范围 327  </span><br><span class="line"></span><br><span class="line">10.2.6 变量键盘读取、数组与声明：read、array、declare 327  </span><br><span class="line"></span><br><span class="line">10.2.7 与文件系统及程序的限制关系：ulimit 329  </span><br><span class="line"></span><br><span class="line">10.2.8 变量内容的删除、取代与替换（可选） 330  </span><br><span class="line"></span><br><span class="line">10.3 命令别名与历史命令 334  </span><br><span class="line"></span><br><span class="line">10.3.1 命令别名设置：alias、unalias 334  </span><br><span class="line"></span><br><span class="line">10.3.2 历史命令：history 335  </span><br><span class="line"></span><br><span class="line">10.4 Bash shell的操作环境 337  </span><br><span class="line"></span><br><span class="line">10.4.1 路径与命令查找顺序 337  </span><br><span class="line"></span><br><span class="line">10.4.2 bash的登录与欢迎信息： etc issue、 etc motd 337  </span><br><span class="line"></span><br><span class="line">10.4.3 bash的环境配置文件 338  </span><br><span class="line"></span><br><span class="line">10.4.4 终端的环境设置：stty、set 342  </span><br><span class="line"></span><br><span class="line">10.4.5 通配符与特殊符号 344  </span><br><span class="line"></span><br><span class="line">10.5 数据流重定向 345  </span><br><span class="line"></span><br><span class="line">10.5.1 什么是数据流重定向 345  </span><br><span class="line"></span><br><span class="line">10.5.2 命令执行的判断根据：;、&amp;&amp;、|| 348  </span><br><span class="line"></span><br><span class="line">10.6 管道命令（pipe） 350  </span><br><span class="line"></span><br><span class="line">10.6.1 选取命令：cut、grep 351  </span><br><span class="line"></span><br><span class="line">10.6.2 排序命令：sort、wc、uniq 353  </span><br><span class="line"></span><br><span class="line">10.6.3 双向重定向：tee 354  </span><br><span class="line"></span><br><span class="line">10.6.4 字符转换命令：tr、col、join、paste、expand 355  </span><br><span class="line"></span><br><span class="line">10.6.5 划分命令：split 357  </span><br><span class="line"></span><br><span class="line">10.6.6 参数代换：xargs 358  </span><br><span class="line"></span><br><span class="line">10.6.7 关于减号【-】的用途 359  </span><br><span class="line"></span><br><span class="line">10.7 重点回顾 359  </span><br><span class="line"></span><br><span class="line">10.8 本章习题 360  </span><br><span class="line"></span><br><span class="line">10.9 参考资料与扩展阅读 361  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 11章 正则表达式与文件格式化处理 362  </span><br><span class="line"></span><br><span class="line">11.1 开始之前：什么是正则表达式 363  </span><br><span class="line"></span><br><span class="line">11.2 基础正则表达式 364  </span><br><span class="line"></span><br><span class="line">11.2.1 语系对正则表达式的影响 365  </span><br><span class="line"></span><br><span class="line">11.2.2 grep 的一些*选项 365  </span><br><span class="line"></span><br><span class="line">11.2.3 基础正则表达式练习 366  </span><br><span class="line"></span><br><span class="line">11.2.4 基础正则表达式字符集合（characters） 371  </span><br><span class="line"></span><br><span class="line">11.2.5 sed工具 373  </span><br><span class="line"></span><br><span class="line">11.3 扩展正则表达式 376  </span><br><span class="line"></span><br><span class="line">11.4 文件的格式化与相关处理 377  </span><br><span class="line"></span><br><span class="line">11.4.1 格式化打印：printf 377  </span><br><span class="line"></span><br><span class="line">11.4.2 awk：好用的数据处理工具 379  </span><br><span class="line"></span><br><span class="line">11.4.3 文件比对工具 381  </span><br><span class="line"></span><br><span class="line">11.4.4 文件打印设置：pr 384  </span><br><span class="line"></span><br><span class="line">11.5 重点回顾 384  </span><br><span class="line"></span><br><span class="line">11.6 本章习题 385  </span><br><span class="line"></span><br><span class="line">11.7 参考资料与扩展阅读 386  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 12章 学习shell脚本 387  </span><br><span class="line"></span><br><span class="line">12.1 什么是shell脚本 388  </span><br><span class="line"></span><br><span class="line">12.1.1 为什么要学习shell脚本 388  </span><br><span class="line"></span><br><span class="line">12.1.2 第 一个脚本的编写与执行 389  </span><br><span class="line"></span><br><span class="line">12.1.3 建立shell脚本的良好编写习惯 391  </span><br><span class="line"></span><br><span class="line">12.2 简单的shell脚本练习 392  </span><br><span class="line"></span><br><span class="line">12.2.1 简单范例 392  </span><br><span class="line"></span><br><span class="line">12.2.2 脚本的执行方式差异（source、sh script、. script） 394  </span><br><span class="line"></span><br><span class="line">12.3 善用判断式 395  </span><br><span class="line"></span><br><span class="line">12.3.1 利用test命令的测试功能 395  </span><br><span class="line"></span><br><span class="line">12.3.2 利用判断符号[ ] 397  </span><br><span class="line"></span><br><span class="line">12.3.3 shell脚本的默认变量（$0、$1...） 399  </span><br><span class="line"></span><br><span class="line">12.4 条件判断式 400  </span><br><span class="line"></span><br><span class="line">12.4.1 利用if…then 401  </span><br><span class="line"></span><br><span class="line">12.4.2 利用case…esac判断 405  </span><br><span class="line"></span><br><span class="line">12.4.3 利用function功能 406  </span><br><span class="line"></span><br><span class="line">12.5 循环（loop） 408  </span><br><span class="line"></span><br><span class="line">12.5.1 while do done、until do done（不定循环） 408  </span><br><span class="line"></span><br><span class="line">12.5.2 for...do...done（固定循环） 409  </span><br><span class="line"></span><br><span class="line">12.5.3 for...do...done的数值处理 411  </span><br><span class="line"></span><br><span class="line">12.5.4 搭配随机数与数组的实验 412  </span><br><span class="line"></span><br><span class="line">12.6 shell脚本的跟踪与调试 413  </span><br><span class="line"></span><br><span class="line">12.7 重点回顾 414  </span><br><span class="line"></span><br><span class="line">12.8 本章习题 415  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第四bu分 Linux使用者管理  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 13章 Linux账号管理与ACL权限设置 417  </span><br><span class="line"></span><br><span class="line">13.1 Linux的账号与用户组 418  </span><br><span class="line"></span><br><span class="line">13.1.1 用户标识符：UID与GID 418  </span><br><span class="line"></span><br><span class="line">13.1.2 用户账号 419  </span><br><span class="line"></span><br><span class="line">13.1.3 关于用户组：有效与初始用户组, groups, newgr 423  </span><br><span class="line"></span><br><span class="line">13.2 账号管理 426  </span><br><span class="line"></span><br><span class="line">13.2.1 新增与删除用户：useradd、相关配置文件、passwd、usermod、  </span><br><span class="line"></span><br><span class="line">userdel 426  </span><br><span class="line"></span><br><span class="line">13.2.2 用户功能 434  </span><br><span class="line"></span><br><span class="line">13.2.3 新增与删除用户组 437  </span><br><span class="line"></span><br><span class="line">13.2.4 账号管理实例 438  </span><br><span class="line"></span><br><span class="line">13.2.5 使用外bu身份认证系统 439  </span><br><span class="line"></span><br><span class="line">13.3 主机的详细权限规划：ACL的使用 440  </span><br><span class="line"></span><br><span class="line">13.3.1 什么是ACL与如何支持启动ACL 440  </span><br><span class="line"></span><br><span class="line">13.3.2 ACL的设置技巧：getfacl、setfacl 441  </span><br><span class="line"></span><br><span class="line">13.4 用户身份切换 444  </span><br><span class="line"></span><br><span class="line">13.4.1 su 445  </span><br><span class="line"></span><br><span class="line">13.4.2 sudo 446  </span><br><span class="line"></span><br><span class="line">13.5 用户的特殊shell与PAM模块 450  </span><br><span class="line"></span><br><span class="line">13.5.1 特殊的shell， sbin nologin 451  </span><br><span class="line"></span><br><span class="line">13.5.2 PAM模块简介 451  </span><br><span class="line"></span><br><span class="line">13.5.3 PAM模块设置语法 452  </span><br><span class="line"></span><br><span class="line">13.5.4 常用模块简介 454  </span><br><span class="line"></span><br><span class="line">13.5.5 其他相关文件 456  </span><br><span class="line"></span><br><span class="line">13.6 Linux主机上的用户信息传递 457  </span><br><span class="line"></span><br><span class="line">13.6.1 查询用户：w、who、last、lastlog 457  </span><br><span class="line"></span><br><span class="line">13.6.2 用户对谈：write、mesg、wall 458  </span><br><span class="line"></span><br><span class="line">13.6.3 用户邮箱：mail 459  </span><br><span class="line"></span><br><span class="line">13.7 CentOS 7环境下大量创建账号的方法 460  </span><br><span class="line"></span><br><span class="line">13.7.1 一些账号相关的检查工具 460  </span><br><span class="line"></span><br><span class="line">13.7.2 大量创建账号模板（适用passwd --stdin选项） 461  </span><br><span class="line"></span><br><span class="line">13.8 重点回顾 462  </span><br><span class="line"></span><br><span class="line">13.9 本章习题 463  </span><br><span class="line"></span><br><span class="line">13.10 参考资料与扩展阅读 464  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 14章 磁盘配额（Quota）与*文件系统管理 465  </span><br><span class="line"></span><br><span class="line">14.1 磁盘配额（Quota）的应用与实践 466  </span><br><span class="line"></span><br><span class="line">14.1.1 什么是磁盘配额 466  </span><br><span class="line"></span><br><span class="line">14.1.2 一个xfs文件系统的磁盘配额实践范例 468  </span><br><span class="line"></span><br><span class="line">14.1.3 实践磁盘配额流程-1：文件系统的支持与查看 469  </span><br><span class="line"></span><br><span class="line">14.1.4 实践磁盘配额流程-2：查看磁盘配额报告数据 469  </span><br><span class="line"></span><br><span class="line">14.1.5 实践磁盘配额流程-3：限制值设置方式 470  </span><br><span class="line"></span><br><span class="line">14.1.6 实践磁盘配额流程-4：project的限制（针对目录限制）  </span><br><span class="line"></span><br><span class="line">（Optional） 471  </span><br><span class="line"></span><br><span class="line">14.1.7 xfs磁盘配额的管理与额外命令对照表 473  </span><br><span class="line"></span><br><span class="line">14.1.8 不修改既有系统的磁盘配额实例 475  </span><br><span class="line"></span><br><span class="line">14.2 软件磁盘阵列（Software RAID） 475  </span><br><span class="line"></span><br><span class="line">14.2.1 什么是RAID 475  </span><br><span class="line"></span><br><span class="line">14.2.2 硬件RAID，软件RAID 479  </span><br><span class="line"></span><br><span class="line">14.2.3 软件磁盘阵列的设置 479  </span><br><span class="line"></span><br><span class="line">14.2.4 模拟RAID错误的恢复模式 482  </span><br><span class="line"></span><br><span class="line">14.2.5 开机自动启动RAID并自动挂载 483  </span><br><span class="line"></span><br><span class="line">14.2.6 关闭软件RAID（重要） 484  </span><br><span class="line"></span><br><span class="line">14.3 逻辑卷管理器（Logical Volume Manager） 484  </span><br><span class="line"></span><br><span class="line">14.3.1 什么是LVM：PV、PE、VG、LV的意义 485  </span><br><span class="line"></span><br><span class="line">14.3.2 LVM实践流程 486  </span><br><span class="line"></span><br><span class="line">14.3.3 放大LV容量 490  </span><br><span class="line"></span><br><span class="line">14.3.4 使用LVM thin Volume让LVM动态自动调整磁盘使用率 492  </span><br><span class="line"></span><br><span class="line">14.3.5 LVM的LV磁盘快照 493  </span><br><span class="line"></span><br><span class="line">14.3.6 LVM相关命令集合与LVM的关闭 496  </span><br><span class="line"></span><br><span class="line">14.4 重点回顾 497  </span><br><span class="line"></span><br><span class="line">14.5 本章习题 498  </span><br><span class="line"></span><br><span class="line">14.6 参考资料与扩展阅读 499  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 15章 计划任务（crontab） 500  </span><br><span class="line"></span><br><span class="line">15.1 什么是计划任务 501  </span><br><span class="line"></span><br><span class="line">15.1.1 Linux计划任务的种类：at、cron 501  </span><br><span class="line"></span><br><span class="line">15.1.2 CentOS Linux系统上常见的例行性工作 501  </span><br><span class="line"></span><br><span class="line">15.2 仅执行一次的计划任务 502  </span><br><span class="line"></span><br><span class="line">15.2.1 atd的启动与at运行的方式 502  </span><br><span class="line"></span><br><span class="line">15.2.2 实际运行单一计划任务 503  </span><br><span class="line"></span><br><span class="line">15.3 循环执行的计划任务 506  </span><br><span class="line"></span><br><span class="line">15.3.1 用户的设置 506  </span><br><span class="line"></span><br><span class="line">15.3.2 系统的配置文件： etc crontab、 etc cron.d * 508  </span><br><span class="line"></span><br><span class="line">15.3.3 一些注意事项 510  </span><br><span class="line"></span><br><span class="line">15.4 可唤醒停机期间的工作任务 511  </span><br><span class="line"></span><br><span class="line">15.4.1 什么是anacron 512  </span><br><span class="line"></span><br><span class="line">15.4.2 anacron与 etc anacrontab 512  </span><br><span class="line"></span><br><span class="line">15.5 重点回顾 514  </span><br><span class="line"></span><br><span class="line">15.6 本章习题 514  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 16章 进程管理与SELinux初探 515  </span><br><span class="line"></span><br><span class="line">16.1 什么是进程（process） 516  </span><br><span class="line"></span><br><span class="line">16.1.1 进程与程序（process &amp; program） 516  </span><br><span class="line"></span><br><span class="line">16.1.2 Linux的多人多任务环境 518  </span><br><span class="line"></span><br><span class="line">16.2 任务管理（job control） 520  </span><br><span class="line"></span><br><span class="line">16.2.1 什么是任务管理 520  </span><br><span class="line"></span><br><span class="line">16.2.2 job control的管理 520  </span><br><span class="line"></span><br><span class="line">16.2.3 脱机管理问题 523  </span><br><span class="line"></span><br><span class="line">16.3 进程管理 524  </span><br><span class="line"></span><br><span class="line">16.3.1 查看进程 524  </span><br><span class="line"></span><br><span class="line">16.3.2 进程的管理 530  </span><br><span class="line"></span><br><span class="line">16.3.3 关于进程的执行顺序 531  </span><br><span class="line"></span><br><span class="line">16.3.4 查看系统资源信息 533  </span><br><span class="line"></span><br><span class="line">16.4 特殊文件与进程 538  </span><br><span class="line"></span><br><span class="line">16.4.1 具有SUID SGID权限的命令执行状态 538  </span><br><span class="line"></span><br><span class="line">16.4.2 proc * 代表的意义 539  </span><br><span class="line"></span><br><span class="line">16.4.3 查询已使用文件或已执行进程使用的文件 540  </span><br><span class="line"></span><br><span class="line">16.5 SELinux初探 543  </span><br><span class="line"></span><br><span class="line">16.5.1 什么是SELinux 543  </span><br><span class="line"></span><br><span class="line">16.5.2 SELinux的运行模式 544  </span><br><span class="line"></span><br><span class="line">16.5.3 SELinux 3种模式的启动、关闭与查看 548  </span><br><span class="line"></span><br><span class="line">16.5.4 SELinux策略内的规则管理 550  </span><br><span class="line"></span><br><span class="line">16.5.5 SELinux安全上下文的修改 552  </span><br><span class="line"></span><br><span class="line">16.5.6 一个网络服务案例及日志文件协助 554  </span><br><span class="line"></span><br><span class="line">16.6 重点回顾 560  </span><br><span class="line"></span><br><span class="line">16.7 本章习题 561  </span><br><span class="line"></span><br><span class="line">16.8 参考资料与扩展阅读 561  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第五bu分 Linux系统管理员  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 17章 认识系统服务（daemon） 563  </span><br><span class="line"></span><br><span class="line">17.1 什么是daemon与服务（service） 564  </span><br><span class="line"></span><br><span class="line">17.1.1 早期System V的init管理操作中daemon的主要分类  </span><br><span class="line"></span><br><span class="line">（Optional） 564  </span><br><span class="line"></span><br><span class="line">17.1.2 systemd使用的unit分类 566  </span><br><span class="line"></span><br><span class="line">17.2 通过systemctl管理服务 568  </span><br><span class="line"></span><br><span class="line">17.2.1 通过systemctl管理单一服务（service unit）的启动 开机启动与查看状态 568  </span><br><span class="line"></span><br><span class="line">17.2.2 通过systemctl查看系统上所有的服务 571  </span><br><span class="line"></span><br><span class="line">17.2.3 通过systemctl管理不同的操作环境（target unit） 572  </span><br><span class="line"></span><br><span class="line">17.2.4 通过systemctl分析各服务之间的依赖性 574  </span><br><span class="line"></span><br><span class="line">17.2.5 与systemd的daemon运行过程相关的目录简介 575  </span><br><span class="line"></span><br><span class="line">17.2.6 关闭网络服务 577  </span><br><span class="line"></span><br><span class="line">17.3 systemctl针对service类型的配置文件 578  </span><br><span class="line"></span><br><span class="line">17.3.1 systemctl配置文件相关目录简介 578  </span><br><span class="line"></span><br><span class="line">17.3.2 systemctl配置文件的设置项目简介 578  </span><br><span class="line"></span><br><span class="line">17.3.3 两个vsftpd运行的实例 581  </span><br><span class="line"></span><br><span class="line">17.3.4 多重的重复设置方式：以getty为例 582  </span><br><span class="line"></span><br><span class="line">17.3.5 自己的服务自己做 585  </span><br><span class="line"></span><br><span class="line">17.4 systemctl针对timer的配置文件 585  </span><br><span class="line"></span><br><span class="line">17.5 CentOS 7.x默认启动的服务概要 588  </span><br><span class="line"></span><br><span class="line">17.6 重点回顾 591  </span><br><span class="line"></span><br><span class="line">17.7 本章习题 591  </span><br><span class="line"></span><br><span class="line">17.8 参考资料与扩展阅读 593  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 18章 认识与分析日志文件 594  </span><br><span class="line"></span><br><span class="line">18.1 什么是日志文件 595  </span><br><span class="line"></span><br><span class="line">18.1.1 CentOS 7日志文件简易说明 595  </span><br><span class="line"></span><br><span class="line">18.1.2 日志文件内容的一般格式 597  </span><br><span class="line"></span><br><span class="line">18.2 rsyslog.service：记录日志文件的服务 598  </span><br><span class="line"></span><br><span class="line">18.2.1 rsyslog.service的配置文件： etc rsyslog.conf 598  </span><br><span class="line"></span><br><span class="line">18.2.2 日志文件的安全性设置 603  </span><br><span class="line"></span><br><span class="line">18.2.3 日志文件服务器的设置 604  </span><br><span class="line"></span><br><span class="line">18.3 日志文件的轮循（logrotate） 605  </span><br><span class="line"></span><br><span class="line">18.3.1 logrotate的配置文件 605  </span><br><span class="line"></span><br><span class="line">18.3.2 实际测试logrotate的操作 608  </span><br><span class="line"></span><br><span class="line">18.3.3 自定义日志文件的轮循功能 609  </span><br><span class="line"></span><br><span class="line">18.4 systemd-journald.service简介 610  </span><br><span class="line"></span><br><span class="line">18.4.1 使用journalctl查看登录信息 611  </span><br><span class="line"></span><br><span class="line">18.4.2 logger命令的应用 612  </span><br><span class="line"></span><br><span class="line">18.4.3 保存journal的方式 612  </span><br><span class="line"></span><br><span class="line">18.5 分析日志文件 613  </span><br><span class="line"></span><br><span class="line">18.5.1 CentOS默认提供的logwatch 613  </span><br><span class="line"></span><br><span class="line">18.5.2 鸟哥自己写的日志文件分析工具 615  </span><br><span class="line"></span><br><span class="line">18.6 重点回顾 616  </span><br><span class="line"></span><br><span class="line">18.7 本章习题 617  </span><br><span class="line"></span><br><span class="line">18.8 参考资料与扩展阅读 617  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 19章 启动流程、模块管理与Loader 618  </span><br><span class="line"></span><br><span class="line">19.1 Linux的启动流程分析 619  </span><br><span class="line"></span><br><span class="line">19.1.1 启动流程一览 619  </span><br><span class="line"></span><br><span class="line">19.1.2 BIOS、boot loader与kernel加载 619  </span><br><span class="line"></span><br><span class="line">19.1.3 第 一个程序systemd及使用default.target进入启动程序分析 625  </span><br><span class="line"></span><br><span class="line">19.1.4 systemd执行sysinit.target初始化系统、basic.target准备系统 627  </span><br><span class="line"></span><br><span class="line">19.1.5 systemd启动multi-user.target下的服务 628  </span><br><span class="line"></span><br><span class="line">19.1.6 systemd启动graphical.target下面的服务 629  </span><br><span class="line"></span><br><span class="line">19.1.7 启动过程会用到的主要配置文件 629  </span><br><span class="line"></span><br><span class="line">19.2 内核与内核模块 630  </span><br><span class="line"></span><br><span class="line">19.2.1 内核模块与依赖性 631  </span><br><span class="line"></span><br><span class="line">19.2.2 查看内核模块 632  </span><br><span class="line"></span><br><span class="line">19.2.3 内核模块的加载与删除 632  </span><br><span class="line"></span><br><span class="line">19.2.4 内核模块的额外参数设置： etc modprobe.d *conf 633  </span><br><span class="line"></span><br><span class="line">19.3 Boot Loader:Grub2 634  </span><br><span class="line"></span><br><span class="line">19.3.1 boot loader的两个stage 634  </span><br><span class="line"></span><br><span class="line">19.3.2 grub2的配置文件 boot grub2 grub.cfg初探 635  </span><br><span class="line"></span><br><span class="line">19.3.3 grub2配置文件维护 etc default grub与 etc grub.d 638  </span><br><span class="line"></span><br><span class="line">19.3.4 initramfs的重要性与建立新initramfs文件 642  </span><br><span class="line"></span><br><span class="line">19.3.5 测试与安装grub2 643  </span><br><span class="line"></span><br><span class="line">19.3.6 启动前的额外功能修改 645  </span><br><span class="line"></span><br><span class="line">19.3.7 关于启动画面与终端画面的图形显示方式 647  </span><br><span class="line"></span><br><span class="line">19.3.8 为个别选项设置密码 647  </span><br><span class="line"></span><br><span class="line">19.4 启动过程的问题解决 650  </span><br><span class="line"></span><br><span class="line">19.4.1 忘记root密码的解决之道 650  </span><br><span class="line"></span><br><span class="line">19.4.2 直接启动就以root执行bash的方法 652  </span><br><span class="line"></span><br><span class="line">19.4.3 因文件系统错误而无法启动 652  </span><br><span class="line"></span><br><span class="line">19.5 重点回顾 653  </span><br><span class="line"></span><br><span class="line">19.6 本章习题 653  </span><br><span class="line"></span><br><span class="line">19.7 参考资料与扩展阅读 654  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 20章 基础系统设置与备份策略 655  </span><br><span class="line"></span><br><span class="line">20.1 系统基本设置 656  </span><br><span class="line"></span><br><span class="line">20.1.1 网络设置（手动设置与DHCP自动获取） 656  </span><br><span class="line"></span><br><span class="line">20.1.2 日期与时间设置 659  </span><br><span class="line"></span><br><span class="line">20.1.3 语系设置 660  </span><br><span class="line"></span><br><span class="line">20.1.4 防火墙简易设置 661  </span><br><span class="line"></span><br><span class="line">20.2 服务器硬件数据的收集 663  </span><br><span class="line"></span><br><span class="line">20.2.1 使用dmidecode查看硬件设备 663  </span><br><span class="line"></span><br><span class="line">20.2.2 硬件资源的收集与分析 664  </span><br><span class="line"></span><br><span class="line">20.2.3 了解磁盘的健康状态 667  </span><br><span class="line"></span><br><span class="line">20.3 备份要点 668  </span><br><span class="line"></span><br><span class="line">20.3.1 备份数据的考虑 668  </span><br><span class="line"></span><br><span class="line">20.3.2 哪些Linux数据具有备份的意义 669  </span><br><span class="line"></span><br><span class="line">20.3.3 备份用存储媒介的选择 670  </span><br><span class="line"></span><br><span class="line">20.4 备份的种类、频率与工具的选择 671  </span><br><span class="line"></span><br><span class="line">20.4.1 完整备份之累积备份（Incremental backup） 672  </span><br><span class="line"></span><br><span class="line">20.4.2 完整备份之差异备份（Differential backup） 673  </span><br><span class="line"></span><br><span class="line">20.4.3 关键数据备份 674  </span><br><span class="line"></span><br><span class="line">20.5 鸟哥的备份策略 675  </span><br><span class="line"></span><br><span class="line">20.5.1 每周系统备份的脚本 675  </span><br><span class="line"></span><br><span class="line">20.5.2 每日备份数据的脚本 676  </span><br><span class="line"></span><br><span class="line">20.5.3 远程备份的脚本 677  </span><br><span class="line"></span><br><span class="line">20.6 灾难恢复的考虑 678  </span><br><span class="line"></span><br><span class="line">20.7 重点回顾 678  </span><br><span class="line"></span><br><span class="line">20.8 本章习题 679  </span><br><span class="line"></span><br><span class="line">20.9 参考资料与扩展阅读 679  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 21章 软件安装：源代码与Tarball 680  </span><br><span class="line"></span><br><span class="line">21.1 开放源码的软件安装与升级简介 681  </span><br><span class="line"></span><br><span class="line">21.1.1 什么是开放源码、编译器与可执行文件 681  </span><br><span class="line"></span><br><span class="line">21.1.2 什么是函数库 683  </span><br><span class="line"></span><br><span class="line">21.1.3 什么是make与configure 683  </span><br><span class="line"></span><br><span class="line">21.1.4 什么是Tarball的软件 684  </span><br><span class="line"></span><br><span class="line">21.1.5 如何安装与升级软件 685  </span><br><span class="line"></span><br><span class="line">21.2 使用传统程序语言进行编译的简单范例 685  </span><br><span class="line"></span><br><span class="line">21.2.1 单一程序：打印Hello World 686  </span><br><span class="line"></span><br><span class="line">21.2.2 主、子程序链接：子程序的编译 687  </span><br><span class="line"></span><br><span class="line">21.2.3 调用外bu函数库：加入链接的函数库 688  </span><br><span class="line"></span><br><span class="line">21.2.4 gcc的简易用法（编译、参数与连接） 689  </span><br><span class="line"></span><br><span class="line">21.3 用make进行宏编译 689  </span><br><span class="line"></span><br><span class="line">21.3.1 为什么要用make 689  </span><br><span class="line"></span><br><span class="line">21.3.2 makefile的基本语法与变量 690  </span><br><span class="line"></span><br><span class="line">21.4 Tarball的管理与建议 692  </span><br><span class="line"></span><br><span class="line">21.4.1 使用源代码管理软件所需要的基础软件 693  </span><br><span class="line"></span><br><span class="line">21.4.2 Tarball安装的基本步骤 693  </span><br><span class="line"></span><br><span class="line">21.4.3 一般Tarball软件安装的建议事项（如何删除？升级？） 695  </span><br><span class="line"></span><br><span class="line">21.4.4 一个简单的范例、利用ntp来示范 696  </span><br><span class="line"></span><br><span class="line">21.4.5 利用patch更新源代码 697  </span><br><span class="line"></span><br><span class="line">21.5 函数库管理 699  </span><br><span class="line"></span><br><span class="line">21.5.1 动态与静态函数库 700  </span><br><span class="line"></span><br><span class="line">21.5.2 ldconfig与 etc ld.so.conf 701  </span><br><span class="line"></span><br><span class="line">21.5.3 程序的动态函数库解析：ldd 701  </span><br><span class="line"></span><br><span class="line">21.6 校验软件正确性 702  </span><br><span class="line"></span><br><span class="line">21.7 重点回顾 703  </span><br><span class="line"></span><br><span class="line">21.8 本章习题 704  </span><br><span class="line"></span><br><span class="line">21.9 参考资料与扩展阅读 705  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 22章 软件安装RPM、SRPM与YUM 706  </span><br><span class="line"></span><br><span class="line">22.1 软件管理器简介 707  </span><br><span class="line"></span><br><span class="line">22.1.1 Linux界的两大主流：RPM与DPKG 707  </span><br><span class="line"></span><br><span class="line">22.1.2 什么是RPM与SRPM 708  </span><br><span class="line"></span><br><span class="line">22.1.3 什么是i386、i586、i686、noarch、x86_64 709  </span><br><span class="line"></span><br><span class="line">22.1.4 RPM的优点 710  </span><br><span class="line"></span><br><span class="line">22.1.5 RPM属性依赖的解决方式：YUM在线升级 711  </span><br><span class="line"></span><br><span class="line">22.2 RPM软件管理程序：rpm 712  </span><br><span class="line"></span><br><span class="line">22.2.1 RPM默认安装的路径 712  </span><br><span class="line"></span><br><span class="line">22.2.2 RPM安装（install） 712  </span><br><span class="line"></span><br><span class="line">22.2.3 RPM升级与更新（upgrade freshen） 714  </span><br><span class="line"></span><br><span class="line">22.2.4 RPM查询（query） 714  </span><br><span class="line"></span><br><span class="line">22.2.5 RPM验证与数字签名（Verify signature） 716  </span><br><span class="line"></span><br><span class="line">22.2.6 RPM反安装与重建数据库（erase rebuilddb） 719  </span><br><span class="line"></span><br><span class="line">22.3 YUM在线升级功能 719  </span><br><span class="line"></span><br><span class="line">22.3.1 利用YUM进行查询、安装、升级与删除功能 720  </span><br><span class="line"></span><br><span class="line">22.3.2 YUM的配置文件 723  </span><br><span class="line"></span><br><span class="line">22.3.3 YUM的软件群组功能 725  </span><br><span class="line"></span><br><span class="line">22.3.4 EPEL ELRepo外挂软件以及自定义配置文件 726  </span><br><span class="line"></span><br><span class="line">22.3.5 全系统自动升级 728  </span><br><span class="line"></span><br><span class="line">22.3.6 管理的抉择：RPM还是Tarball 728  </span><br><span class="line"></span><br><span class="line">22.3.7 基础服务管理：以Apache为例 729  </span><br><span class="line"></span><br><span class="line">22.4 SRPM的使用：rpmbuild（Optional） 730  </span><br><span class="line"></span><br><span class="line">22.4.1 利用默认值安装SRPM文件（--rebuid --recompile） 730  </span><br><span class="line"></span><br><span class="line">22.4.2 SRPM使用的路径与需要的软件 731  </span><br><span class="line"></span><br><span class="line">22.4.3 配置文件的主要内容（*.spec） 732  </span><br><span class="line"></span><br><span class="line">22.4.4 SRPM的编译命令（-ba -bb） 735  </span><br><span class="line"></span><br><span class="line">22.4.5 一个打包自己软件的范例 736  </span><br><span class="line"></span><br><span class="line">22.5 重点回顾 737  </span><br><span class="line"></span><br><span class="line">22.6 本章习题 738  </span><br><span class="line"></span><br><span class="line">22.7 参考资料与扩展阅读 738  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 23章 X Window设置介绍 739  </span><br><span class="line"></span><br><span class="line">23.1 什么是X Window System 740  </span><br><span class="line"></span><br><span class="line">23.1.1 X Window System的发展简史 740  </span><br><span class="line"></span><br><span class="line">23.1.2 主要组件：X Server XClient Window Manager DisplayManager 741  </span><br><span class="line"></span><br><span class="line">23.1.3 X Window System的启动流程 743  </span><br><span class="line"></span><br><span class="line">23.1.4 X启动流程测试 746  </span><br><span class="line"></span><br><span class="line">23.1.5 我是否需要启用X WindowSystem 747  </span><br><span class="line"></span><br><span class="line">23.2 X Server配置文件解析与设置 748  </span><br><span class="line"></span><br><span class="line">23.2.1 解析xorg.conf设置 748  </span><br><span class="line"></span><br><span class="line">23.2.2 字体管理 751  </span><br><span class="line"></span><br><span class="line">23.2.3 显示器参数微调 753  </span><br><span class="line"></span><br><span class="line">23.3 显卡驱动程序安装范例 754  </span><br><span class="line"></span><br><span class="line">23.3.1 NVIDIA 754  </span><br><span class="line"></span><br><span class="line">23.3.2 AMD（ATI） 756  </span><br><span class="line"></span><br><span class="line">23.3.3 Intel 756  </span><br><span class="line"></span><br><span class="line">23.4 重点回顾 757  </span><br><span class="line"></span><br><span class="line">23.5 本章习题 758  </span><br><span class="line"></span><br><span class="line">23.6 参考资料与扩展阅读 758  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第 24章 Linux内核编译与管理 759  </span><br><span class="line"></span><br><span class="line">24.1 编译前的任务：认识内核与获取内核源代码 760  </span><br><span class="line"></span><br><span class="line">24.1.1 什么是内核（Kernel） 760  </span><br><span class="line"></span><br><span class="line">24.1.2 更新内核的目的 761  </span><br><span class="line"></span><br><span class="line">24.1.3 内核的版本 762  </span><br><span class="line"></span><br><span class="line">24.1.4 内核源代码的获取方式 763  </span><br><span class="line"></span><br><span class="line">24.1.5 内核源代码的解压缩、安装、查看 764  </span><br><span class="line"></span><br><span class="line">24.2 内核编译前的预处理与内核功能选择 765  </span><br><span class="line"></span><br><span class="line">24.2.1 硬件环境查看与内核功能要求 765  </span><br><span class="line"></span><br><span class="line">24.2.2 保持干净源代码：make mrproper 765  </span><br><span class="line"></span><br><span class="line">24.2.3 开始选择内核功能：make XXconfig 765  </span><br><span class="line"></span><br><span class="line">24.2.4 内核功能详细选项选择 767  </span><br><span class="line"></span><br><span class="line">24.3 内核的编译与安装 772  </span><br><span class="line"></span><br><span class="line">24.3.1 编译内核与内核模块 772  </span><br><span class="line"></span><br><span class="line">24.3.2 实际安装模块 773  </span><br><span class="line"></span><br><span class="line">24.3.3 开始安装新内核与多重内核选项（grub） 773  </span><br><span class="line"></span><br><span class="line">24.4 额外（单一）内核模块编译 774  </span><br><span class="line"></span><br><span class="line">24.4.1 编译前注意事项 774  </span><br><span class="line"></span><br><span class="line">24.4.2 单一模块编译 775  </span><br><span class="line"></span><br><span class="line">24.4.3 内核模块管理 777  </span><br><span class="line"></span><br><span class="line">24.5 以*新内核版本编译CentOS 7.x的内核 777  </span><br><span class="line"></span><br><span class="line">24.6 重点回顾 778  </span><br><span class="line"></span><br><span class="line">24.7 本章习题 778  </span><br><span class="line"></span><br><span class="line">24.8 参考资料与扩展阅读 778</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>轻量级JavaEE企业应用实战 PDF</title>
    <url>/posts/513677f4/</url>
    <content><![CDATA[<h4 id="《轻量级JavaEE企业应用实战》"><a href="#《轻量级JavaEE企业应用实战》" class="headerlink" title="《轻量级JavaEE企业应用实战》"></a>《轻量级JavaEE企业应用实战》</h4><h6 id="链接-https-pan-baidu-com-s-1bNYeZHn2OuK1vOsVc6vVWQ-提取码-rtzw"><a href="#链接-https-pan-baidu-com-s-1bNYeZHn2OuK1vOsVc6vVWQ-提取码-rtzw" class="headerlink" title="链接: https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ 提取码: rtzw"></a>链接: <a href="https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ">https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ</a> 提取码: rtzw</h6><p>本书介绍了Java EE开发非常流行的三个开源框架：Spring MVC、Spring和MyBatis，其中Spring MVC、Spring用的是5.1版本，MyBatis用的是3.5版本。本书重点介绍了如何整合Spring MVC + Spring + MyBatis进行开发，内容主要包括三部分。部分介绍Java EE开发的基础知识，以及如何搭建开发环境。第二部分详细讲解MyBatis、Spring和Spring MVC三个框架的用法，并从Eclipse IDE的使用上手，一步步带领读者深入三个框架的核心。这部分是本书的核心内容，因此也是重点部分。这部分并不是简单地讲授三个框架的基本用法，而是真正剖析它们在实际开发场景中面临的挑战及佳实践，并对其诸多关键技术实现提供了源代码解读，这样既能加深读者对框架本质的理解，也能直接提升读者的Java功底。第三部分示范开发了一个包含7个表，表之间具有复杂的关联映射、继承映射等关系，且业务也相对复杂的工作流案例，帮助读者理论联系实际，将三个框架真正运用到实际开发中。该案例采用目前非常流行、规范的Java EE架构，整个应用分为领域对象层、Mapper（DAO）。层、业务逻辑层、MVC层和视图层，各层之间分层清晰，层与层之间以松耦合的方式组织在一起。该案例既提供了与IDE无关的、基于Ant管理的项目源代码，也提供了基于Eclipse IDE的项目源代码，大限度地满足读者的需求。本书配有读者答疑交流群，读者可通过扫描本书封面勒口上的二维码，按照指引加入，本书作者将通过交流群提供线上不定期答疑服务。<br><a id="more"></a></p>
<p><img src="/images/9b25cf376e19e474288f31a4208342df1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 Java EE应用和开发环境 1</span><br><span class="line"></span><br><span class="line">1．1 Java EE应用概述 2</span><br><span class="line"></span><br><span class="line">1．1．1 Java EE应用的分层模型 2</span><br><span class="line"></span><br><span class="line">1．1．2 Java EE应用的组件 3</span><br><span class="line"></span><br><span class="line">1．1．3 Java EE应用的结构和优势 4</span><br><span class="line"></span><br><span class="line">1．1．4 常用的Java EE服务器 4</span><br><span class="line"></span><br><span class="line">1．2 轻量级Java EE应用相关技术 5</span><br><span class="line"></span><br><span class="line">1．2．1 JSP、Servlet 4．x和JavaBean及替代技术 5</span><br><span class="line"></span><br><span class="line">1．2．2 Spring MVC及替代技术 6</span><br><span class="line"></span><br><span class="line">1．2．3 MyBatis及替代技术 6</span><br><span class="line"></span><br><span class="line">1．2．4 Spring及替代技术 7</span><br><span class="line"></span><br><span class="line">1．3 Tomcat的下载和安装 8</span><br><span class="line"></span><br><span class="line">1．3．1 安装Tomcat服务器 8</span><br><span class="line"></span><br><span class="line">1．3．2 配置Tomcat的服务端口 9</span><br><span class="line"></span><br><span class="line">1．3．3 进入控制台 10</span><br><span class="line"></span><br><span class="line">1．3．4 部署Web应用 12</span><br><span class="line"></span><br><span class="line">1．3．5 配置Tomcat的数据源 13</span><br><span class="line"></span><br><span class="line">1．4 Eclipse的安装和使用 15</span><br><span class="line"></span><br><span class="line">1．4．1 Eclipse的下载和安装 15</span><br><span class="line"></span><br><span class="line">1．4．2 在线安装Eclipse插件 15</span><br><span class="line"></span><br><span class="line">1．4．3 从本地压缩包安装插件 17</span><br><span class="line"></span><br><span class="line">1．4．4 手动安装Eclipse插件 18</span><br><span class="line"></span><br><span class="line">1．4．5 使用Eclipse开发Java Web应用 18</span><br><span class="line"></span><br><span class="line">1．4．6 导入Eclipse项目 21</span><br><span class="line"></span><br><span class="line">1．4．7 导入非Eclipse项目 22</span><br><span class="line"></span><br><span class="line">1．5 Ant的安装和使用 23</span><br><span class="line"></span><br><span class="line">1．5．1 Ant的下载和安装 24</span><br><span class="line"></span><br><span class="line">1．5．2 使用Ant工具 25</span><br><span class="line"></span><br><span class="line">1．5．3 定义生成文件 26</span><br><span class="line"></span><br><span class="line">1．5．4 Ant的任务（task） 30</span><br><span class="line"></span><br><span class="line">1．6 Maven的安装和使用 32</span><br><span class="line"></span><br><span class="line">1．6．1 下载和安装Maven 33</span><br><span class="line"></span><br><span class="line">1．6．2 设置Maven 34</span><br><span class="line"></span><br><span class="line">1．6．3 创建、构建简单的项目 35</span><br><span class="line"></span><br><span class="line">1．6．4 Maven的核心概念 39</span><br><span class="line"></span><br><span class="line">1．6．5 依赖管理 44</span><br><span class="line"></span><br><span class="line">1．6．6 POM文件的元素 46</span><br><span class="line"></span><br><span class="line">1．7 使用Git进行软件配置管理（SCM） 47</span><br><span class="line"></span><br><span class="line">1．7．1 下载和安装Git、TortoiseGit 47</span><br><span class="line"></span><br><span class="line">1．7．2 创建本地资源库 49</span><br><span class="line"></span><br><span class="line">1．7．3 添加文件和文件夹 51</span><br><span class="line"></span><br><span class="line">1．7．4 提交修改 52</span><br><span class="line"></span><br><span class="line">1．7．5 查看文件或文件夹的版本变更 53</span><br><span class="line"></span><br><span class="line">1．7．6 删除文件或文件夹 54</span><br><span class="line"></span><br><span class="line">1．7．7 从以前版本重新开始 55</span><br><span class="line"></span><br><span class="line">1．7．8 克隆项目 56</span><br><span class="line"></span><br><span class="line">1．7．9 创建分支 56</span><br><span class="line"></span><br><span class="line">1．7．10 沿着分支开发 57</span><br><span class="line"></span><br><span class="line">1．7．11 合并分支 58</span><br><span class="line"></span><br><span class="line">1．7．12 使用Eclipse作为Git客户端 59</span><br><span class="line"></span><br><span class="line">1．7．13 配置远程中央资源库 61</span><br><span class="line"></span><br><span class="line">1．7．14 推送项目 64</span><br><span class="line"></span><br><span class="line">1．7．15 获取项目和拉取项目 64</span><br><span class="line"></span><br><span class="line">1．8 本章小结 66</span><br><span class="line"></span><br><span class="line">第2章 MyBatis的基础用法 67</span><br><span class="line"></span><br><span class="line">2．1 MyBatis是ORM框架吗 68</span><br><span class="line"></span><br><span class="line">2．1．1 何谓ORM 68</span><br><span class="line"></span><br><span class="line">2．1．2 ORM的映射方式 69</span><br><span class="line"></span><br><span class="line">2．1．3 MyBatis的映射方式 70</span><br><span class="line"></span><br><span class="line">2．2 MyBatis入门 71</span><br><span class="line"></span><br><span class="line">2．2．1 MyBatis的下载和安装 72</span><br><span class="line"></span><br><span class="line">2．2．2 MyBatis的数据库操作 72</span><br><span class="line"></span><br><span class="line">2．2．3 使用MyBatis执行CRUD 78</span><br><span class="line"></span><br><span class="line">2．2．4 利用Mapper对象 80</span><br><span class="line"></span><br><span class="line">2．2．5 在Eclipse中使用MyBatis 84</span><br><span class="line"></span><br><span class="line">2．3 MyBatis核心API及作用域 90</span><br><span class="line"></span><br><span class="line">2．3．1 SqlSessionFactoryBuilder的作用域 90</span><br><span class="line"></span><br><span class="line">2．3．2 SqlSessionFactory的作用域 91</span><br><span class="line"></span><br><span class="line">2．3．3 SqlSession及其作用域 92</span><br><span class="line"></span><br><span class="line">2．3．4 Mapper组件的作用域 94</span><br><span class="line"></span><br><span class="line">2．4 MyBatis配置详解 94</span><br><span class="line"></span><br><span class="line">2．4．1 属性配置 95</span><br><span class="line"></span><br><span class="line">2．4．2 设置配置 98</span><br><span class="line"></span><br><span class="line">2．4．3 为类型配置别名 101</span><br><span class="line"></span><br><span class="line">2．4．4 对象工厂 103</span><br><span class="line"></span><br><span class="line">2．4．5 加载Mapper 105</span><br><span class="line"></span><br><span class="line">2．5 类型处理器 106</span><br><span class="line"></span><br><span class="line">2．5．1 内置的类型处理器 106</span><br><span class="line"></span><br><span class="line">2．5．2 自定义类型处理器 107</span><br><span class="line"></span><br><span class="line">2．5．3 枚举的类型处理器 111</span><br><span class="line"></span><br><span class="line">2．5．4 存储枚举值的序号 112</span><br><span class="line"></span><br><span class="line">2．5．5 同时存储枚举值的名称和序号 113</span><br><span class="line"></span><br><span class="line">2．6 数据库环境配置 116</span><br><span class="line"></span><br><span class="line">2．6．1 环境配置与默认环境配置 116</span><br><span class="line"></span><br><span class="line">2．6．2 事务管理器 117</span><br><span class="line"></span><br><span class="line">2．6．3 数据源配置 121</span><br><span class="line"></span><br><span class="line">2．6．4 配置第三方C3P0数据源 122</span><br><span class="line"></span><br><span class="line">2．7 支持不同类型的数据库 124</span><br><span class="line"></span><br><span class="line">2．8 Mapper基础 127</span><br><span class="line"></span><br><span class="line">2．8．1 select的用法 128</span><br><span class="line"></span><br><span class="line">2．8．2 insert的用法 130</span><br><span class="line"></span><br><span class="line">2．8．3 使用useGeneratedKeys返回 自增长的主键值 131</span><br><span class="line"></span><br><span class="line">2．8．4 使用selectKey生成主键值 132</span><br><span class="line"></span><br><span class="line">2．8．5 update和delete元素的用法 134</span><br><span class="line"></span><br><span class="line">2．8．6 使用sql元素定义可复用的SQL片段 134</span><br><span class="line"></span><br><span class="line">2．8．7 参数处理 136</span><br><span class="line"></span><br><span class="line">2．8．8 参数的额外声明 142</span><br><span class="line"></span><br><span class="line">2．8．9 字符串替换 142</span><br><span class="line"></span><br><span class="line">2．9 MyBatis代码生成器 144</span><br><span class="line"></span><br><span class="line">2．9．1 提供配置文件 145</span><br><span class="line"></span><br><span class="line">2．9．2 运行MBG 146</span><br><span class="line"></span><br><span class="line">2．10 本章小结 149</span><br><span class="line"></span><br><span class="line">第3章 深入使用MyBatis 151</span><br><span class="line"></span><br><span class="line">3．1 结果集映射 152</span><br><span class="line"></span><br><span class="line">3．1．1 简单resultMap映射 152</span><br><span class="line"></span><br><span class="line">3．1．2 构造器映射 154</span><br><span class="line"></span><br><span class="line">3．1．3 自动映射 157</span><br><span class="line"></span><br><span class="line">3．2 调用存储过程 159</span><br><span class="line"></span><br><span class="line">3．2．1 调用返回结果集的存储过程 159</span><br><span class="line"></span><br><span class="line">3．2．2 调用带out模式参数的存储过程 160</span><br><span class="line"></span><br><span class="line">3．2．3 调用传出参数为游标引用的存储过程 162</span><br><span class="line"></span><br><span class="line">3．3 关联映射 165</span><br><span class="line"></span><br><span class="line">3．3．1 基于嵌套select的一对一映射 165</span><br><span class="line"></span><br><span class="line">3．3．2 基于嵌套select映射策略的性能缺陷 171</span><br><span class="line"></span><br><span class="line">3．3．3加载的原理 175</span><br><span class="line"></span><br><span class="line">3．3．4 基于多表连接查询的一对一映射 176</span><br><span class="line"></span><br><span class="line">3．3．5 基于多结果集的一对一映射 182</span><br><span class="line"></span><br><span class="line">3．3．6 基于嵌套select的一对多映射 184</span><br><span class="line"></span><br><span class="line">3．3．7 基于多表连接查询的一对多映射 191</span><br><span class="line"></span><br><span class="line">3．3．8 基于多结果集的一对多映射 192</span><br><span class="line"></span><br><span class="line">3．3．9 多对多映射的三种策略 194</span><br><span class="line"></span><br><span class="line">3．4 基于辨别者列的继承映射 201</span><br><span class="line"></span><br><span class="line">3．4．1 继承映射的简单示例 201</span><br><span class="line"></span><br><span class="line">3．4．2 继承映射的复杂示例 205</span><br><span class="line"></span><br><span class="line">3．5 动态SQL 210</span><br><span class="line"></span><br><span class="line">3．5．1 if元素的用法 210</span><br><span class="line"></span><br><span class="line">3．5．2 在update更新列中使用if 216</span><br><span class="line"></span><br><span class="line">3．5．3 在insert动态插入列中使用if 219</span><br><span class="line"></span><br><span class="line">3．5．4 choose、when、otherwise元素的 用法 222</span><br><span class="line"></span><br><span class="line">3．5．5 where与trim的用法 225</span><br><span class="line"></span><br><span class="line">3．5．6 set与trim的用法 228</span><br><span class="line"></span><br><span class="line">3．5．7 使用trim实现动态插入 230</span><br><span class="line"></span><br><span class="line">3．5．8 foreach元素的基本用法 232</span><br><span class="line"></span><br><span class="line">3．5．9 foreach实现批量插入 234</span><br><span class="line"></span><br><span class="line">3．5．10 foreach实现批量更新 236</span><br><span class="line"></span><br><span class="line">3．5．11 bind元素的用法 239</span><br><span class="line"></span><br><span class="line">3．6 缓存 240</span><br><span class="line"></span><br><span class="line">3．6．1 一级缓存 240</span><br><span class="line"></span><br><span class="line">3．6．2 一级缓存的脏数据与避免方法 243</span><br><span class="line"></span><br><span class="line">3．6．3 二级缓存 246</span><br><span class="line"></span><br><span class="line">3．6．4 二级缓存的脏数据与避免方法 248</span><br><span class="line"></span><br><span class="line">3．6．5 整合Ehcache实现二级缓存 252</span><br><span class="line"></span><br><span class="line">3．7 用插件扩展MyBatis 254</span><br><span class="line"></span><br><span class="line">3．7．1 拦截器接口及作用原理 254</span><br><span class="line"></span><br><span class="line">3．7．2 可拦截的目标 256</span><br><span class="line"></span><br><span class="line">3．7．3 为MyBatis开发分页插件 260</span><br><span class="line"></span><br><span class="line">3．8 本章小结 266</span><br><span class="line"></span><br><span class="line">第4章 Spring的基础用法 267</span><br><span class="line"></span><br><span class="line">4．1 Spring简介和Spring 5的变化 268</span><br><span class="line"></span><br><span class="line">4．1．1 Spring简介 268</span><br><span class="line"></span><br><span class="line">4．1．2 Spring 5．x的变化 269</span><br><span class="line"></span><br><span class="line">4．2 Spring入门 269</span><br><span class="line"></span><br><span class="line">4．2．1 Spring的下载和安装 270</span><br><span class="line"></span><br><span class="line">4．2．2 使用Spring管理Bean 270</span><br><span class="line"></span><br><span class="line">4．2．3 在Eclipse中使用Spring 274</span><br><span class="line"></span><br><span class="line">4．3 Spring的核心机制：依赖注入 276</span><br><span class="line"></span><br><span class="line">4．3．1 理解依赖注入 277</span><br><span class="line"></span><br><span class="line">4．3．2 设值注入 278</span><br><span class="line"></span><br><span class="line">4．3．3 构造注入 282</span><br><span class="line"></span><br><span class="line">4．3．4 两种注入方式的对比 284</span><br><span class="line"></span><br><span class="line">4．4 使用Spring容器 284</span><br><span class="line"></span><br><span class="line">4．4．1 Spring容器 284</span><br><span class="line"></span><br><span class="line">4．4．2 使用ApplicationContext 286</span><br><span class="line"></span><br><span class="line">4．4．3 ApplicationContext的化支持 287</span><br><span class="line"></span><br><span class="line">4．4．4 ApplicationContext的事件机制 289</span><br><span class="line"></span><br><span class="line">4．4．5 让Bean获取Spring容器 292</span><br><span class="line"></span><br><span class="line">4．5 Spring容器中的Bean 294</span><br><span class="line"></span><br><span class="line">4．5．1 Bean的基本定义和Bean别名 294</span><br><span class="line"></span><br><span class="line">4．5．2 容器中Bean的作用域 295</span><br><span class="line"></span><br><span class="line">4．5．3 配置依赖 299</span><br><span class="line"></span><br><span class="line">4．5．4 设置普通属性值 300</span><br><span class="line"></span><br><span class="line">4．5．5 配置合作者Bean 302</span><br><span class="line"></span><br><span class="line">4．5．6 使用自动装配注入合作者Bean 302</span><br><span class="line"></span><br><span class="line">4．5．7 注入嵌套Bean 305</span><br><span class="line"></span><br><span class="line">4．5．8 注入集合值 306</span><br><span class="line"></span><br><span class="line">4．5．9 组合属性 311</span><br><span class="line"></span><br><span class="line">4．5．10 Spring的Bean和JavaBean 312</span><br><span class="line"></span><br><span class="line">4．6 Spring的Java配置管理 313</span><br><span class="line"></span><br><span class="line">4．7 创建Bean的三种方式 316</span><br><span class="line"></span><br><span class="line">4．7．1 使用构造器创建Bean 316</span><br><span class="line"></span><br><span class="line">4．7．2 使用静态工厂方法创建Bean 317</span><br><span class="line"></span><br><span class="line">4．7．3 使用实例工厂方法创建Bean 319</span><br><span class="line"></span><br><span class="line">4．8 深入理解容器中的Bean 321</span><br><span class="line"></span><br><span class="line">4．8．1 抽象Bean与子Bean 322</span><br><span class="line"></span><br><span class="line">4．8．2 Bean继承与Java继承的区别 323</span><br><span class="line"></span><br><span class="line">4．8．3 容器中的工厂Bean 323</span><br><span class="line"></span><br><span class="line">4．8．4 获得Bean本身的id 326</span><br><span class="line"></span><br><span class="line">4．8．5 强制初始化Bean 327</span><br><span class="line"></span><br><span class="line">4．9 容器中Bean的生命周期 327</span><br><span class="line"></span><br><span class="line">4．9．1 依赖关系注入之后的行为 328</span><br><span class="line"></span><br><span class="line">4．9．2 Bean销毁之前的行为 330</span><br><span class="line"></span><br><span class="line">4．9．3 协调作用域不同步的Bean 332</span><br><span class="line"></span><br><span class="line">4．10依赖关系配置 336</span><br><span class="line"></span><br><span class="line">4．10．1 获取其他Bean的属性值 336</span><br><span class="line"></span><br><span class="line">4．10．2 获取Field值 339</span><br><span class="line"></span><br><span class="line">4．10．3 获取方法的返回值 341</span><br><span class="line"></span><br><span class="line">4．11 基于XML Schema的简化配置方式 344</span><br><span class="line"></span><br><span class="line">4．11．1 使用p：命名空间简化配置 344</span><br><span class="line"></span><br><span class="line">4．11．2 使用c：命名空间简化配置 345</span><br><span class="line"></span><br><span class="line">4．11．3 使用util：命名空间简化配置 347</span><br><span class="line"></span><br><span class="line">4．12 Spring表达式语言 349</span><br><span class="line"></span><br><span class="line">4．12．1 使用Expression接口进行表达式求值 350</span><br><span class="line"></span><br><span class="line">4．12．2 Bean定义中的表达式语言支持 352</span><br><span class="line"></span><br><span class="line">4．12．3 SpEL语法详述 353</span><br><span class="line"></span><br><span class="line">4．13 本章小结 358</span><br><span class="line"></span><br><span class="line">第5章 深入使用Spring 359</span><br><span class="line"></span><br><span class="line">5．1 两种后处理器 360</span><br><span class="line"></span><br><span class="line">5．1．1 Bean后处理器 360</span><br><span class="line"></span><br><span class="line">5．1．2 Bean后处理器的用处 364</span><br><span class="line"></span><br><span class="line">5．1．3 容器后处理器 364</span><br><span class="line"></span><br><span class="line">5．1．4 属性占位符配置器 366</span><br><span class="line"></span><br><span class="line">5．1．5 重写占位符配置器 367</span><br><span class="line"></span><br><span class="line">5．2 “零配置”支持 368</span><br><span class="line"></span><br><span class="line">5．2．1 搜索Bean类 368</span><br><span class="line"></span><br><span class="line">5．2．2 指定Bean的作用域 371</span><br><span class="line"></span><br><span class="line">5．2．3 使用@Resource、@Value配置依赖 372</span><br><span class="line"></span><br><span class="line">5．2．4 使用@PostConstruct和@PreDestroy定制生命周期行为 373</span><br><span class="line"></span><br><span class="line">5．2．5 @DependsOn和@Lazy 374</span><br><span class="line"></span><br><span class="line">5．2．6 自动装配和装配 374</span><br><span class="line"></span><br><span class="line">5．2．7 Spring 5新增的注解 379</span><br><span class="line"></span><br><span class="line">5．3 资源访问 380</span><br><span class="line"></span><br><span class="line">5．3．1 Resource实现类 381</span><br><span class="line"></span><br><span class="line">5．3．2 ResourceLoader接口和 ResourceLoaderAware接口 385</span><br><span class="line"></span><br><span class="line">5．3．3 使用Resource作为属性 388</span><br><span class="line"></span><br><span class="line">5．3．4 在ApplicationContext中使用资源 389</span><br><span class="line"></span><br><span class="line">5．4 Spring的AOP 392</span><br><span class="line"></span><br><span class="line">5．4．1 为什么需要AOP 393</span><br><span class="line"></span><br><span class="line">5．4．2 使用AspectJ实现AOP 394</span><br><span class="line"></span><br><span class="line">5．4．3 AOP的基本概念 401</span><br><span class="line"></span><br><span class="line">5．4．4 Spring的AOP支持 402</span><br><span class="line"></span><br><span class="line">5．4．5 基于注解的“零配置”方式 403</span><br><span class="line"></span><br><span class="line">5．4．6 基于XML配置文件的管理方式 418</span><br><span class="line"></span><br><span class="line">5．5 Spring的缓存机制 424</span><br><span class="line"></span><br><span class="line">5．5．1 启用Spring缓存 425</span><br><span class="line"></span><br><span class="line">5．5．2 使用@Cacheable执行缓存 427</span><br><span class="line"></span><br><span class="line">5．5．3 使用@CacheEvict清除缓存数据 431</span><br><span class="line"></span><br><span class="line">5．6 Spring的事务 433</span><br><span class="line"></span><br><span class="line">5．6．1 Spring支持的事务策略 433</span><br><span class="line"></span><br><span class="line">5．6．2 使用XML Schema配置事务策略 436</span><br><span class="line"></span><br><span class="line">5．6．3 使用@Transactional 442</span><br><span class="line"></span><br><span class="line">5．7 Spring整合MyBatis 443</span><br><span class="line"></span><br><span class="line">5．7．1 整合MyBatis的关键点及快速入门 443</span><br><span class="line"></span><br><span class="line">5．7．2 配置SqlSessionFactory 448</span><br><span class="line"></span><br><span class="line">5．7．3 通过工厂Bean配置Mapper组件 449</span><br><span class="line"></span><br><span class="line">5．7．4 通过扫描自动配置Mapper组件 450</span><br><span class="line"></span><br><span class="line">5．7．5 基于SqlSession实现DAO组件 452</span><br><span class="line"></span><br><span class="line">5．7．6 继承SqlSessionDaoSupport实现DAO组件 455</span><br><span class="line"></span><br><span class="line">5．7．7 事务管理 457</span><br><span class="line"></span><br><span class="line">5．8 本章小结 458</span><br><span class="line"></span><br><span class="line">第6章 Spring MVC的基础用法 459</span><br><span class="line"></span><br><span class="line">6．1 MVC概述 460</span><br><span class="line"></span><br><span class="line">6．1．1 MVC模式及其优势 460</span><br><span class="line"></span><br><span class="line">6．1．2 Spring MVC与Struts 2的区别 461</span><br><span class="line"></span><br><span class="line">6．2 Spring MVC入门 463</span><br><span class="line"></span><br><span class="line">6．2．1 在Web应用中启动Spring容器 463</span><br><span class="line"></span><br><span class="line">6．2．2 配置核心控制器 466</span><br><span class="line"></span><br><span class="line">6．2．3 开发控制器 468</span><br><span class="line"></span><br><span class="line">6．2．4 提供视图资源 470</span><br><span class="line"></span><br><span class="line">6．2．5 使用Eclipse开发Spring MVC应用 471</span><br><span class="line"></span><br><span class="line">6．3 Spring MVC的流程 472</span><br><span class="line"></span><br><span class="line">6．3．1 Spring MVC应用的开发步骤 472</span><br><span class="line"></span><br><span class="line">6．3．2 Spring MVC的运行流程 474</span><br><span class="line"></span><br><span class="line">6．3．3 DispatcherServlet详解 475</span><br><span class="line"></span><br><span class="line">6．3．4 mvc：annotation-driven详解 480</span><br><span class="line"></span><br><span class="line">6．4 静态资源处理 481</span><br><span class="line"></span><br><span class="line">6．4．1 静态资源映射 481</span><br><span class="line"></span><br><span class="line">6．4．2 配置默认Servlet 483</span><br><span class="line"></span><br><span class="line">6．5 视图解析器 485</span><br><span class="line"></span><br><span class="line">6．5．1 UrlBasedViewResolver的功能与用法 486</span><br><span class="line"></span><br><span class="line">6．5．2 InternalResourceViewResolver的功能与用法 491</span><br><span class="line"></span><br><span class="line">6．5．3 XmlViewResolver及视图解析器的链式处理 492</span><br><span class="line"></span><br><span class="line">6．5．4 ResourceBundleViewResolver的功能与用法 496</span><br><span class="line"></span><br><span class="line">6．5．5 BeanNameViewResolver的功能与用法 497</span><br><span class="line"></span><br><span class="line">6．5．6 重定向视图 499</span><br><span class="line"></span><br><span class="line">6．5．7 将数据传给重定向目标 500</span><br><span class="line"></span><br><span class="line">6．5．8 ContentNegotiatingViewResolver的功能与用法 503</span><br><span class="line"></span><br><span class="line">6．6 请求映射与参数处理 510</span><br><span class="line"></span><br><span class="line">6．6．1 HandlerMapping与处理映射 510</span><br><span class="line"></span><br><span class="line">6．6．2 SimpleUrlHandlerMapping的功能与用法 511</span><br><span class="line"></span><br><span class="line">6．6．3 @RequestMapping注解及其变体 512</span><br><span class="line"></span><br><span class="line">6．6．4 处理方法允许的返回值类型 515</span><br><span class="line"></span><br><span class="line">6．6．5 @RequestParam注解与MultiValueMap 516</span><br><span class="line"></span><br><span class="line">6．6．6 使用@PathVariable获取路径变量的值 520</span><br><span class="line"></span><br><span class="line">6．6．7 使用@PathVariable处理正则 表达式 523</span><br><span class="line"></span><br><span class="line">6．6．8 路径模式 524</span><br><span class="line"></span><br><span class="line">6．6．9 使用@MatrixVariable处理Matrix变量 526</span><br><span class="line"></span><br><span class="line">6．6．10 使用@RequestHeader获取请求头的值 529</span><br><span class="line"></span><br><span class="line">6．6．11 异步处理 530</span><br><span class="line"></span><br><span class="line">6．6．12 使用DeferredResult支持异步处理 534</span><br><span class="line"></span><br><span class="line">6．6．13 使用@ModelAttribute修饰方法本身 536</span><br><span class="line"></span><br><span class="line">6．6．14 使用@ModelAttribute修饰方法参数 539</span><br><span class="line"></span><br><span class="line">6．7 将数据传给视图页面 541</span><br><span class="line"></span><br><span class="line">6．7．1 Model、ModelMap和RedirectAttributes 541</span><br><span class="line"></span><br><span class="line">6．7．2 使用@SessionAttributes添加session属性 542</span><br><span class="line"></span><br><span class="line">6．8 RESTful服务支持 544</span><br><span class="line"></span><br><span class="line">6．8．1 RESTful简介 544</span><br><span class="line"></span><br><span class="line">6．8．2 @RequestBody与@ResponseBody注解 546</span><br><span class="line"></span><br><span class="line">6．8．3 HttpMessageConverter与消息转换 550</span><br><span class="line"></span><br><span class="line">6．8．4 转换XML数据 553</span><br><span class="line"></span><br><span class="line">6．8．5 使用@RestController修饰RESTful控制器 557</span><br><span class="line"></span><br><span class="line">6．8．6 @CrossOrigin注解与跨域请求 557</span><br><span class="line"></span><br><span class="line">6．9 访问Servlet API相关数据 561</span><br><span class="line"></span><br><span class="line">6．9．1 处理方法可接受的形参类型 561</span><br><span class="line"></span><br><span class="line">6．9．2 使用@RequestAttribute获取请求属性 562</span><br><span class="line"></span><br><span class="line">6．9．3 使用@SessionAttribute获取session属性 563</span><br><span class="line"></span><br><span class="line">6．9．4 直接访问Servlet API 566</span><br><span class="line"></span><br><span class="line">6．9．5 使用WebRequest和NativeWebRequest伪访问 567</span><br><span class="line"></span><br><span class="line">6．9．6 使用@CookieValue获取cookie值 569</span><br><span class="line"></span><br><span class="line">6．9．7 在处理方法中使用IO流 571</span><br><span class="line"></span><br><span class="line">6．10 本章小结 573</span><br><span class="line"></span><br><span class="line">第7章 深入使用Spring MVC 574</span><br><span class="line"></span><br><span class="line">7．1化 575</span><br><span class="line"></span><br><span class="line">7．1．1化到底怎么做 575</span><br><span class="line"></span><br><span class="line">7．1．2 根据浏览器请求头确定Locale 577</span><br><span class="line"></span><br><span class="line">7．1．3 根据session确定Locale 582</span><br><span class="line"></span><br><span class="line">7．1．4 根据cookie值确定Locale 586</span><br><span class="line"></span><br><span class="line">7．2 异常处理 587</span><br><span class="line"></span><br><span class="line">7．2．1 Spring MVC异常处理 587</span><br><span class="line"></span><br><span class="line">7．2．2 传统的异常处理机制 590</span><br><span class="line"></span><br><span class="line">7．2．3 使用@ResponseStatus修饰异常类 594</span><br><span class="line"></span><br><span class="line">7．2．4 使用@ExceptionHandler修饰异常 处理方法 596</span><br><span class="line"></span><br><span class="line">7．2．5 使用@ControllerAdvice定义异常Aspect 599</span><br><span class="line"></span><br><span class="line">7．2．6 使用@RestControllerAdvice定义异常Aspect 600</span><br><span class="line"></span><br><span class="line">7．3 标签库 602</span><br><span class="line"></span><br><span class="line">7．3．1 form标签与普通表单域标签 602</span><br><span class="line"></span><br><span class="line">7．3．2 radiobutton和radiobuttons标签 605</span><br><span class="line"></span><br><span class="line">7．3．3 checkbox和checkboxes标签 607</span><br><span class="line"></span><br><span class="line">7．3．4 select和option、options标签 610</span><br><span class="line"></span><br><span class="line">7．3．5 htmlEscape和escapeBody标签 612</span><br><span class="line"></span><br><span class="line">7．3．6 url和param标签 613</span><br><span class="line"></span><br><span class="line">7．4 类型转换与绑定 615</span><br><span class="line"></span><br><span class="line">7．4．1 BeanWrapper简介 616</span><br><span class="line"></span><br><span class="line">7．4．2 PropertyEditor与内置实现类 618</span><br><span class="line"></span><br><span class="line">7．4．3 自定义PropertyEditor 619</span><br><span class="line"></span><br><span class="line">7．4．4 使用WebBindingInitializer注册全局PropertyEditor 621</span><br><span class="line"></span><br><span class="line">7．4．5 使用ConversionService执行转换 623</span><br><span class="line"></span><br><span class="line">7．4．6 处理转换 626</span><br><span class="line"></span><br><span class="line">7．5 格式化 629</span><br><span class="line"></span><br><span class="line">7．5．1 使用格式化器 630</span><br><span class="line"></span><br><span class="line">7．5．2 使用FormatterRegistrar注册 格式化器 633</span><br><span class="line"></span><br><span class="line">7．6 数据校验 634</span><br><span class="line"></span><br><span class="line">7．6．1 使用Validation执行校验 634</span><br><span class="line"></span><br><span class="line">7．6．2 基于JSR 303执行校验 638</span><br><span class="line"></span><br><span class="line">7．7 文件上传与下载 641</span><br><span class="line"></span><br><span class="line">7．7．1 使用MultipartFile处理文件上传 641</span><br><span class="line"></span><br><span class="line">7．7．2 基于Commons FileUpload组件 上传文件 646</span><br><span class="line"></span><br><span class="line">7．7．3 使用@RequestPart注解 647</span><br><span class="line"></span><br><span class="line">7．7．4 文件下载 650</span><br><span class="line"></span><br><span class="line">7．7．5 下载前的授权控制 652</span><br><span class="line"></span><br><span class="line">7．8 拦截器 653</span><br><span class="line"></span><br><span class="line">7．9 SSM整合开发 656</span><br><span class="line"></span><br><span class="line">7．9．1 搭建项目 657</span><br><span class="line"></span><br><span class="line">7．9．2 开发Mapper组件 659</span><br><span class="line"></span><br><span class="line">7．9．3 开发Service组件 660</span><br><span class="line"></span><br><span class="line">7．9．4 控制器与视图 661</span><br><span class="line"></span><br><span class="line">7．10 本章小结 666</span><br><span class="line"></span><br><span class="line">第8章 简单工作流 667</span><br><span class="line"></span><br><span class="line">8．1 项目背景及结构 668</span><br><span class="line"></span><br><span class="line">8．1．1 应用背景 668</span><br><span class="line"></span><br><span class="line">8．1．2功能介绍 668</span><br><span class="line"></span><br><span class="line">8．1．3 相关技术介绍 669</span><br><span class="line"></span><br><span class="line">8．1．4结构 670</span><br><span class="line"></span><br><span class="line">8．1．5的功能模块 670</span><br><span class="line"></span><br><span class="line">8．2 领域对象层 671</span><br><span class="line"></span><br><span class="line">8．2．1 设计领域对象 671</span><br><span class="line"></span><br><span class="line">8．2．2 创建领域对象类 672</span><br><span class="line"></span><br><span class="line">8．3 实现Mapper（DAO）层 677</span><br><span class="line"></span><br><span class="line">8．3．1 Mapper组件的定义 677</span><br><span class="line"></span><br><span class="line">8．3．2 实现Mapper组件 681</span><br><span class="line"></span><br><span class="line">8．3．3 部署Mapper层 685</span><br><span class="line"></span><br><span class="line">8．4 实现Service层 686</span><br><span class="line"></span><br><span class="line">8．4．1 业务逻辑组件的设计 686</span><br><span class="line"></span><br><span class="line">8．4．2 实现业务逻辑组件 687</span><br><span class="line"></span><br><span class="line">8．4．3 事务管理 692</span><br><span class="line"></span><br><span class="line">8．4．4 部署业务逻辑组件 693</span><br><span class="line"></span><br><span class="line">8．5 实现任务的自动调度 693</span><br><span class="line"></span><br><span class="line">8．5．1 使用Quartz 693</span><br><span class="line"></span><br><span class="line">8．5．2 在Spring中使用Quartz 698</span><br><span class="line"></span><br><span class="line">8．6 实现Web层 700</span><br><span class="line"></span><br><span class="line">8．6．1 配置核心控制器和启动Spring容器 700</span><br><span class="line"></span><br><span class="line">8．6．2 控制器的处理顺序 701</span><br><span class="line"></span><br><span class="line">8．6．3 员工登录 702</span><br><span class="line"></span><br><span class="line">8．6．4 进入打卡 705</span><br><span class="line"></span><br><span class="line">8．6．5 处理打卡 707</span><br><span class="line"></span><br><span class="line">8．6．6 进入申请 708</span><br><span class="line"></span><br><span class="line">8．6．7 提交申请 709</span><br><span class="line"></span><br><span class="line">8．6．8 使用拦截器完成权限管理 710</span><br><span class="line"></span><br><span class="line">8．7 本章小结 712</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>人工智能复杂问题求解的结构和策略 PDF</title>
    <url>/posts/26314762/</url>
    <content><![CDATA[<h4 id="《人工智能复杂问题求解的结构和策略》"><a href="#《人工智能复杂问题求解的结构和策略》" class="headerlink" title="《人工智能复杂问题求解的结构和策略》"></a>《人工智能复杂问题求解的结构和策略》</h4><h6 id="链接-https-pan-baidu-com-s-1YKwaiTfWRd3Tb1WsSLfHng-提取码-5ji1"><a href="#链接-https-pan-baidu-com-s-1YKwaiTfWRd3Tb1WsSLfHng-提取码-5ji1" class="headerlink" title="链接: https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng 提取码: 5ji1"></a>链接: <a href="https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng">https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng</a> 提取码: 5ji1</h6><p>　　《人工智能复杂问题求解的结构和策略（原书第6版）》是一本经典的人工智能教材，全面阐述了人工智能的基础理论，有效结合了求解智能问题的数据结构以及实现的算法。把人工智能的应用程序应用于实际环境中，并从社会和哲学、心理学以及神经生理学角度对人工智能进行了全面的讨论。<br><a id="more"></a></p>
<p>　　本版新增内容</p>
<p>新增一章，介绍用于机器学习的随机方法，包括一阶贝叶斯网络、各种隐马尔可夫模型、马尔可</p>
<p>　　夫随机场推理和循环信念传播。</p>
<p>介绍针对期望学习以及利用马尔可夫链蒙特卡罗抽样的结构化学习的参数选择，强化学习</p>
<p>　　中马尔可夫决策过程的利用。</p>
<p>介绍智能体技术和本体的使用。</p>
<p>介绍自然语言处理的动态规划（Earley语法分析）以及Viterbi等其他概率语法分析技术。</p>
<p>书中的许多算法采用Prolog，LISP和Java语言来构建。</p>
<p><img src="/images/67728ba68913c6d8c851912a10b528221.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">出版者的话</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第一部分 人工智能的历史渊源及研究范围</span><br><span class="line"></span><br><span class="line">第1章 人工智能的历史及应用</span><br><span class="line"></span><br><span class="line">1.1 从伊甸园到第一台电子计算机：对智能、知识和人类技能的态度</span><br><span class="line"></span><br><span class="line">1.1.1 人工智能基础的简要历史</span><br><span class="line"></span><br><span class="line">1.1.2 理性主义和经验主义学派对人工智能的影响</span><br><span class="line"></span><br><span class="line">1.1.3 形式逻辑的发展</span><br><span class="line"></span><br><span class="line">1.1.4 图灵测试</span><br><span class="line"></span><br><span class="line">1.1.5 智能的生物和社会模型：主体理论</span><br><span class="line"></span><br><span class="line">1.2 人工智能应用领域概述</span><br><span class="line"></span><br><span class="line">1.2.1 博弈</span><br><span class="line"></span><br><span class="line">1.2.2 自动推理和定理证明</span><br><span class="line"></span><br><span class="line">1.2.3 专家系统</span><br><span class="line"></span><br><span class="line">1.2.4 自然语言理解和语义学</span><br><span class="line"></span><br><span class="line">1.2.5 对人类表现建模</span><br><span class="line"></span><br><span class="line">1.2.6 规划和机器人学</span><br><span class="line"></span><br><span class="line">1.2.7 人工智能的语言和环境</span><br><span class="line"></span><br><span class="line">1.2.8 机器学习</span><br><span class="line"></span><br><span class="line">1.2.9 其他表示：神经网络和遗传算法</span><br><span class="line"></span><br><span class="line">1.2.1 0AI和哲学</span><br><span class="line"></span><br><span class="line">1.3 人工智能小结</span><br><span class="line"></span><br><span class="line">1.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">1.5 习题</span><br><span class="line"></span><br><span class="line">第二部分 作为表示和搜索的人工智能</span><br><span class="line"></span><br><span class="line">第2章 谓词演算</span><br><span class="line"></span><br><span class="line">2.0 简介</span><br><span class="line"></span><br><span class="line">2.1 命题演算（选读）</span><br><span class="line"></span><br><span class="line">2.1.1 符号和语句</span><br><span class="line"></span><br><span class="line">2.1.2 命题演算的语义</span><br><span class="line"></span><br><span class="line">2.2 谓词演算</span><br><span class="line"></span><br><span class="line">2.2.1 谓词的语法和语句</span><br><span class="line"></span><br><span class="line">2.2.2 谓词演算的语义</span><br><span class="line"></span><br><span class="line">2.2.3 语义含义的积木世界例子</span><br><span class="line"></span><br><span class="line">2.3 使用推理规则产生谓词演算表达式</span><br><span class="line"></span><br><span class="line">2.3.1 推理规则</span><br><span class="line"></span><br><span class="line">2.3.2 合一算法</span><br><span class="line"></span><br><span class="line">2.3.3 合一的例子</span><br><span class="line"></span><br><span class="line">2.4 应用：一个基于逻辑的财务顾问</span><br><span class="line"></span><br><span class="line">2.5 结语和参考文献</span><br><span class="line"></span><br><span class="line">2.6 习题</span><br><span class="line"></span><br><span class="line">第3章 状态空间搜索的结构和策略</span><br><span class="line"></span><br><span class="line">3.0 简介</span><br><span class="line"></span><br><span class="line">3.1 状态空间搜索的结构</span><br><span class="line"></span><br><span class="line">3.1.1 图论（选读）</span><br><span class="line"></span><br><span class="line">3.1.2 有限状态自动机（选读）</span><br><span class="line"></span><br><span class="line">3.1.3 问题的状态空间表示</span><br><span class="line"></span><br><span class="line">3.2 用于状态空间搜索的策略</span><br><span class="line"></span><br><span class="line">3.2.1 数据驱动搜索和目标驱动搜索</span><br><span class="line"></span><br><span class="line">3.2.2 图搜索的实现</span><br><span class="line"></span><br><span class="line">3.2.3 深度优先搜索和宽度优先搜索</span><br><span class="line"></span><br><span class="line">3.2.4 迭代加深的深度优先搜索</span><br><span class="line"></span><br><span class="line">3.3 利用状态空间来表示命题演算和谓词演算的推理</span><br><span class="line"></span><br><span class="line">3.3.1 逻辑系统的状态空间描述</span><br><span class="line"></span><br><span class="line">3.3.2 与或图</span><br><span class="line"></span><br><span class="line">3.3.3 进一步的例子和应用</span><br><span class="line"></span><br><span class="line">3.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">3.5 习题</span><br><span class="line"></span><br><span class="line">第4章 启发式搜索</span><br><span class="line"></span><br><span class="line">4.0 简介</span><br><span class="line"></span><br><span class="line">4.1 爬山法和动态规划法</span><br><span class="line"></span><br><span class="line">4.1.1 爬山</span><br><span class="line"></span><br><span class="line">4.1.2 动态规划</span><br><span class="line"></span><br><span class="line">4.2 最佳优先搜索算法</span><br><span class="line"></span><br><span class="line">4.2.1 实现最佳优先搜索</span><br><span class="line"></span><br><span class="line">4.2.2 实现启发评估函数</span><br><span class="line"></span><br><span class="line">4.2.3 启发式搜索和专家系统</span><br><span class="line"></span><br><span class="line">4.3 可采纳性、单调性和信息度</span><br><span class="line"></span><br><span class="line">4.3.1 可采纳性度量</span><br><span class="line"></span><br><span class="line">4.3.2 单调性</span><br><span class="line"></span><br><span class="line">4.3.3 信息度更高的启发是更好的启发</span><br><span class="line"></span><br><span class="line">4.4 在博弈中使用启发</span><br><span class="line"></span><br><span class="line">4.4.1 在可穷举搜索图上的极小极大过程</span><br><span class="line"></span><br><span class="line">4.4.2 固定层深的极小极大过程</span><br><span class="line"></span><br><span class="line">4.4.3 α-β过程</span><br><span class="line"></span><br><span class="line">4.5 复杂度问题</span><br><span class="line"></span><br><span class="line">4.6 结语和参考文献</span><br><span class="line"></span><br><span class="line">4.7 习题</span><br><span class="line"></span><br><span class="line">第5章 随机方法</span><br><span class="line"></span><br><span class="line">5.0 简介</span><br><span class="line"></span><br><span class="line">5.1 计数基础（选读）</span><br><span class="line"></span><br><span class="line">5.1.1 加法和乘法规则</span><br><span class="line"></span><br><span class="line">5.1.2 排列与组合</span><br><span class="line"></span><br><span class="line">5.2 概率论基础</span><br><span class="line"></span><br><span class="line">5.2.1 样本空间、概率和独立性</span><br><span class="line"></span><br><span class="line">5.2.2 概率推理：一个道路&#x2F;交通例子</span><br><span class="line"></span><br><span class="line">5.2.3 随机变量</span><br><span class="line"></span><br><span class="line">5.2.4 条件概率</span><br><span class="line"></span><br><span class="line">5.3 贝叶斯定理</span><br><span class="line"></span><br><span class="line">5.4 随机方法学的应用</span><br><span class="line"></span><br><span class="line">5.4.1 “tomato”是如何发音的</span><br><span class="line"></span><br><span class="line">5.4.2 道路&#x2F;交通例子的扩展</span><br><span class="line"></span><br><span class="line">5.5 结语和参考文献</span><br><span class="line"></span><br><span class="line">5.6 习题</span><br><span class="line"></span><br><span class="line">第6章 为状态空间搜索建立控制算法</span><br><span class="line"></span><br><span class="line">6.0 简介</span><br><span class="line"></span><br><span class="line">6.1 基于递归的搜索（选读）</span><br><span class="line"></span><br><span class="line">6.1.1 递归</span><br><span class="line"></span><br><span class="line">6.1.2 一个递归搜索的例子：模式驱动推理</span><br><span class="line"></span><br><span class="line">6.2 产生式系统</span><br><span class="line"></span><br><span class="line">6.2.1 定义和历史</span><br><span class="line"></span><br><span class="line">6.2.2 产生式系统的例子</span><br><span class="line"></span><br><span class="line">6.2.3 产生式系统中的搜索控制</span><br><span class="line"></span><br><span class="line">6.2.4 AI产生式系统的优点</span><br><span class="line"></span><br><span class="line">6.3 用于问题求解的黑板结构</span><br><span class="line"></span><br><span class="line">6.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">6.5 习题</span><br><span class="line"></span><br><span class="line">第三部分 捕获智能：AI中的挑战</span><br><span class="line"></span><br><span class="line">第7章 知识表示</span><br><span class="line"></span><br><span class="line">7.0 知识表示问题</span><br><span class="line"></span><br><span class="line">7.1 AI表示模式的简要历史</span><br><span class="line"></span><br><span class="line">7.1.1 语义关联理论</span><br><span class="line"></span><br><span class="line">7.1.2 语义网的早期研究</span><br><span class="line"></span><br><span class="line">7.1.3 网络关系的标准化</span><br><span class="line"></span><br><span class="line">7.1.4 脚本</span><br><span class="line"></span><br><span class="line">7.1.5 框架</span><br><span class="line"></span><br><span class="line">7.2 概念图：网络语言</span><br><span class="line"></span><br><span class="line">7.2.1 概念图简介</span><br><span class="line"></span><br><span class="line">7.2.2 类型、个体和名字</span><br><span class="line"></span><br><span class="line">7.2.3 类型层次</span><br><span class="line"></span><br><span class="line">7.2.4 泛化和特化</span><br><span class="line"></span><br><span class="line">7.2.5 命题结点</span><br><span class="line"></span><br><span class="line">7.2.6 概念图和逻辑</span><br><span class="line"></span><br><span class="line">7.3 其他表示方法和本体</span><br><span class="line"></span><br><span class="line">7.3.1 Brooks的包容结构</span><br><span class="line"></span><br><span class="line">7.3.2 Copycat结构</span><br><span class="line"></span><br><span class="line">7.3.3 多种表示、本体和知识服务</span><br><span class="line"></span><br><span class="line">7.4 基于主体的和分布式的问题求解方法</span><br><span class="line"></span><br><span class="line">7.4.1 基于主体的定义</span><br><span class="line"></span><br><span class="line">7.4.2 基于主体的应用</span><br><span class="line"></span><br><span class="line">7.5 结语和参考文献</span><br><span class="line"></span><br><span class="line">7.6 习题</span><br><span class="line"></span><br><span class="line">第8章 求解问题的强方法</span><br><span class="line"></span><br><span class="line">8.0 简介</span><br><span class="line"></span><br><span class="line">8.1 专家系统技术概览</span><br><span class="line"></span><br><span class="line">8.1.1 基于规则的专家系统设计</span><br><span class="line"></span><br><span class="line">8.1.2 问题选择和知识工程的步骤</span><br><span class="line"></span><br><span class="line">8.1.3 概念模型及其在知识获取中的作用</span><br><span class="line"></span><br><span class="line">8.2 基于规则的专家系统</span><br><span class="line"></span><br><span class="line">8.2.1 产生式系统和目标驱动问题求解</span><br><span class="line"></span><br><span class="line">8.2.2 目标驱动推理中的解释和透明性</span><br><span class="line"></span><br><span class="line">8.2.3 利用产生式系统进行数据驱动推理</span><br><span class="line"></span><br><span class="line">8.2.4 专家系统的启发和控制</span><br><span class="line"></span><br><span class="line">8.3 基于模型系统、基于案例系统和混合系统</span><br><span class="line"></span><br><span class="line">8.3.1 基于模型推理简介</span><br><span class="line"></span><br><span class="line">8.3.2 基于模型推理：来自NASA的例子</span><br><span class="line"></span><br><span class="line">8.3.3 基于案例推理介绍</span><br><span class="line"></span><br><span class="line">8.3.4 混合设计：强方法系统的优势和不足</span><br><span class="line"></span><br><span class="line">8.4 规划</span><br><span class="line"></span><br><span class="line">8.4.1 规划简介：机器人学</span><br><span class="line"></span><br><span class="line">8.4.2 使用规划宏：STRIPS</span><br><span class="line"></span><br><span class="line">8.4.3 teleoreactive规划</span><br><span class="line"></span><br><span class="line">8.4.4 规划：来自NASA的例子</span><br><span class="line"></span><br><span class="line">8.5 结语和参考文献</span><br><span class="line"></span><br><span class="line">8.6 习题</span><br><span class="line"></span><br><span class="line">第9章 不确定条件下的推理</span><br><span class="line"></span><br><span class="line">9.0 简介</span><br><span class="line"></span><br><span class="line">9.1 基于逻辑的反绎推理</span><br><span class="line"></span><br><span class="line">9.1.1 非单调推理逻辑</span><br><span class="line"></span><br><span class="line">9.1.2 真值维护系统</span><br><span class="line"></span><br><span class="line">9.1.3 基于最小模型的逻辑</span><br><span class="line"></span><br><span class="line">9.1.4 集合覆盖和基于逻辑的反绎</span><br><span class="line"></span><br><span class="line">9.2 反绎：逻辑之外的办法</span><br><span class="line"></span><br><span class="line">9.2.1 Stanford确信度代数</span><br><span class="line"></span><br><span class="line">9.2.2 模糊集推理</span><br><span class="line"></span><br><span class="line">9.2.3 DempsterShafer证据理论</span><br><span class="line"></span><br><span class="line">9.3 处理不确定性的随机方法</span><br><span class="line"></span><br><span class="line">9.3.1 有向图模型：贝叶斯信念网络</span><br><span class="line"></span><br><span class="line">9.3.2 有向图模型：d-可分</span><br><span class="line"></span><br><span class="line">9.3.3 有向图模型：一个推理算法</span><br><span class="line"></span><br><span class="line">9.3.4 有向图模型：动态贝叶斯网络</span><br><span class="line"></span><br><span class="line">9.3.5 马尔可夫模型：离散马尔可夫过程</span><br><span class="line"></span><br><span class="line">9.3.6 马尔可夫模型：变形</span><br><span class="line"></span><br><span class="line">9.3.7 BBN概率建模的一阶替代方案</span><br><span class="line"></span><br><span class="line">9.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">9.5 习题</span><br><span class="line"></span><br><span class="line">第四部分 机器学习</span><br><span class="line"></span><br><span class="line">第10章 基于符号的机器学习</span><br><span class="line"></span><br><span class="line">10.0 简介</span><br><span class="line"></span><br><span class="line">10.1 基于符号学习的框架</span><br><span class="line"></span><br><span class="line">10.2 变形空间搜索</span><br><span class="line"></span><br><span class="line">10.2.1 泛化操作符和概念空间</span><br><span class="line"></span><br><span class="line">10.2.2 候选解排除算法</span><br><span class="line"></span><br><span class="line">10.2.3 LEX：启发式归纳搜索</span><br><span class="line"></span><br><span class="line">10.2.4 评估候选解排除算法</span><br><span class="line"></span><br><span class="line">10.3 ID3决策树归纳算法</span><br><span class="line"></span><br><span class="line">10.3.1 自顶向下决策树归纳</span><br><span class="line"></span><br><span class="line">10.3.2 测试选择的信息论方法</span><br><span class="line"></span><br><span class="line">10.3.3 评价ID3</span><br><span class="line"></span><br><span class="line">10.3.4 决策树数据问题：打包、推进</span><br><span class="line"></span><br><span class="line">10.4 归纳偏置和学习能力</span><br><span class="line"></span><br><span class="line">10.4.1 归纳偏置</span><br><span class="line"></span><br><span class="line">10.4.2 可学习性理论</span><br><span class="line"></span><br><span class="line">10.5 知识和学习</span><br><span class="line"></span><br><span class="line">10.5.1 MetaDENDRAL</span><br><span class="line"></span><br><span class="line">10.5.2 基于解释的学习</span><br><span class="line"></span><br><span class="line">10.5.3 EBL和知识层学习</span><br><span class="line"></span><br><span class="line">10.5.4 类比推理</span><br><span class="line"></span><br><span class="line">10.6 无监督学习</span><br><span class="line"></span><br><span class="line">10.6.1 发现和无监督学习</span><br><span class="line"></span><br><span class="line">10.6.2 概念聚类</span><br><span class="line"></span><br><span class="line">10.6.3 COBWEB和分类知识的结构</span><br><span class="line"></span><br><span class="line">10.7 强化学习</span><br><span class="line"></span><br><span class="line">10.7.1 强化学习的组成部分</span><br><span class="line"></span><br><span class="line">10.7.2 一个例子：九宫游戏</span><br><span class="line"></span><br><span class="line">10.7.3 强化学习的推理算法和应用</span><br><span class="line"></span><br><span class="line">10.8 结语和参考文献</span><br><span class="line"></span><br><span class="line">10.9 习题</span><br><span class="line"></span><br><span class="line">第11章 机器学习：连接机制</span><br><span class="line"></span><br><span class="line">11.0 简介</span><br><span class="line"></span><br><span class="line">11.1 连接网络的基础</span><br><span class="line"></span><br><span class="line">11.2 感知机学习</span><br><span class="line"></span><br><span class="line">11.2.1 感知机训练算法</span><br><span class="line"></span><br><span class="line">11.2.2 例子：用感知机网络进行分类</span><br><span class="line"></span><br><span class="line">11.2.3 通用delta规则</span><br><span class="line"></span><br><span class="line">11.3 反传学习</span><br><span class="line"></span><br><span class="line">11.3.1 反传算法的起源</span><br><span class="line"></span><br><span class="line">11.3.2 反传算法实例1：NETtalk</span><br><span class="line"></span><br><span class="line">11.3.3 反传算法实例2：异或</span><br><span class="line"></span><br><span class="line">11.4 竞争学习</span><br><span class="line"></span><br><span class="line">11.4.1 对于分类的“胜者全拿”学习</span><br><span class="line"></span><br><span class="line">11.4.2 学习原型的Kohonen网络</span><br><span class="line"></span><br><span class="line">11.4.3 outstar网络和逆传</span><br><span class="line"></span><br><span class="line">11.4.4 支持向量机</span><br><span class="line"></span><br><span class="line">11.5 Hebbian一致性学习</span><br><span class="line"></span><br><span class="line">11.5.1 概述</span><br><span class="line"></span><br><span class="line">11.5.2 无监督Hebbian学习的例子</span><br><span class="line"></span><br><span class="line">11.5.3 有监督Hebbian学习</span><br><span class="line"></span><br><span class="line">11.5.4 联想记忆和线性联想器</span><br><span class="line"></span><br><span class="line">11.6 吸引子网络或“记忆”</span><br><span class="line"></span><br><span class="line">11.6.1 概述</span><br><span class="line"></span><br><span class="line">11.6.2 双向联想记忆</span><br><span class="line"></span><br><span class="line">11.6.3 BAM处理的例子</span><br><span class="line"></span><br><span class="line">11.6.4 自相关记忆和Hopfield网络</span><br><span class="line"></span><br><span class="line">11.7 结语和参考文献</span><br><span class="line"></span><br><span class="line">11.8 习题</span><br><span class="line"></span><br><span class="line">第12章 机器学习：遗传性和涌现性</span><br><span class="line"></span><br><span class="line">12.0 社会性和涌现性的学习模型</span><br><span class="line"></span><br><span class="line">12.1 遗传算法</span><br><span class="line"></span><br><span class="line">12.1.1 两个例子：CNF可满足性问题和巡回推销员问题</span><br><span class="line"></span><br><span class="line">12.1.2 遗传算法的评估</span><br><span class="line"></span><br><span class="line">12.2 分类器系统和遗传程序设计</span><br><span class="line"></span><br><span class="line">12.2.1 分类器系统</span><br><span class="line"></span><br><span class="line">12.2.2 用遗传算子进行程序设计</span><br><span class="line"></span><br><span class="line">12.3 人工生命和基于社会的学习</span><br><span class="line"></span><br><span class="line">12.3.1 生命游戏</span><br><span class="line"></span><br><span class="line">12.3.2 进化规划</span><br><span class="line"></span><br><span class="line">12.3.3 涌现的实例研究</span><br><span class="line"></span><br><span class="line">12.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">12.5 习题</span><br><span class="line"></span><br><span class="line">第13章 机器学习：概率理论</span><br><span class="line"></span><br><span class="line">13.0 学习中的随机模型和动态模型</span><br><span class="line"></span><br><span class="line">13.1 隐马尔可夫模型(HMM)</span><br><span class="line"></span><br><span class="line">13.1.1 隐马尔可夫模型的介绍和定义</span><br><span class="line"></span><br><span class="line">13.1.2 隐马尔可夫模型的重要变形</span><br><span class="line"></span><br><span class="line">13.1.3 使用HMM和Viterbi解码音素串</span><br><span class="line"></span><br><span class="line">13.2 动态贝叶斯网络和学习</span><br><span class="line"></span><br><span class="line">13.2.1 动态贝叶斯网络</span><br><span class="line"></span><br><span class="line">13.2.2 学习贝叶斯网络</span><br><span class="line"></span><br><span class="line">13.2.3 期望最大化：一个例子</span><br><span class="line"></span><br><span class="line">13.3 强化学习的随机扩展</span><br><span class="line"></span><br><span class="line">13.3.1 马尔可夫决策过程</span><br><span class="line"></span><br><span class="line">13.3.2 部分 可观测的马尔可夫决策过程</span><br><span class="line"></span><br><span class="line">13.3.3 马尔可夫决策过程实现的例子</span><br><span class="line"></span><br><span class="line">13.4 结语和参考文献</span><br><span class="line"></span><br><span class="line">13.5 习题</span><br><span class="line"></span><br><span class="line">第五部分 人工智能问题求解的高级课题</span><br><span class="line"></span><br><span class="line">第14章 自动推理</span><br><span class="line"></span><br><span class="line">14.0 定理证明中的弱方法</span><br><span class="line"></span><br><span class="line">14.1 通用问题求解器和差别表</span><br><span class="line"></span><br><span class="line">14.2 归结定理证明</span><br><span class="line"></span><br><span class="line">14.2.1 概述</span><br><span class="line"></span><br><span class="line">14.2.2 为归结反驳生成子句形式</span><br><span class="line"></span><br><span class="line">14.2.3 二元归结证明过程</span><br><span class="line"></span><br><span class="line">14.2.4 归结策略和简化技术</span><br><span class="line"></span><br><span class="line">14.2.5 从归结反驳中抽取解答</span><br><span class="line"></span><br><span class="line">14.3 Prolog和自动推理</span><br><span class="line"></span><br><span class="line">14.3.1 概述</span><br><span class="line"></span><br><span class="line">14.3.2 逻辑程序设计和Prolog</span><br><span class="line"></span><br><span class="line">14.4 自动推理进一步的问题</span><br><span class="line"></span><br><span class="line">14.4.1 弱方法求解的统一表示法</span><br><span class="line"></span><br><span class="line">14.4.2 可选推理规则</span><br><span class="line"></span><br><span class="line">14.4.3 归结反驳支持下的问答机制</span><br><span class="line"></span><br><span class="line">14.4.4 搜索策略及其使用</span><br><span class="line"></span><br><span class="line">14.5 结语和参考文献</span><br><span class="line"></span><br><span class="line">14.6 习题</span><br><span class="line"></span><br><span class="line">第15章 自然语言理解</span><br><span class="line"></span><br><span class="line">15.0 自然语言理解问题</span><br><span class="line"></span><br><span class="line">15.1 解构语言：分析</span><br><span class="line"></span><br><span class="line">15.2 语法</span><br><span class="line"></span><br><span class="line">15.2.1 使用上下文无关文法说明和解析</span><br><span class="line"></span><br><span class="line">15.2.2 Earley解析器：动态规划二次访问</span><br><span class="line"></span><br><span class="line">15.3 转移网络解析器及语义学</span><br><span class="line"></span><br><span class="line">15.3.1 转移网络解析器</span><br><span class="line"></span><br><span class="line">15.3.2 乔姆斯基层次和上下文相关文法</span><br><span class="line"></span><br><span class="line">15.3.3 ATN解析器的语义</span><br><span class="line"></span><br><span class="line">15.3.4 结合句法和语义知识的ATN</span><br><span class="line"></span><br><span class="line">15.4 语言理解的随机工具</span><br><span class="line"></span><br><span class="line">15.4.1 概述：语言分析中的统计技术</span><br><span class="line"></span><br><span class="line">15.4.2 马尔可夫模型方法</span><br><span class="line"></span><br><span class="line">15.4.3 决策树方法</span><br><span class="line"></span><br><span class="line">15.4.4 解析的概率方法</span><br><span class="line"></span><br><span class="line">15.4.5 概率上下文无关解析器</span><br><span class="line"></span><br><span class="line">15.5 自然语言应用</span><br><span class="line"></span><br><span class="line">15.5.1 故事理解和问题解答</span><br><span class="line"></span><br><span class="line">15.5.2 数据库前端</span><br><span class="line"></span><br><span class="line">15.5.3 Web信息抽取和摘要系统</span><br><span class="line"></span><br><span class="line">15.5.4 用学习算法来泛化抽取的信息</span><br><span class="line"></span><br><span class="line">15.6 结语和参考文献</span><br><span class="line"></span><br><span class="line">15.7 习题</span><br><span class="line"></span><br><span class="line">第六部分 后记</span><br><span class="line"></span><br><span class="line">第16章 人工智能是经验式的学科</span><br><span class="line"></span><br><span class="line">16.0 简介</span><br><span class="line"></span><br><span class="line">16.1 人工智能：修订的定义</span><br><span class="line"></span><br><span class="line">16.1.1 人工智能和物理符号系统假设</span><br><span class="line"></span><br><span class="line">16.1.2 连接或者“神经”计算</span><br><span class="line"></span><br><span class="line">16.1.3 主体、涌现和智能</span><br><span class="line"></span><br><span class="line">16.1.4 概率模型和随机技术</span><br><span class="line"></span><br><span class="line">16.2 智能系统科学</span><br><span class="line"></span><br><span class="line">16.2.1 心理学约束</span><br><span class="line"></span><br><span class="line">16.2.2 认识论问题</span><br><span class="line"></span><br><span class="line">16.3 人工智能：当前的挑战和未来的方向</span><br><span class="line"></span><br><span class="line">16.4 结语和参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入分析JavaWeb技术内幕 PDF</title>
    <url>/posts/bf3816d8/</url>
    <content><![CDATA[<h4 id="《深入分析JavaWeb技术内幕》"><a href="#《深入分析JavaWeb技术内幕》" class="headerlink" title="《深入分析JavaWeb技术内幕》"></a>《深入分析JavaWeb技术内幕》</h4><h6 id="链接-https-pan-baidu-com-s-18kVo23EaUYuusPtVfNzrHQ-提取码-vivd"><a href="#链接-https-pan-baidu-com-s-18kVo23EaUYuusPtVfNzrHQ-提取码-vivd" class="headerlink" title="链接: https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ 提取码: vivd"></a>链接: <a href="https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ">https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ</a> 提取码: vivd</h6><p>《深入分析Java Web技术内幕（修订版）》新增了淘 宝在无线端的应用实践，包括：CDN 动态加速、多终端化改造、 多终端Session 统一 ，以及在大流量的情况下，如何跨越性能、网络和一个地区的电力瓶颈等内容，并提供了比较完整的解决方案。<br><a id="more"></a></p>
<p>《深入分析Java Web技术内幕（修订版）》主要围绕Java Web 相关技术从三方面全面、深入地进行了阐述。首先介绍前端知识，即在JavaWeb 开发中涉及的一些基本知识，包括Web 请求过程、HTTP、DNS 技术和CDN 技术。其次深入介绍了Java 技术，包括I/O 技术、中文编码问题、Javac 编译原理、class 文件结构解析、ClassLoader 工作机制及JVM 的内存管理等。最后介绍了Java 服务端技术，主要包括Servlet、Session 与Cookie、Tomcat 与Jetty服务器、Spring 容器、iBatis 框架和Velocity 框架等原理介绍，并介绍了服务端的一些优化技术。</p>
<p>《深入分析Java Web技术内幕（修订版）》不仅介绍这些技术和框架的工作原理，而且结合示例来讲解，通过通俗易懂的文字和丰富、生动的配图，让读者充分并深入理解它们的内部工作原理，同时还结合了设计模式来介绍这些技术背后的架构思维。</p>
<p><img src="/images/bc389026cc6eb51d216f4bd225ca015a1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 深入Web请求过程 1</span><br><span class="line"></span><br><span class="line">1．1 B&#x2F;S网络架构概述 2</span><br><span class="line"></span><br><span class="line">1．2 如何发起一个请求 4</span><br><span class="line"></span><br><span class="line">1．3 HTTP协议解析 6</span><br><span class="line"></span><br><span class="line">1．3．1 查看HTTP信息的工具 8</span><br><span class="line"></span><br><span class="line">1．3．2 浏览器缓存机制 9</span><br><span class="line"></span><br><span class="line">1．4 DNS域名解析 12</span><br><span class="line"></span><br><span class="line">1．4．1 DNS域名解析过程 12</span><br><span class="line"></span><br><span class="line">1．4．2 跟踪域名解析过程 15</span><br><span class="line"></span><br><span class="line">1．4．3 清除缓存的域名 18</span><br><span class="line"></span><br><span class="line">1．4．4 几种域名解析方式 19</span><br><span class="line"></span><br><span class="line">1．5 CDN工作机制 20</span><br><span class="line"></span><br><span class="line">1．5．1 CDN架构 20</span><br><span class="line"></span><br><span class="line">1．5．2 负载均衡 21</span><br><span class="line"></span><br><span class="line">1．5．3 CDN动态加速 24</span><br><span class="line"></span><br><span class="line">1．6 总结 25</span><br><span class="line"></span><br><span class="line">第2章 深入分析Java I&#x2F;O的工作机制 26</span><br><span class="line"></span><br><span class="line">2．1 Java的I&#x2F;O类库的基本架构 26</span><br><span class="line"></span><br><span class="line">2．1．1 基于字节的I&#x2F;O操作接口 27</span><br><span class="line"></span><br><span class="line">2．1．2 基于字符的I&#x2F;O操作接口 28</span><br><span class="line"></span><br><span class="line">2．1．3 字节与字符的转化接口 29</span><br><span class="line"></span><br><span class="line">2．2 磁盘I&#x2F;O工作机制 30</span><br><span class="line"></span><br><span class="line">2．2．1 几种访问文件的方式 30</span><br><span class="line"></span><br><span class="line">2．2．2 Java访问磁盘文件 34</span><br><span class="line"></span><br><span class="line">2．2．3 Java序列化技术 35</span><br><span class="line"></span><br><span class="line">2．3 网络I&#x2F;O工作机制 37</span><br><span class="line"></span><br><span class="line">2．3．1 TCP状态转化 38</span><br><span class="line"></span><br><span class="line">2．3．2 影响网络传输的因素 40</span><br><span class="line"></span><br><span class="line">2．3．3 Java Socket的工作机制 40</span><br><span class="line"></span><br><span class="line">2．3．4 建立通信链路 41</span><br><span class="line"></span><br><span class="line">2．3．5 数据传输 42</span><br><span class="line"></span><br><span class="line">2．4 NIO的工作方式 42</span><br><span class="line"></span><br><span class="line">2．4．1 BIO带来的挑战 42</span><br><span class="line"></span><br><span class="line">2．4．2 NIO的工作机制 43</span><br><span class="line"></span><br><span class="line">2．4．3 Buffer的工作方式 46</span><br><span class="line"></span><br><span class="line">2．4．4 NIO的数据访问方式 48</span><br><span class="line"></span><br><span class="line">2．5 I&#x2F;O调优 50</span><br><span class="line"></span><br><span class="line">2．5．1 磁盘I&#x2F;O优化 50</span><br><span class="line"></span><br><span class="line">2．5．2 TCP网络参数调优 51</span><br><span class="line"></span><br><span class="line">2．5．3 网络I&#x2F;O优化 53</span><br><span class="line"></span><br><span class="line">2．6 设计模式解析之适配器模式 57</span><br><span class="line"></span><br><span class="line">2．6．1 适配器模式的结构 57</span><br><span class="line"></span><br><span class="line">2．6．2 Java I&#x2F;O中的适配器模式 58</span><br><span class="line"></span><br><span class="line">2．7 设计模式解析之装饰器模式 58</span><br><span class="line"></span><br><span class="line">2．7．1 装饰器模式的结构 59</span><br><span class="line"></span><br><span class="line">2．7．2 Java I&#x2F;O中的装饰器模式 59</span><br><span class="line"></span><br><span class="line">2．8 适配器模式与装饰器模式的区别 60</span><br><span class="line"></span><br><span class="line">2．9 总结 60</span><br><span class="line"></span><br><span class="line">第3章 深入分析Java Web中的中文编码问题 61</span><br><span class="line"></span><br><span class="line">3．1 几种常见的编码格式 61</span><br><span class="line"></span><br><span class="line">3．1．1 为什么要编码 61</span><br><span class="line"></span><br><span class="line">3．1．2 如何“翻译” 62</span><br><span class="line"></span><br><span class="line">3．2 在Java中需要编码的场景 64</span><br><span class="line"></span><br><span class="line">3．2．1 在I&#x2F;O操作中存在的编码 64</span><br><span class="line"></span><br><span class="line">3．2．2 在内存操作中的编码 66</span><br><span class="line"></span><br><span class="line">3．3 在Java中如何编解码 67</span><br><span class="line"></span><br><span class="line">3．3．1 按照ISO-8859-1编码 69</span><br><span class="line"></span><br><span class="line">3．3．2 按照GB2312编码 70</span><br><span class="line"></span><br><span class="line">3．3．3 按照GBK编码 71</span><br><span class="line"></span><br><span class="line">3．3．4 按照UTF-16编码 71</span><br><span class="line"></span><br><span class="line">3．3．5 按照UTF-8编码 72</span><br><span class="line"></span><br><span class="line">3．3．6 UTF-8编码代码片段 72</span><br><span class="line"></span><br><span class="line">3．3．7 对几种编码格式的比较 74</span><br><span class="line"></span><br><span class="line">3．4 在Java Web中涉及的编解码 74</span><br><span class="line"></span><br><span class="line">3．4．1 URL的编解码 76</span><br><span class="line"></span><br><span class="line">3．4．2 HTTP Header的编解码 79</span><br><span class="line"></span><br><span class="line">3．4．3 POST表单的编解码 79</span><br><span class="line"></span><br><span class="line">3．4．4 HTTP BODY的编解码 80</span><br><span class="line"></span><br><span class="line">3．5 JS中的编码问题 81</span><br><span class="line"></span><br><span class="line">3．5．1 外部引入JS文件 81</span><br><span class="line"></span><br><span class="line">3．5．2 JS的URL编码 82</span><br><span class="line"></span><br><span class="line">3．5．3 其他需要编码的地方 84</span><br><span class="line"></span><br><span class="line">3．6 常见问题分析 84</span><br><span class="line"></span><br><span class="line">3．6．1 中文变成了看不懂的字符 84</span><br><span class="line"></span><br><span class="line">3．6．2 一个汉字变成一个问号 85</span><br><span class="line"></span><br><span class="line">3．6．3 一个汉字变成两个问号 85</span><br><span class="line"></span><br><span class="line">3．6．4 一种不正常的正确编码 86</span><br><span class="line"></span><br><span class="line">3．7 一种繁简转换的实现方式 87</span><br><span class="line"></span><br><span class="line">3．8 总结 88</span><br><span class="line"></span><br><span class="line">第4章 Javac编译原理 89</span><br><span class="line"></span><br><span class="line">4．1 Javac是什么 90</span><br><span class="line"></span><br><span class="line">4．2 Javac编译器的基本结构 90</span><br><span class="line"></span><br><span class="line">4．3 Javac工作原理分析 92</span><br><span class="line"></span><br><span class="line">4．3．1 词法分析器 93</span><br><span class="line"></span><br><span class="line">4．3．2 语法分析器 100</span><br><span class="line"></span><br><span class="line">4．3．3 语义分析器 105</span><br><span class="line"></span><br><span class="line">4．3．4 代码生成器 115</span><br><span class="line"></span><br><span class="line">4．4 设计模式解析之访问者模式 118</span><br><span class="line"></span><br><span class="line">4．4．1 访问者模式的结构 119</span><br><span class="line"></span><br><span class="line">4．4．2 Javac中访问者模式的实现 120</span><br><span class="line"></span><br><span class="line">4．5 总结 121</span><br><span class="line"></span><br><span class="line">第5章 深入class文件结构 122</span><br><span class="line"></span><br><span class="line">5．1 JVM指令集简介 122</span><br><span class="line"></span><br><span class="line">5．1．1 与类相关的指令 124</span><br><span class="line"></span><br><span class="line">5．1．2 方法的定义 125</span><br><span class="line"></span><br><span class="line">5．1．3 属性的定义 126</span><br><span class="line"></span><br><span class="line">5．1．4 其他指令集 127</span><br><span class="line"></span><br><span class="line">5．2 class文件头的表示形式 135</span><br><span class="line"></span><br><span class="line">5．3 常量池 139</span><br><span class="line"></span><br><span class="line">5．3．1 UTF8常量类型 142</span><br><span class="line"></span><br><span class="line">5．3．2 Fieldref、Methodref常量类型 143</span><br><span class="line"></span><br><span class="line">5．3．3 Class常量类型 143</span><br><span class="line"></span><br><span class="line">5．3．4 NameAndType常量类型 144</span><br><span class="line"></span><br><span class="line">5．4 类信息 144</span><br><span class="line"></span><br><span class="line">5．5 Fields和Methods定义 145</span><br><span class="line"></span><br><span class="line">5．6 类属性描述 149</span><br><span class="line"></span><br><span class="line">5．7 Javap生成的class文件结构 150</span><br><span class="line"></span><br><span class="line">5．7．1 LineNumberTable 152</span><br><span class="line"></span><br><span class="line">5．7．2 LocalVariableTable 153</span><br><span class="line"></span><br><span class="line">5．8 总结 155</span><br><span class="line"></span><br><span class="line">第6章 深入分析ClassLoader工作机制 156</span><br><span class="line"></span><br><span class="line">6．1 ClassLoader类结构分析 157</span><br><span class="line"></span><br><span class="line">6．2 ClassLoader的等级加载机制 158</span><br><span class="line"></span><br><span class="line">6．3 如何加载class文件 161</span><br><span class="line"></span><br><span class="line">6．3．1 加载字节码到内存 161</span><br><span class="line"></span><br><span class="line">6．3．2 验证与解析 163</span><br><span class="line"></span><br><span class="line">6．3．3 初始化Class对象 163</span><br><span class="line"></span><br><span class="line">6．4 常见加载类错误分析 163</span><br><span class="line"></span><br><span class="line">6．4．1 ClassNotFoundException 163</span><br><span class="line"></span><br><span class="line">6．4．2 NoClassDefFoundError 164</span><br><span class="line"></span><br><span class="line">6．4．3 UnsatisfiedLinkError 165</span><br><span class="line"></span><br><span class="line">6．4．4 ClassCastException 166</span><br><span class="line"></span><br><span class="line">6．4．5 ExceptionInInitializerError 167</span><br><span class="line"></span><br><span class="line">6．5 常用的ClassLoader分析 168</span><br><span class="line"></span><br><span class="line">6．6 如何实现自己的ClassLoader 172</span><br><span class="line"></span><br><span class="line">6．6．1 加载自定义路径下的class文件 172</span><br><span class="line"></span><br><span class="line">6．6．2 加载自定义格式的class文件 174</span><br><span class="line"></span><br><span class="line">6．7 实现类的热部署 176</span><br><span class="line"></span><br><span class="line">6．8 Java应不应该动态加载类 178</span><br><span class="line"></span><br><span class="line">6．9 总结 179</span><br><span class="line"></span><br><span class="line">第7章 JVM体系结构与工作方式 180</span><br><span class="line"></span><br><span class="line">7．1 JVM体系结构 180</span><br><span class="line"></span><br><span class="line">7．1．1 何谓JVM 180</span><br><span class="line"></span><br><span class="line">7．1．2 JVM体系结构详解 183</span><br><span class="line"></span><br><span class="line">7．2 JVM工作机制 185</span><br><span class="line"></span><br><span class="line">7．2．1 机器如何执行代码 185</span><br><span class="line"></span><br><span class="line">7．2．2 JVM为何选择基于栈的架构 186</span><br><span class="line"></span><br><span class="line">7．2．3 执行引擎的架构设计 187</span><br><span class="line"></span><br><span class="line">7．2．4 执行引擎的执行过程 188</span><br><span class="line"></span><br><span class="line">7．2．5 JVM方法调用栈 193</span><br><span class="line"></span><br><span class="line">7．3 总结 197</span><br><span class="line"></span><br><span class="line">第8章 JVM内存管理 198</span><br><span class="line"></span><br><span class="line">8．1 物理内存与虚拟内存 199</span><br><span class="line"></span><br><span class="line">8．2 内核空间与用户空间 200</span><br><span class="line"></span><br><span class="line">8．3 在Java中哪些组件需要使用内存 201</span><br><span class="line"></span><br><span class="line">8．3．1 Java堆 201</span><br><span class="line"></span><br><span class="line">8．3．2 线程 201</span><br><span class="line"></span><br><span class="line">8．3．3 类和类加载器 202</span><br><span class="line"></span><br><span class="line">8．3．4 NIO 202</span><br><span class="line"></span><br><span class="line">8．3．5 JNI 203</span><br><span class="line"></span><br><span class="line">8．4 JVM内存结构 203</span><br><span class="line"></span><br><span class="line">8．4．1 PC寄存器 204</span><br><span class="line"></span><br><span class="line">8．4．2 Java栈 204</span><br><span class="line"></span><br><span class="line">8．4．3 堆 205</span><br><span class="line"></span><br><span class="line">8．4．4 方法区 205</span><br><span class="line"></span><br><span class="line">8．4．5 运行时常量池 206</span><br><span class="line"></span><br><span class="line">8．4．6 本地方法栈 206</span><br><span class="line"></span><br><span class="line">8．5 JVM内存分配策略 206</span><br><span class="line"></span><br><span class="line">8．5．1 通常的内存分配策略 207</span><br><span class="line"></span><br><span class="line">8．5．2 Java中的内存分配详解 207</span><br><span class="line"></span><br><span class="line">8．6 JVM内存回收策略 212</span><br><span class="line"></span><br><span class="line">8．6．1 静态内存分配和回收 212</span><br><span class="line"></span><br><span class="line">8．6．2 动态内存分配和回收 213</span><br><span class="line"></span><br><span class="line">8．6．3 如何检测垃圾 213</span><br><span class="line"></span><br><span class="line">8．6．4 基于分代的垃圾收集算法 215</span><br><span class="line"></span><br><span class="line">8．7 内存问题分析 224</span><br><span class="line"></span><br><span class="line">8．7．1 GC日志分析 224</span><br><span class="line"></span><br><span class="line">8．7．2 堆快照文件分析 227</span><br><span class="line"></span><br><span class="line">8．7．3 JVM Crash日志分析 227</span><br><span class="line"></span><br><span class="line">8．8 实例1 233</span><br><span class="line"></span><br><span class="line">8．9 实例2 235</span><br><span class="line"></span><br><span class="line">8．10 实例3 237</span><br><span class="line"></span><br><span class="line">8．11 总结 242</span><br><span class="line"></span><br><span class="line">第9章 Servlet工作原理解析 243</span><br><span class="line"></span><br><span class="line">9．1 从Servlet容器说起 243</span><br><span class="line"></span><br><span class="line">9．1．1 Servlet容器的启动过程 244</span><br><span class="line"></span><br><span class="line">9．1．2 Web应用的初始化工作 247</span><br><span class="line"></span><br><span class="line">9．2 创建Servlet实例 249</span><br><span class="line"></span><br><span class="line">9．2．1 创建Servlet对象 250</span><br><span class="line"></span><br><span class="line">9．2．2 初始化Servlet 250</span><br><span class="line"></span><br><span class="line">9．3 Servlet体系结构 252</span><br><span class="line"></span><br><span class="line">9．4 Servlet如何工作 255</span><br><span class="line"></span><br><span class="line">9．5 Servlet中的Listener 257</span><br><span class="line"></span><br><span class="line">9．6 Filter如何工作 259</span><br><span class="line"></span><br><span class="line">9．7 Servlet中的url-pattern 261</span><br><span class="line"></span><br><span class="line">9．8 总结 262</span><br><span class="line"></span><br><span class="line">第10章 深入理解Session与Cookie 263</span><br><span class="line"></span><br><span class="line">10．1 理解Cookie 264</span><br><span class="line"></span><br><span class="line">10．1．1 Cookie属性项 264</span><br><span class="line"></span><br><span class="line">10．1．2 Cookie如何工作 265</span><br><span class="line"></span><br><span class="line">10．1．3 使用Cookie的限制 268</span><br><span class="line"></span><br><span class="line">10．2 理解Session 269</span><br><span class="line"></span><br><span class="line">10．2．1 Session与Cookie 269</span><br><span class="line"></span><br><span class="line">10．2．2 Session如何工作 270</span><br><span class="line"></span><br><span class="line">10．3 Cookie安全问题 273</span><br><span class="line"></span><br><span class="line">10．4 分布式Session框架 274</span><br><span class="line"></span><br><span class="line">10．4．1 存在哪些问题 274</span><br><span class="line"></span><br><span class="line">10．4．2 可以解决哪些问题 275</span><br><span class="line"></span><br><span class="line">10．4．3 总体实现思路 275</span><br><span class="line"></span><br><span class="line">10．5 Cookie压缩 280</span><br><span class="line"></span><br><span class="line">10．6 表单重复提交问题 282</span><br><span class="line"></span><br><span class="line">10．7 多终端Session统一 283</span><br><span class="line"></span><br><span class="line">10．8 总结 285</span><br><span class="line"></span><br><span class="line">第11章 Tomcat的系统架构与设计模式 286</span><br><span class="line"></span><br><span class="line">11．1 Tomcat总体设计 286</span><br><span class="line"></span><br><span class="line">11．1．1 Tomcat总体结构 287</span><br><span class="line"></span><br><span class="line">11．1．2 Connector组件 293</span><br><span class="line"></span><br><span class="line">11．1．3 Servlet容器Container 298</span><br><span class="line"></span><br><span class="line">11．1．4 Tomcat中的其他组件 309</span><br><span class="line"></span><br><span class="line">11．2 Tomcat中的设计模式 309</span><br><span class="line"></span><br><span class="line">11．2．1 门面设计模式 309</span><br><span class="line"></span><br><span class="line">11．2．2 观察者设计模式 311</span><br><span class="line"></span><br><span class="line">11．2．3 命令设计模式 313</span><br><span class="line"></span><br><span class="line">11．2．4 责任链设计模式 314</span><br><span class="line"></span><br><span class="line">11．3 总结 316</span><br><span class="line"></span><br><span class="line">第12章 Jetty的工作原理解析 317</span><br><span class="line"></span><br><span class="line">12．1 Jetty的基本架构 317</span><br><span class="line"></span><br><span class="line">12．1．1 Jetty的基本架构简介 317</span><br><span class="line"></span><br><span class="line">12．1．2 Handler的体系结构 319</span><br><span class="line"></span><br><span class="line">12．2 Jetty的启动过程 320</span><br><span class="line"></span><br><span class="line">12．3 接受请求 321</span><br><span class="line"></span><br><span class="line">12．3．1 基于HTTP协议工作 321</span><br><span class="line"></span><br><span class="line">12．3．2 基于AJP工作 323</span><br><span class="line"></span><br><span class="line">12．3．3 基于NIO方式工作 326</span><br><span class="line"></span><br><span class="line">12．4 处理请求 327</span><br><span class="line"></span><br><span class="line">12．5 与JBoss集成 330</span><br><span class="line"></span><br><span class="line">12．6 与Tomcat的比较 331</span><br><span class="line"></span><br><span class="line">12．6．1 架构比较 331</span><br><span class="line"></span><br><span class="line">12．6．2 性能比较 332</span><br><span class="line"></span><br><span class="line">12．6．3 特性比较 332</span><br><span class="line"></span><br><span class="line">12．7 总结 333</span><br><span class="line"></span><br><span class="line">第13章 Spring框架的设计理念与设计模式分析 334</span><br><span class="line"></span><br><span class="line">13．1 Spring的骨骼架构 334</span><br><span class="line"></span><br><span class="line">13．1．1 Spring的设计理念 335</span><br><span class="line"></span><br><span class="line">13．1．2 核心组件如何协同工作 336</span><br><span class="line"></span><br><span class="line">13．2 核心组件详解 337</span><br><span class="line"></span><br><span class="line">13．2．1 Bean组件 337</span><br><span class="line"></span><br><span class="line">13．2．2 Context组件 339</span><br><span class="line"></span><br><span class="line">13．2．3 Core组件 340</span><br><span class="line"></span><br><span class="line">13．2．4 Ioc容器如何工作 342</span><br><span class="line"></span><br><span class="line">13．3 Spring中AOP的特性详解 352</span><br><span class="line"></span><br><span class="line">13．3．1 动态代理的实现原理 352</span><br><span class="line"></span><br><span class="line">13．3．2 Spring AOP如何实现 355</span><br><span class="line"></span><br><span class="line">13．4 设计模式解析之代理模式 358</span><br><span class="line"></span><br><span class="line">13．4．1 代理模式原理 358</span><br><span class="line"></span><br><span class="line">13．4．2 Spring中代理模式的实现 358</span><br><span class="line"></span><br><span class="line">13．5 设计模式解析之策略模式 361</span><br><span class="line"></span><br><span class="line">13．5．1 策略模式原理 361</span><br><span class="line"></span><br><span class="line">13．5．2 Spring中策略模式的实现 362</span><br><span class="line"></span><br><span class="line">13．6 总结 362</span><br><span class="line"></span><br><span class="line">第14章 Spring MVC工作机制与设计模式 364</span><br><span class="line"></span><br><span class="line">14．1 Spring MVC的总体设计 364</span><br><span class="line"></span><br><span class="line">14．2 Control设计 369</span><br><span class="line"></span><br><span class="line">14．2．1 HandlerMapping初始化 370</span><br><span class="line"></span><br><span class="line">14．2．2 HandlerAdapter初始化 372</span><br><span class="line"></span><br><span class="line">14．2．3 Control的调用逻辑 373</span><br><span class="line"></span><br><span class="line">14．3 Model设计 374</span><br><span class="line"></span><br><span class="line">14．4 View设计 375</span><br><span class="line"></span><br><span class="line">14．5 框架设计的思考 377</span><br><span class="line"></span><br><span class="line">14．5．1 为什么需要框架 377</span><br><span class="line"></span><br><span class="line">14．5．2 需要什么样的框架 377</span><br><span class="line"></span><br><span class="line">14．5．3 框架设计的原则 378</span><br><span class="line"></span><br><span class="line">14．5．4 “指航灯” 378</span><br><span class="line"></span><br><span class="line">14．5．5 最基本的原则 378</span><br><span class="line"></span><br><span class="line">14．6 设计模式解析之模板模式 379</span><br><span class="line"></span><br><span class="line">14．6．1 模板模式的结构 379</span><br><span class="line"></span><br><span class="line">14．6．2 Spring MVC中的模板模式示例 379</span><br><span class="line"></span><br><span class="line">14．7 总结 380</span><br><span class="line"></span><br><span class="line">第15章 深入分析Ibatis框架之系统架构与映射原理 381</span><br><span class="line"></span><br><span class="line">15．1 Ibatis框架主要的类层次结构 381</span><br><span class="line"></span><br><span class="line">15．2 Ibatis框架的设计策略 382</span><br><span class="line"></span><br><span class="line">15．3 Ibatis框架的运行原理 384</span><br><span class="line"></span><br><span class="line">15．4 示例 386</span><br><span class="line"></span><br><span class="line">15．5 Ibatis对SQL语句的解析 388</span><br><span class="line"></span><br><span class="line">15．6 数据库字段映射到Java对象 389</span><br><span class="line"></span><br><span class="line">15．7 示例运行的结果 391</span><br><span class="line"></span><br><span class="line">15．8 设计模式解析之简单工厂模式 391</span><br><span class="line"></span><br><span class="line">15．8．1 简单工厂模式的实现原理 391</span><br><span class="line"></span><br><span class="line">15．8．2 在Ibatis中的简单工厂模式示例 392</span><br><span class="line"></span><br><span class="line">15．9 设计模式解析之工厂模式 393</span><br><span class="line"></span><br><span class="line">15．9．1 工厂模式的实现原理 393</span><br><span class="line"></span><br><span class="line">15．9．2 Ibatis中的工厂模式示例 394</span><br><span class="line"></span><br><span class="line">15．10 总结 395</span><br><span class="line"></span><br><span class="line">第16章 Velocity工作原理解析 397</span><br><span class="line"></span><br><span class="line">16．1 Velocity总体架构 398</span><br><span class="line"></span><br><span class="line">16．2 JJTree渲染过程解析 401</span><br><span class="line"></span><br><span class="line">16．2．1 #set语法 405</span><br><span class="line"></span><br><span class="line">16．2．2 Velocity的方法调用 406</span><br><span class="line"></span><br><span class="line">16．2．3 #if、#elseif和#else语法 409</span><br><span class="line"></span><br><span class="line">16．2．4 #foreach语法 410</span><br><span class="line"></span><br><span class="line">16．2．5 #parse语法 412</span><br><span class="line"></span><br><span class="line">16．3 事件处理机制 413</span><br><span class="line"></span><br><span class="line">16．4 常用优化技巧 416</span><br><span class="line"></span><br><span class="line">16．4．1 减少树的总节点数量 416</span><br><span class="line"></span><br><span class="line">16．4．2 减少渲染耗时的节点数量 416</span><br><span class="line"></span><br><span class="line">16．5 与JSP比较 417</span><br><span class="line"></span><br><span class="line">16．5．1 JSP渲染机制 417</span><br><span class="line"></span><br><span class="line">16．5．2 Velocity与JSP 423</span><br><span class="line"></span><br><span class="line">16．6 设计模式解析之合成模式 423</span><br><span class="line"></span><br><span class="line">16．6．1 合成模式的结构 423</span><br><span class="line"></span><br><span class="line">16．6．2 Velocity中合成模式的实现 424</span><br><span class="line"></span><br><span class="line">16．7 设计模式解析之解释器模式 425</span><br><span class="line"></span><br><span class="line">16．7．1 解释器模式的结构 425</span><br><span class="line"></span><br><span class="line">16．7．2 Velocity中解释器模式的实现 426</span><br><span class="line"></span><br><span class="line">16．8 总结 426</span><br><span class="line"></span><br><span class="line">第17章 Velocity优化实践 427</span><br><span class="line"></span><br><span class="line">17．1 现实存在的问题 427</span><br><span class="line"></span><br><span class="line">17．2 优化的理论基础 428</span><br><span class="line"></span><br><span class="line">17．2．1 程序语言的三角形结构 428</span><br><span class="line"></span><br><span class="line">17．2．2 数据结构减少抽象化 429</span><br><span class="line"></span><br><span class="line">17．2．3 简单的程序复杂化 429</span><br><span class="line"></span><br><span class="line">17．2．4 减少翻译的代价 430</span><br><span class="line"></span><br><span class="line">17．2．5 变的转化为不变 430</span><br><span class="line"></span><br><span class="line">17．3 一个高效的模板引擎的实现思路 430</span><br><span class="line"></span><br><span class="line">17．3．1 vm模板如何被编译 432</span><br><span class="line"></span><br><span class="line">17．3．2 方法调用的无反射优化 439</span><br><span class="line"></span><br><span class="line">17．3．3 将字符输出改成字节输出 442</span><br><span class="line"></span><br><span class="line">17．4 优化的成果 443</span><br><span class="line"></span><br><span class="line">17．4．1 将char转成byte 443</span><br><span class="line"></span><br><span class="line">17．4．2 无反射执行 444</span><br><span class="line"></span><br><span class="line">17．5 其他优化手段 445</span><br><span class="line"></span><br><span class="line">17．6 总结 445</span><br><span class="line"></span><br><span class="line">第18章 大浏览量系统的静态化架构设计 446</span><br><span class="line"></span><br><span class="line">18．1 淘宝大浏览量商品详情系统简介 446</span><br><span class="line"></span><br><span class="line">18．2 系统面临哪些挑战 447</span><br><span class="line"></span><br><span class="line">18．3 淘宝前台系统的优化历程 449</span><br><span class="line"></span><br><span class="line">18．4 大浏览量系统的静态改造 449</span><br><span class="line"></span><br><span class="line">18．4．1 什么是静态化系统 449</span><br><span class="line"></span><br><span class="line">18．4．2 为什么要进行静态化架构设计 450</span><br><span class="line"></span><br><span class="line">18．4．3 如何改造动态系统 451</span><br><span class="line"></span><br><span class="line">18．4．4 几种静态化方案的设计及选择 453</span><br><span class="line"></span><br><span class="line">18．4．5 如何解决失效问题 458</span><br><span class="line"></span><br><span class="line">18．4．6 服务端静态化方案的演进：CDN化 459</span><br><span class="line"></span><br><span class="line">18．5 总结 462</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入理解Java虚拟机第二版 PDF</title>
    <url>/posts/c83f264e/</url>
    <content><![CDATA[<h4 id="《深入理解Java虚拟机第二版》"><a href="#《深入理解Java虚拟机第二版》" class="headerlink" title="《深入理解Java虚拟机第二版》"></a>《深入理解Java虚拟机第二版》</h4><h6 id="链接-https-pan-baidu-com-s-1ADYS7pjefl3gA4zWX3hUSA-提取码-jj6z"><a href="#链接-https-pan-baidu-com-s-1ADYS7pjefl3gA4zWX3hUSA-提取码-jj6z" class="headerlink" title="链接: https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA 提取码: jj6z"></a>链接: <a href="https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA">https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA</a> 提取码: jj6z</h6><p>　本书第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个Java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很的改进：根据全新的JDK 1.7对全书内容进行了全面的升级和补充；增加了量处理各种常见JVM问题的技巧和优佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。<br><a id="more"></a></p>
<p>　　本书共分为五部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解本书后面内容有重要帮助。第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第一部分　走近Java</span><br><span class="line"></span><br><span class="line">第1章　走近Java</span><br><span class="line"></span><br><span class="line">1.1　概述</span><br><span class="line"></span><br><span class="line">1.2　Java技术体系</span><br><span class="line"></span><br><span class="line">1.3　Java发展史</span><br><span class="line"></span><br><span class="line">1.4　Java虚拟机发展史</span><br><span class="line"></span><br><span class="line">1.4.1　Sun Classic Exact VM</span><br><span class="line"></span><br><span class="line">1.4.2　Sun HotSpot VM</span><br><span class="line"></span><br><span class="line">1.4.3　Sun Mobile-Embedded VM Meta-Circular VM</span><br><span class="line"></span><br><span class="line">1.4.4　BEA JRockit IBM J9 VM</span><br><span class="line"></span><br><span class="line">1.4.5　Azul VM BEA Liquid VM</span><br><span class="line"></span><br><span class="line">1.4.6　Apache Harmony Google Android Dalvik VM</span><br><span class="line"></span><br><span class="line">1.4.7　Microsoft JVM及其他</span><br><span class="line"></span><br><span class="line">1.5　展望Java技术的未来</span><br><span class="line"></span><br><span class="line">1.5.1　模块化</span><br><span class="line"></span><br><span class="line">1.5.2　混合语言</span><br><span class="line"></span><br><span class="line">1.5.3　多核并行</span><br><span class="line"></span><br><span class="line">1.5.4　进一步丰富语法</span><br><span class="line"></span><br><span class="line">1.5.5　64位虚拟机</span><br><span class="line"></span><br><span class="line">1.6　实战：自己编译JDK</span><br><span class="line"></span><br><span class="line">1.6.1　获取JDK源码</span><br><span class="line"></span><br><span class="line">1.6.2　系统需求</span><br><span class="line"></span><br><span class="line">1.6.3　构建编译环境</span><br><span class="line"></span><br><span class="line">1.6.4　进行编译</span><br><span class="line"></span><br><span class="line">1.6.5　在IDE工具中进行源码调试</span><br><span class="line"></span><br><span class="line">1.7　本章小结</span><br><span class="line"></span><br><span class="line">第二部分　自动内存管理机制</span><br><span class="line"></span><br><span class="line">第2章　Java内存区域与内存溢出异常</span><br><span class="line"></span><br><span class="line">2.1　概述</span><br><span class="line"></span><br><span class="line">2.2　运行时数据区域</span><br><span class="line"></span><br><span class="line">2.2.1　程序计数器</span><br><span class="line"></span><br><span class="line">2.2.2　Java虚拟机栈</span><br><span class="line"></span><br><span class="line">2.2.3　本地方法栈</span><br><span class="line"></span><br><span class="line">2.2.4　Java堆</span><br><span class="line"></span><br><span class="line">2.2.5　方法区</span><br><span class="line"></span><br><span class="line">2.2.6　运行时常量池</span><br><span class="line"></span><br><span class="line">2.2.7　直接内存</span><br><span class="line"></span><br><span class="line">2.3　HotSpot虚拟机对象探秘</span><br><span class="line"></span><br><span class="line">2.3.1　对象的创建</span><br><span class="line"></span><br><span class="line">2.3.2　对象的内存布局</span><br><span class="line"></span><br><span class="line">2.3.3　对象的访问定位</span><br><span class="line"></span><br><span class="line">2.4　实战：OutOfMemoryError异常</span><br><span class="line"></span><br><span class="line">2.4.1　Java堆溢出</span><br><span class="line"></span><br><span class="line">2.4.2　虚拟机栈和本地方法栈溢出</span><br><span class="line"></span><br><span class="line">2.4.3　方法区和运行时常量池溢出</span><br><span class="line"></span><br><span class="line">2.4.4　本机直接内存溢出</span><br><span class="line"></span><br><span class="line">2.5　本章小结</span><br><span class="line"></span><br><span class="line">第3章　垃圾收集器与内存分配策略</span><br><span class="line"></span><br><span class="line">3.1　概述</span><br><span class="line"></span><br><span class="line">3.2　对象已死</span><br><span class="line"></span><br><span class="line">3.2.1　引用计数算法</span><br><span class="line"></span><br><span class="line">3.2.2　可达性分析算法</span><br><span class="line"></span><br><span class="line">3.2.3　再谈引用</span><br><span class="line"></span><br><span class="line">3.2.4　生存还是死亡</span><br><span class="line"></span><br><span class="line">3.2.5　回收方法区</span><br><span class="line"></span><br><span class="line">3.3　垃圾收集算法</span><br><span class="line"></span><br><span class="line">3.3.1　标记-清除算法</span><br><span class="line"></span><br><span class="line">3.3.2　复制算法</span><br><span class="line"></span><br><span class="line">3.3.3　标记-整理算法</span><br><span class="line"></span><br><span class="line">3.3.4　分代收集算法</span><br><span class="line"></span><br><span class="line">3.4　HotSpot的算法实现</span><br><span class="line"></span><br><span class="line">3.4.1　枚举根节点</span><br><span class="line"></span><br><span class="line">3.4.2　安全点</span><br><span class="line"></span><br><span class="line">3.4.3　安全区域</span><br><span class="line"></span><br><span class="line">3.5　垃圾收集器</span><br><span class="line"></span><br><span class="line">3.5.1　Serial收集器</span><br><span class="line"></span><br><span class="line">3.5.2　ParNew收集器</span><br><span class="line"></span><br><span class="line">3.5.3　Parallel Scavenge收集器</span><br><span class="line"></span><br><span class="line">3.5.4　Serial Old收集器</span><br><span class="line"></span><br><span class="line">3.5.5　Parallel Old收集器</span><br><span class="line"></span><br><span class="line">3.5.6　CMS收集器</span><br><span class="line"></span><br><span class="line">3.5.7　G1收集器</span><br><span class="line"></span><br><span class="line">3.5.8　理解GC日志</span><br><span class="line"></span><br><span class="line">3.5.9　垃圾收集器参数总结</span><br><span class="line"></span><br><span class="line">3.6　内存分配与回收策略</span><br><span class="line"></span><br><span class="line">3.6.1　对象优先在Eden分配</span><br><span class="line"></span><br><span class="line">3.6.2　对象直接进入老年代</span><br><span class="line"></span><br><span class="line">3.6.3　长期存活的对象将进入老年代</span><br><span class="line"></span><br><span class="line">3.6.4　动态对象年龄判定</span><br><span class="line"></span><br><span class="line">3.6.5　空间分配担保</span><br><span class="line"></span><br><span class="line">3.7　本章小结</span><br><span class="line"></span><br><span class="line">第4章　虚拟机性能监控与故障处理工具</span><br><span class="line"></span><br><span class="line">4.1　概述</span><br><span class="line"></span><br><span class="line">4.2　JDK的命令行工具</span><br><span class="line"></span><br><span class="line">4.2.1　jps：虚拟机进程状况工具</span><br><span class="line"></span><br><span class="line">4.2.2　jstat：虚拟机统计信息监视工具</span><br><span class="line"></span><br><span class="line">4.2.3　jinfo：Java配置信息工具</span><br><span class="line"></span><br><span class="line">4.2.4　jmap：Java内存映像工具</span><br><span class="line"></span><br><span class="line">4.2.5　jhat：虚拟机堆转储快照分析工具</span><br><span class="line"></span><br><span class="line">4.2.6　jstack：Java堆栈跟踪工具</span><br><span class="line"></span><br><span class="line">4.2.7　HSDIS：JIT生成代码反汇编</span><br><span class="line"></span><br><span class="line">4.3　JDK的可视化工具</span><br><span class="line"></span><br><span class="line">4.3.1　JConsole：Java监视与管理控制台</span><br><span class="line"></span><br><span class="line">4.3.2　VisualVM：多合一故障处理工具</span><br><span class="line"></span><br><span class="line">4.4　本章小结</span><br><span class="line"></span><br><span class="line">第5章　调优案例分析与实战</span><br><span class="line"></span><br><span class="line">5.1　概述</span><br><span class="line"></span><br><span class="line">5.2　案例分析</span><br><span class="line"></span><br><span class="line">5.2.1　高性能硬件上的程序部署策略</span><br><span class="line"></span><br><span class="line">5.2.2　集群间同步导致的内存溢出</span><br><span class="line"></span><br><span class="line">5.2.3　堆外内存导致的溢出错误</span><br><span class="line"></span><br><span class="line">5.2.4　外部命令导致系统缓慢</span><br><span class="line"></span><br><span class="line">5.2.5　服务器JVM进程崩溃</span><br><span class="line"></span><br><span class="line">5.2.6　不恰当数据结构导致内存占用过</span><br><span class="line"></span><br><span class="line">5.2.7　由Windows虚拟内存导致的长时间停顿</span><br><span class="line"></span><br><span class="line">5.3　实战：Eclipse运行速度调优</span><br><span class="line"></span><br><span class="line">5.3.1　调优前的程序运行状态</span><br><span class="line"></span><br><span class="line">5.3.2　升级JDK 1.6的性能变化及兼容问题</span><br><span class="line"></span><br><span class="line">5.3.3　编译时间和类加载时间的优化</span><br><span class="line"></span><br><span class="line">5.3.4　调整内存设置控制垃圾收集频率</span><br><span class="line"></span><br><span class="line">5.3.5　选择收集器降低延迟</span><br><span class="line"></span><br><span class="line">5.4　本章小结</span><br><span class="line"></span><br><span class="line">第三部分　虚拟机执行子系统</span><br><span class="line"></span><br><span class="line">第6章　类文件结构</span><br><span class="line"></span><br><span class="line">6.1　概述</span><br><span class="line"></span><br><span class="line">6.2　无关性的基石</span><br><span class="line"></span><br><span class="line">6.3　Class类文件的结构</span><br><span class="line"></span><br><span class="line">6.3.1　魔数与Class文件的版本</span><br><span class="line"></span><br><span class="line">6.3.2　常量池</span><br><span class="line"></span><br><span class="line">6.3.3　访问标志</span><br><span class="line"></span><br><span class="line">6.3.4　类索引、父类索引与接口索引集合</span><br><span class="line"></span><br><span class="line">6.3.5　字段表集合</span><br><span class="line"></span><br><span class="line">6.3.6　方法表集合</span><br><span class="line"></span><br><span class="line">6.3.7　属性表集合</span><br><span class="line"></span><br><span class="line">6.4　字节码指令简介</span><br><span class="line"></span><br><span class="line">6.4.1　字节码与数据类型</span><br><span class="line"></span><br><span class="line">6.4.2　加载和存储指令</span><br><span class="line"></span><br><span class="line">6.4.3　运算指令</span><br><span class="line"></span><br><span class="line">6.4.4　类型转换指令</span><br><span class="line"></span><br><span class="line">6.4.5　对象创建与访问指令</span><br><span class="line"></span><br><span class="line">6.4.6　操作数栈管理指令</span><br><span class="line"></span><br><span class="line">6.4.7　控制转移指令</span><br><span class="line"></span><br><span class="line">6.4.8　方法调用和返回指令</span><br><span class="line"></span><br><span class="line">6.4.9　异常处理指令</span><br><span class="line"></span><br><span class="line">6.4.10　同步指令</span><br><span class="line"></span><br><span class="line">6.5　公有设计和私有实现</span><br><span class="line"></span><br><span class="line">6.6　Class文件结构的发展</span><br><span class="line"></span><br><span class="line">6.7　本章小结</span><br><span class="line"></span><br><span class="line">第7章　虚拟机类加载机制</span><br><span class="line"></span><br><span class="line">7.1　概述</span><br><span class="line"></span><br><span class="line">7.2　类加载的时机</span><br><span class="line"></span><br><span class="line">7.3　类加载的过程</span><br><span class="line"></span><br><span class="line">7.3.1　加载</span><br><span class="line"></span><br><span class="line">7.3.2　验证</span><br><span class="line"></span><br><span class="line">7.3.3　准备</span><br><span class="line"></span><br><span class="line">7.3.4　解析</span><br><span class="line"></span><br><span class="line">7.3.5　初始化</span><br><span class="line"></span><br><span class="line">7.4　类加载器</span><br><span class="line"></span><br><span class="line">7.4.1　类与类加载器</span><br><span class="line"></span><br><span class="line">7.4.2　双亲委派模型</span><br><span class="line"></span><br><span class="line">7.4.3　破坏双亲委派模型</span><br><span class="line"></span><br><span class="line">7.5　本章小结</span><br><span class="line"></span><br><span class="line">第8章　虚拟机字节码执行引擎</span><br><span class="line"></span><br><span class="line">8.1　概述</span><br><span class="line"></span><br><span class="line">8.2　运行时栈帧结构</span><br><span class="line"></span><br><span class="line">8.2.1　局部变量表</span><br><span class="line"></span><br><span class="line">8.2.2　操作数栈</span><br><span class="line"></span><br><span class="line">8.2.3　动态连接</span><br><span class="line"></span><br><span class="line">8.2.4　方法返回地址</span><br><span class="line"></span><br><span class="line">8.2.5　附加信息</span><br><span class="line"></span><br><span class="line">8.3　方法调用</span><br><span class="line"></span><br><span class="line">8.3.1　解析</span><br><span class="line"></span><br><span class="line">8.3.2　分派</span><br><span class="line"></span><br><span class="line">8.3.3　动态类型语言支持</span><br><span class="line"></span><br><span class="line">8.4　基于栈的字节码解释执行引擎</span><br><span class="line"></span><br><span class="line">8.4.1　解释执行</span><br><span class="line"></span><br><span class="line">8.4.2　基于栈的指令集与基于寄存器的指令集</span><br><span class="line"></span><br><span class="line">8.4.3　基于栈的解释器执行过程</span><br><span class="line"></span><br><span class="line">8.5　本章小结</span><br><span class="line"></span><br><span class="line">第9章　类加载及执行子系统的案例与实战</span><br><span class="line"></span><br><span class="line">9.1　概述</span><br><span class="line"></span><br><span class="line">9.2　案例分析</span><br><span class="line"></span><br><span class="line">9.2.1　Tomcat：正统的类加载器架构</span><br><span class="line"></span><br><span class="line">9.2.2　OSGi：灵活的类加载器架构</span><br><span class="line"></span><br><span class="line">9.2.3　字节码生成技术与动态代理的实现</span><br><span class="line"></span><br><span class="line">9.2.4　Retrotranslator：跨越JDK版本</span><br><span class="line"></span><br><span class="line">9.3　实战：自己动手实现远程执行功能</span><br><span class="line"></span><br><span class="line">9.3.1　目标</span><br><span class="line"></span><br><span class="line">9.3.2　思路</span><br><span class="line"></span><br><span class="line">9.3.3　实现</span><br><span class="line"></span><br><span class="line">9.3.4　验证</span><br><span class="line"></span><br><span class="line">9.4　本章小结</span><br><span class="line"></span><br><span class="line">第四部分　程序编译与代码优化</span><br><span class="line"></span><br><span class="line">第10章　早期（编译期）优化</span><br><span class="line"></span><br><span class="line">10.1　概述</span><br><span class="line"></span><br><span class="line">10.2　Javac编译器</span><br><span class="line"></span><br><span class="line">10.2.1　Javac的源码与调试</span><br><span class="line"></span><br><span class="line">10.2.2　解析与填充符号表</span><br><span class="line"></span><br><span class="line">10.2.3　注解处理器</span><br><span class="line"></span><br><span class="line">10.2.4　语义分析与字节码生成</span><br><span class="line"></span><br><span class="line">10.3　Java语法糖的味道</span><br><span class="line"></span><br><span class="line">10.3.1　泛型与类型擦除</span><br><span class="line"></span><br><span class="line">10.3.2　自动装箱、拆箱与遍历循环</span><br><span class="line"></span><br><span class="line">10.3.3　条件编译</span><br><span class="line"></span><br><span class="line">10.4　实战：插入式注解处理器</span><br><span class="line"></span><br><span class="line">10.4.1　实战目标</span><br><span class="line"></span><br><span class="line">10.4.2　代码实现</span><br><span class="line"></span><br><span class="line">10.4.3　运行与测试</span><br><span class="line"></span><br><span class="line">10.4.4　其他应用案例</span><br><span class="line"></span><br><span class="line">10.5　本章小结</span><br><span class="line"></span><br><span class="line">第11章　晚期（运行期）优化</span><br><span class="line"></span><br><span class="line">11.1　概述</span><br><span class="line"></span><br><span class="line">11.2　HotSpot虚拟机内的即时编译器</span><br><span class="line"></span><br><span class="line">11.2.1　解释器与编译器</span><br><span class="line"></span><br><span class="line">11.2.2　编译对象与触发条件</span><br><span class="line"></span><br><span class="line">11.2.3　编译过程</span><br><span class="line"></span><br><span class="line">11.2.4　查看及分析即时编译结果</span><br><span class="line"></span><br><span class="line">11.3　编译优化技术</span><br><span class="line"></span><br><span class="line">11.3.1　优化技术概览</span><br><span class="line"></span><br><span class="line">11.3.2　公共子表达式消除</span><br><span class="line"></span><br><span class="line">11.3.3　数组边界检查消除</span><br><span class="line"></span><br><span class="line">11.3.4　方法内联</span><br><span class="line"></span><br><span class="line">11.3.5　逃逸分析</span><br><span class="line"></span><br><span class="line">11.4　Java与CC++的编译器对比</span><br><span class="line"></span><br><span class="line">11.5　本章小结</span><br><span class="line"></span><br><span class="line">第五部分　高效并发</span><br><span class="line"></span><br><span class="line">第12章　Java内存模型与线程</span><br><span class="line"></span><br><span class="line">12.1　概述</span><br><span class="line"></span><br><span class="line">12.2　硬件的效率与一致性</span><br><span class="line"></span><br><span class="line">12.3　Java内存模型</span><br><span class="line"></span><br><span class="line">12.3.1　主内存与工作内存</span><br><span class="line"></span><br><span class="line">12.3.2　内存间交互操作</span><br><span class="line"></span><br><span class="line">12.3.3　对于volatile型变量的特殊规则</span><br><span class="line"></span><br><span class="line">12.3.4　对于long和double型变量的特殊规则</span><br><span class="line"></span><br><span class="line">12.3.5　原子性、可见性与有序性</span><br><span class="line"></span><br><span class="line">12.3.6　先行发生原则</span><br><span class="line"></span><br><span class="line">12.4　Java与线程</span><br><span class="line"></span><br><span class="line">12.4.1　线程的实现</span><br><span class="line"></span><br><span class="line">12.4.2　Java线程调度</span><br><span class="line"></span><br><span class="line">12.4.3　状态转换</span><br><span class="line"></span><br><span class="line">12.5　本章小结</span><br><span class="line"></span><br><span class="line">第13章　线程安全与锁优化</span><br><span class="line"></span><br><span class="line">13.1　概述</span><br><span class="line"></span><br><span class="line">13.2　线程安全</span><br><span class="line"></span><br><span class="line">13.2.1　Java语言中的线程安全</span><br><span class="line"></span><br><span class="line">13.2.2　线程安全的实现方法</span><br><span class="line"></span><br><span class="line">13.3　锁优化</span><br><span class="line"></span><br><span class="line">13.3.1　自旋锁与自适应自旋</span><br><span class="line"></span><br><span class="line">13.3.2　锁消除</span><br><span class="line"></span><br><span class="line">13.3.3　锁粗化</span><br><span class="line"></span><br><span class="line">13.3.4　轻量级锁</span><br><span class="line"></span><br><span class="line">13.3.5　偏向锁</span><br><span class="line"></span><br><span class="line">13.4　本章小结</span><br><span class="line"></span><br><span class="line">附　　录</span><br><span class="line"></span><br><span class="line">附录A　编译Windows版的OpenJDK</span><br><span class="line"></span><br><span class="line">附录B　虚拟机字节码指令表</span><br><span class="line"></span><br><span class="line">附录C　HotSpot虚拟机主要参数表</span><br><span class="line"></span><br><span class="line">附录D　对象查询语言（OQL）简介</span><br><span class="line"></span><br><span class="line">附录E　JDK历史版本轨迹</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析Tomcat PDF</title>
    <url>/posts/565bb3ed/</url>
    <content><![CDATA[<h4 id="《深入剖析Tomcat》"><a href="#《深入剖析Tomcat》" class="headerlink" title="《深入剖析Tomcat》"></a>《深入剖析Tomcat》</h4><h6 id="链接-https-pan-baidu-com-s-1wzEEDDatdPzhE6Go-I1zqg-提取码-p42w"><a href="#链接-https-pan-baidu-com-s-1wzEEDDatdPzhE6Go-I1zqg-提取码-p42w" class="headerlink" title="链接: https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg 提取码: p42w"></a>链接: <a href="https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg">https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg</a> 提取码: p42w</h6><p>《深入剖析Tomcat》深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习《深入剖析Tomcat》，你将可以自行开发Tomcat组件，或者扩展已有的组件。 Tomcat是目前比较流行的Web服务器之一。作为一个开源和小型的轻量级应用服务器，Tomcat 易于使用，便于部署，但Tomcat本身是一个非常复杂的系统，包含了很多功能模块。这些功能模块构成了Tomcat的核心结构。《深入剖析Tomcat》从基本的HTTP请求开始，直至使用JMX技术管理Tomcat中的应用程序，逐一剖析Tomcat的基本功能模块，并配以示例代码，使读者可以逐步实现自己的Web服务器。<br><a id="more"></a></p>
<p><img src="/images/31075b65d99b5b4ae18523a205b4f6601.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《深入剖析Tomcat》</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前 言</span><br><span class="line"></span><br><span class="line">第1章 一个简单的Web服务器1</span><br><span class="line"></span><br><span class="line">1.1 HTTP1</span><br><span class="line"></span><br><span class="line">1.1.1 HTTP请求1</span><br><span class="line"></span><br><span class="line">1.1.2 HTTP响应2</span><br><span class="line"></span><br><span class="line">1.2 Socket类3</span><br><span class="line"></span><br><span class="line">1.3 应用程序5</span><br><span class="line"></span><br><span class="line">1.3.1 HttpServer类5</span><br><span class="line"></span><br><span class="line">1.3.2 Request类8</span><br><span class="line"></span><br><span class="line">1.3.3 Response类10</span><br><span class="line"></span><br><span class="line">1.3.4 运行应用程序12</span><br><span class="line"></span><br><span class="line">1.4 小结13</span><br><span class="line"></span><br><span class="line">第2章 一个简单的servlet容器14</span><br><span class="line"></span><br><span class="line">2.1 javax.servlet.Servlet接口14</span><br><span class="line"></span><br><span class="line">2.2 应用程序 116</span><br><span class="line"></span><br><span class="line">2.2.1 HttpServer1类17</span><br><span class="line"></span><br><span class="line">2.2.2 Request类19</span><br><span class="line"></span><br><span class="line">2.2.3 Response类21</span><br><span class="line"></span><br><span class="line">2.2.4 StaticResourceProcessor类23</span><br><span class="line"></span><br><span class="line">2.2.5 servletProcessor1类24</span><br><span class="line"></span><br><span class="line">2.2.6 运行应用程序27</span><br><span class="line"></span><br><span class="line">2.3 应用程序227</span><br><span class="line"></span><br><span class="line">2.4 小结30</span><br><span class="line"></span><br><span class="line">第3章 连接器31</span><br><span class="line"></span><br><span class="line">3.1 StringManager类31</span><br><span class="line"></span><br><span class="line">3.2 应用程序33</span><br><span class="line"></span><br><span class="line">3.2.1 启动应用程序35</span><br><span class="line"></span><br><span class="line">3.2.2 HttpConnector类36</span><br><span class="line"></span><br><span class="line">3.2.3 创建HttpRequest对象38</span><br><span class="line"></span><br><span class="line">3.2.4 创建HttpResponse对象49</span><br><span class="line"></span><br><span class="line">3.2.5 静态资源处理器和servlet处理器50</span><br><span class="line"></span><br><span class="line">3.2.6 运行应用程序50</span><br><span class="line"></span><br><span class="line">3.3 小结52</span><br><span class="line"></span><br><span class="line">第4章 Tomcat的默认连接器53</span><br><span class="line"></span><br><span class="line">4.1 HTTP 1.1的新特性54</span><br><span class="line"></span><br><span class="line">4.1.1 持久连接54</span><br><span class="line"></span><br><span class="line">4.1.2 块编码54</span><br><span class="line"></span><br><span class="line">4.1.3 状态码100的使用55</span><br><span class="line"></span><br><span class="line">4.2 Connector接口55</span><br><span class="line"></span><br><span class="line">4.3 HttpConnector类56</span><br><span class="line"></span><br><span class="line">4.3.1 创建服务器套接字56</span><br><span class="line"></span><br><span class="line">4.3.2 维护HttpProcessor实例56</span><br><span class="line"></span><br><span class="line">4.3.3 提供HTTP请求服务57</span><br><span class="line"></span><br><span class="line">4.4 HttpProcessor类58</span><br><span class="line"></span><br><span class="line">4.5 Request对象61</span><br><span class="line"></span><br><span class="line">4.6 Response对象62</span><br><span class="line"></span><br><span class="line">4.7 处理请求62</span><br><span class="line"></span><br><span class="line">4.7.1 解析连接65</span><br><span class="line"></span><br><span class="line">4.7.2 解析请求65</span><br><span class="line"></span><br><span class="line">4.7.3 解析请求头65</span><br><span class="line"></span><br><span class="line">4.8 简单的Container应用程序66</span><br><span class="line"></span><br><span class="line">4.9 小结70</span><br><span class="line"></span><br><span class="line">第5章 servlet容器71</span><br><span class="line"></span><br><span class="line">5.1 Container接口71</span><br><span class="line"></span><br><span class="line">5.2 管道任务73</span><br><span class="line"></span><br><span class="line">5.2.1 Pipeline接口76</span><br><span class="line"></span><br><span class="line">5.2.2 Valve接口76</span><br><span class="line"></span><br><span class="line">5.2.3 ValveContext接口76</span><br><span class="line"></span><br><span class="line">5.2.4 Contained接口77</span><br><span class="line"></span><br><span class="line">5.3 Wrapper接口77</span><br><span class="line"></span><br><span class="line">5.4 Context接口78</span><br><span class="line"></span><br><span class="line">5.5 Wrapper应用程序78</span><br><span class="line"></span><br><span class="line">5.5.1 ex05.pyrmont.core.SimpleLoader类78</span><br><span class="line"></span><br><span class="line">5.5.2 ex05.pyrmont.core.SimplePipeline类79</span><br><span class="line"></span><br><span class="line">5.5.3 ex05.pyrmont.core.SimpleWrapper类79</span><br><span class="line"></span><br><span class="line">5.5.4 ex05.pyrmont.core.SimpleWrapperValve类80</span><br><span class="line"></span><br><span class="line">5.5.5 ex05.pyrmont.valves.ClientIPLoggerValve类81</span><br><span class="line"></span><br><span class="line">5.5.6 ex05.pyrmont.valves.HeaderLoggerValve类81</span><br><span class="line"></span><br><span class="line">5.5.7 ex05.pyrmont.startup.Bootstrap182</span><br><span class="line"></span><br><span class="line">5.5.8 运行应用程序84</span><br><span class="line"></span><br><span class="line">5.6 Context应用程序84</span><br><span class="line"></span><br><span class="line">5.6.1 ex05.pyrmont.core.SimpleContextValve类87</span><br><span class="line"></span><br><span class="line">5.6.2 ex05.pyrmont.core.SimpleContextMapper类87</span><br><span class="line"></span><br><span class="line">5.6.3 ex05.pyrmont.core.SimpleContext类89</span><br><span class="line"></span><br><span class="line">5.6.4 ex05.pyrmont.startup.Bootstrap289</span><br><span class="line"></span><br><span class="line">5.6.5 运行应用程序91</span><br><span class="line"></span><br><span class="line">5.7 小结92</span><br><span class="line"></span><br><span class="line">第6章 生命周期93</span><br><span class="line"></span><br><span class="line">6.1 Lifecycle接口93</span><br><span class="line"></span><br><span class="line">6.2 LifecycleEvent类94</span><br><span class="line"></span><br><span class="line">6.3 LifecycleListener接口94</span><br><span class="line"></span><br><span class="line">6.4 LifecycleSupport类95</span><br><span class="line"></span><br><span class="line">6.5 应用程序97</span><br><span class="line"></span><br><span class="line">6.5.1 ex06.pyrmont.core.SimpleContext类97</span><br><span class="line"></span><br><span class="line">6.5.2 ex06.pyrmont.core.SimpleContextLifecycleListener类100</span><br><span class="line"></span><br><span class="line">6.5.3 ex06.pyrmont.core.SimpleLoader类101</span><br><span class="line"></span><br><span class="line">6.5.4 ex06.pyrmont.core.SimplePipeline类101</span><br><span class="line"></span><br><span class="line">6.5.5 ex06.pyrmont.core.SimpleWrapper类101</span><br><span class="line"></span><br><span class="line">6.5.6 运行应用程序103</span><br><span class="line"></span><br><span class="line">6.6 小结104</span><br><span class="line"></span><br><span class="line">第7章 日志记录器105</span><br><span class="line"></span><br><span class="line">7.1 Logger接口105</span><br><span class="line"></span><br><span class="line">7.2 Tomcat的日志记录器106</span><br><span class="line"></span><br><span class="line">7.2.1 LoggerBase类106</span><br><span class="line"></span><br><span class="line">7.2.2 SystemOutLogger类107</span><br><span class="line"></span><br><span class="line">7.2.3 SystemErrLogger类107</span><br><span class="line"></span><br><span class="line">7.2.4 FileLogger类108</span><br><span class="line"></span><br><span class="line">7.3 应用程序111</span><br><span class="line"></span><br><span class="line">7.4 小结112</span><br><span class="line"></span><br><span class="line">第8章 载入器113</span><br><span class="line"></span><br><span class="line">8.1 Java的类载入器113</span><br><span class="line"></span><br><span class="line">8.2 Loader接口114</span><br><span class="line"></span><br><span class="line">8.3 Reloader接口116</span><br><span class="line"></span><br><span class="line">8.4 WebappLoader类116</span><br><span class="line"></span><br><span class="line">8.4.1 创建类载入器117</span><br><span class="line"></span><br><span class="line">8.4.2 设置仓库118</span><br><span class="line"></span><br><span class="line">8.4.3 设置类路径118</span><br><span class="line"></span><br><span class="line">8.4.4 设置访问权限118</span><br><span class="line"></span><br><span class="line">8.4.5 开启新线程执行类的重新载入118</span><br><span class="line"></span><br><span class="line">8.5 WebappClassLoader类120</span><br><span class="line"></span><br><span class="line">8.5.1 类缓存120</span><br><span class="line"></span><br><span class="line">8.5.2 载入类121</span><br><span class="line"></span><br><span class="line">8.5.3 应用程序121</span><br><span class="line"></span><br><span class="line">8.6 运行应用程序124</span><br><span class="line"></span><br><span class="line">8.7 小结124</span><br><span class="line"></span><br><span class="line">第9章 Session管理125</span><br><span class="line"></span><br><span class="line">9.1 Session对象126</span><br><span class="line"></span><br><span class="line">9.1.1 Session接口126</span><br><span class="line"></span><br><span class="line">9.1.2 StandardSession类127</span><br><span class="line"></span><br><span class="line">9.1.3 StandardSessionFacade类129</span><br><span class="line"></span><br><span class="line">9.2 Manager130</span><br><span class="line"></span><br><span class="line">9.2.1 Manager接口130</span><br><span class="line"></span><br><span class="line">9.2.2 ManagerBase类131</span><br><span class="line"></span><br><span class="line">9.2.3 StandardManager类132</span><br><span class="line"></span><br><span class="line">9.2.4 PersistentManagerBase类133</span><br><span class="line"></span><br><span class="line">9.2.5 PersistentManager类135</span><br><span class="line"></span><br><span class="line">9.2.6 DistributedManager类135</span><br><span class="line"></span><br><span class="line">9.3 存储器136</span><br><span class="line"></span><br><span class="line">9.3.1 StoreBase类137</span><br><span class="line"></span><br><span class="line">9.3.2 FileStore类138</span><br><span class="line"></span><br><span class="line">9.3.3 JDBCStore类139</span><br><span class="line"></span><br><span class="line">9.4 应用程序139</span><br><span class="line"></span><br><span class="line">9.4.1 Bootstrap类139</span><br><span class="line"></span><br><span class="line">9.4.2 SimpleWrapperValve类140</span><br><span class="line"></span><br><span class="line">9.4.3 运行应用程序141</span><br><span class="line"></span><br><span class="line">9.5 小结142</span><br><span class="line"></span><br><span class="line">第10章 安全性143</span><br><span class="line"></span><br><span class="line">10.1 领域143</span><br><span class="line"></span><br><span class="line">10.2 GenericPrincipal类144</span><br><span class="line"></span><br><span class="line">10.3 LoginConfig类145</span><br><span class="line"></span><br><span class="line">10.4 Authenticator接口145</span><br><span class="line"></span><br><span class="line">10.5 安装验证器阀146</span><br><span class="line"></span><br><span class="line">10.6 应用程序147</span><br><span class="line"></span><br><span class="line">10.6.1 ex10.pyrmont.core.SimpleContextConfig类147</span><br><span class="line"></span><br><span class="line">10.6.2 ex10.pyrmont.realm.SimpleRealm类149</span><br><span class="line"></span><br><span class="line">10.6.3 ex10.pyrmont.realm.SimpleUserDatabaseRealm152</span><br><span class="line"></span><br><span class="line">10.6.4 ex10.pyrmont.startup.Bootstrap1类154</span><br><span class="line"></span><br><span class="line">10.6.5 ex10.pyrmont.startup.Bootstrap2类156</span><br><span class="line"></span><br><span class="line">10.6.6 运行应用程序158</span><br><span class="line"></span><br><span class="line">10.7 小结158</span><br><span class="line"></span><br><span class="line">第11章 StandardWrapper159</span><br><span class="line"></span><br><span class="line">11.1 方法调用序列159</span><br><span class="line"></span><br><span class="line">11.2 SingleThreadModel160</span><br><span class="line"></span><br><span class="line">11.3 StandardWrapper161</span><br><span class="line"></span><br><span class="line">11.3.1 分配servlet实例162</span><br><span class="line"></span><br><span class="line">11.3.2 载入servlet类164</span><br><span class="line"></span><br><span class="line">11.3.3 ServletConfig对象167</span><br><span class="line"></span><br><span class="line">11.3.4 servlet容器的父子关系169</span><br><span class="line"></span><br><span class="line">11.4 StandardWrapperFacade类170</span><br><span class="line"></span><br><span class="line">11.5 StandardWrapperValve类171</span><br><span class="line"></span><br><span class="line">11.6 FilterDef类172</span><br><span class="line"></span><br><span class="line">11.7 ApplicationFilterConfig类174</span><br><span class="line"></span><br><span class="line">11.8 ApplicationFilterChain类175</span><br><span class="line"></span><br><span class="line">11.9 应用程序175</span><br><span class="line"></span><br><span class="line">11.10 小结177</span><br><span class="line"></span><br><span class="line">第12章 StandardContext类178</span><br><span class="line"></span><br><span class="line">12.1 StandardContext的配置178</span><br><span class="line"></span><br><span class="line">12.1.1 StandardContext类的构造函数179</span><br><span class="line"></span><br><span class="line">12.1.2 启动StandardContext实例179</span><br><span class="line"></span><br><span class="line">12.1.3 invoke()方法183</span><br><span class="line"></span><br><span class="line">12.2 StandardContextMapper类184</span><br><span class="line"></span><br><span class="line">12.3 对重载的支持187</span><br><span class="line"></span><br><span class="line">12.4 backgroundProcess()方法188</span><br><span class="line"></span><br><span class="line">12.5 小结190</span><br><span class="line"></span><br><span class="line">第13章 Host和Engine191</span><br><span class="line"></span><br><span class="line">13.1 Host接口191</span><br><span class="line"></span><br><span class="line">13.2 StandardHost类193</span><br><span class="line"></span><br><span class="line">13.3 StandardHostMapper类195</span><br><span class="line"></span><br><span class="line">13.4 StandardHostValve类196</span><br><span class="line"></span><br><span class="line">13.5 为什么必须要有一个Host容器197</span><br><span class="line"></span><br><span class="line">13.6 应用程序1198</span><br><span class="line"></span><br><span class="line">13.7 Engine接口199</span><br><span class="line"></span><br><span class="line">13.8 StandardEngine类201</span><br><span class="line"></span><br><span class="line">13.9 StandardEngineValve类201</span><br><span class="line"></span><br><span class="line">13.10 应用程序2202</span><br><span class="line"></span><br><span class="line">13.11 小结203</span><br><span class="line"></span><br><span class="line">第14章 服务器组件和服务组件204</span><br><span class="line"></span><br><span class="line">14.1 服务器组件204</span><br><span class="line"></span><br><span class="line">14.2 StandardServer类206</span><br><span class="line"></span><br><span class="line">14.2.1 initialize()方法206</span><br><span class="line"></span><br><span class="line">14.2.2 start()方法207</span><br><span class="line"></span><br><span class="line">14.2.3 stop()方法207</span><br><span class="line"></span><br><span class="line">14.2.4 await()方法208</span><br><span class="line"></span><br><span class="line">14.3 Service接口209</span><br><span class="line"></span><br><span class="line">14.4 StandardService类211</span><br><span class="line"></span><br><span class="line">14.4.1 connector和container211</span><br><span class="line"></span><br><span class="line">14.4.2 与生命周期有关的方法213</span><br><span class="line"></span><br><span class="line">14.5 应用程序215</span><br><span class="line"></span><br><span class="line">14.5.1 Bootstrap类215</span><br><span class="line"></span><br><span class="line">14.5.2 Stopper类217</span><br><span class="line"></span><br><span class="line">14.5.3 运行应用程序218</span><br><span class="line"></span><br><span class="line">14.6 小结219</span><br><span class="line"></span><br><span class="line">第15章 Digester库220</span><br><span class="line"></span><br><span class="line">15.1 Digester库221</span><br><span class="line"></span><br><span class="line">15.1.1 Digester类221</span><br><span class="line"></span><br><span class="line">15.1.2 Digester库示例1225</span><br><span class="line"></span><br><span class="line">15.1.3 Digester库示例2227</span><br><span class="line"></span><br><span class="line">15.1.4 Rule类230</span><br><span class="line"></span><br><span class="line">15.1.5 Digester库示例3：使用RuleSet232</span><br><span class="line"></span><br><span class="line">15.2 ContextConfig类234</span><br><span class="line"></span><br><span class="line">15.2.1 defaultConfig(...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入浅出MySQL++数据库开发优化与管理维护 PDF</title>
    <url>/posts/215c837b/</url>
    <content><![CDATA[<h4 id="《深入浅出MySQL-数据库开发优化与管理维护》"><a href="#《深入浅出MySQL-数据库开发优化与管理维护》" class="headerlink" title="《深入浅出MySQL++数据库开发优化与管理维护》"></a>《深入浅出MySQL++数据库开发优化与管理维护》</h4><h6 id="链接-https-pan-baidu-com-s-1ydnPTZ531FwRxOdOPDj51A-提取码-5eez"><a href="#链接-https-pan-baidu-com-s-1ydnPTZ531FwRxOdOPDj51A-提取码-5eez" class="headerlink" title="链接: https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A 提取码: 5eez"></a>链接: <a href="https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A">https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A</a> 提取码: 5eez</h6><p>本书分为“基础篇”“开发篇”“优化篇”“管理维护篇”和“架构篇”，其内容源自网易公司多位资深数据库专家数年的经验总结和MySQL数据库的使用心得。本书以实用性和可操作性为主旨，章节安排合理有序，内容丰富全面，讲解由浅入深，还提供了大量的一线工作实例。<br><a id="more"></a></p>
<p>无论是数据库初学人员，还是有一定经验的数据库管理/维护/开发人员，都可以在阅读本书的过程中或有匪浅。本书还适合作为数据库相关专业的参考用户，以及相关培训机柜的培训教材</p>
<p><img src="/images/c48d985d53d116c73bdfb0baa4aa71dc1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 一部分 基础篇</span><br><span class="line"></span><br><span class="line">第　1章 MySQL的安装与配置　2</span><br><span class="line"></span><br><span class="line">1．1　MySQL的下载　2</span><br><span class="line"></span><br><span class="line">1．1．1　在Windows平台下下载MySQL　3</span><br><span class="line"></span><br><span class="line">1．1．2　在Linux平台下下载MySQL　3</span><br><span class="line"></span><br><span class="line">1．2　MySQL的安装　5</span><br><span class="line"></span><br><span class="line">1．2．1　在Windows平台下安装MySQL　5</span><br><span class="line"></span><br><span class="line">1．2．2　在Linux平台下安装MySQL　8</span><br><span class="line"></span><br><span class="line">1．3　MySQL的配置　12</span><br><span class="line"></span><br><span class="line">1．3．1　Windows平台下配置MySQL　12</span><br><span class="line"></span><br><span class="line">1．3．2　Linux平台下配置MySQL　13</span><br><span class="line"></span><br><span class="line">1．4　启动和关闭MySQL服务　13</span><br><span class="line"></span><br><span class="line">1．4．1　在Windows平台下启动和关闭MySQL服务　13</span><br><span class="line"></span><br><span class="line">1．4．2　在Linux平台下启动和关闭MySQL服务　13</span><br><span class="line"></span><br><span class="line">1．5　小结　14</span><br><span class="line"></span><br><span class="line">第　2章 SQL基础　15</span><br><span class="line"></span><br><span class="line">2．1　SQL简介　15</span><br><span class="line"></span><br><span class="line">2．2　（My）SQL使用入门　15</span><br><span class="line"></span><br><span class="line">2．2．1　SQL分类　15</span><br><span class="line"></span><br><span class="line">2．2．2　DDL语句　16</span><br><span class="line"></span><br><span class="line">2．2．3　DML语句　23</span><br><span class="line"></span><br><span class="line">2．2．4　DCL语句　33</span><br><span class="line"></span><br><span class="line">2．3　帮助的使用　34</span><br><span class="line"></span><br><span class="line">2．3．1　按照层次看帮助　34</span><br><span class="line"></span><br><span class="line">2．3．2　快速查阅帮助　35</span><br><span class="line"></span><br><span class="line">2．4　查询元数据信息　36</span><br><span class="line"></span><br><span class="line">2．5　小结　37</span><br><span class="line"></span><br><span class="line">第3章　MySQL支持的数据类型　38</span><br><span class="line"></span><br><span class="line">3．1　数值类型　38</span><br><span class="line"></span><br><span class="line">3．2　日期时间类型　43</span><br><span class="line"></span><br><span class="line">3．3　字符串类型　49</span><br><span class="line"></span><br><span class="line">3．3．1　CHAR和VARCHAR类型　50</span><br><span class="line"></span><br><span class="line">3．3．2　BINARY和VARBINARY类型　51</span><br><span class="line"></span><br><span class="line">3．3．3　ENUM类型　51</span><br><span class="line"></span><br><span class="line">3．3．4　SET类型　52</span><br><span class="line"></span><br><span class="line">3．4　JSON类型　52</span><br><span class="line"></span><br><span class="line">3．5　小结　54</span><br><span class="line"></span><br><span class="line">第4章　MySQL中的运算符　55</span><br><span class="line"></span><br><span class="line">4．1　算术运算符　55</span><br><span class="line"></span><br><span class="line">4．2　比较运算符　56</span><br><span class="line"></span><br><span class="line">4．3　逻辑运算符　59</span><br><span class="line"></span><br><span class="line">4．4　位运算符　60</span><br><span class="line"></span><br><span class="line">4．5　运算符的优先级　61</span><br><span class="line"></span><br><span class="line">4．6　小结　62</span><br><span class="line"></span><br><span class="line">第5章　常用函数　63</span><br><span class="line"></span><br><span class="line">5．1　字符串函数　63</span><br><span class="line"></span><br><span class="line">5．2　数值函数　66</span><br><span class="line"></span><br><span class="line">5．3　日期和时间函数　68</span><br><span class="line"></span><br><span class="line">5．4　流程函数　71</span><br><span class="line"></span><br><span class="line">5．5　JSON函数　73</span><br><span class="line"></span><br><span class="line">5．5．1　创建JSON函数　74</span><br><span class="line"></span><br><span class="line">5．5．2　查询JSON函数　75</span><br><span class="line"></span><br><span class="line">5．5．3　修改JSON的函数　79</span><br><span class="line"></span><br><span class="line">5．5．4　查询JSON元数据函数　81</span><br><span class="line"></span><br><span class="line">5．5．5　JSON工具函数　83</span><br><span class="line"></span><br><span class="line">5．6　窗口函数　86</span><br><span class="line"></span><br><span class="line">5．6．1　ROW_NUMBER()　87</span><br><span class="line"></span><br><span class="line">5．6．2　RANK()&#x2F;DENSE_RANK()　89</span><br><span class="line"></span><br><span class="line">5．6．3　PERCENT_RANK()&#x2F;CUME_DIST()　89</span><br><span class="line"></span><br><span class="line">5．6．4　NFILE(N)　90</span><br><span class="line"></span><br><span class="line">5．6．5　NTH_VALUE(expr，N)　91</span><br><span class="line"></span><br><span class="line">5．6．6　LAG(expr，N)&#x2F;LEAD(expr，N)　91</span><br><span class="line"></span><br><span class="line">5．6．7　FIRST_VALUE（expr）&#x2F;LAST_VALUE（expr）　92</span><br><span class="line"></span><br><span class="line">5．6．8　聚合函数作为窗口函数　93</span><br><span class="line"></span><br><span class="line">5．7　其他常用函数　93</span><br><span class="line"></span><br><span class="line">5．8　小结　95</span><br><span class="line"></span><br><span class="line">第二部分　开发篇</span><br><span class="line"></span><br><span class="line">第6章　表类型（存储引擎）的选择　98</span><br><span class="line"></span><br><span class="line">6．1　MySQL存储引擎概述　98</span><br><span class="line"></span><br><span class="line">6．2　各种存储引擎的特性　100</span><br><span class="line"></span><br><span class="line">6．2．1　MyISAM　101</span><br><span class="line"></span><br><span class="line">6．2．2　InnoDB　102</span><br><span class="line"></span><br><span class="line">6．2．3　MEMORY　108</span><br><span class="line"></span><br><span class="line">6．2．4　MERGE　109</span><br><span class="line"></span><br><span class="line">6．2．5　TokuDB　111</span><br><span class="line"></span><br><span class="line">6．3　如何选择合适的存储引擎　112</span><br><span class="line"></span><br><span class="line">6．4　小结　113</span><br><span class="line"></span><br><span class="line">第7章　选择合适的数据类型　114</span><br><span class="line"></span><br><span class="line">7．1　CHAR与VARCHAR　114</span><br><span class="line"></span><br><span class="line">7．2　TEXT与BLOB　115</span><br><span class="line"></span><br><span class="line">7．3　浮点数与定点数　118</span><br><span class="line"></span><br><span class="line">7．4　日期类型选择　120</span><br><span class="line"></span><br><span class="line">7．5　小结　120</span><br><span class="line"></span><br><span class="line">第8章　字符集　121</span><br><span class="line"></span><br><span class="line">8．1　字符集概述　121</span><br><span class="line"></span><br><span class="line">8．2　Unicode简述　121</span><br><span class="line"></span><br><span class="line">8．3　汉字及一些常见字符集　123</span><br><span class="line"></span><br><span class="line">8．4　怎样选择合适的字符集　124</span><br><span class="line"></span><br><span class="line">8．5　MySQL支持的字符集简介　125</span><br><span class="line"></span><br><span class="line">8．6　MySQL字符集的设置　126</span><br><span class="line"></span><br><span class="line">8．6．1　服务器字符集和排序规则　126</span><br><span class="line"></span><br><span class="line">8．6．2　数据库字符集和排序规则　127</span><br><span class="line"></span><br><span class="line">8．6．3　表字符集和排序规则　127</span><br><span class="line"></span><br><span class="line">8．6．4　列字符集和排序规则　128</span><br><span class="line"></span><br><span class="line">8．6．5　连接字符集和排序规则　128</span><br><span class="line"></span><br><span class="line">8．7　字符集的修改步骤　129</span><br><span class="line"></span><br><span class="line">8．8　小结　129</span><br><span class="line"></span><br><span class="line">第9章　索引的设计和使用　130</span><br><span class="line"></span><br><span class="line">9．1　索引概述　130</span><br><span class="line"></span><br><span class="line">9．2　设计索引的原则　131</span><br><span class="line"></span><br><span class="line">9．3　索引设计的误区　132</span><br><span class="line"></span><br><span class="line">9．4　索引设计的一般步骤　132</span><br><span class="line"></span><br><span class="line">9．5　BTREE索引与HASH索引　133</span><br><span class="line"></span><br><span class="line">9．6　索引在MySQL 8．0中的改进　134</span><br><span class="line"></span><br><span class="line">9．6．1　不可见索引　134</span><br><span class="line"></span><br><span class="line">9．6．2　倒序索引　135</span><br><span class="line"></span><br><span class="line">9．7　小结　136</span><br><span class="line"></span><br><span class="line">第　10章 开发常用数据库对象　137</span><br><span class="line"></span><br><span class="line">10．1　视图　137</span><br><span class="line"></span><br><span class="line">10．1．1　什么是视图　137</span><br><span class="line"></span><br><span class="line">10．1．2　视图操作　137</span><br><span class="line"></span><br><span class="line">10．1．3　创建或者修改视图　137</span><br><span class="line"></span><br><span class="line">10．1．4　删除视图　139</span><br><span class="line"></span><br><span class="line">10．1．5　查看视图　139</span><br><span class="line"></span><br><span class="line">10．2　存储过程和函数　140</span><br><span class="line"></span><br><span class="line">10．2．1　什么是存储过程和函数　141</span><br><span class="line"></span><br><span class="line">10．2．2　存储过程和函数的相关操作　141</span><br><span class="line"></span><br><span class="line">10．2．3　创建、修改存储过程或者函数　141</span><br><span class="line"></span><br><span class="line">10．2．4　删除存储过程或者函数　144</span><br><span class="line"></span><br><span class="line">10．2．5　查看存储过程或者函数　144</span><br><span class="line"></span><br><span class="line">10．2．6　变量的使用　146</span><br><span class="line"></span><br><span class="line">10．2．7　定义条件和处理　146</span><br><span class="line"></span><br><span class="line">10．2．8　光标的使用　148</span><br><span class="line"></span><br><span class="line">10．2．9　流程控制　149</span><br><span class="line"></span><br><span class="line">10．2．10　事件调度器　152</span><br><span class="line"></span><br><span class="line">10．3　触发器　155</span><br><span class="line"></span><br><span class="line">10．3．1　创建触发器　155</span><br><span class="line"></span><br><span class="line">10．3．2　删除触发器　157</span><br><span class="line"></span><br><span class="line">10．3．3　查看触发器　157</span><br><span class="line"></span><br><span class="line">10．3．4　触发器的使用　158</span><br><span class="line"></span><br><span class="line">10．4　小结　159</span><br><span class="line"></span><br><span class="line">第　11章 事务控制和锁定语句　160</span><br><span class="line"></span><br><span class="line">11．1　LOCK TABLES和UNLOCK TABLES　160</span><br><span class="line"></span><br><span class="line">11．2　事务控制　161</span><br><span class="line"></span><br><span class="line">11．3　分布式事务的使用　166</span><br><span class="line"></span><br><span class="line">11．3．1　分布式事务的原理　166</span><br><span class="line"></span><br><span class="line">11．3．2　分布式事务的语法　166</span><br><span class="line"></span><br><span class="line">11．3．3　存在的问题　168</span><br><span class="line"></span><br><span class="line">11．4　小结　171</span><br><span class="line"></span><br><span class="line">第　12章 SQL中的安全问题　172</span><br><span class="line"></span><br><span class="line">12．1　SQL注入简介　172</span><br><span class="line"></span><br><span class="line">12．2　应用开发中可以采取的应对措施　173</span><br><span class="line"></span><br><span class="line">12．2．1　PrepareStatement+Bind-Variable　173</span><br><span class="line"></span><br><span class="line">12．2．2　使用应用程序提供的转换函数　174</span><br><span class="line"></span><br><span class="line">12．2．3　自己定义函数进行校验　174</span><br><span class="line"></span><br><span class="line">12．3　小结　175</span><br><span class="line"></span><br><span class="line">第　13章 SQL Mode及相关问题　176</span><br><span class="line"></span><br><span class="line">13．1　MySQL SQL Mode简介　176</span><br><span class="line"></span><br><span class="line">13．2　SQL Mode的常见功能　178</span><br><span class="line"></span><br><span class="line">13．3　常用的SQL Mode　180</span><br><span class="line"></span><br><span class="line">13．4　SQL Mode在迁移中如何使用　182</span><br><span class="line"></span><br><span class="line">13．5　小结　183</span><br><span class="line"></span><br><span class="line">第　14章 MySQL分区　184</span><br><span class="line"></span><br><span class="line">14．1　分区概述　184</span><br><span class="line"></span><br><span class="line">14．2　分区类型　185</span><br><span class="line"></span><br><span class="line">14．2．1　RANGE分区　187</span><br><span class="line"></span><br><span class="line">14．2．2　LIST 分区　188</span><br><span class="line"></span><br><span class="line">14．2．3　COLUMNS 分区　189</span><br><span class="line"></span><br><span class="line">14．2．4　HASH分区　192</span><br><span class="line"></span><br><span class="line">14．2．5　KEY分区　195</span><br><span class="line"></span><br><span class="line">14．2．6　子分区　196</span><br><span class="line"></span><br><span class="line">14．2．7　MySQL分区处理NULL值的方式　197</span><br><span class="line"></span><br><span class="line">14．3　分区管理　199</span><br><span class="line"></span><br><span class="line">14．3．1　RANGE与LIST分区管理　199</span><br><span class="line"></span><br><span class="line">14．3．2　HASH与KEY分区管理　205</span><br><span class="line"></span><br><span class="line">14．3．3　交换分区　206</span><br><span class="line"></span><br><span class="line">14．4　小结　208</span><br><span class="line"></span><br><span class="line">第三部分　优化篇</span><br><span class="line"></span><br><span class="line">第　15章 SQL优化　210</span><br><span class="line"></span><br><span class="line">15．1　优化SQL语句的一般步骤　210</span><br><span class="line"></span><br><span class="line">15．1．1　通过show status命令了解各种SQL的执行频率　210</span><br><span class="line"></span><br><span class="line">15．1．2　定位执行效率较低的SQL语句　211</span><br><span class="line"></span><br><span class="line">15．1．3　通过EXPLAIN分析低效SQL的执行计划　211</span><br><span class="line"></span><br><span class="line">15．1．4　通过show profile分析SQL　216</span><br><span class="line"></span><br><span class="line">15．1．5　通过trace分析优化器如何选择执行计划　219</span><br><span class="line"></span><br><span class="line">15．1．6　确定问题并采取相应的优化措施　220</span><br><span class="line"></span><br><span class="line">15．2　索引问题　220</span><br><span class="line"></span><br><span class="line">15．2．1　索引的存储分类　220</span><br><span class="line"></span><br><span class="line">15．2．2　MySQL如何使用索引　222</span><br><span class="line"></span><br><span class="line">15．2．3　查看索引使用情况　231</span><br><span class="line"></span><br><span class="line">15．3　两个简单实用的优化方法　231</span><br><span class="line"></span><br><span class="line">15．3．1　定期分析表和检查表　232</span><br><span class="line"></span><br><span class="line">15．3．2　定期优化表　233</span><br><span class="line"></span><br><span class="line">15．4　常用SQL的优化　233</span><br><span class="line"></span><br><span class="line">15．4．1　大批量插入数据　234</span><br><span class="line"></span><br><span class="line">15．4．2　优化INSERT语句　235</span><br><span class="line"></span><br><span class="line">15．4．3　优化ORDER BY语句　235</span><br><span class="line"></span><br><span class="line">15．4．4　优化GROUP BY语句　239</span><br><span class="line"></span><br><span class="line">15．4．5　优化JOIN操作　239</span><br><span class="line"></span><br><span class="line">15．4．6　优化嵌套查询　243</span><br><span class="line"></span><br><span class="line">15．4．7　MySQL如何优化OR条件　245</span><br><span class="line"></span><br><span class="line">15．4．8　优化分页查询　246</span><br><span class="line"></span><br><span class="line">15．4．9　使用SQL提示　248</span><br><span class="line"></span><br><span class="line">15．5　直方图　250</span><br><span class="line"></span><br><span class="line">15．5．1　什么是直方图　250</span><br><span class="line"></span><br><span class="line">15．5．2　直方图的分类　251</span><br><span class="line"></span><br><span class="line">15．5．3　直方图实例应用　252</span><br><span class="line"></span><br><span class="line">15．5．4　直方图小结　256</span><br><span class="line"></span><br><span class="line">15．6　使用查询重写　256</span><br><span class="line"></span><br><span class="line">15．7　常用SQL技巧　259</span><br><span class="line"></span><br><span class="line">15．7．1　正则表达式的使用　259</span><br><span class="line"></span><br><span class="line">15．7．2　巧用RAND()提取随机行　261</span><br><span class="line"></span><br><span class="line">15．7．3　利用GROUP BY的WITH ROLLUP子句　262</span><br><span class="line"></span><br><span class="line">15．7．4　用BIT GROUP FUNCTIONS做统计　263</span><br><span class="line"></span><br><span class="line">15．7．5　数据库名、表名大小写问题　265</span><br><span class="line"></span><br><span class="line">15．7．6　使用外键需要注意的问题　265</span><br><span class="line"></span><br><span class="line">15．8　小结　266</span><br><span class="line"></span><br><span class="line">第　16章 锁问题　267</span><br><span class="line"></span><br><span class="line">16．1　MySQL锁概述　267</span><br><span class="line"></span><br><span class="line">16．2　MyISAM表锁　268</span><br><span class="line"></span><br><span class="line">16．2．1　查询表级锁争用情况　268</span><br><span class="line"></span><br><span class="line">16．2．2　MySQL表级锁的锁模式　268</span><br><span class="line"></span><br><span class="line">16．2．3　如何加表锁　269</span><br><span class="line"></span><br><span class="line">16．2．4　并发插入（Concurrent Inserts）　271</span><br><span class="line"></span><br><span class="line">16．2．5　MyISAM的锁调度　272</span><br><span class="line"></span><br><span class="line">16．3　InnoDB锁问题　273</span><br><span class="line"></span><br><span class="line">16．3．1　背景知识　273</span><br><span class="line"></span><br><span class="line">16．3．2　获取InnoDB行锁争用情况　275</span><br><span class="line"></span><br><span class="line">16．3．3　InnoDB的行锁模式及加锁方法　276</span><br><span class="line"></span><br><span class="line">16．3．4　InnoDB行锁实现方式　279</span><br><span class="line"></span><br><span class="line">16．3．5　Next-Key锁　283</span><br><span class="line"></span><br><span class="line">16．3．6　恢复和复制的需要，对InnoDB锁机制的影响　284</span><br><span class="line"></span><br><span class="line">16．3．7　InnoDB在不同隔离级别下的一致性读及锁的差异　287</span><br><span class="line"></span><br><span class="line">16．3．8　什么时候使用表锁　288</span><br><span class="line"></span><br><span class="line">16．3．9　关于死锁　289</span><br><span class="line"></span><br><span class="line">16．4　小结　294</span><br><span class="line"></span><br><span class="line">第　17章 优化MySQL Server　296</span><br><span class="line"></span><br><span class="line">17．1　MySQL体系结构概览　296</span><br><span class="line"></span><br><span class="line">17．2　MySQL内存管理及优化　298</span><br><span class="line"></span><br><span class="line">17．2．1　内存优化原则　298</span><br><span class="line"></span><br><span class="line">17．2．2　MyISAM内存优化　298</span><br><span class="line"></span><br><span class="line">17．2．3　InnoDB内存优化　301</span><br><span class="line"></span><br><span class="line">17．2．4　调整用户服务线程排序缓存区　305</span><br><span class="line"></span><br><span class="line">17．3　InnoDB log机制及优化　305</span><br><span class="line"></span><br><span class="line">17．3．1　InnoDB重做日志　305</span><br><span class="line"></span><br><span class="line">17．3．2　innodb_flush_log_at_trx_commit的设置　306</span><br><span class="line"></span><br><span class="line">17．3．3　设置log file size，控制检查点　307</span><br><span class="line"></span><br><span class="line">17．3．4　调整innodb_log_buffer_size　308</span><br><span class="line"></span><br><span class="line">17．4　调整MySQL并发相关的参数　308</span><br><span class="line"></span><br><span class="line">17．4．1　调整max_connections，提高并发连接　308</span><br><span class="line"></span><br><span class="line">17．4．2　调整back_log　309</span><br><span class="line"></span><br><span class="line">17．4．3　调整table_open_cache　309</span><br><span class="line"></span><br><span class="line">17．4．4　调整thread_cache_size　309</span><br><span class="line"></span><br><span class="line">17．4．5　innodb_lock_wait_timeout的设置　309</span><br><span class="line"></span><br><span class="line">17．5　持久化全局变量　309</span><br><span class="line"></span><br><span class="line">17．6　使用资源组　310</span><br><span class="line"></span><br><span class="line">17．7　小结　312</span><br><span class="line"></span><br><span class="line">第　18章 磁盘I&#x2F;O问题　313</span><br><span class="line"></span><br><span class="line">18．1　使用固态硬盘　313</span><br><span class="line"></span><br><span class="line">18．2　使用磁盘阵列　314</span><br><span class="line"></span><br><span class="line">18．2．1　常见RAID级别及其特性　314</span><br><span class="line"></span><br><span class="line">18．2．2　如何选择RAID级别　315</span><br><span class="line"></span><br><span class="line">18．3　虚拟文件卷或软RAID　315</span><br><span class="line"></span><br><span class="line">18．4　使用Symbolic Links分布I&#x2F;O　315</span><br><span class="line"></span><br><span class="line">18．5　禁止操作系统更新文件的atime属性　316</span><br><span class="line"></span><br><span class="line">18．6　调整I&#x2F;O调度算法　316</span><br><span class="line"></span><br><span class="line">18．7　RAID卡电池充放电问题　318</span><br><span class="line"></span><br><span class="line">18．7．1　什么是RAID卡电池充放电　318</span><br><span class="line"></span><br><span class="line">18．7．2　RAID卡缓存策略　319</span><br><span class="line"></span><br><span class="line">18．7．3　如何应对RAID卡电池充放电带来的I&#x2F;O性能波动　321</span><br><span class="line"></span><br><span class="line">18．8　NUMA架构优化　322</span><br><span class="line"></span><br><span class="line">18．9　小结　325</span><br><span class="line"></span><br><span class="line">第　19章 应用优化　326</span><br><span class="line"></span><br><span class="line">19．1　优化数据表的设计　326</span><br><span class="line"></span><br><span class="line">19．1．1　优化表的数据类型　326</span><br><span class="line"></span><br><span class="line">19．1．2　通过拆分提高表的访问效率　328</span><br><span class="line"></span><br><span class="line">19．1．3　逆规范化　329</span><br><span class="line"></span><br><span class="line">19．2　数据库应用优化　330</span><br><span class="line"></span><br><span class="line">19．2．1　使用连接池　330</span><br><span class="line"></span><br><span class="line">19．2．2　减少对MySQL的访问　330</span><br><span class="line"></span><br><span class="line">19．2．3　负载均衡　331</span><br><span class="line"></span><br><span class="line">19．3　小结　331</span><br><span class="line"></span><br><span class="line">第　20章 PS&#x2F;SYS数据库　332</span><br><span class="line"></span><br><span class="line">20．1　Performance Schema库　332</span><br><span class="line"></span><br><span class="line">20．1．1　如何开启PS库　332</span><br><span class="line"></span><br><span class="line">20．1．2　PS库的表　333</span><br><span class="line"></span><br><span class="line">20．2　SYS 库　335</span><br><span class="line"></span><br><span class="line">20．2．1　SYS库的对象　335</span><br><span class="line"></span><br><span class="line">20．2．2　SYS对象的实际应用　336</span><br><span class="line"></span><br><span class="line">20．3　小结　340</span><br><span class="line"></span><br><span class="line">第　21章 故障诊断　341</span><br><span class="line"></span><br><span class="line">21．1　故障诊断和处理的原则　341</span><br><span class="line"></span><br><span class="line">21．2　故障处理一般流程　343</span><br><span class="line"></span><br><span class="line">21．2．1　故障发现　343</span><br><span class="line"></span><br><span class="line">21．2．2　故障定位　345</span><br><span class="line"></span><br><span class="line">21．2．3　故障解决　346</span><br><span class="line"></span><br><span class="line">21．3　典型故障案例　349</span><br><span class="line"></span><br><span class="line">21．3．1　案例1　349</span><br><span class="line"></span><br><span class="line">21．3．2　案例2　353</span><br><span class="line"></span><br><span class="line">21．4　小结　356</span><br><span class="line"></span><br><span class="line">第四部分　管理维护篇</span><br><span class="line"></span><br><span class="line">第　22章 MySQL高级安装和升级　358</span><br><span class="line"></span><br><span class="line">22．1　Linux&#x2F;UNIX平台下的安装　358</span><br><span class="line"></span><br><span class="line">22．1．1　安装包比较　358</span><br><span class="line"></span><br><span class="line">22．1．2　安装二进制包　359</span><br><span class="line"></span><br><span class="line">22．1．3　安装源码包　359</span><br><span class="line"></span><br><span class="line">22．1．4　参数设置方法　360</span><br><span class="line"></span><br><span class="line">22．2　升级MySQL　361</span><br><span class="line"></span><br><span class="line">22．3　小结　363</span><br><span class="line"></span><br><span class="line">第　23章 MySQL中的常用工具　364</span><br><span class="line"></span><br><span class="line">23．1　MySQL官方工具　364</span><br><span class="line"></span><br><span class="line">23．1．1　mysql（客户端连接工具）　364</span><br><span class="line"></span><br><span class="line">23．1．2　mysqladmin（MySQL管理工具）　371</span><br><span class="line"></span><br><span class="line">23．1．3　mysqlbinlog（日志管理工具）　371</span><br><span class="line"></span><br><span class="line">23．1．4　mysqlcheck（表维护工具）　378</span><br><span class="line"></span><br><span class="line">23．1．5　mysqldump（数据导出工具）　380</span><br><span class="line"></span><br><span class="line">23．1．6　mysqlpump（并行的数据导出工具）　384</span><br><span class="line"></span><br><span class="line">23．1．7　mysqlimport（数据导入工具）　385</span><br><span class="line"></span><br><span class="line">23．1．8　mysqlshow（数据库对象查看工具）　385</span><br><span class="line"></span><br><span class="line">23．1．9　perror（错误代码查看工具）　387</span><br><span class="line"></span><br><span class="line">23．1．10　MySQL Shell　387</span><br><span class="line"></span><br><span class="line">23．2　Percona工具包　390</span><br><span class="line"></span><br><span class="line">23．2．1　pt-archiver（数据归档工具）　391</span><br><span class="line"></span><br><span class="line">23．2．2　pt-config-diff（参数对比工具）　393</span><br><span class="line"></span><br><span class="line">23．2．3　pt-duplicate-key-checker（检查冗余索引工具）　394</span><br><span class="line"></span><br><span class="line">23．2．4　pt-find（查找工具）　395</span><br><span class="line"></span><br><span class="line">23．2．5　pt-heartbeat（监控主从延迟工具）　395</span><br><span class="line"></span><br><span class="line">23．2．6　pt-kill（杀死会话工具）　397</span><br><span class="line"></span><br><span class="line">23．2．7　pt-online-schema-change（在线修改表结构工具）　397</span><br><span class="line"></span><br><span class="line">23．2．8　pt-query-digest（SQL分析工具）　399</span><br><span class="line"></span><br><span class="line">23．2．9　pt-table-checksum（数据检验工具）　401</span><br><span class="line"></span><br><span class="line">23．2．10　pt-table-sync（数据同步工具）　402</span><br><span class="line"></span><br><span class="line">23．3　小结　403</span><br><span class="line"></span><br><span class="line">第　24章 MySQL日志　404</span><br><span class="line"></span><br><span class="line">24．1　错误日志　404</span><br><span class="line"></span><br><span class="line">24．2　二进制日志　405</span><br><span class="line"></span><br><span class="line">24．2．1　日志的位置和格式　405</span><br><span class="line"></span><br><span class="line">24．2．2　日志的读取　406</span><br><span class="line"></span><br><span class="line">24．2．3　日志的删除　407</span><br><span class="line"></span><br><span class="line">24．2．4　日志的事件　411</span><br><span class="line"></span><br><span class="line">24．2．5　日志闪回　412</span><br><span class="line"></span><br><span class="line">24．3　查询日志　415</span><br><span class="line"></span><br><span class="line">24．3．1　日志的位置和格式　415</span><br><span class="line"></span><br><span class="line">24．3．2　日志的读取　416</span><br><span class="line"></span><br><span class="line">24．4　慢查询日志　416</span><br><span class="line"></span><br><span class="line">24．4．1　文件位置和格式　416</span><br><span class="line"></span><br><span class="line">24．4．2　日志的读取　417</span><br><span class="line"></span><br><span class="line">24．4．3　Anemometer简介　419</span><br><span class="line"></span><br><span class="line">24．5　小结　421</span><br><span class="line"></span><br><span class="line">第　25章 备份与恢复　422</span><br><span class="line"></span><br><span class="line">25．1　备份&#x2F;恢复策略　422</span><br><span class="line"></span><br><span class="line">25．2　逻辑备份和恢复　422</span><br><span class="line"></span><br><span class="line">25．2．1　备份　423</span><br><span class="line"></span><br><span class="line">25．2．2　完全恢复　425</span><br><span class="line"></span><br><span class="line">25．2．3　基于时间点恢复　427</span><br><span class="line"></span><br><span class="line">25．2．4　基于位置恢复　427</span><br><span class="line"></span><br><span class="line">25．2．5　并行恢复　427</span><br><span class="line"></span><br><span class="line">25．3　物理备份和恢复　428</span><br><span class="line"></span><br><span class="line">25．3．1　冷备份和热备份　428</span><br><span class="line"></span><br><span class="line">25．3．2　MyISAM存储引擎的热备份　429</span><br><span class="line"></span><br><span class="line">25．3．3　InnoDB存储引擎的热备份　429</span><br><span class="line"></span><br><span class="line">25．4　表的导入和导出　438</span><br><span class="line"></span><br><span class="line">25．4．1　导出　438</span><br><span class="line"></span><br><span class="line">25．4．2　导入　442</span><br><span class="line"></span><br><span class="line">25．5　小结　445</span><br><span class="line"></span><br><span class="line">第　26章 MySQL权限与安全　446</span><br><span class="line"></span><br><span class="line">26．1　MySQL权限管理　446</span><br><span class="line"></span><br><span class="line">26．1．1　权限系统的工作原理　446</span><br><span class="line"></span><br><span class="line">26．1．2　权限表的存取　446</span><br><span class="line"></span><br><span class="line">26．1．3　账号管理　449</span><br><span class="line"></span><br><span class="line">26．2　MySQL安全问题　461</span><br><span class="line"></span><br><span class="line">26．2．1　操作系统相关的安全问题　461</span><br><span class="line"></span><br><span class="line">26．2．2　数据库相关的安全问题　463</span><br><span class="line"></span><br><span class="line">26．3　其他安全设置选项　471</span><br><span class="line"></span><br><span class="line">26．3．1　密码插件　471</span><br><span class="line"></span><br><span class="line">26．3．2　safe-user-create　472</span><br><span class="line"></span><br><span class="line">26．3．3　表空间加密　473</span><br><span class="line"></span><br><span class="line">26．3．4　skip-grant-tables　474</span><br><span class="line"></span><br><span class="line">26．3．5　skip-networking　474</span><br><span class="line"></span><br><span class="line">26．3．6　skip-show-database　475</span><br><span class="line"></span><br><span class="line">26．4　小结　475</span><br><span class="line"></span><br><span class="line">第　27章 MySQL监控　476</span><br><span class="line"></span><br><span class="line">27．1　如何选择一个监控方案　476</span><br><span class="line"></span><br><span class="line">27．1．1　选择何种监控方式　476</span><br><span class="line"></span><br><span class="line">27．1．2　如何选择适合自己的监控工具　477</span><br><span class="line"></span><br><span class="line">27．2　常用的网络监控工具　477</span><br><span class="line"></span><br><span class="line">27．2．1　Open-Falcon简介　477</span><br><span class="line"></span><br><span class="line">27．2．2　Nagios简介　479</span><br><span class="line"></span><br><span class="line">27．2．3　Zabbix简介　480</span><br><span class="line"></span><br><span class="line">27．2．4　几种常见开源软件比较　481</span><br><span class="line"></span><br><span class="line">27．3　Zabbix 部署　481</span><br><span class="line"></span><br><span class="line">27．3．1　Zabbix Server软件安装　482</span><br><span class="line"></span><br><span class="line">27．3．2　Zabbix Server配置与启动　482</span><br><span class="line"></span><br><span class="line">27．3．3　配置Zabbix Web服务端　483</span><br><span class="line"></span><br><span class="line">27．3．4　Zabbix Agent安装和配置　485</span><br><span class="line"></span><br><span class="line">27．3．5　PMP插件介绍和部署　486</span><br><span class="line"></span><br><span class="line">27．3．6　Zabbix Web端操作　489</span><br><span class="line"></span><br><span class="line">27．4　性能医生orzdba　491</span><br><span class="line"></span><br><span class="line">27．4．1　orzdba安装　491</span><br><span class="line"></span><br><span class="line">27．4．2　orzdba使用　492</span><br><span class="line"></span><br><span class="line">27．5　小结　492</span><br><span class="line"></span><br><span class="line">第　28章 MySQL常见问题和应用技巧　493</span><br><span class="line"></span><br><span class="line">28．1　忘记MySQL的root密码　493</span><br><span class="line"></span><br><span class="line">28．2　数据目录磁盘空间不足的问题　494</span><br><span class="line"></span><br><span class="line">28．3　mysql．sock丢失后如何连接数据库　495</span><br><span class="line"></span><br><span class="line">28．4　从mysqldump文件抽取需要恢复的表　496</span><br><span class="line"></span><br><span class="line">28．5　使用innobackupex备份恢复单表　497</span><br><span class="line"></span><br><span class="line">28．6　分析BINLOG，找出写的热点表　498</span><br><span class="line"></span><br><span class="line">28．7　在线DDL　499</span><br><span class="line"></span><br><span class="line">28．8　小结　502</span><br><span class="line"></span><br><span class="line">第　29章 自动化运维系统的开发　503</span><br><span class="line"></span><br><span class="line">29．1　MySQL自动化运维背景　503</span><br><span class="line"></span><br><span class="line">29．2　CMDB系统搭建　504</span><br><span class="line"></span><br><span class="line">29．2．1　CMDB数据库　504</span><br><span class="line"></span><br><span class="line">29．2．2　批量管理系统　505</span><br><span class="line"></span><br><span class="line">29．2．3　后台API　511</span><br><span class="line"></span><br><span class="line">29．3　任务调度系统　515</span><br><span class="line"></span><br><span class="line">29．3．1　Celery安装　515</span><br><span class="line"></span><br><span class="line">29．3．2　Celery任务部署　516</span><br><span class="line"></span><br><span class="line">29．3．3　Flower监控　518</span><br><span class="line"></span><br><span class="line">29．4　客户端搭建　519</span><br><span class="line"></span><br><span class="line">29．4．1　Vue．js简介　519</span><br><span class="line"></span><br><span class="line">29．4．2　Vue项目搭建　520</span><br><span class="line"></span><br><span class="line">29．5　自动化运维平台实战　525</span><br><span class="line"></span><br><span class="line">29．5．1　搭建CMDB　525</span><br><span class="line"></span><br><span class="line">29．5．2　搭建任务调度平台　528</span><br><span class="line"></span><br><span class="line">29．5．3　搭建客户端　529</span><br><span class="line"></span><br><span class="line">29．5．4　项目演示　532</span><br><span class="line"></span><br><span class="line">29．6　小结　532</span><br><span class="line"></span><br><span class="line">第五部分　架构篇</span><br><span class="line"></span><br><span class="line">第30章　MySQL复制　534</span><br><span class="line"></span><br><span class="line">30．1　复制概述　534</span><br><span class="line"></span><br><span class="line">30．1．1　复制中的各类文件　536</span><br><span class="line"></span><br><span class="line">30．1．2　3种复制方式　537</span><br><span class="line"></span><br><span class="line">30．1．3　复制的4种常见架构　540</span><br><span class="line"></span><br><span class="line">30．2　复制搭建　543</span><br><span class="line"></span><br><span class="line">30．2．1　异步复制　543</span><br><span class="line"></span><br><span class="line">30．2．2　多线程复制　547</span><br><span class="line"></span><br><span class="line">30．2．3　增强半同步复制　553</span><br><span class="line"></span><br><span class="line">30．3　GTID（Global Transaction Identifier）　558</span><br><span class="line"></span><br><span class="line">30．3．1　格式与存储　558</span><br><span class="line"></span><br><span class="line">30．3．2　gtid_purged　561</span><br><span class="line"></span><br><span class="line">30．3．3　复制搭建　565</span><br><span class="line"></span><br><span class="line">30．3．4　主从切换　571</span><br><span class="line"></span><br><span class="line">30．3．5　常见问题　572</span><br><span class="line"></span><br><span class="line">30．4　主要复制启动选项　576</span><br><span class="line"></span><br><span class="line">30．4．1　log-slave-updates　576</span><br><span class="line"></span><br><span class="line">30．4．2　read-only&#x2F;super_read_only　576</span><br><span class="line"></span><br><span class="line">30．4．3　指定复制的数据库或者表　577</span><br><span class="line"></span><br><span class="line">30．4．4　slave-skip-errors　579</span><br><span class="line"></span><br><span class="line">30．5　日常管理维护　579</span><br><span class="line"></span><br><span class="line">30．5．1　查看从库复制状态和进度　579</span><br><span class="line"></span><br><span class="line">30．5．2　主从复制问题集锦　580</span><br><span class="line"></span><br><span class="line">30．5．3　多主复制时的自增长变量冲突问题　582</span><br><span class="line"></span><br><span class="line">30．5．4　如何提高复制的性能　584</span><br><span class="line"></span><br><span class="line">30．6　小结　588</span><br><span class="line"></span><br><span class="line">第31章　高可用架构　589</span><br><span class="line"></span><br><span class="line">31．1　MHA架构　589</span><br><span class="line"></span><br><span class="line">31．1．1　安装部署MHA　591</span><br><span class="line"></span><br><span class="line">31．1．2　应用连接配置　598</span><br><span class="line"></span><br><span class="line">31．1．3　自动failover　605</span><br><span class="line"></span><br><span class="line">31．1．4　网络问题触发的failover操作　614</span><br><span class="line"></span><br><span class="line">31．1．5　手动failover　614</span><br><span class="line"></span><br><span class="line">31．1．6　在线进行切换　615</span><br><span class="line"></span><br><span class="line">31．1．7　修复宕掉的Master　617</span><br><span class="line"></span><br><span class="line">31．2　MGR架构　617</span><br><span class="line"></span><br><span class="line">31．2．1　安装部署MGR　618</span><br><span class="line"></span><br><span class="line">31．2．2　监控　625</span><br><span class="line"></span><br><span class="line">31．2．3　primary成员切换　626</span><br><span class="line"></span><br><span class="line">31．2．4　重要特性　628</span><br><span class="line"></span><br><span class="line">31．2．5　常见问题　629</span><br><span class="line"></span><br><span class="line">31．3　InnoDB Cluster　636</span><br><span class="line"></span><br><span class="line">31．3．1　安装部署　637</span><br><span class="line"></span><br><span class="line">31．3．2　初始化MySQL Router　642</span><br><span class="line"></span><br><span class="line">31．3．3　集群Metadata　643</span><br><span class="line"></span><br><span class="line">31．3．4　集群成员角色切换　644</span><br><span class="line"></span><br><span class="line">31．3．5　集群删除&#x2F;增加节点　646</span><br><span class="line"></span><br><span class="line">31．3．6　重新加入节点　648</span><br><span class="line"></span><br><span class="line">31．4　小结　649</span><br><span class="line"></span><br><span class="line">第32章　MySQL中间件　650</span><br><span class="line"></span><br><span class="line">32．1　MySQL Router　650</span><br><span class="line"></span><br><span class="line">32．1．1　MySQL Router的安装　651</span><br><span class="line"></span><br><span class="line">32．1．2　MySQL Router的初始化　653</span><br><span class="line"></span><br><span class="line">32．1．3　MySQL Router策略验证　656</span><br><span class="line"></span><br><span class="line">32．2　Cetus架构　658</span><br><span class="line"></span><br><span class="line">32．2．1　Cetus的安装配置　659</span><br><span class="line"></span><br><span class="line">32．2．2　Cetus的使用　670</span><br><span class="line"></span><br><span class="line">32．2．3　Cetus日志文件　674</span><br><span class="line"></span><br><span class="line">32．2．4　Cetus的后端管理　675</span><br><span class="line"></span><br><span class="line">32．2．5　Cetus的路由策略　678</span><br><span class="line"></span><br><span class="line">32．2．6　常见问题　681</span><br><span class="line"></span><br><span class="line">32．3　小结　682</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入探索C++对象模型 PDF</title>
    <url>/posts/b855d2c1/</url>
    <content><![CDATA[<h4 id="《深入探索C-对象模型》"><a href="#《深入探索C-对象模型》" class="headerlink" title="《深入探索C++对象模型》"></a>《深入探索C++对象模型》</h4><h6 id="链接-https-pan-baidu-com-s-1wgdmx-bfiJGCYnmuEimYdw-提取码-s4ht"><a href="#链接-https-pan-baidu-com-s-1wgdmx-bfiJGCYnmuEimYdw-提取码-s4ht" class="headerlink" title="链接: https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw 提取码: s4ht"></a>链接: <a href="https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw">https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw</a> 提取码: s4ht</h6><p>　本书重点介绍了C++面向对象程序设计的底层机制，包括结构式语意、暂时性对象的生成、封装、继承和虚拟——虚拟函数和虚拟继承。书中向你表明：理解底层实现模型，可以极大地提高你的编码效率。Lippman澄清了那些关于C++系统开销与复杂性的各种错误信息和猜测，指出了其中某些成本和利益交换确实存在。他在书中详述了各种实现模型，指出了它们的发展方向以及促使其发展的根本原因。本书涵盖了C++对象模型的语意暗示，并指出了这个模型是如何对程序造成影响的。<br><a id="more"></a><br><!-- more --></p>
<p>　　</p>
<p><img src="/images/81525f59696ba87581b9a945efdeb1021.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">1 Object Lessons</span><br><span class="line"></span><br><span class="line">2 The Semantics of Constructors</span><br><span class="line"></span><br><span class="line">3 The Semantics of Data</span><br><span class="line"></span><br><span class="line">4 The Semantics of Function</span><br><span class="line"></span><br><span class="line">5 Semantics of Construction,Destruction,and Copy</span><br><span class="line"></span><br><span class="line">6 Runtime Semantics</span><br><span class="line"></span><br><span class="line">7 On the Cusp of the Object Model</span><br><span class="line"></span><br><span class="line">Index</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python数据处理 PDF</title>
    <url>/posts/cf52e257/</url>
    <content><![CDATA[<h4 id="《Python数据处理》"><a href="#《Python数据处理》" class="headerlink" title="《Python数据处理》"></a>《Python数据处理》</h4><h6 id="链接-https-pan-baidu-com-s-1mgZhwNG-Qzz9C3YfJjl7-g-提取码-m42q"><a href="#链接-https-pan-baidu-com-s-1mgZhwNG-Qzz9C3YfJjl7-g-提取码-m42q" class="headerlink" title="链接: https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g 提取码: m42q"></a>链接: <a href="https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g">https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g</a> 提取码: m42q</h6><p>本书采用基于项目的方法，介绍用Python完成数据获取、数据清洗、数据探索、数据呈现、数据规模化和自动化的过程。主要内容包括：Python基础知识，如何从CSV、Excel、XML、JSON和PDF文件中提取数据，如何获取与存储数据，各种数据清洗与分析技术，数据可视化方法，如何从网站和API中提取数据。<br><a id="more"></a></p>
<p><img src="/images/1d6bed61c2ccd7d6786e738938e9f3b71.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言 xiii</span><br><span class="line"></span><br><span class="line">第1　章 Python 简介　1</span><br><span class="line"></span><br><span class="line">1．1　为什么选择Python　4</span><br><span class="line"></span><br><span class="line">1．2　开始使用Python　4</span><br><span class="line"></span><br><span class="line">1．2．1　Python 版本选择　5</span><br><span class="line"></span><br><span class="line">1．2．2　安装Python　6</span><br><span class="line"></span><br><span class="line">1．2．3　测试Python　9</span><br><span class="line"></span><br><span class="line">1．2．4　安装pip　11</span><br><span class="line"></span><br><span class="line">1．2．5　安装代码编辑器　12</span><br><span class="line"></span><br><span class="line">1．2．6　安装IPython（可选）　13</span><br><span class="line"></span><br><span class="line">1．3　小结　13</span><br><span class="line"></span><br><span class="line">第2　章 Python 基础　14</span><br><span class="line"></span><br><span class="line">2．1　基本数据类型　15</span><br><span class="line"></span><br><span class="line">2．1．1　字符串　15</span><br><span class="line"></span><br><span class="line">2．1．2　整数和浮点数　15</span><br><span class="line"></span><br><span class="line">2．2　数据容器　18</span><br><span class="line"></span><br><span class="line">2．2．1　变量　18</span><br><span class="line"></span><br><span class="line">2．2．2　列表　21</span><br><span class="line"></span><br><span class="line">2．2．3　字典　22</span><br><span class="line"></span><br><span class="line">2．3　各种数据类型的用途　23</span><br><span class="line"></span><br><span class="line">2．3．1　字符串方法：字符串能做什么　24</span><br><span class="line"></span><br><span class="line">2．3．2　数值方法：数字能做什么　25</span><br><span class="line"></span><br><span class="line">2．3．3　列表方法：列表能做什么　26</span><br><span class="line"></span><br><span class="line">2．3．4　字典方法：字典能做什么　27</span><br><span class="line"></span><br><span class="line">2．4　有用的工具：type、dir 和help　28</span><br><span class="line"></span><br><span class="line">2．4．1　type　28</span><br><span class="line"></span><br><span class="line">2．4．2　dir　28</span><br><span class="line"></span><br><span class="line">2．4．3　help　30</span><br><span class="line"></span><br><span class="line">2．5　综合运用　31</span><br><span class="line"></span><br><span class="line">2．6　代码的含义　32</span><br><span class="line"></span><br><span class="line">2．7　小结　33</span><br><span class="line"></span><br><span class="line">第3　章 供机器读取的数据　34</span><br><span class="line"></span><br><span class="line">3．1　CSV 数据　35</span><br><span class="line"></span><br><span class="line">3．1．1　如何导入CSV 数据　36</span><br><span class="line"></span><br><span class="line">3．1．2　将代码保存到文件中并在命令行中运行　39</span><br><span class="line"></span><br><span class="line">3．2　JSON 数据　41</span><br><span class="line"></span><br><span class="line">3．3　XML 数据　44</span><br><span class="line"></span><br><span class="line">3．4　小结　56</span><br><span class="line"></span><br><span class="line">第4　章 处理Excel 文件　58</span><br><span class="line"></span><br><span class="line">4．1　安装Python 包　58</span><br><span class="line"></span><br><span class="line">4．2　解析Excel 文件　59</span><br><span class="line"></span><br><span class="line">4．3　开始解析　60</span><br><span class="line"></span><br><span class="line">4．4　小结　71</span><br><span class="line"></span><br><span class="line">第5　章 处理PDF 文件，以及用Python 解决问题　73</span><br><span class="line"></span><br><span class="line">5．1　尽量不要用PDF　73</span><br><span class="line"></span><br><span class="line">5．2　解析PDF 的编程方法　74</span><br><span class="line"></span><br><span class="line">5．2．1　利用slate 库打开并读取PDF　75</span><br><span class="line"></span><br><span class="line">5．2．2　将PDF 转换成文本　77</span><br><span class="line"></span><br><span class="line">5．3　利用pdfminer 解析PDF　78</span><br><span class="line"></span><br><span class="line">5．4　学习解决问题的方法　92</span><br><span class="line"></span><br><span class="line">5．4．1　练习：使用表格提取，换用另一个库　94</span><br><span class="line"></span><br><span class="line">5．4．2　练习：手动清洗数据　98</span><br><span class="line"></span><br><span class="line">5．4．3　练习：试用另一种工具　98</span><br><span class="line"></span><br><span class="line">5．5　不常见的文件类型　101</span><br><span class="line"></span><br><span class="line">5．6　小结　101</span><br><span class="line"></span><br><span class="line">第6　章 数据获取与存储　103</span><br><span class="line"></span><br><span class="line">6．1　并非所有数据生而平等　103</span><br><span class="line"></span><br><span class="line">6．2　真实性核查　104</span><br><span class="line"></span><br><span class="line">6．3　数据可读性、数据清洁度和数据寿命　105</span><br><span class="line"></span><br><span class="line">6．4　寻找数据　105</span><br><span class="line"></span><br><span class="line">6．4．1　打电话　105</span><br><span class="line"></span><br><span class="line">6．4．2　美国政府数据　106</span><br><span class="line"></span><br><span class="line">6．4．3　全球政府和城市开放数据　107</span><br><span class="line"></span><br><span class="line">6．4．4　组织数据和非政府组织数据　109</span><br><span class="line"></span><br><span class="line">6．4．5　教育数据和大学数据　109</span><br><span class="line"></span><br><span class="line">6．4．6　医学数据和科学数据　109</span><br><span class="line"></span><br><span class="line">6．4．7　众包数据和API　110</span><br><span class="line"></span><br><span class="line">6．5　案例研究：数据调查实例　111</span><br><span class="line"></span><br><span class="line">6．5．1　埃博拉病毒危机　111</span><br><span class="line"></span><br><span class="line">6．5．2　列车安全　111</span><br><span class="line"></span><br><span class="line">6．5．3　足球运动员的薪水　112</span><br><span class="line"></span><br><span class="line">6．5．4　童工　112</span><br><span class="line"></span><br><span class="line">6．6　数据存储　113</span><br><span class="line"></span><br><span class="line">6．7　数据库简介　113</span><br><span class="line"></span><br><span class="line">6．7．1　关系型数据库：MySQL 和PostgreSQL　114</span><br><span class="line"></span><br><span class="line">6．7．2　非关系型数据库：NoSQL　116</span><br><span class="line"></span><br><span class="line">6．7．3　用Python 创建本地数据库　117</span><br><span class="line"></span><br><span class="line">6．8　使用简单文件　118</span><br><span class="line"></span><br><span class="line">6．8．1　云存储和Python　118</span><br><span class="line"></span><br><span class="line">6．8．2　本地存储和Python　119</span><br><span class="line"></span><br><span class="line">6．9　其他数据存储方式　119</span><br><span class="line"></span><br><span class="line">6．10　小结　119</span><br><span class="line"></span><br><span class="line">第7　章 数据清洗：研究、匹配与格式化　121</span><br><span class="line"></span><br><span class="line">7．1　为什么要清洗数据　121</span><br><span class="line"></span><br><span class="line">7．2　数据清洗基础知识　122</span><br><span class="line"></span><br><span class="line">7．2．1　找出需要清洗的数据　123</span><br><span class="line"></span><br><span class="line">7．2．2　数据格式化　131</span><br><span class="line"></span><br><span class="line">7．2．3　找出离群值和不良数据　135</span><br><span class="line"></span><br><span class="line">7．2．4　找出重复值　140</span><br><span class="line"></span><br><span class="line">7．2．5　模糊匹配　143</span><br><span class="line"></span><br><span class="line">7．2．6　正则表达式匹配　146</span><br><span class="line"></span><br><span class="line">7．2．7　如何处理重复记录　150</span><br><span class="line"></span><br><span class="line">7．3　小结　151</span><br><span class="line"></span><br><span class="line">第8　章 数据清洗：标准化和脚本化　153</span><br><span class="line"></span><br><span class="line">8．1　数据归一化和标准化　153</span><br><span class="line"></span><br><span class="line">8．2　数据存储　154</span><br><span class="line"></span><br><span class="line">8．3　找到适合项目的数据清洗方法　156</span><br><span class="line"></span><br><span class="line">8．4　数据清洗脚本化　157</span><br><span class="line"></span><br><span class="line">8．5　用新数据测试　170</span><br><span class="line"></span><br><span class="line">8．6　小结　172</span><br><span class="line"></span><br><span class="line">第9　章 数据探索和分析　173</span><br><span class="line"></span><br><span class="line">9．1　探索数据　173</span><br><span class="line"></span><br><span class="line">9．1．1　导入数据　174</span><br><span class="line"></span><br><span class="line">9．1．2　探索表函数　179</span><br><span class="line"></span><br><span class="line">9．1．3　联结多个数据集　182</span><br><span class="line"></span><br><span class="line">9．1．4　识别相关性　186</span><br><span class="line"></span><br><span class="line">9．1．5　找出离群值　187</span><br><span class="line"></span><br><span class="line">9．1．6　创建分组　189</span><br><span class="line"></span><br><span class="line">9．1．7　深入探索　192</span><br><span class="line"></span><br><span class="line">9．2　分析数据　193</span><br><span class="line"></span><br><span class="line">9．2．1　分离和聚焦数据　194</span><br><span class="line"></span><br><span class="line">9．2．2　你的数据在讲什么　196</span><br><span class="line"></span><br><span class="line">9．2．3　描述结论　196</span><br><span class="line"></span><br><span class="line">9．2．4　将结论写成文档　197</span><br><span class="line"></span><br><span class="line">9．3　小结　197</span><br><span class="line"></span><br><span class="line">第10　章 展示数据　199</span><br><span class="line"></span><br><span class="line">10．1　避免讲故事陷阱　199</span><br><span class="line"></span><br><span class="line">10．1．1　怎样讲故事　200</span><br><span class="line"></span><br><span class="line">10．1．2　了解听众　200</span><br><span class="line"></span><br><span class="line">10．2　可视化数据　201</span><br><span class="line"></span><br><span class="line">10．2．1　图表　201</span><br><span class="line"></span><br><span class="line">10．2．2　时间相关数据　207</span><br><span class="line"></span><br><span class="line">10．2．3　地图　208</span><br><span class="line"></span><br><span class="line">10．2．4　交互式元素　211</span><br><span class="line"></span><br><span class="line">10．2．5　文字　212</span><br><span class="line"></span><br><span class="line">10．2．6　图片、视频和插画　212</span><br><span class="line"></span><br><span class="line">10．3　展示工具　213</span><br><span class="line"></span><br><span class="line">10．4　发布数据　213</span><br><span class="line"></span><br><span class="line">10．4．1　使用可用站点　213</span><br><span class="line"></span><br><span class="line">10．4．2　开源平台：创建一个新网站　215</span><br><span class="line"></span><br><span class="line">10．4．3　Jupyter（曾名IPython notebook）　216</span><br><span class="line"></span><br><span class="line">10．5　小结　219</span><br><span class="line"></span><br><span class="line">第11　章 网页抓取：获取并存储网络数据　221</span><br><span class="line"></span><br><span class="line">11．1　抓取什么和如何抓取　221</span><br><span class="line"></span><br><span class="line">11．2　分析网页　223</span><br><span class="line"></span><br><span class="line">11．2．1　检视：标记结构　224</span><br><span class="line"></span><br><span class="line">11．2．2　网络&#x2F; 时间线：页面是如何加载的　230</span><br><span class="line"></span><br><span class="line">11．2．3　控制台：同JavaScript 交互　232</span><br><span class="line"></span><br><span class="line">11．2．4　页面的深入分析　236</span><br><span class="line"></span><br><span class="line">11．3　得到页面：如何通过互联网发出请求　237</span><br><span class="line"></span><br><span class="line">11．4　使用Beautiful Soup 读取网页　238</span><br><span class="line"></span><br><span class="line">11．5　使用lxml 读取网页　241</span><br><span class="line"></span><br><span class="line">11．6　小结　249</span><br><span class="line"></span><br><span class="line">第12　章 高级网页抓取：屏幕抓取器与爬虫　251</span><br><span class="line"></span><br><span class="line">12．1　基于浏览器的解析　251</span><br><span class="line"></span><br><span class="line">12．1．1　使用Selenium 进行屏幕读取　252</span><br><span class="line"></span><br><span class="line">12．1．2　使用Ghost．py 进行屏幕读取　260</span><br><span class="line"></span><br><span class="line">12．2　爬取网页　266</span><br><span class="line"></span><br><span class="line">12．2．1　使用Scrapy 创建一个爬虫　266</span><br><span class="line"></span><br><span class="line">12．2．2　使用Scrapy 爬取整个网站　273</span><br><span class="line"></span><br><span class="line">12．3　网络：互联网的工作原理，以及为什么它会让脚本崩溃　281</span><br><span class="line"></span><br><span class="line">12．4　变化的互联网（或脚本为什么崩溃）　283</span><br><span class="line"></span><br><span class="line">12．5　几句忠告　284</span><br><span class="line"></span><br><span class="line">12．6　小结　284</span><br><span class="line"></span><br><span class="line">第13　章 应用编程接口　286</span><br><span class="line"></span><br><span class="line">13．1　API 特性　287</span><br><span class="line"></span><br><span class="line">13．1．1　REST API 与流式API　287</span><br><span class="line"></span><br><span class="line">13．1．2　频率限制　287</span><br><span class="line"></span><br><span class="line">13．1．3　分级数据卷　288</span><br><span class="line"></span><br><span class="line">13．1．4　API key 和token　289</span><br><span class="line"></span><br><span class="line">13．2　一次简单的Twitter REST API 数据拉取　290</span><br><span class="line"></span><br><span class="line">13．3　使用Twitter REST API 进行高级数据收集　292</span><br><span class="line"></span><br><span class="line">13．4　使用Twitter 流式API 进行高级数据收集　295</span><br><span class="line"></span><br><span class="line">13．5　小结　297</span><br><span class="line"></span><br><span class="line">第14　章 自动化和规模化　298</span><br><span class="line"></span><br><span class="line">14．1　为什么要自动化　298</span><br><span class="line"></span><br><span class="line">14．2　自动化步骤　299</span><br><span class="line"></span><br><span class="line">14．3　什么会出错　301</span><br><span class="line"></span><br><span class="line">14．4　在哪里自动化　302</span><br><span class="line"></span><br><span class="line">14．5　自动化的特殊工具　303</span><br><span class="line"></span><br><span class="line">14．5．1　使用本地文件、参数及配置文件　303</span><br><span class="line"></span><br><span class="line">14．5．2　在数据处理中使用云　308</span><br><span class="line"></span><br><span class="line">14．5．3　使用并行处理　310</span><br><span class="line"></span><br><span class="line">14．5．4　使用分布式处理　312</span><br><span class="line"></span><br><span class="line">14．6　简单的自动化　313</span><br><span class="line"></span><br><span class="line">14．6．1　CronJobs　314</span><br><span class="line"></span><br><span class="line">14．6．2　Web 接口　316</span><br><span class="line"></span><br><span class="line">14．6．3　Jupyter notebook　316</span><br><span class="line"></span><br><span class="line">14．7　大规模自动化　317</span><br><span class="line"></span><br><span class="line">14．7．1　Celery：基于队列的自动化　317</span><br><span class="line"></span><br><span class="line">14．7．2　Ansible：操作自动化　318</span><br><span class="line"></span><br><span class="line">14．8　监控自动化程序　319</span><br><span class="line"></span><br><span class="line">14．8．1　Python 日志　320</span><br><span class="line"></span><br><span class="line">14．8．2　添加自动化信息　322</span><br><span class="line"></span><br><span class="line">14．8．3　上传和其他报告　326</span><br><span class="line"></span><br><span class="line">14．8．4　日志和监控服务　327</span><br><span class="line"></span><br><span class="line">14．9　没有万无一失的系统　328</span><br><span class="line"></span><br><span class="line">14．10　小结　328</span><br><span class="line"></span><br><span class="line">第15　章 结论　330</span><br><span class="line"></span><br><span class="line">15．1　数据处理者的职责　330</span><br><span class="line"></span><br><span class="line">15．2　数据处理之上　331</span><br><span class="line"></span><br><span class="line">15．2．1　成为一名更优秀的数据分析师　331</span><br><span class="line"></span><br><span class="line">15．2．2　成为一名更优秀的开发者　331</span><br><span class="line"></span><br><span class="line">15．2．3　成为一名更优秀的视觉化讲故事者　332</span><br><span class="line"></span><br><span class="line">15．2．4　成为一名更优秀的系统架构师　332</span><br><span class="line"></span><br><span class="line">15．3　下一步做什么　332</span><br><span class="line"></span><br><span class="line">附录A　编程语言对比　334</span><br><span class="line"></span><br><span class="line">附录B　初学者的Python 学习资源　336</span><br><span class="line"></span><br><span class="line">附录C　学习命令行　338</span><br><span class="line"></span><br><span class="line">附录D　高级Python 设置　349</span><br><span class="line"></span><br><span class="line">附录E　Python 陷阱　361</span><br><span class="line"></span><br><span class="line">附录F　IPython 指南　370</span><br><span class="line"></span><br><span class="line">附录G　使用亚马逊网络服务　374</span><br><span class="line"></span><br><span class="line">关于作者　378</span><br><span class="line"></span><br><span class="line">关于封面　378</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python开发实战 PDF</title>
    <url>/posts/3116463c/</url>
    <content><![CDATA[<h4 id="《Python开发实战》"><a href="#《Python开发实战》" class="headerlink" title="《Python开发实战》"></a>《Python开发实战》</h4><h6 id="链接-https-pan-baidu-com-s-16jATIJ3mFqT8T05H384hoA-提取码-2bnj"><a href="#链接-https-pan-baidu-com-s-16jATIJ3mFqT8T05H384hoA-提取码-2bnj" class="headerlink" title="链接: https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA 提取码: 2bnj"></a>链接: <a href="https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA">https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA</a> 提取码: 2bnj</h6><p>《Python开发实战》来自真正的开发现场，是BePROUD公司众多极客在真实项目中的经验总结。作者从Python的环境搭建讲起，介绍了Web应用开发方法、任务管理，以及评审、测试及高效部署、服务器调试等内容，尽可能网罗了Python开发流程中所涉及的方方面面。在这里，Python仅仅是一个载体，很多知识点在非Python下也适用，这也是本书大的特色所在。《Python开发实战》适合有基础的Python开发者，以及使用PHP或Ruby进行网页开发的读者阅读。…<br><a id="more"></a></p>
<p><img src="/images/f08603bbeaa793fd38dc6b28f4d51ad41.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">部分　使用Python开发</span><br><span class="line"></span><br><span class="line">01　开始使用Python　2</span><br><span class="line"></span><br><span class="line">01．01　Python环境搭建　2</span><br><span class="line"></span><br><span class="line">01．01．01　安装apt软件包　2</span><br><span class="line"></span><br><span class="line">01．01．02　easy_install与pip　3</span><br><span class="line"></span><br><span class="line">01．01．03　安装virtualenv　4</span><br><span class="line"></span><br><span class="line">01．01．04　使用不同版本的Python　9</span><br><span class="line"></span><br><span class="line">01．02　Mercurial环境搭建　12</span><br><span class="line"></span><br><span class="line">01．02．01　Mercurial的简介　12</span><br><span class="line"></span><br><span class="line">01．02．02　Mercurial的安装　12</span><br><span class="line"></span><br><span class="line">01．02．03　代码库的建立　13</span><br><span class="line"></span><br><span class="line">01．02．04　文件的操作　14</span><br><span class="line"></span><br><span class="line">01．03　编辑器与方便的开发工具　17</span><br><span class="line"></span><br><span class="line">01．03．01　编辑器　17</span><br><span class="line"></span><br><span class="line">01．03．02　Python开发小贴士　19</span><br><span class="line"></span><br><span class="line">01．04　本章小结　22</span><br><span class="line"></span><br><span class="line">02　开发Web应用程序　23</span><br><span class="line"></span><br><span class="line">02．01　了解Web应用程序　23</span><br><span class="line"></span><br><span class="line">02．01．01　什么是Web应用程序　23</span><br><span class="line"></span><br><span class="line">02．01．02　Web应用程序与桌面应用程序的不同　24</span><br><span class="line"></span><br><span class="line">02．01．03　Web应用程序的机制　24</span><br><span class="line"></span><br><span class="line">02．02　Web应用程序开发的事前准备　27</span><br><span class="line"></span><br><span class="line">02．02．01　关于Flask　27</span><br><span class="line"></span><br><span class="line">02．02．02　Flask的安装　27</span><br><span class="line"></span><br><span class="line">02．03　Web应用程序的开发流程　28</span><br><span class="line"></span><br><span class="line">02．04　明确需要开发的目标系统　28</span><br><span class="line"></span><br><span class="line">02．04．01　留言簿应用程序的需求　28</span><br><span class="line"></span><br><span class="line">02．04．02　明确必要的功能　29</span><br><span class="line"></span><br><span class="line">02．04．03　明确页面的表现形式　29</span><br><span class="line"></span><br><span class="line">02．05　页面设计　29</span><br><span class="line"></span><br><span class="line">02．05．01　页面设计草图　30</span><br><span class="line"></span><br><span class="line">02．05．02　设计HTML和CSS　30</span><br><span class="line"></span><br><span class="line">02．06　后台功能的开发　35</span><br><span class="line"></span><br><span class="line">02．06．01　保存评论数据　35</span><br><span class="line"></span><br><span class="line">02．06．02　取出保存过的评论数据　36</span><br><span class="line"></span><br><span class="line">02．06．03　使用模板引擎显示页面　37</span><br><span class="line"></span><br><span class="line">02．06．04　准备评论的目标URL地址　39</span><br><span class="line"></span><br><span class="line">02．06．05　调整模板输出　40</span><br><span class="line"></span><br><span class="line">02．07　功能验证　41</span><br><span class="line"></span><br><span class="line">02．08　本章小结　42</span><br><span class="line"></span><br><span class="line">第二部分　团队开发的周期和流程</span><br><span class="line"></span><br><span class="line">……”...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python开发技术详解 PDF</title>
    <url>/posts/461176aa/</url>
    <content><![CDATA[<h4 id="《Python开发技术详解》"><a href="#《Python开发技术详解》" class="headerlink" title="《Python开发技术详解》"></a>《Python开发技术详解》</h4><h6 id="链接-https-pan-baidu-com-s-1SEgxhjYLstG3aPU-LRbZMw-提取码-3kjn"><a href="#链接-https-pan-baidu-com-s-1SEgxhjYLstG3aPU-LRbZMw-提取码-3kjn" class="headerlink" title="链接: https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw 提取码: 3kjn"></a>链接: <a href="https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw">https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw</a> 提取码: 3kjn</h6><p>深入解析Python语言，透析应用开发的方方面面<br><a id="more"></a></p>
<p>　　涵盖9大应用领域的各类Python框架</p>
<p>　　详细讲解Python语言的基本要点和基础类库</p>
<p>　　内容覆盖GUI、数据库、Web、系统管理、网络编程、图像处理、游戏开发等领域</p>
<p>　　深入讲解常用开发框架Django、PyWin32、PyGame、Twisted等框架工具包</p>
<p>　　通过丰富的典型应用实例，读者迅速掌握实用技术</p>
<p><img src="/images/102c3099920c798deec1460c720cdbb91.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">篇　Python语言基础知识</span><br><span class="line"></span><br><span class="line">　章　Python概述</span><br><span class="line"></span><br><span class="line">　第2章　Python的基本语法</span><br><span class="line"></span><br><span class="line">　第3章　Python的控制语句</span><br><span class="line"></span><br><span class="line">　第4章　内置数据结构</span><br><span class="line"></span><br><span class="line">　第5章　模块与函数</span><br><span class="line"></span><br><span class="line">　第6章　字符串与正则表达式</span><br><span class="line"></span><br><span class="line">　第7章　文件的处理</span><br><span class="line"></span><br><span class="line">　第8章　面向对象编程</span><br><span class="line"></span><br><span class="line">　第9章　异常处理与程序调试</span><br><span class="line"></span><br><span class="line">　0章　Python 的数据库编程</span><br><span class="line"></span><br><span class="line">第二篇　Python的GUI程序设计</span><br><span class="line"></span><br><span class="line">　1章　WxPython的开发环境</span><br><span class="line"></span><br><span class="line">　2章　WxPython框架初步</span><br><span class="line"></span><br><span class="line">　3章　WxPython库中的基本组件</span><br><span class="line"></span><br><span class="line">　4章　WxPython库中的菜单、窗口与对话框控件</span><br><span class="line"></span><br><span class="line">　5章　WxPython库中的控件</span><br><span class="line"></span><br><span class="line">　6章　WxPython库中的功能</span><br><span class="line"></span><br><span class="line">第三篇　Python的Web开发</span><br><span class="line"></span><br><span class="line">　7章　Python的HTML应用</span><br><span class="line"></span><br><span class="line">　8章　Python和XML</span><br><span class="line"></span><br><span class="line">　9章　Python的Web开发——Django框架的应用</span><br><span class="line"></span><br><span class="line">　第20章　敏捷方法学在Python中的应用——测试驱动开发</span><br><span class="line"></span><br><span class="line">第四篇　Python的其他应用</span><br><span class="line"></span><br><span class="line">　第21章　Python中的进程和线程</span><br><span class="line"></span><br><span class="line">　第22章　基于Python的管理</span><br><span class="line"></span><br><span class="line">　第23章　Python和网络编程</span><br><span class="line"></span><br><span class="line">　第24章　常见的Python网络应用</span><br><span class="line"></span><br><span class="line">　第25章　图像处理和游戏开发</span><br><span class="line"></span><br><span class="line">　第26章　Python语言的扩展与嵌入</span><br><span class="line"></span><br><span class="line">　第27章　Windows下的Python</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python金融大数据分析 PDF</title>
    <url>/posts/d6ae6b3b/</url>
    <content><![CDATA[<h4 id="《Python金融大数据分析》"><a href="#《Python金融大数据分析》" class="headerlink" title="《Python金融大数据分析》"></a>《Python金融大数据分析》</h4><h6 id="链接-https-pan-baidu-com-s-1Y2X95od-ZdAywfRV8-ZdQ-提取码-rpqw"><a href="#链接-https-pan-baidu-com-s-1Y2X95od-ZdAywfRV8-ZdQ-提取码-rpqw" class="headerlink" title="链接: https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ 提取码: rpqw"></a>链接: <a href="https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ">https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ</a> 提取码: rpqw</h6><p>Python已成为数据驱动AI、金融优先选择的编程语言。现在，一些大型的投资银行和对冲资金均使用Python及其生态系统来构建核心交易与风险管理系统。在本书中，作者向开发人员和量化分析人员介绍了使用Python程序库与工具，完成金融数据科学、算法交易和计算金融任务的方法。<br><a id="more"></a></p>
<p>Python与金融：Python交互式金融分析与程序开发入门。</p>
<p>基本知识：学习Python数据类型与结构、NumPy、pandas及其DataFrame类、面向对象编程。</p>
<p>金融数据科学：探索用于金融时间序列数据、I/O操作、推断统计学和机器学习的Python技术与程序库。</p>
<p>算法交易：使用Python来验证和部署自动算法交易策略。</p>
<p>衍生品分析：开发灵活、强大的Python期权、衍生品定价和风险管理程序库。</p>
<p><img src="/images/386dac4a4b8fe049bfed8bcd93126f861.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第　1部分 Python与金融</span><br><span class="line"></span><br><span class="line">第　1章 为什么将Python用于金融　3</span><br><span class="line"></span><br><span class="line">1．1　Python编程语言　3</span><br><span class="line"></span><br><span class="line">1．1．1　Python简史　5</span><br><span class="line"></span><br><span class="line">1．1．2　Python生态系统　6</span><br><span class="line"></span><br><span class="line">1．1．3　Python用户谱系　7</span><br><span class="line"></span><br><span class="line">1．1．4　科学栈　7</span><br><span class="line"></span><br><span class="line">1．2　金融中的科技　8</span><br><span class="line"></span><br><span class="line">1．2．1　科技投入　9</span><br><span class="line"></span><br><span class="line">1．2．2　作为业务引擎的科技　9</span><br><span class="line"></span><br><span class="line">1．2．3　作为进入门槛的科技和人才　10</span><br><span class="line"></span><br><span class="line">1．2．4　不断提高的速度、频率和数据量　10</span><br><span class="line"></span><br><span class="line">1．2．5　实时分析的兴起　11</span><br><span class="line"></span><br><span class="line">1．3　用于金融的Python　12</span><br><span class="line"></span><br><span class="line">1．3．1　金融和Python语法　12</span><br><span class="line"></span><br><span class="line">1．3．2　Python的效率和生产率　16</span><br><span class="line"></span><br><span class="line">1．3．3　从原型化到生产　20</span><br><span class="line"></span><br><span class="line">1．4　数据驱动和人工智能优先的金融学　21</span><br><span class="line"></span><br><span class="line">1．4．1　数据驱动金融学　21</span><br><span class="line"></span><br><span class="line">1．4．2　人工智能优先金融学　24</span><br><span class="line"></span><br><span class="line">1．5　结语　26</span><br><span class="line"></span><br><span class="line">1．6　延伸阅读　27</span><br><span class="line"></span><br><span class="line">第　2章 Python基础架构　29</span><br><span class="line"></span><br><span class="line">2．1　作为包管理器使用的conda　31</span><br><span class="line"></span><br><span class="line">2．1．1　安装Miniconda　31</span><br><span class="line"></span><br><span class="line">2．1．2　conda基本操作　33</span><br><span class="line"></span><br><span class="line">2．2　作为虚拟环境管理器的conda　37</span><br><span class="line"></span><br><span class="line">2．3　使用Docker容器　41</span><br><span class="line"></span><br><span class="line">2．3．1　Docker镜像和容器　41</span><br><span class="line"></span><br><span class="line">2．3．2　构建Ubuntu和Python Docker镜像　42</span><br><span class="line"></span><br><span class="line">2．4　使用云实例　46</span><br><span class="line"></span><br><span class="line">2．4．1　RSA公钥和私钥　47</span><br><span class="line"></span><br><span class="line">2．4．2　Jupyter Notebook配置文件　48</span><br><span class="line"></span><br><span class="line">2．4．3　Python和Jupyter Notebook安装脚本　49</span><br><span class="line"></span><br><span class="line">2．4．4　协调Droplet设置的脚本　51</span><br><span class="line"></span><br><span class="line">2．5　结语　52</span><br><span class="line"></span><br><span class="line">2．6　延伸阅读　53</span><br><span class="line"></span><br><span class="line">第　2部分 掌握基础知识</span><br><span class="line"></span><br><span class="line">第3章　数据类型与结构　57</span><br><span class="line"></span><br><span class="line">3．1　基本数据类型　58</span><br><span class="line"></span><br><span class="line">3．1．1　整数　58</span><br><span class="line"></span><br><span class="line">3．1．2　浮点数　59</span><br><span class="line"></span><br><span class="line">3．1．3　布尔值　61</span><br><span class="line"></span><br><span class="line">3．1．4　字符串　65</span><br><span class="line"></span><br><span class="line">3．1．5　题外话：打印和字符串替换　66</span><br><span class="line"></span><br><span class="line">3．1．6　题外话：正则表达式　69</span><br><span class="line"></span><br><span class="line">3．2　基本数据结构　71</span><br><span class="line"></span><br><span class="line">3．2．1　元组　71</span><br><span class="line"></span><br><span class="line">3．2．2　列表　72</span><br><span class="line"></span><br><span class="line">3．2．3　题外话：控制结构　74</span><br><span class="line"></span><br><span class="line">3．2．4　题外话：函数式编程　75</span><br><span class="line"></span><br><span class="line">3．2．5　字典　76</span><br><span class="line"></span><br><span class="line">3．2．6　集合　78</span><br><span class="line"></span><br><span class="line">3．3　结语　79</span><br><span class="line"></span><br><span class="line">3．4　延伸阅读　79</span><br><span class="line"></span><br><span class="line">第4章　用NumPy进行数值计算　81</span><br><span class="line"></span><br><span class="line">4．1　数据数组　82</span><br><span class="line"></span><br><span class="line">4．1．1　用Python列表形成数组　82</span><br><span class="line"></span><br><span class="line">4．1．2　Python array类　84</span><br><span class="line"></span><br><span class="line">4．2　常规NumPy数组　86</span><br><span class="line"></span><br><span class="line">4．2．1　基础知识　86</span><br><span class="line"></span><br><span class="line">4．2．2　多维数组　89</span><br><span class="line"></span><br><span class="line">4．2．3　元信息　93</span><br><span class="line"></span><br><span class="line">4．2．4　改变组成与大小　93</span><br><span class="line"></span><br><span class="line">4．2．5　布尔数组　97</span><br><span class="line"></span><br><span class="line">4．2．6　速度对比　99</span><br><span class="line"></span><br><span class="line">4．3　NumPy结构数组　100</span><br><span class="line"></span><br><span class="line">4．4　代码向量化　102</span><br><span class="line"></span><br><span class="line">4．4．1　基本向量化　102</span><br><span class="line"></span><br><span class="line">4．4．2　内存布局　105</span><br><span class="line"></span><br><span class="line">4．5　结语　107</span><br><span class="line"></span><br><span class="line">4．6　延伸阅读　108</span><br><span class="line"></span><br><span class="line">第5章　pandas数据分析　109</span><br><span class="line"></span><br><span class="line">5．1　DataFrame类　110</span><br><span class="line"></span><br><span class="line">5．1．1　使用DataFrame类的第 一步　110</span><br><span class="line"></span><br><span class="line">5．1．2　使用DataFrame类的第二步　114</span><br><span class="line"></span><br><span class="line">5．2　基本分析　118</span><br><span class="line"></span><br><span class="line">5．3　基本可视化　122</span><br><span class="line"></span><br><span class="line">5．4　Series类　124</span><br><span class="line"></span><br><span class="line">5．5　GroupBy操作　126</span><br><span class="line"></span><br><span class="line">5．6　复杂选择　128</span><br><span class="line"></span><br><span class="line">5．7　联接、连接和合并　131</span><br><span class="line"></span><br><span class="line">5．7．1　联接　132</span><br><span class="line"></span><br><span class="line">5．7．2　连接　133</span><br><span class="line"></span><br><span class="line">5．7．3　合并　135</span><br><span class="line"></span><br><span class="line">5．8　性能特征　137</span><br><span class="line"></span><br><span class="line">5．9　结语　139</span><br><span class="line"></span><br><span class="line">5．10　延伸阅读　140</span><br><span class="line"></span><br><span class="line">第6章　面向对象编程　141</span><br><span class="line"></span><br><span class="line">6．1　Python对象简介　145</span><br><span class="line"></span><br><span class="line">6．1．1　int　145</span><br><span class="line"></span><br><span class="line">6．1．2　list　146</span><br><span class="line"></span><br><span class="line">6．1．3　ndarray　146</span><br><span class="line"></span><br><span class="line">6．1．4　DataFrame　148</span><br><span class="line"></span><br><span class="line">6．2　Python类基础知识　149</span><br><span class="line"></span><br><span class="line">6．3　Python数据模型　154</span><br><span class="line"></span><br><span class="line">6．4　Vector类　158</span><br><span class="line"></span><br><span class="line">6．5　结语　159</span><br><span class="line"></span><br><span class="line">6．6　延伸阅读　159</span><br><span class="line"></span><br><span class="line">第3部分　金融数据科学</span><br><span class="line"></span><br><span class="line">第7章　数据可视化　163</span><br><span class="line"></span><br><span class="line">7．1　静态2D绘图　164</span><br><span class="line"></span><br><span class="line">7．1．1　一维数据集　164</span><br><span class="line"></span><br><span class="line">7．1．2　二维数据集　170</span><br><span class="line"></span><br><span class="line">7．1．3　其他绘图样式　177</span><br><span class="line"></span><br><span class="line">7．2　静态3D绘图　184</span><br><span class="line"></span><br><span class="line">7．3　交互式2D绘图　188</span><br><span class="line"></span><br><span class="line">7．3．1　基本图表　188</span><br><span class="line"></span><br><span class="line">7．3．2　金融图表　192</span><br><span class="line"></span><br><span class="line">7．4　结语　196</span><br><span class="line"></span><br><span class="line">7．5　延伸阅读　196</span><br><span class="line"></span><br><span class="line">第8章　金融时间序列　197</span><br><span class="line"></span><br><span class="line">8．1　金融数据　198</span><br><span class="line"></span><br><span class="line">8．1．1　数据导入　198</span><br><span class="line"></span><br><span class="line">8．1．2　汇总统计　201</span><br><span class="line"></span><br><span class="line">8．1．3　随时间推移的变化　203</span><br><span class="line"></span><br><span class="line">8．1．4　重新采样　207</span><br><span class="line"></span><br><span class="line">8．2　滚动统计　209</span><br><span class="line"></span><br><span class="line">8．2．1　概述　209</span><br><span class="line"></span><br><span class="line">8．2．2　技术分析示例　211</span><br><span class="line"></span><br><span class="line">8．3　相关分析　213</span><br><span class="line"></span><br><span class="line">8．3．1　数据　213</span><br><span class="line"></span><br><span class="line">8．3．2　对数回报率　214</span><br><span class="line"></span><br><span class="line">8．3．3　OLS回归　216</span><br><span class="line"></span><br><span class="line">8．3．4　相关　217</span><br><span class="line"></span><br><span class="line">8．4　高频数据　218</span><br><span class="line"></span><br><span class="line">8．5　结语　220</span><br><span class="line"></span><br><span class="line">8．6　延伸阅读　220</span><br><span class="line"></span><br><span class="line">第9章　输入&#x2F;输出操作　221</span><br><span class="line"></span><br><span class="line">9．1　Python基本I&#x2F;O　222</span><br><span class="line"></span><br><span class="line">9．1．1　将对象写入磁盘　222</span><br><span class="line"></span><br><span class="line">9．1．2　读取和写入文本文件　225</span><br><span class="line"></span><br><span class="line">9．1．3　使用SQL数据库　229</span><br><span class="line"></span><br><span class="line">9．1．4　读写NumPy数组　232</span><br><span class="line"></span><br><span class="line">9．2　pandas的I&#x2F;O　234</span><br><span class="line"></span><br><span class="line">9．2．1　使用SQL数据库　235</span><br><span class="line"></span><br><span class="line">9．2．2　从SQL到pandas　237</span><br><span class="line"></span><br><span class="line">9．2．3　使用CSV文件　239</span><br><span class="line"></span><br><span class="line">9．2．4　使用Excel文件　240</span><br><span class="line"></span><br><span class="line">9．3　PyTables的I&#x2F;O　242</span><br><span class="line"></span><br><span class="line">9．3．1　使用表　242</span><br><span class="line"></span><br><span class="line">9．3．2　使用压缩表　250</span><br><span class="line"></span><br><span class="line">9．3．3　使用数组　252</span><br><span class="line"></span><br><span class="line">9．3．4　内存外计算　253</span><br><span class="line"></span><br><span class="line">9．4　TsTables的I&#x2F;O　256</span><br><span class="line"></span><br><span class="line">9．4．1　样板数据　257</span><br><span class="line"></span><br><span class="line">9．4．2　数据存储　258</span><br><span class="line"></span><br><span class="line">9．4．3　数据检索　259</span><br><span class="line"></span><br><span class="line">9．5　结语　261</span><br><span class="line"></span><br><span class="line">9．6　延伸阅读　262</span><br><span class="line"></span><br><span class="line">第　10章 高性能的Python　265</span><br><span class="line"></span><br><span class="line">10．1　循环　266</span><br><span class="line"></span><br><span class="line">10．1．1　Python　266</span><br><span class="line"></span><br><span class="line">10．1．2　NumPy　267</span><br><span class="line"></span><br><span class="line">10．1．3　Numba　268</span><br><span class="line"></span><br><span class="line">10．1．4　Cython　269</span><br><span class="line"></span><br><span class="line">10．2　算法　271</span><br><span class="line"></span><br><span class="line">10．2．1　质数　271</span><br><span class="line"></span><br><span class="line">10．2．2　斐波那契数　275</span><br><span class="line"></span><br><span class="line">10．2．3　π　279</span><br><span class="line"></span><br><span class="line">10．3　二叉树　283</span><br><span class="line"></span><br><span class="line">10．3．1　Python　283</span><br><span class="line"></span><br><span class="line">10．3．2　NumPy　285</span><br><span class="line"></span><br><span class="line">10．3．3　Numba　286</span><br><span class="line"></span><br><span class="line">10．3．4　Cython　287</span><br><span class="line"></span><br><span class="line">10．4　蒙特卡洛模拟　288</span><br><span class="line"></span><br><span class="line">10．4．1　Python　289</span><br><span class="line"></span><br><span class="line">10．4．2　NumPy　291</span><br><span class="line"></span><br><span class="line">10．4．3　Numba　291</span><br><span class="line"></span><br><span class="line">10．4．4　Cython　292</span><br><span class="line"></span><br><span class="line">10．4．5　多进程　293</span><br><span class="line"></span><br><span class="line">10．5　pandas递归算法　294</span><br><span class="line"></span><br><span class="line">10．5．1　Python　294</span><br><span class="line"></span><br><span class="line">10．5．2　Numba　296</span><br><span class="line"></span><br><span class="line">10．5．3　Cython　296</span><br><span class="line"></span><br><span class="line">10．6　结语　297</span><br><span class="line"></span><br><span class="line">10．7　延伸阅读　298</span><br><span class="line"></span><br><span class="line">第　11章 数学工具　299</span><br><span class="line"></span><br><span class="line">11．1　逼近法　299</span><br><span class="line"></span><br><span class="line">11．1．1　回归　301</span><br><span class="line"></span><br><span class="line">11．1．2　插值　310</span><br><span class="line"></span><br><span class="line">11．2　凸优化　314</span><br><span class="line"></span><br><span class="line">11．2．1　全局优化　315</span><br><span class="line"></span><br><span class="line">11．2．2　局部优化　317</span><br><span class="line"></span><br><span class="line">11．2．3　有约束优化　318</span><br><span class="line"></span><br><span class="line">11．3　积分　320</span><br><span class="line"></span><br><span class="line">11．3．1　数值积分　321</span><br><span class="line"></span><br><span class="line">11．3．2　通过模拟求取积分　322</span><br><span class="line"></span><br><span class="line">11．4　符号计算　323</span><br><span class="line"></span><br><span class="line">11．4．1　基础知识　323</span><br><span class="line"></span><br><span class="line">11．4．2　方程式　325</span><br><span class="line"></span><br><span class="line">11．4．3　积分与微分　325</span><br><span class="line"></span><br><span class="line">11．4．4　微分　326</span><br><span class="line"></span><br><span class="line">11．5　结语　328</span><br><span class="line"></span><br><span class="line">11．6　延伸阅读　328</span><br><span class="line"></span><br><span class="line">第　12章 推断统计学　331</span><br><span class="line"></span><br><span class="line">12．1　随机数　332</span><br><span class="line"></span><br><span class="line">12．2　模拟　338</span><br><span class="line"></span><br><span class="line">12．2．1　随机变量　338</span><br><span class="line"></span><br><span class="line">12．2．2　随机过程　341</span><br><span class="line"></span><br><span class="line">12．2．3　方差缩减　356</span><br><span class="line"></span><br><span class="line">12．3　估值　359</span><br><span class="line"></span><br><span class="line">12．3．1　欧式期权　359</span><br><span class="line"></span><br><span class="line">12．3．2　美式期权　364</span><br><span class="line"></span><br><span class="line">12．4　风险测度　367</span><br><span class="line"></span><br><span class="line">12．4．1　风险价值　367</span><br><span class="line"></span><br><span class="line">12．4．2　信用价值调整　371</span><br><span class="line"></span><br><span class="line">12．5　Python脚本　374</span><br><span class="line"></span><br><span class="line">12．6　结语　377</span><br><span class="line"></span><br><span class="line">12．7　延伸阅读　377</span><br><span class="line"></span><br><span class="line">第　13章 统计学　379</span><br><span class="line"></span><br><span class="line">13．1　正态性检验　380</span><br><span class="line"></span><br><span class="line">13．1．1　基准案例　381</span><br><span class="line"></span><br><span class="line">13．1．2　真实数据　390</span><br><span class="line"></span><br><span class="line">13．2　投资组合优化　396</span><br><span class="line"></span><br><span class="line">13．2．1　数据　396</span><br><span class="line"></span><br><span class="line">13．2．2　基本理论　398</span><br><span class="line"></span><br><span class="line">13．2．3　最优投资组合　401</span><br><span class="line"></span><br><span class="line">13．2．4　有效边界　404</span><br><span class="line"></span><br><span class="line">13．2．5　资本市场线　405</span><br><span class="line"></span><br><span class="line">13．3　贝叶斯统计　408</span><br><span class="line"></span><br><span class="line">13．3．1　贝叶斯公式　409</span><br><span class="line"></span><br><span class="line">13．3．2　贝叶斯回归　410</span><br><span class="line"></span><br><span class="line">13．3．3　两种金融工具　414</span><br><span class="line"></span><br><span class="line">13．3．4　随时更新估算值　418</span><br><span class="line"></span><br><span class="line">13．4　机器学习　423</span><br><span class="line"></span><br><span class="line">13．4．1　无监督学习　423</span><br><span class="line"></span><br><span class="line">13．4．2　有监督学习　426</span><br><span class="line"></span><br><span class="line">13．5　结语　441</span><br><span class="line"></span><br><span class="line">13．6　延伸阅读　441</span><br><span class="line"></span><br><span class="line">第4部分　算法交易</span><br><span class="line"></span><br><span class="line">第　14章 FXCM交易平台　445</span><br><span class="line"></span><br><span class="line">14．1　入门　446</span><br><span class="line"></span><br><span class="line">14．2　读取数据　447</span><br><span class="line"></span><br><span class="line">14．2．1　读取分笔交易数据　447</span><br><span class="line"></span><br><span class="line">14．2．2　读取K线（蜡烛图）数据　449</span><br><span class="line"></span><br><span class="line">14．3　使用API　451</span><br><span class="line"></span><br><span class="line">14．3．1　读取历史数据　452</span><br><span class="line"></span><br><span class="line">14．3．2　读取流数据　454</span><br><span class="line"></span><br><span class="line">14．3．3　下单　455</span><br><span class="line"></span><br><span class="line">14．3．4　账户信息　457</span><br><span class="line"></span><br><span class="line">14．4　结语　457</span><br><span class="line"></span><br><span class="line">14．5　延伸阅读　458</span><br><span class="line"></span><br><span class="line">第　15章 交易策略　459</span><br><span class="line"></span><br><span class="line">15．1　简单移动平均数　460</span><br><span class="line"></span><br><span class="line">15．1．1　数据导入　460</span><br><span class="line"></span><br><span class="line">15．1．2　交易策略　461</span><br><span class="line"></span><br><span class="line">15．1．3　向量化事后检验　463</span><br><span class="line"></span><br><span class="line">15．1．4　优化　465</span><br><span class="line"></span><br><span class="line">15．2　随机游走假设　467</span><br><span class="line"></span><br><span class="line">15．3　线性OLS回归　469</span><br><span class="line"></span><br><span class="line">15．3．1　数据　470</span><br><span class="line"></span><br><span class="line">15．3．2　回归　472</span><br><span class="line"></span><br><span class="line">15．4　聚类　474</span><br><span class="line"></span><br><span class="line">15．5　频率方法　476</span><br><span class="line"></span><br><span class="line">15．6　分类　479</span><br><span class="line"></span><br><span class="line">15．6．1　两个二元特征　479</span><br><span class="line"></span><br><span class="line">15．6．2　5个二元特征　480</span><br><span class="line"></span><br><span class="line">15．6．3　5个数字化特征　482</span><br><span class="line"></span><br><span class="line">15．6．4　顺序训练-测试分离　484</span><br><span class="line"></span><br><span class="line">15．6．5　随机训练-测试分离　485</span><br><span class="line"></span><br><span class="line">15．7　深度神经网络　486</span><br><span class="line"></span><br><span class="line">15．7．1　用scikit-learn实现DNN　486</span><br><span class="line"></span><br><span class="line">15．7．2　用TensorFlow实现DNN　489</span><br><span class="line"></span><br><span class="line">15．8　结语　492</span><br><span class="line"></span><br><span class="line">15．9　延伸阅读　493</span><br><span class="line"></span><br><span class="line">第　16章 自动化交易　495</span><br><span class="line"></span><br><span class="line">16．1　资本管理　496</span><br><span class="line"></span><br><span class="line">16．1．1　二项设定中的凯利标准　496</span><br><span class="line"></span><br><span class="line">16．1．2　用于股票及指数的凯利标准　500</span><br><span class="line"></span><br><span class="line">16．2　基于ML的交易策略　505</span><br><span class="line"></span><br><span class="line">16．2．1　向量化事后检验　505</span><br><span class="line"></span><br><span class="line">16．2．2　最优杠杆　510</span><br><span class="line"></span><br><span class="line">16．2．3　风险分析　512</span><br><span class="line"></span><br><span class="line">16．2．4　持久化模型对象　515</span><br><span class="line"></span><br><span class="line">16．3　在线算法　516</span><br><span class="line"></span><br><span class="line">16．4　基础设施与部署　518</span><br><span class="line"></span><br><span class="line">16．5　日志与监控　519</span><br><span class="line"></span><br><span class="line">16．6　结语　521</span><br><span class="line"></span><br><span class="line">16．7　Python脚本　522</span><br><span class="line"></span><br><span class="line">16．7．1　自动化交易策略　522</span><br><span class="line"></span><br><span class="line">16．7．2　策略监控　525</span><br><span class="line"></span><br><span class="line">16．8　延伸阅读　525</span><br><span class="line"></span><br><span class="line">第5部分　衍生品分析</span><br><span class="line"></span><br><span class="line">第　17章 估值框架　529</span><br><span class="line"></span><br><span class="line">17．1　资产定价基本定理　529</span><br><span class="line"></span><br><span class="line">17．1．1　简单示例　530</span><br><span class="line"></span><br><span class="line">17．1．2　一般结果　530</span><br><span class="line"></span><br><span class="line">17．2　风险中立折现　532</span><br><span class="line"></span><br><span class="line">17．2．1　日期建模与处理　532</span><br><span class="line"></span><br><span class="line">17．2．2　恒定短期利率　534</span><br><span class="line"></span><br><span class="line">17．3　市场环境　536</span><br><span class="line"></span><br><span class="line">17．4　结语　539</span><br><span class="line"></span><br><span class="line">17．5　延伸阅读　540</span><br><span class="line"></span><br><span class="line">第　18章 金融模型的模拟　541</span><br><span class="line"></span><br><span class="line">18．1　随机数生成　542</span><br><span class="line"></span><br><span class="line">18．2　通用模拟类　544</span><br><span class="line"></span><br><span class="line">18．3　几何布朗运动　548</span><br><span class="line"></span><br><span class="line">18．3．1　模拟类　548</span><br><span class="line"></span><br><span class="line">18．3．2　用例　550</span><br><span class="line"></span><br><span class="line">18．4　跳跃扩散　553</span><br><span class="line"></span><br><span class="line">18．4．1　模拟类　553</span><br><span class="line"></span><br><span class="line">18．4．2　用例　556</span><br><span class="line"></span><br><span class="line">18．5　平方根扩散　557</span><br><span class="line"></span><br><span class="line">18．5．1　模拟类　558</span><br><span class="line"></span><br><span class="line">18．5．2　用例　560</span><br><span class="line"></span><br><span class="line">18．6　结语　561</span><br><span class="line"></span><br><span class="line">18．7　延伸阅读　563</span><br><span class="line"></span><br><span class="line">第　19章 衍生品估值　565</span><br><span class="line"></span><br><span class="line">19．1　通用估值类　566</span><br><span class="line"></span><br><span class="line">19．2　欧式行权　570</span><br><span class="line"></span><br><span class="line">19．2．1　估值类　570</span><br><span class="line"></span><br><span class="line">19．2．2　用例　572</span><br><span class="line"></span><br><span class="line">19．3　美式行权　577</span><br><span class="line"></span><br><span class="line">19．3．1　最小二乘蒙特卡洛方法　577</span><br><span class="line"></span><br><span class="line">19．3．2　估值类　578</span><br><span class="line"></span><br><span class="line">19．3．3　用例　580</span><br><span class="line"></span><br><span class="line">19．4　结语　583</span><br><span class="line"></span><br><span class="line">19．5　延伸阅读　585</span><br><span class="line"></span><br><span class="line">第　20章 投资组合估值　587</span><br><span class="line"></span><br><span class="line">20．1　衍生品头寸　588</span><br><span class="line"></span><br><span class="line">20．1．1　类　588</span><br><span class="line"></span><br><span class="line">20．1．2　用例　590</span><br><span class="line"></span><br><span class="line">20．2　衍生品投资组合　592</span><br><span class="line"></span><br><span class="line">20．2．1　类　592</span><br><span class="line"></span><br><span class="line">20．2．2　用例　597</span><br><span class="line"></span><br><span class="line">20．3　结语　604</span><br><span class="line"></span><br><span class="line">20．4　延伸阅读　605</span><br><span class="line"></span><br><span class="line">第　21章 基于市场的估值　607</span><br><span class="line"></span><br><span class="line">21．1　期权数据　608</span><br><span class="line"></span><br><span class="line">21．2　模型检验　610</span><br><span class="line"></span><br><span class="line">21．2．1　相关市场数据　611</span><br><span class="line"></span><br><span class="line">21．2．2　期权建模　612</span><br><span class="line"></span><br><span class="line">21．2．3　检验过程　615</span><br><span class="line"></span><br><span class="line">21．3　投资组合估值　620</span><br><span class="line"></span><br><span class="line">21．3．1　建立期权头寸模型　621</span><br><span class="line"></span><br><span class="line">21．3．2　期权投资组合　622</span><br><span class="line"></span><br><span class="line">21．4　Python代码　623</span><br><span class="line"></span><br><span class="line">21．5　结语　625</span><br><span class="line"></span><br><span class="line">21．6　延伸阅读　626</span><br><span class="line"></span><br><span class="line">附录A　日期与时间　627</span><br><span class="line"></span><br><span class="line">A．1　Python　627</span><br><span class="line"></span><br><span class="line">A．2　NumPy　633</span><br><span class="line"></span><br><span class="line">A．3　pandas　636</span><br><span class="line"></span><br><span class="line">附录B　BSM期权类　641</span><br><span class="line"></span><br><span class="line">B．1　类定义　641</span><br><span class="line"></span><br><span class="line">B．2　类的使用　643</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python灰帽子黑客与逆向工程师的Python编程之道 PDF</title>
    <url>/posts/a1a95bad/</url>
    <content><![CDATA[<h4 id="《Python灰帽子黑客与逆向工程师的Python编程之道》"><a href="#《Python灰帽子黑客与逆向工程师的Python编程之道》" class="headerlink" title="《Python灰帽子黑客与逆向工程师的Python编程之道》"></a>《Python灰帽子黑客与逆向工程师的Python编程之道》</h4><h6 id="链接-https-pan-baidu-com-s-11b-tkIcexYXDe2Ge1a-kaA-提取码-ev5v"><a href="#链接-https-pan-baidu-com-s-11b-tkIcexYXDe2Ge1a-kaA-提取码-ev5v" class="headerlink" title="链接: https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA 提取码: ev5v"></a>链接: <a href="https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA">https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA</a> 提取码: ev5v</h6><p>本书是由知名安全机构ImmunityInc的资深黑帽JustinSeitz先生主笔撰写的一本关于编程语言Python如何被广泛应用于黑客与逆向工程领域的书籍．老牌黑客，同时也是ImmunityInc的创始人兼首席技术执行官(CT0)DaveAitel为本书担任了技术编辑一职。本书的绝大部分篇幅着眼于黑客技术领域中的两大经久不衰的话题：逆向工程与漏洞挖掘，并向读者呈现了几乎每个逆向工程师或安全研究人员在日常工作中所面临的各种场景，其中包括：如何设计?构建自己的调试工具，如何自动化实现烦琐的逆向分析任务，如何设计与构建自己的fuzzing工具，如何利用fuzzing测试来找出存在于软件产品中的安全漏洞，一些小技巧诸如钩子与注入技术的应用，以及对一些主流Python安全工具如PyDbg、ImmunityDebugger、Sulley、IDAPython、PyEmu等的深入介绍。作者借助于如今黑客社区中备受青睐的编程语言Python读者构建出精悍的脚本程序来——应对上述这些问题。出现在本书中的相当一部分Python代码实例借鉴或直接来源于一些的开源安全项目，诸如PedramAmini的Paimei，由此读者可以领略到安全研究者?是如何将黑客艺术与工程技术优雅融合来解决那些棘手问题的。<br><a id="more"></a></p>
<p><img src="/images/a793890e55326ef4fe5a29b0803ad5401.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">章  搭建开发环境</span><br><span class="line"></span><br><span class="line">  1.1  操作系统要求</span><br><span class="line"></span><br><span class="line">  1.2获取和安装Python 2.5</span><br><span class="line"></span><br><span class="line">    1.2.1  在Windows下安装Python</span><br><span class="line"></span><br><span class="line">    1.2.2  在Linux下安装Python</span><br><span class="line"></span><br><span class="line">  1.3  安装Eclipse和PyDev</span><br><span class="line"></span><br><span class="line">    1.3.1  黑客挚友：ctype库</span><br><span class="line"></span><br><span class="line">    1.3.2  使用动态链接库</span><br><span class="line"></span><br><span class="line">    1.3.3  构建C数据类型</span><br><span class="line"></span><br><span class="line">    1.3.4  按引用传参</span><br><span class="line"></span><br><span class="line">    1.3.5  定义结构体和联合体</span><br><span class="line"></span><br><span class="line">第2章  调试器原理和设计</span><br><span class="line"></span><br><span class="line">  2.1  通用寄存器</span><br><span class="line"></span><br><span class="line">  2.2  栈</span><br><span class="line"></span><br><span class="line">  2.3  调试事件</span><br><span class="line"></span><br><span class="line">  2.4  断点</span><br><span class="line"></span><br><span class="line">    2.4.1  软断点</span><br><span class="line"></span><br><span class="line">    2.4.2  硬件断点</span><br><span class="line"></span><br><span class="line">    2.4.3  内存断点</span><br><span class="line"></span><br><span class="line">第3?  构建自己的Windows调试器</span><br><span class="line"></span><br><span class="line">  3.1  Debugee，敢问你在何处</span><br><span class="line"></span><br><span class="line">  3.2  获取寄存器状态信息</span><br><span class="line"></span><br><span class="line">    3.2.1  线程枚举</span><br><span class="line"></span><br><span class="line">    3.2.2功能整合</span><br><span class="line"></span><br><span class="line">  3.3  实现调试事件处理例程</span><br><span class="line"></span><br><span class="line">  3.4  的断点</span><br><span class="line"></span><br><span class="line">    3.4.1  软断点</span><br><span class="line"></span><br><span class="line">    3.4.2  硬件断点</span><br><span class="line"></span><br><span class="line">    3.4.3  内存断点</span><br><span class="line"></span><br><span class="line">　3.5  总结</span><br><span class="line"></span><br><span class="line">第4章  PyDbg——WindoWS下的纯Python调试器</span><br><span class="line"></span><br><span class="line">　4.1  扩展断点处理例程</span><br><span class="line"></span><br><span class="line">　4.2  非法内存操作处理例程</span><br><span class="line"></span><br><span class="line">　4.3  进程快照</span><br><span class="line"></span><br><span class="line">    4.3.1  获取进程快照</span><br><span class="line"></span><br><span class="line">    4.3.2汇总与整合</span><br><span class="line"></span><br><span class="line">第5章  Immunity Debugger一两极世界的选择</span><br><span class="line"></span><br><span class="line">  5.1  安装Immunity Debugger</span><br><span class="line"></span><br><span class="line">  5.2  Immunity Debugger l01</span><br><span class="line"></span><br><span class="line">    5.2.1  PyCommand命令</span><br><span class="line"></span><br><span class="line">    5.2.2  PyHooks</span><br><span class="line"></span><br><span class="line">　5.3  Exploit(漏洞利用程序)开发</span><br><span class="line"></span><br><span class="line">    5.3.1  搜寻exploit友好指令</span><br><span class="line"></span><br><span class="line">    5.3.2“坏”字符过滤</span><br><span class="line"></span><br><span class="line">    5.3.3  绕过Windows下的DEP机制</span><br><span class="line"></span><br><span class="line">　5.4  破除恶意软件中的反调试例程</span><br><span class="line"></span><br><span class="line">    5.4 1  lsDebuugerPresent</span><br><span class="line"></span><br><span class="line">    5.4.2  破除进程枚举例程</span><br><span class="line"></span><br><span class="line">第6章  钩子的艺术</span><br><span class="line"></span><br><span class="line">  6.1  使用PyDbg部署软钩子</span><br><span class="line"></span><br><span class="line">  6.2  使用Immunity Debugger部署硬钩子</span><br><span class="line"></span><br><span class="line">第7章  DLL注入与代码注入技术</span><br><span class="line"></span><br><span class="line">  7.1  创建远程线程</span><br><span class="line"></span><br><span class="line">    7.1.1  DLL注入</span><br><span class="line"></span><br><span class="line">    7.1.2  代码注入</span><br><span class="line"></span><br><span class="line">　……</span><br><span class="line"></span><br><span class="line">第8章　Fuzzing</span><br><span class="line"></span><br><span class="line">第9章　Sulley</span><br><span class="line"></span><br><span class="line">0章　面向Windows驱动的Fuzzing测试技术</span><br><span class="line"></span><br><span class="line">1章　IDAPyrhon——IDA PRO环境下的Pyrhon</span><br><span class="line"></span><br><span class="line">2章　PYEmu——脚本驱动式仿真器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python高级编程第2版 PDF</title>
    <url>/posts/38a00a17/</url>
    <content><![CDATA[<h4 id="《Python高级编程第2版》"><a href="#《Python高级编程第2版》" class="headerlink" title="《Python高级编程第2版》"></a>《Python高级编程第2版》</h4><h6 id="链接-https-pan-baidu-com-s-1tSk97zVE1iDboX9BJ1D-Rw-提取码-62qy"><a href="#链接-https-pan-baidu-com-s-1tSk97zVE1iDboX9BJ1D-Rw-提取码-62qy" class="headerlink" title="链接: https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw 提取码: 62qy"></a>链接: <a href="https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw">https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw</a> 提取码: 62qy</h6><p>Python是一门动态编程语言，它简单而又强大，适用于众多领域。尽管编写Python代码比较容易，但是编写高效且易于维护和复用的代码是一个挑战。<br><a id="more"></a></p>
<p>本书的重点是让你熟悉实践、有用的工具以及标准，这都是Python专业人士每天使用的。首先，你将了解Python 3.5中新增加的功能以及可以提高生产力的快速技巧。接下来，你将学习使用这个新版本中的高-级且有用的Python语法元素，以及实现元编程的不同方法。本书讲解了代码管理工具、编写清晰文档的方法和测试驱动开发，这些都是编写代码的重要因素。通过学习优化的一般原则、查找瓶颈的策略以及应用优化的选定工具，你可以对如何编写高效的代码有更深入的理解。</p>
<p>读完本书后，你会成为一名可以编写高效且可维护代码的专家。</p>
<p>通过阅读本书，你将能够：</p>
<p>了解在Python社区中广泛采用的约定和实践；</p>
<p>高效打包Python代码，以便将其应用于社区和生产；</p>
<p>应用在远程系统上自动化部署代码的简单且轻量的方法；</p>
<p>提高代码的质量、可靠性及性能；</p>
<p>在Python中编写并发代码；</p>
<p>使用其他语言编写的代码来扩展Python。</p>
<p><img src="/images/6bf5b937dc482f3f6597025d1f7e8e1f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 Python现状 1</span><br><span class="line"></span><br><span class="line">1.1 Python的现状与未来 1</span><br><span class="line"></span><br><span class="line">1.2 Python升级及其原因 2</span><br><span class="line"></span><br><span class="line">1.3 追踪Python最新变化——PEP文档 2</span><br><span class="line"></span><br><span class="line">1.4 当前Python 3的普及程度 3</span><br><span class="line"></span><br><span class="line">1.5 Python 3和Python 2的主要差异 4</span><br><span class="line"></span><br><span class="line">1.5.1 为什么要关注这些差异 4</span><br><span class="line"></span><br><span class="line">1.5.2 主要的语法差异和常见陷阱 4</span><br><span class="line"></span><br><span class="line">1.5.3 用于保持跨版本兼容性的常用工具和技术 6</span><br><span class="line"></span><br><span class="line">1.6 不只是CPython 9</span><br><span class="line"></span><br><span class="line">1.6.1 为什么要关注Python实现 10</span><br><span class="line"></span><br><span class="line">1.6.2 Stackless Python 10</span><br><span class="line"></span><br><span class="line">1.6.3 Jython 10</span><br><span class="line"></span><br><span class="line">1.6.4 IronPython 11</span><br><span class="line"></span><br><span class="line">1.6.5 PyPy 11</span><br><span class="line"></span><br><span class="line">1.7 Python开发的现代方法 12</span><br><span class="line"></span><br><span class="line">1.8 应用层Python环境隔离 13</span><br><span class="line"></span><br><span class="line">1.8.1 为什么要隔离 14</span><br><span class="line"></span><br><span class="line">1.8.2 常用解决方案 15</span><br><span class="line"></span><br><span class="line">1.8.3 选择哪种工具 18</span><br><span class="line"></span><br><span class="line">1.9 系统级环境隔离 19</span><br><span class="line"></span><br><span class="line">1.9.1 使用Vagrant的虚拟开发环境 20</span><br><span class="line"></span><br><span class="line">1.9.2 容器化与虚拟化的对比 21</span><br><span class="line"></span><br><span class="line">1.10 常用的生产力工具 21</span><br><span class="line"></span><br><span class="line">1.10.1 自定义Python shell— IPython、bpython、 ptpython等 22</span><br><span class="line"></span><br><span class="line">1.10.2 交互式调试器 24</span><br><span class="line"></span><br><span class="line">1.11 有用的资源 25</span><br><span class="line"></span><br><span class="line">1.12 小结 25</span><br><span class="line"></span><br><span class="line">第2章 语法最佳实践——类级别以下 26</span><br><span class="line"></span><br><span class="line">2.1 Python的内置类型 26</span><br><span class="line"></span><br><span class="line">2.1.1 字符串与字节 27</span><br><span class="line"></span><br><span class="line">2.1.2 集合类型 30</span><br><span class="line"></span><br><span class="line">2.2 高级语法 39</span><br><span class="line"></span><br><span class="line">2.2.1 迭代器 40</span><br><span class="line"></span><br><span class="line">2.2.2 yield语句 41</span><br><span class="line"></span><br><span class="line">2.2.3 装饰器 44</span><br><span class="line"></span><br><span class="line">2.2.4 上下文管理器—with语句 54</span><br><span class="line"></span><br><span class="line">2.3 你可能还不知道的其他语法元素 58</span><br><span class="line"></span><br><span class="line">2.3.1 for...else...语句 58</span><br><span class="line"></span><br><span class="line">2.3.2 函数注解 59</span><br><span class="line"></span><br><span class="line">2.4 小结 60</span><br><span class="line"></span><br><span class="line">第3章 语法最佳实践—类级别以上 61</span><br><span class="line"></span><br><span class="line">3.1 子类化内置类型 61</span><br><span class="line"></span><br><span class="line">3.2 访问超类中的方法 63</span><br><span class="line"></span><br><span class="line">3.2.1 Python 2中的旧式类与super 65</span><br><span class="line"></span><br><span class="line">3.2.2 理解Python的方法解析顺序 66</span><br><span class="line"></span><br><span class="line">3.2.3 使用super易犯的错误 70</span><br><span class="line"></span><br><span class="line">3.2.4 最佳实践 73</span><br><span class="line"></span><br><span class="line">3.3 高级属性访问模式 73</span><br><span class="line"></span><br><span class="line">3.3.1 描述符 74</span><br><span class="line"></span><br><span class="line">3.3.2 property 79</span><br><span class="line"></span><br><span class="line">3.3.3 槽 81</span><br><span class="line"></span><br><span class="line">3.4 元编程 82</span><br><span class="line"></span><br><span class="line">3.4.1 装饰器— 一种元编程方法 83</span><br><span class="line"></span><br><span class="line">3.4.2 类装饰器 83</span><br><span class="line"></span><br><span class="line">3.4.3 使用__new__()方法覆写实例创建过程 85</span><br><span class="line"></span><br><span class="line">3.4.4 元类 87</span><br><span class="line"></span><br><span class="line">3.4.5 一些关于代码生成的提示 94</span><br><span class="line"></span><br><span class="line">3.5 小结 100</span><br><span class="line"></span><br><span class="line">第4章 选择好的名称 101</span><br><span class="line"></span><br><span class="line">4.1 PEP 8与命名最佳实践 101</span><br><span class="line"></span><br><span class="line">4.1.1 为何要遵守PEP 8以及何时遵守PEP 8 101</span><br><span class="line"></span><br><span class="line">4.1.2 超越PEP 8—团队的风格指南 102</span><br><span class="line"></span><br><span class="line">4.2 命名风格 102</span><br><span class="line"></span><br><span class="line">4.3 命名指南 110</span><br><span class="line"></span><br><span class="line">4.3.1 用“has”或“is”前缀命名布尔元素 111</span><br><span class="line"></span><br><span class="line">4.3.2 用复数形式命名集合变量 111</span><br><span class="line"></span><br><span class="line">4.3.3 用显式名称命名字典 111</span><br><span class="line"></span><br><span class="line">4.3.4 避免通用名称 111</span><br><span class="line"></span><br><span class="line">4.3.5 避免现有名称 112</span><br><span class="line"></span><br><span class="line">4.4 参数的最佳实践 113</span><br><span class="line"></span><br><span class="line">4.4.1 通过迭代设计构建参数 113</span><br><span class="line"></span><br><span class="line">4.4.2 信任参数和测试 114</span><br><span class="line"></span><br><span class="line">4.4.3 小心使用*args和**kwargs魔法参数 115</span><br><span class="line"></span><br><span class="line">4.5 类的名称 117</span><br><span class="line"></span><br><span class="line">4.6 模块和包的名称 117</span><br><span class="line"></span><br><span class="line">4.7 有用的工具 118</span><br><span class="line"></span><br><span class="line">4.7.1 Pylint 118</span><br><span class="line"></span><br><span class="line">4.7.2 pep8和flake8 120</span><br><span class="line"></span><br><span class="line">4.8 小结 120</span><br><span class="line"></span><br><span class="line">第5章 编写一个包 121</span><br><span class="line"></span><br><span class="line">5.1 创建一个包 121</span><br><span class="line"></span><br><span class="line">5.1.1 Python打包工具的混乱状态 122</span><br><span class="line"></span><br><span class="line">5.1.2 项目配置 123</span><br><span class="line"></span><br><span class="line">5.1.3 自定义setup命令 131</span><br><span class="line"></span><br><span class="line">5.1.4 在开发期间使用包 132</span><br><span class="line"></span><br><span class="line">5.2 命名空间包 133</span><br><span class="line"></span><br><span class="line">5.2.1 为什么有用 133</span><br><span class="line"></span><br><span class="line">5.2.2 PEP 420—隐式命名空间包 135</span><br><span class="line"></span><br><span class="line">5.2.3 以前Python版本中的命名空间包 136</span><br><span class="line"></span><br><span class="line">5.3 上传一个包 137</span><br><span class="line"></span><br><span class="line">5.3.1 PyPI—Python包索引 137</span><br><span class="line"></span><br><span class="line">5.3.2 源代码包与构建包 139</span><br><span class="line"></span><br><span class="line">5.4 独立可执行文件 142</span><br><span class="line"></span><br><span class="line">5.4.1 独立可执行文件何时有用 143</span><br><span class="line"></span><br><span class="line">5.4.2 常用工具 143</span><br><span class="line"></span><br><span class="line">5.4.3 可执行包中Python代码的安全性 150</span><br><span class="line"></span><br><span class="line">5.5 小结 151</span><br><span class="line"></span><br><span class="line">第6章 部署代码 152</span><br><span class="line"></span><br><span class="line">6.1 十二要素应用 152</span><br><span class="line"></span><br><span class="line">6.2 用Fabric进行自动化部署 154</span><br><span class="line"></span><br><span class="line">6.3 你自己的包索引或索引镜像 158</span><br><span class="line"></span><br><span class="line">6.3.1 PyPI镜像 159</span><br><span class="line"></span><br><span class="line">6.3.2 使用包进行部署 160</span><br><span class="line"></span><br><span class="line">6.4 常见约定与实践 168</span><br><span class="line"></span><br><span class="line">6.4.1 文件系统层次结构 168</span><br><span class="line"></span><br><span class="line">6.4.2 隔离 168</span><br><span class="line"></span><br><span class="line">6.4.3 使用进程管理工具 169</span><br><span class="line"></span><br><span class="line">6.4.4 应该在用户空间运行应用代码 170</span><br><span class="line"></span><br><span class="line">6.4.5 使用HTTP反向代理 171</span><br><span class="line"></span><br><span class="line">6.4.6 优雅地重新加载进程 171</span><br><span class="line"></span><br><span class="line">6.5 代码检测与监控 172</span><br><span class="line"></span><br><span class="line">6.5.1 记录错误—sentry&#x2F;raven 173</span><br><span class="line"></span><br><span class="line">6.5.2 监控系统与应用指标 175</span><br><span class="line"></span><br><span class="line">6.5.3 处理应用日志 177</span><br><span class="line"></span><br><span class="line">6.6 小结 181</span><br><span class="line"></span><br><span class="line">第7章 使用其他语言开发Python扩展 182</span><br><span class="line"></span><br><span class="line">7.1 使用C或者C++编写扩展 182</span><br><span class="line"></span><br><span class="line">7.2 为什么你想用扩展 184</span><br><span class="line"></span><br><span class="line">7.2.1 提高关键代码段的性能 185</span><br><span class="line"></span><br><span class="line">7.2.2 集成现有的使用不同语言编写的代码 185</span><br><span class="line"></span><br><span class="line">7.2.3 集成第三方动态库 185</span><br><span class="line"></span><br><span class="line">7.2.4 创建自定义数据类型 186</span><br><span class="line"></span><br><span class="line">7.3 编写扩展 186</span><br><span class="line"></span><br><span class="line">7.3.1 纯C扩展 187</span><br><span class="line"></span><br><span class="line">7.3.2 Cython 201</span><br><span class="line"></span><br><span class="line">7.4 挑战 205</span><br><span class="line"></span><br><span class="line">7.4.1 额外的复杂性 205</span><br><span class="line"></span><br><span class="line">7.4.2 调试 206</span><br><span class="line"></span><br><span class="line">7.5 无扩展的动态库接口 206</span><br><span class="line"></span><br><span class="line">7.5.1 ctypes 207</span><br><span class="line"></span><br><span class="line">7.5.2 CFFI 212</span><br><span class="line"></span><br><span class="line">7.6 小结 214</span><br><span class="line"></span><br><span class="line">第8章 管理代码 215</span><br><span class="line"></span><br><span class="line">8.1 版本控制系统 215</span><br><span class="line"></span><br><span class="line">8.1.1 集中式系统 215</span><br><span class="line"></span><br><span class="line">8.1.2 分布式系统 217</span><br><span class="line"></span><br><span class="line">8.1.3 集中式还是分布式 219</span><br><span class="line"></span><br><span class="line">8.1.4 尽可能使用Git 219</span><br><span class="line"></span><br><span class="line">8.1.5 Git工作流程与GitHub工作流程 220</span><br><span class="line"></span><br><span class="line">8.2 持续的开发过程 223</span><br><span class="line"></span><br><span class="line">8.2.1 持续集成 224</span><br><span class="line"></span><br><span class="line">8.2.2 持续交付 227</span><br><span class="line"></span><br><span class="line">8.2.3 持续部署 227</span><br><span class="line"></span><br><span class="line">8.2.4 常用的持续集成工具 228</span><br><span class="line"></span><br><span class="line">8.2.5 选择正确的工具和常见的陷阱 234</span><br><span class="line"></span><br><span class="line">8.3 小结 236</span><br><span class="line"></span><br><span class="line">第9章 文档化你的项目 237</span><br><span class="line"></span><br><span class="line">9.1 7项技术写作规则 237</span><br><span class="line"></span><br><span class="line">9.1.1 两步写作 238</span><br><span class="line"></span><br><span class="line">9.1.2 定位读者 238</span><br><span class="line"></span><br><span class="line">9.1.3 使用简单的风格 239</span><br><span class="line"></span><br><span class="line">9.1.4 限制信息范围 240</span><br><span class="line"></span><br><span class="line">9.1.5 使用现实中的代码示例 240</span><br><span class="line"></span><br><span class="line">9.1.6 使用轻量且充分的方法 241</span><br><span class="line"></span><br><span class="line">9.1.7 使用模板 241</span><br><span class="line"></span><br><span class="line">9.2 reStructuredText入门 242</span><br><span class="line"></span><br><span class="line">9.2.1 章节结构 243</span><br><span class="line"></span><br><span class="line">9.2.2 列表 245</span><br><span class="line"></span><br><span class="line">9.2.3 行内标记 246</span><br><span class="line"></span><br><span class="line">9.2.4 文字块 246</span><br><span class="line"></span><br><span class="line">9.2.5 链接 247</span><br><span class="line"></span><br><span class="line">9.3 构建文档 248</span><br><span class="line"></span><br><span class="line">9.4 构建自己的文档集 254</span><br><span class="line"></span><br><span class="line">9.4.1 构建格局 254</span><br><span class="line"></span><br><span class="line">9.4.2 文档构建与持续集成 259</span><br><span class="line"></span><br><span class="line">9.5 小结 260</span><br><span class="line"></span><br><span class="line">第10章 测试驱动开发 261</span><br><span class="line"></span><br><span class="line">10.1 我不测试 261</span><br><span class="line"></span><br><span class="line">10.1.1 测试开发的原则 261</span><br><span class="line"></span><br><span class="line">10.1.2 什么样的测试 265</span><br><span class="line"></span><br><span class="line">10.1.3 达式Python标准测试工具 268</span><br><span class="line"></span><br><span class="line">10.2 我做测试 273</span><br><span class="line"></span><br><span class="line">10.2.1 unittest陷阱 273</span><br><span class="line"></span><br><span class="line">10.2.2 unittest的替代品 274</span><br><span class="line"></span><br><span class="line">10.2.3 测试覆盖率 280</span><br><span class="line"></span><br><span class="line">10.2.4 仿真与模拟 282</span><br><span class="line"></span><br><span class="line">10.2.5 测试环境与依赖兼容性 289</span><br><span class="line"></span><br><span class="line">10.2.6 文档驱动开发 292</span><br><span class="line"></span><br><span class="line">10.3 小结 294</span><br><span class="line"></span><br><span class="line">第11章 优化——一般原则与分析技术 295</span><br><span class="line"></span><br><span class="line">11.1 3个优化规则 295</span><br><span class="line"></span><br><span class="line">11.1.1 首先要能工作 295</span><br><span class="line"></span><br><span class="line">11.1.2 从用户的角度考虑 296</span><br><span class="line"></span><br><span class="line">11.1.3 保持代码的可读性和可维护性 297</span><br><span class="line"></span><br><span class="line">11.2 优化策略 297</span><br><span class="line"></span><br><span class="line">11.2.1 找到另外的罪魁祸首 297</span><br><span class="line"></span><br><span class="line">11.2.2 扩展硬件 298</span><br><span class="line"></span><br><span class="line">11.2.3 编写速度测试 298</span><br><span class="line"></span><br><span class="line">11.3 查找瓶颈 299</span><br><span class="line"></span><br><span class="line">11.3.1 分析CPU使用情况 299</span><br><span class="line"></span><br><span class="line">11.3.2 分析内存使用 307</span><br><span class="line"></span><br><span class="line">11.3.3 分析网络使用情况 315</span><br><span class="line"></span><br><span class="line">11.4 小结 316</span><br><span class="line"></span><br><span class="line">第12章 优化——一些强大的技术 317</span><br><span class="line"></span><br><span class="line">第13章 并发 339</span><br><span class="line"></span><br><span class="line">第14章 有用的设计模式 376</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python编程入门经典 PDF</title>
    <url>/posts/4fa73a81/</url>
    <content><![CDATA[<h4 id="《Python编程入门经典》"><a href="#《Python编程入门经典》" class="headerlink" title="《Python编程入门经典》"></a>《Python编程入门经典》</h4><h6 id="链接-https-pan-baidu-com-s-10r-ljM2oHNKQogsiOGknJQ-提取码-g4pr"><a href="#链接-https-pan-baidu-com-s-10r-ljM2oHNKQogsiOGknJQ-提取码-g4pr" class="headerlink" title="链接: https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ 提取码: g4pr"></a>链接: <a href="https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ">https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ</a> 提取码: g4pr</h6><p>《Python入门经典：以解决计算问题为导向的Python编程实践》是一本系统而科学的Python入门教程，美国密歇根州立大学等多所美国知名高校采用其作为编程语言的入门教材，被奉为经典。它不仅从计算机教学和计算机科学的角度讲解了初学者如何才能更有效地去学习Python，而且特别强调用Python解决生活中的实际问题，精心组织了大量来源于生活中不同领域的与数值计算和数据处理相关的案例。通过本书，读者不仅能系统掌握Python编程相关的知识，而且还能掌握利用Python处理各种与数据相关的问题。本书分为五部分，部分介绍计算机设备的一般概念和一些计算机术语；第二部分开始介绍编程的基本知识，包括入门知识和控制语句，为后续内容做铺垫；第三部分讲述数据结构和函数，包括字符串、列表和元组、字典和集合、文件、函数、算法和程序等进阶内容，有助于读者提升编程技能；第四部分重点介绍如何使用类定义数据结构和算法、开发程序等，培养读者运用Python语言来实现基本的计算思想和策略的能力；第五部分主要介绍异常、测试和递归，旨在使读者成为更好的程序员。本书深入浅出，每一章节均给出了大量的实例、示范代码和自测练习，便于读者理解和掌握相关知识。读者通过学习本书，不仅能掌握Python语言的基本知识，还能学习如何在实践中运用该语言解决问题。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《Python入门经典：以解决计算问题为导向的Python编程实践》</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">*部分关于计算机的思考</span><br><span class="line"></span><br><span class="line">第0章计算机科学研究</span><br><span class="line"></span><br><span class="line">0.1为什么要研究计算机科学</span><br><span class="line"></span><br><span class="line">0.1.1计算机科学的重要性</span><br><span class="line"></span><br><span class="line">0.1.2计算机“科学”</span><br><span class="line"></span><br><span class="line">0.1.3通过编程学习计算机科学</span><br><span class="line"></span><br><span class="line">0.2编程的困难和使命</span><br><span class="line"></span><br><span class="line">0.2.1困难1：同时做两件事</span><br><span class="line"></span><br><span class="line">0.2.2困难2：什么是好程序</span><br><span class="line"></span><br><span class="line">0.2.3程序的使命</span><br><span class="line"></span><br><span class="line">0.3选择一种计算机语言</span><br><span class="line"></span><br><span class="line">0.3.1各种计算机语言</span><br><span class="line"></span><br><span class="line">0.3.2为什么选Python</span><br><span class="line"></span><br><span class="line">0.3.3Python是*好的程序语言吗</span><br><span class="line"></span><br><span class="line">0.4什么是计算</span><br><span class="line"></span><br><span class="line">0.5什么是计算机</span><br><span class="line"></span><br><span class="line">0.5.1自然界中的计算</span><br><span class="line"></span><br><span class="line">0.5.2人类制造的计算机</span><br><span class="line"></span><br><span class="line">0.6现代电子计算机</span><br><span class="line"></span><br><span class="line">0.6.1就是开关</span><br><span class="line"></span><br><span class="line">0.6.2晶体管</span><br><span class="line"></span><br><span class="line">0.7从更高层面来了解现代计算机</span><br><span class="line"></span><br><span class="line">0.8数据表示</span><br><span class="line"></span><br><span class="line">0.8.1二进制数据</span><br><span class="line"></span><br><span class="line">0.8.2使用二进制</span><br><span class="line"></span><br><span class="line">0.8.3局限性</span><br><span class="line"></span><br><span class="line">0.8.4字符表示</span><br><span class="line"></span><br><span class="line">0.8.5其他数据表示</span><br><span class="line"></span><br><span class="line">0.8.6数字代表什么</span><br><span class="line"></span><br><span class="line">0.8.7数据量</span><br><span class="line"></span><br><span class="line">0.8.8数据量有多大</span><br><span class="line"></span><br><span class="line">0.9后续章节概述</span><br><span class="line"></span><br><span class="line">0.10总结</span><br><span class="line"></span><br><span class="line">第二部分开始编程</span><br><span class="line"></span><br><span class="line">第1章入门</span><br><span class="line"></span><br><span class="line">1.1练习，练习，再练习</span><br><span class="line"></span><br><span class="line">1.2快速入门——计算圆周长的程序</span><br><span class="line"></span><br><span class="line">1.3交互式会话</span><br><span class="line"></span><br><span class="line">1.4程序组成部分</span><br><span class="line"></span><br><span class="line">1.4.1模块</span><br><span class="line"></span><br><span class="line">1.4.2表达式和语句</span><br><span class="line"></span><br><span class="line">1.4.3空白</span><br><span class="line"></span><br><span class="line">1.4.4注释</span><br><span class="line"></span><br><span class="line">1.4.5Python 的特殊元素：标记</span><br><span class="line"></span><br><span class="line">1.4.6对象命名</span><br><span class="line"></span><br><span class="line">1.5变量</span><br><span class="line"></span><br><span class="line">1.6对象和类型</span><br><span class="line"></span><br><span class="line">1.6.1数字</span><br><span class="line"></span><br><span class="line">1.6.2其他内置类型</span><br><span class="line"></span><br><span class="line">1.6.3对象类型：非变量类型</span><br><span class="line"></span><br><span class="line">1.6.4创建新值</span><br><span class="line"></span><br><span class="line">1.7运算符</span><br><span class="line"></span><br><span class="line">1.7.1整数运算符</span><br><span class="line"></span><br><span class="line">1.7.2浮点运算符</span><br><span class="line"></span><br><span class="line">1.7.3混合运算符</span><br><span class="line"></span><br><span class="line">1.7.4运算符顺序和圆括号</span><br><span class="line"></span><br><span class="line">1.7.5增强的赋值运算符：快捷方式</span><br><span class="line"></span><br><span class="line">1.8*个模块：math模块</span><br><span class="line"></span><br><span class="line">1.9开发算法</span><br><span class="line"></span><br><span class="line">1.10总结</span><br><span class="line"></span><br><span class="line">1.11视觉场景：海龟绘图</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第2章控制语句</span><br><span class="line"></span><br><span class="line">2.1选择语句：if</span><br><span class="line"></span><br><span class="line">2.1.1利用布尔值做决定</span><br><span class="line"></span><br><span class="line">2.1.2if 语句</span><br><span class="line"></span><br><span class="line">2.1.3示例：在篮球运动中，领先多少分才安全</span><br><span class="line"></span><br><span class="line">2.1.4循环</span><br><span class="line"></span><br><span class="line">2.1.5例子：寻找完全数</span><br><span class="line"></span><br><span class="line">2.1.6例子：对数字分类</span><br><span class="line"></span><br><span class="line">2.2深入控制语句</span><br><span class="line"></span><br><span class="line">2.2.1真与假：布尔值</span><br><span class="line"></span><br><span class="line">2.2.2布尔变量</span><br><span class="line"></span><br><span class="line">2.2.3关系运算符</span><br><span class="line"></span><br><span class="line">2.2.4布尔运算符</span><br><span class="line"></span><br><span class="line">2.2.5优先级</span><br><span class="line"></span><br><span class="line">2.2.6布尔运算符示例</span><br><span class="line"></span><br><span class="line">2.2.7另一种赋值方式</span><br><span class="line"></span><br><span class="line">2.2.8用于判定的选择语句</span><br><span class="line"></span><br><span class="line">2.2.9Python判定语句进阶</span><br><span class="line"></span><br><span class="line">2.2.10循环：while语句</span><br><span class="line"></span><br><span class="line">2.2.11信号量循环</span><br><span class="line"></span><br><span class="line">2.2.12循环总结</span><br><span class="line"></span><br><span class="line">2.2.13for语句进阶</span><br><span class="line"></span><br><span class="line">2.2.14嵌套</span><br><span class="line"></span><br><span class="line">2.2.15冰雹序列示例</span><br><span class="line"></span><br><span class="line">2.3视觉场景：用pylab对数据绘图</span><br><span class="line"></span><br><span class="line">2.3.1使用列表和*次绘制</span><br><span class="line"></span><br><span class="line">2.3.2更有趣的绘图：正弦波</span><br><span class="line"></span><br><span class="line">2.4计算机科学观点：*小的通用计算</span><br><span class="line"></span><br><span class="line">2.5总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第3章算法和程序开发</span><br><span class="line"></span><br><span class="line">3.1什么是算法</span><br><span class="line"></span><br><span class="line">3.2算法特征</span><br><span class="line"></span><br><span class="line">3.2.1算法和程序</span><br><span class="line"></span><br><span class="line">3.2.2细化</span><br><span class="line"></span><br><span class="line">3.2.3有效性</span><br><span class="line"></span><br><span class="line">3.2.4指定行为</span><br><span class="line"></span><br><span class="line">3.2.5通用算法</span><br><span class="line"></span><br><span class="line">3.2.6真的可以实现一切吗</span><br><span class="line"></span><br><span class="line">3.3程序是什么</span><br><span class="line"></span><br><span class="line">3.3.1可读性</span><br><span class="line"></span><br><span class="line">3.2.2鲁棒性</span><br><span class="line"></span><br><span class="line">3.3.3正确性</span><br><span class="line"></span><br><span class="line">3.4程序设计策略</span><br><span class="line"></span><br><span class="line">3.4.1参与并提交</span><br><span class="line"></span><br><span class="line">3.4.2了解，然后想象</span><br><span class="line"></span><br><span class="line">3.4.3编程之前先思考</span><br><span class="line"></span><br><span class="line">3.4.4实验</span><br><span class="line"></span><br><span class="line">3.4.5简化</span><br><span class="line"></span><br><span class="line">3.4.6停下来思考</span><br><span class="line"></span><br><span class="line">3.4.7放松：让自己休息一下</span><br><span class="line"></span><br><span class="line">3.5简单示例</span><br><span class="line"></span><br><span class="line">3.5.1搭建框架</span><br><span class="line"></span><br><span class="line">3.5.2输出</span><br><span class="line"></span><br><span class="line">3.5.3输入</span><br><span class="line"></span><br><span class="line">3.5.4计算</span><br><span class="line"></span><br><span class="line">3.6总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">第三部分组织：数据结构和函数</span><br><span class="line"></span><br><span class="line">第4章字符串</span><br><span class="line"></span><br><span class="line">4.1字符串类型</span><br><span class="line"></span><br><span class="line">4.1.1三重引号字符串</span><br><span class="line"></span><br><span class="line">4.1.2非显示字符</span><br><span class="line"></span><br><span class="line">4.1.3字符串表示形式</span><br><span class="line"></span><br><span class="line">4.1.4字符序列</span><br><span class="line"></span><br><span class="line">4.1.5索引和分片</span><br><span class="line"></span><br><span class="line">4.2字符串操作</span><br><span class="line"></span><br><span class="line">4.2.1连接（+）和重复（*）</span><br><span class="line"></span><br><span class="line">4.2.2“+”什么时候表示加法运算，什么时候表示连接运算</span><br><span class="line"></span><br><span class="line">4.2.3比较运算符</span><br><span class="line"></span><br><span class="line">4.2.4in运算符</span><br><span class="line"></span><br><span class="line">4.2.5字符串集合是不可变的</span><br><span class="line"></span><br><span class="line">4.3函数和方法预览</span><br><span class="line"></span><br><span class="line">4.3.1*步：什么是函数</span><br><span class="line"></span><br><span class="line">4.3.2选择方法的名字和参数</span><br><span class="line"></span><br><span class="line">4.3.3字符串方法</span><br><span class="line"></span><br><span class="line">4.3.4字符串函数</span><br><span class="line"></span><br><span class="line">4.4字符串的格式化输出</span><br><span class="line"></span><br><span class="line">4.4.1描述符码</span><br><span class="line"></span><br><span class="line">4.4.2宽度描述符</span><br><span class="line"></span><br><span class="line">4.4.3浮点数精度描述符</span><br><span class="line"></span><br><span class="line">4.5字符串与控制语句</span><br><span class="line"></span><br><span class="line">4.6处理字符串</span><br><span class="line"></span><br><span class="line">4.6.1示例：记录人名</span><br><span class="line"></span><br><span class="line">4.6.2回文</span><br><span class="line"></span><br><span class="line">4.7示例：计算扑克牌</span><br><span class="line"></span><br><span class="line">4.8总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第5章函数快速入门</span><br><span class="line"></span><br><span class="line">5.1函数是什么</span><br><span class="line"></span><br><span class="line">5.2Python 函数</span><br><span class="line"></span><br><span class="line">5.3函数控制语句</span><br><span class="line"></span><br><span class="line">5.3.1函数控制语句详解</span><br><span class="line"></span><br><span class="line">5.3.2另一个函数示例</span><br><span class="line"></span><br><span class="line">5.3.3函数示例：猜词</span><br><span class="line"></span><br><span class="line">5.3.4函数调用函数</span><br><span class="line"></span><br><span class="line">5.3.5什么时候使用函数</span><br><span class="line"></span><br><span class="line">5.3.6如果没有return语句会如何</span><br><span class="line"></span><br><span class="line">5.3.7如果有多条return语句会如何</span><br><span class="line"></span><br><span class="line">5.4视觉场景：用海龟绘图法绘制美国国旗</span><br><span class="line"></span><br><span class="line">5.5总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第6章列表和元组</span><br><span class="line"></span><br><span class="line">6.1什么是列表</span><br><span class="line"></span><br><span class="line">6.2操作列表</span><br><span class="line"></span><br><span class="line">6.2.1索引和分片</span><br><span class="line"></span><br><span class="line">6.2.2运算符</span><br><span class="line"></span><br><span class="line">6.2.3函数</span><br><span class="line"></span><br><span class="line">6.2.4列表循环</span><br><span class="line"></span><br><span class="line">6.3列表新内容</span><br><span class="line"></span><br><span class="line">6.3.1列表可变性</span><br><span class="line"></span><br><span class="line">6.3.2列表方法</span><br><span class="line"></span><br><span class="line">6.4range、split及其他函数和方法</span><br><span class="line"></span><br><span class="line">6.4.1range、split和多重赋值</span><br><span class="line"></span><br><span class="line">6.4.2使用join在列表和字符串之间转换</span><br><span class="line"></span><br><span class="line">6.4.3sorted 函数</span><br><span class="line"></span><br><span class="line">6.5示例</span><br><span class="line"></span><br><span class="line">6.5.1字谜</span><br><span class="line"></span><br><span class="line">6.5.2示例：文件分析</span><br><span class="line"></span><br><span class="line">6.6可变对象及其引用</span><br><span class="line"></span><br><span class="line">6.6.1深拷贝与浅拷贝</span><br><span class="line"></span><br><span class="line">6.6.2可变与不可变</span><br><span class="line"></span><br><span class="line">6.7元组</span><br><span class="line"></span><br><span class="line">6.7.1从列表到元组</span><br><span class="line"></span><br><span class="line">6.7.2为什么需要元组</span><br><span class="line"></span><br><span class="line">6.8列表：数据结构</span><br><span class="line"></span><br><span class="line">6.8.1数据结构示例</span><br><span class="line"></span><br><span class="line">6.8.2数据结构的另一个示例</span><br><span class="line"></span><br><span class="line">6.9算法示例：美国环境保护署通车里程数据</span><br><span class="line"></span><br><span class="line">6.10列表解析</span><br><span class="line"></span><br><span class="line">6.11视觉场景：更多绘制任务</span><br><span class="line"></span><br><span class="line">6.11.1numpy阵列</span><br><span class="line"></span><br><span class="line">6.11.2绘制三角函数</span><br><span class="line"></span><br><span class="line">6.12总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第7章深入了解函数</span><br><span class="line"></span><br><span class="line">7.1函数调用函数</span><br><span class="line"></span><br><span class="line">7.2作用域</span><br><span class="line"></span><br><span class="line">7.2.1实参、形参和命名空间</span><br><span class="line"></span><br><span class="line">7.2.2传递可变对象</span><br><span class="line"></span><br><span class="line">7.2.3返回复杂对象</span><br><span class="line"></span><br><span class="line">7.2.4重构evens</span><br><span class="line"></span><br><span class="line">7.3默认值以及形参为关键字</span><br><span class="line"></span><br><span class="line">7.3.1示例：默认值和参数关键字</span><br><span class="line"></span><br><span class="line">7.3.2默认值问题</span><br><span class="line"></span><br><span class="line">7.4函数和对象</span><br><span class="line"></span><br><span class="line">7.5示例：确定*终成绩</span><br><span class="line"></span><br><span class="line">7.5.1数据</span><br><span class="line"></span><br><span class="line">7.5.2设计</span><br><span class="line"></span><br><span class="line">7.5.3函数：weightedGrade</span><br><span class="line"></span><br><span class="line">7.5.4函数：grade</span><br><span class="line"></span><br><span class="line">7.5.5函数：main</span><br><span class="line"></span><br><span class="line">7.5.6使用示例</span><br><span class="line"></span><br><span class="line">7.6“传值”或者“传引用”</span><br><span class="line"></span><br><span class="line">7.7总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第8章字典和集合</span><br><span class="line"></span><br><span class="line">8.1字典</span><br><span class="line"></span><br><span class="line">8.1.1字典示例</span><br><span class="line"></span><br><span class="line">8.1.2Python 字典</span><br><span class="line"></span><br><span class="line">8.1.3字典索引和赋值</span><br><span class="line"></span><br><span class="line">8.1.4运算符</span><br><span class="line"></span><br><span class="line">8.2单词计数示例</span><br><span class="line"></span><br><span class="line">8.2.1统计字符串中的单词数</span><br><span class="line"></span><br><span class="line">8.2.2《葛底斯堡演说》中的单词出现频率</span><br><span class="line"></span><br><span class="line">8.2.3输出和注释</span><br><span class="line"></span><br><span class="line">8.3示例：周期表</span><br><span class="line"></span><br><span class="line">8.3.1使用CSV文件</span><br><span class="line"></span><br><span class="line">8.3.2算法概述</span><br><span class="line"></span><br><span class="line">8.3.3实现分治的函数</span><br><span class="line"></span><br><span class="line">8.4集合</span><br><span class="line"></span><br><span class="line">8.4.1集合的历史</span><br><span class="line"></span><br><span class="line">8.4.2集合的组成</span><br><span class="line"></span><br><span class="line">8.4.3Python 集合</span><br><span class="line"></span><br><span class="line">8.4.4Python集合的方法、运算符和函数</span><br><span class="line"></span><br><span class="line">8.4.5集合方法</span><br><span class="line"></span><br><span class="line">8.5集合应用</span><br><span class="line"></span><br><span class="line">8.5.1不同文件中单词之间的关系</span><br><span class="line"></span><br><span class="line">8.5.2输出和注释</span><br><span class="line"></span><br><span class="line">8.6作用域：完整的故事</span><br><span class="line"></span><br><span class="line">8.6.1命名空间和作用域</span><br><span class="line"></span><br><span class="line">8.6.2作用域搜寻规则</span><br><span class="line"></span><br><span class="line">8.6.3局部命名空间</span><br><span class="line"></span><br><span class="line">8.6.4全局命名空间</span><br><span class="line"></span><br><span class="line">8.6.5内置模块</span><br><span class="line"></span><br><span class="line">8.6.6封闭式变量</span><br><span class="line"></span><br><span class="line">8.7Python指针：使用zip创建字典</span><br><span class="line"></span><br><span class="line">8.8视觉场景：词频条形图</span><br><span class="line"></span><br><span class="line">8.8.1正确获取数据</span><br><span class="line"></span><br><span class="line">8.8.2标签和xticks命令</span><br><span class="line"></span><br><span class="line">8.8.3绘图</span><br><span class="line"></span><br><span class="line">8.9总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第9章文件</span><br><span class="line"></span><br><span class="line">9.1什么是文件</span><br><span class="line"></span><br><span class="line">9.2存取文件：读取文本文件</span><br><span class="line"></span><br><span class="line">9.2.1其他文件存取方法</span><br><span class="line"></span><br><span class="line">9.2.2数据流</span><br><span class="line"></span><br><span class="line">9.3存取文件：写文本文件</span><br><span class="line"></span><br><span class="line">9.4在程序中存取文本文件</span><br><span class="line"></span><br><span class="line">9.5创建文件和重写文件</span><br><span class="line"></span><br><span class="line">9.5.1通用新行格式</span><br><span class="line"></span><br><span class="line">9.5.2文件内移动</span><br><span class="line"></span><br><span class="line">9.6关闭文件</span><br><span class="line"></span><br><span class="line">9.7CSV文件</span><br><span class="line"></span><br><span class="line">9.7.1CSV模块</span><br><span class="line"></span><br><span class="line">9.7.2CSV Reader</span><br><span class="line"></span><br><span class="line">9.7.3CSV Writer</span><br><span class="line"></span><br><span class="line">9.7.4示例：更新某些成绩</span><br><span class="line"></span><br><span class="line">9.8示例：反复提示，要求输入正确的文件名</span><br><span class="line"></span><br><span class="line">9.9模块：os</span><br><span class="line"></span><br><span class="line">9.9.1目录&#x2F;文件夹的结构</span><br><span class="line"></span><br><span class="line">9.9.2os模块函数</span><br><span class="line"></span><br><span class="line">9.9.3os模块示例</span><br><span class="line"></span><br><span class="line">9.10总结</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">编程项目</span><br><span class="line"></span><br><span class="line">第10章程序开发进阶</span><br><span class="line"></span><br><span class="line">10.1简介</span><br><span class="line"></span><br><span class="line">10.2分治</span><br><span class="line"></span><br><span class="line">10.3乳腺癌分类</span><br><span class="line"></span><br><span class="line">10.3.1...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python编程初学者指南 PDF</title>
    <url>/posts/d1c3af22/</url>
    <content><![CDATA[<h4 id="《Python编程初学者指南》"><a href="#《Python编程初学者指南》" class="headerlink" title="《Python编程初学者指南》"></a>《Python编程初学者指南》</h4><h6 id="链接-https-pan-baidu-com-s-195kd2E0Euy4mIPBFjVlnEw-提取码-k86q"><a href="#链接-https-pan-baidu-com-s-195kd2E0Euy4mIPBFjVlnEw-提取码-k86q" class="headerlink" title="链接: https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw 提取码: k86q"></a>链接: <a href="https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw">https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw</a> 提取码: k86q</h6><p>通过本书，你将会学到：<br><a id="more"></a></p>
<p>字符串的构建、切片和索引；</p>
<p>定义函数；</p>
<p>读写文本文件；</p>
<p>创建并操作sprite；</p>
<p>面向对象编程；</p>
<p>创建GUI；</p>
<p>处理声音和音乐，创建动画。</p>
<p>本书的网站上都有些什么？</p>
<p>Python 3.1.1的Windows安装包。</p>
<p>pygame 1.9.1 for Python 3.1.x的Windows安装包。</p>
<p>livewires游戏引擎。</p>
<p>书中所有完整程序的源码。</p>
<p><img src="/images/9ee69fe8ad0323afe413eae4e73bd9441.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">章 启程：Game Over程序第2章 类型、变量以及简单I&#x2F;O：Useless Trivia程序第3章 条件分支、while循环以及程序策划：Guess My Number游戏第4章 for循环、字符串以及元组：Word Jumble游戏 80第5章 列表和字典：Hangman游戏第6章 函数：Tic-Tac-Toe游戏第7章 文件和异常：Trivia Challenge游戏第8章 软件对象：Critter Caretaker程序第9章 面向对象编程：Blackjack游戏0章 GUI开发：Mad Lib程序1章 图形图像：Pizza Panic游戏2章 声音、动画以及程序开发：Astrocrash游戏附录A 配套网站附录B livewires参考</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python数据分析与挖掘实战 PDF</title>
    <url>/posts/a6c49fb4/</url>
    <content><![CDATA[<h4 id="《Python数据分析与挖掘实战》"><a href="#《Python数据分析与挖掘实战》" class="headerlink" title="《Python数据分析与挖掘实战》"></a>《Python数据分析与挖掘实战》</h4><h6 id="链接-https-pan-baidu-com-s-1OjNqNn3nNVKXBkHUeZ2mVg-提取码-evbm"><a href="#链接-https-pan-baidu-com-s-1OjNqNn3nNVKXBkHUeZ2mVg-提取码-evbm" class="headerlink" title="链接: https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg 提取码: evbm"></a>链接: <a href="https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg">https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg</a> 提取码: evbm</h6><p>第一部分 基础篇（第1～5章）<br><a id="more"></a></p>
<p>主要讲解了Python数据分析与挖掘的工具和技术理论，包括数据挖掘的基础知识、Python数据挖掘与建模工具、数据挖掘的建模过程，以及挖掘建模的常用算法和原理等内容。</p>
<p>第二部分 实战篇（第6～12章）</p>
<p>通过工程实践案例讲解了数据挖掘技术在金融、航空、零售、能源、制造、电商等行业的应用。在案例组织结构上，本书按照“介绍案例背景与挖掘目标→阐述分析方法与过程→完成模型构建”的顺序进行，在建模过程关键环节，穿插程序实现代码。最后，通过上机实践加深对案例应用中的数据挖掘技术的理解。</p>
<p>第三部分 提高篇（第13章）</p>
<p>重点讲解了基于Python引擎的开源数据挖掘建模平台（TipDM）的功能和使用方法，以航空公司客户价值分析为案例，介绍了如何使用该平台快速搭建数据分析与挖掘工程。</p>
<p>本书不仅提供TipDM这样的上机实践环境，而且还提供配套的案例建模数据、Python源代码、教学PPT。</p>
<p><img src="/images/d7e3b72a207afe3f2939fe1a60faaa121.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">基础篇</span><br><span class="line"></span><br><span class="line">第1章　数据挖掘基础 2</span><br><span class="line"></span><br><span class="line">1.1　某知名连锁餐饮企业的困惑 2</span><br><span class="line"></span><br><span class="line">1.2　从餐饮服务到数据挖掘 4</span><br><span class="line"></span><br><span class="line">1.3　数据挖掘的基本任务 5</span><br><span class="line"></span><br><span class="line">1.4　数据挖掘建模过程 5</span><br><span class="line"></span><br><span class="line">1.4.1　定义挖掘目标 6</span><br><span class="line"></span><br><span class="line">1.4.2　数据取样 6</span><br><span class="line"></span><br><span class="line">1.4.3　数据探索 7</span><br><span class="line"></span><br><span class="line">1.4.4　数据预处理 8</span><br><span class="line"></span><br><span class="line">1.4.5　挖掘建模 8</span><br><span class="line"></span><br><span class="line">1.4.6　模型评价 8</span><br><span class="line"></span><br><span class="line">1.5　常用数据挖掘建模工具 9</span><br><span class="line"></span><br><span class="line">1.6　小结 11</span><br><span class="line"></span><br><span class="line">第2章　Python数据分析简介 12</span><br><span class="line"></span><br><span class="line">2.1　搭建Python开发平台 14</span><br><span class="line"></span><br><span class="line">2.1.1　所要考虑的问题 14</span><br><span class="line"></span><br><span class="line">2.1.2　基础平台的搭建 14</span><br><span class="line"></span><br><span class="line">2.2　Python使用入门 16</span><br><span class="line"></span><br><span class="line">2.2.1　运行方式 16</span><br><span class="line"></span><br><span class="line">2.2.2　基本命令 17</span><br><span class="line"></span><br><span class="line">2.2.3　数据结构 19</span><br><span class="line"></span><br><span class="line">2.2.4　库的导入与添加 24</span><br><span class="line"></span><br><span class="line">2.3　Python数据分析工具 26</span><br><span class="line"></span><br><span class="line">2.3.1　NumPy 27</span><br><span class="line"></span><br><span class="line">2.3.2　SciPy 28</span><br><span class="line"></span><br><span class="line">2.3.3　Matplotlib 29</span><br><span class="line"></span><br><span class="line">2.3.4　pandas 31</span><br><span class="line"></span><br><span class="line">2.3.5　StatsModels 33</span><br><span class="line"></span><br><span class="line">2.3.6　scikit-learn 33</span><br><span class="line"></span><br><span class="line">2.3.7　Keras 34</span><br><span class="line"></span><br><span class="line">2.3.8　Gensim 36</span><br><span class="line"></span><br><span class="line">2.4　配套附件使用设置 37</span><br><span class="line"></span><br><span class="line">2.5　小结 38</span><br><span class="line"></span><br><span class="line">第3章　数据探索 39</span><br><span class="line"></span><br><span class="line">3.1　数据质量分析 39</span><br><span class="line"></span><br><span class="line">3.1.1　缺失值分析 40</span><br><span class="line"></span><br><span class="line">3.1.2　异常值分析 40</span><br><span class="line"></span><br><span class="line">3.1.3　一致性分析 44</span><br><span class="line"></span><br><span class="line">3.2　数据特征分析 44</span><br><span class="line"></span><br><span class="line">3.2.1　分布分析 44</span><br><span class="line"></span><br><span class="line">3.2.2　对比分析 48</span><br><span class="line"></span><br><span class="line">3.2.3　统计量分析 51</span><br><span class="line"></span><br><span class="line">3.2.4　周期性分析 54</span><br><span class="line"></span><br><span class="line">3.2.5　贡献度分析 55</span><br><span class="line"></span><br><span class="line">3.2.6　相关性分析 58</span><br><span class="line"></span><br><span class="line">3.3　Python主要数据探索函数 62</span><br><span class="line"></span><br><span class="line">3.3.1　基本统计特征函数 62</span><br><span class="line"></span><br><span class="line">3.3.2　拓展统计特征函数 66</span><br><span class="line"></span><br><span class="line">3.3.3　统计绘图函数 67</span><br><span class="line"></span><br><span class="line">3.4　小结 74</span><br><span class="line"></span><br><span class="line">第4章　数据预处理 75</span><br><span class="line"></span><br><span class="line">4.1　数据清洗 75</span><br><span class="line"></span><br><span class="line">4.1.1　缺失值处理 75</span><br><span class="line"></span><br><span class="line">4.1.2　异常值处理 80</span><br><span class="line"></span><br><span class="line">4.2　数据集成 80</span><br><span class="line"></span><br><span class="line">4.2.1　实体识别 81</span><br><span class="line"></span><br><span class="line">4.2.2　冗余属性识别 81</span><br><span class="line"></span><br><span class="line">4.2.3　数据变换 81</span><br><span class="line"></span><br><span class="line">4.2.4　简单函数变换 81</span><br><span class="line"></span><br><span class="line">4.2.5　规范化 82</span><br><span class="line"></span><br><span class="line">4.2.6　连续属性离散化 84</span><br><span class="line"></span><br><span class="line">4.2.7　属性构造 87</span><br><span class="line"></span><br><span class="line">4.2.8　小波变换 88</span><br><span class="line"></span><br><span class="line">4.3　数据归约 91</span><br><span class="line"></span><br><span class="line">4.3.1　属性归约 91</span><br><span class="line"></span><br><span class="line">4.3.2　数值归约 95</span><br><span class="line"></span><br><span class="line">4.4　Python主要数据预处理函数 98</span><br><span class="line"></span><br><span class="line">4.5　小结 101</span><br><span class="line"></span><br><span class="line">第5章　挖掘建模 102</span><br><span class="line"></span><br><span class="line">5.1　分类与预测 102</span><br><span class="line"></span><br><span class="line">5.1.1　实现过程 103</span><br><span class="line"></span><br><span class="line">5.1.2　常用的分类与预测算法 103</span><br><span class="line"></span><br><span class="line">5.1.3　回归分析 104</span><br><span class="line"></span><br><span class="line">5.1.4　决策树 108</span><br><span class="line"></span><br><span class="line">5.1.5　人工神经网络 115</span><br><span class="line"></span><br><span class="line">5.1.6　分类与预测算法评价 120</span><br><span class="line"></span><br><span class="line">5.1.7　Python分类预测模型特点 125</span><br><span class="line"></span><br><span class="line">5.2　聚类分析 125</span><br><span class="line"></span><br><span class="line">5.2.1　常用聚类分析算法 126</span><br><span class="line"></span><br><span class="line">5.2.2　K-Means聚类算法 127</span><br><span class="line"></span><br><span class="line">5.2.3　聚类分析算法评价 132</span><br><span class="line"></span><br><span class="line">5.2.4　Python主要聚类分析算法 133</span><br><span class="line"></span><br><span class="line">5.3　关联规则 135</span><br><span class="line"></span><br><span class="line">5.3.1　常用关联规则算法 136</span><br><span class="line"></span><br><span class="line">5.3.2　Apriori算法 136</span><br><span class="line"></span><br><span class="line">5.4　时序模式 142</span><br><span class="line"></span><br><span class="line">5.4.1　时间序列算法 142</span><br><span class="line"></span><br><span class="line">5.4.2　时间序列的预处理 143</span><br><span class="line"></span><br><span class="line">5.4.3　平稳时间序列分析 145</span><br><span class="line"></span><br><span class="line">5.4.4　非平稳时间序列分析 148</span><br><span class="line"></span><br><span class="line">5.4.5　Python主要时序模式算法 156</span><br><span class="line"></span><br><span class="line">5.5　离群点检测 159</span><br><span class="line"></span><br><span class="line">5.5.1　离群点的成因及类型 160</span><br><span class="line"></span><br><span class="line">5.5.2　离群点检测方法 160</span><br><span class="line"></span><br><span class="line">5.5.3　基于模型的离群点检测方法 161</span><br><span class="line"></span><br><span class="line">5.5.4　基于聚类的离群点检测方法 164</span><br><span class="line"></span><br><span class="line">5.6　小结 167</span><br><span class="line"></span><br><span class="line">实战篇</span><br><span class="line"></span><br><span class="line">第6章　财政收入影响因素分析及预测 170</span><br><span class="line"></span><br><span class="line">6.1　背景与挖掘目标 170</span><br><span class="line"></span><br><span class="line">6.2　分析方法与过程 171</span><br><span class="line"></span><br><span class="line">6.2.1　分析步骤与流程 172</span><br><span class="line"></span><br><span class="line">6.2.2　数据探索分析 172</span><br><span class="line"></span><br><span class="line">6.2.3　数据预处理 176</span><br><span class="line"></span><br><span class="line">6.2.4　模型构建 178</span><br><span class="line"></span><br><span class="line">6.3　上机实验 184</span><br><span class="line"></span><br><span class="line">6.4　拓展思考 185</span><br><span class="line"></span><br><span class="line">6.5　小结 186</span><br><span class="line"></span><br><span class="line">第7章　航空公司客户价值分析 187</span><br><span class="line"></span><br><span class="line">7.1　背景与挖掘目标 187</span><br><span class="line"></span><br><span class="line">7.2　分析方法与过程 188</span><br><span class="line"></span><br><span class="line">7.2.1　分析步骤与流程 189</span><br><span class="line"></span><br><span class="line">7.2.2　数据探索分析 189</span><br><span class="line"></span><br><span class="line">7.2.3　数据预处理 200</span><br><span class="line"></span><br><span class="line">7.2.4　模型构建 207</span><br><span class="line"></span><br><span class="line">7.2.5　模型应用 212</span><br><span class="line"></span><br><span class="line">7.3　上机实验 214</span><br><span class="line"></span><br><span class="line">7.4　拓展思考 215</span><br><span class="line"></span><br><span class="line">7.5　小结 216</span><br><span class="line"></span><br><span class="line">第8章　商品零售购物篮分析 217</span><br><span class="line"></span><br><span class="line">8.1　背景与挖掘目标 217</span><br><span class="line"></span><br><span class="line">8.2　分析方法与过程 218</span><br><span class="line"></span><br><span class="line">8.2.1　数据探索分析 219</span><br><span class="line"></span><br><span class="line">8.2.2　数据预处理 224</span><br><span class="line"></span><br><span class="line">8.2.3　模型构建 226</span><br><span class="line"></span><br><span class="line">8.3　上机实验 232</span><br><span class="line"></span><br><span class="line">8.4　拓展思考 233</span><br><span class="line"></span><br><span class="line">8.5　小结 233</span><br><span class="line"></span><br><span class="line">第9章　基于水色图像的水质评价 234</span><br><span class="line"></span><br><span class="line">9.1　背景与挖掘目标 234</span><br><span class="line"></span><br><span class="line">9.2　分析方法与过程 235</span><br><span class="line"></span><br><span class="line">9.2.1　分析步骤与流程 236</span><br><span class="line"></span><br><span class="line">9.2.2　数据预处理 236</span><br><span class="line"></span><br><span class="line">9.2.3　模型构建 240</span><br><span class="line"></span><br><span class="line">9.2.4　水质评价 241</span><br><span class="line"></span><br><span class="line">9.3　上机实验 242</span><br><span class="line"></span><br><span class="line">9.4　拓展思考 242</span><br><span class="line"></span><br><span class="line">9.5　小结 243</span><br><span class="line"></span><br><span class="line">第10章　家用热水器用户行为分析与事件识别 244</span><br><span class="line"></span><br><span class="line">10.1　背景与挖掘目标 244</span><br><span class="line"></span><br><span class="line">10.2　分析方法与过程 245</span><br><span class="line"></span><br><span class="line">10.2.1　数据探索分析 246</span><br><span class="line"></span><br><span class="line">10.2.2　数据预处理 249</span><br><span class="line"></span><br><span class="line">10.2.3　模型构建 260</span><br><span class="line"></span><br><span class="line">10.2.4　模型检验 261</span><br><span class="line"></span><br><span class="line">10.3　上机实验 262</span><br><span class="line"></span><br><span class="line">10.4　拓展思考 264</span><br><span class="line"></span><br><span class="line">10.5　小结 265</span><br><span class="line"></span><br><span class="line">第11章　电子商务网站用户行为分析及服务推荐 266</span><br><span class="line"></span><br><span class="line">11.1　背景与挖掘目标 266</span><br><span class="line"></span><br><span class="line">11.2　分析方法与过程 267</span><br><span class="line"></span><br><span class="line">11.2.1　分析步骤与流程 267</span><br><span class="line"></span><br><span class="line">11.2.2　数据抽取 269</span><br><span class="line"></span><br><span class="line">11.2.3　数据探索分析 270</span><br><span class="line"></span><br><span class="line">11.2.4　数据预处理 279</span><br><span class="line"></span><br><span class="line">11.2.5　构建智能推荐模型 283</span><br><span class="line"></span><br><span class="line">11.3　上机实验 291</span><br><span class="line"></span><br><span class="line">11.4　拓展思考 293</span><br><span class="line"></span><br><span class="line">11.5　小结 293</span><br><span class="line"></span><br><span class="line">第12章　电商产品评论数据情感分析 294</span><br><span class="line"></span><br><span class="line">12.1　背景与挖掘目标 294</span><br><span class="line"></span><br><span class="line">12.2　分析方法与过程 295</span><br><span class="line"></span><br><span class="line">12.2.1　评论预处理 296</span><br><span class="line"></span><br><span class="line">12.2.2　评论分词 297</span><br><span class="line"></span><br><span class="line">12.2.3　构建模型 303</span><br><span class="line"></span><br><span class="line">12.3　上机实验 315</span><br><span class="line"></span><br><span class="line">12.4　拓展思考 316</span><br><span class="line"></span><br><span class="line">12.5　小结 318</span><br><span class="line"></span><br><span class="line">提高篇</span><br><span class="line"></span><br><span class="line">第13章　基于Python引擎的开源数据挖掘建模平台（TipDM） 320</span><br><span class="line"></span><br><span class="line">13.1　平台简介 321</span><br><span class="line"></span><br><span class="line">13.1.1　模板 321</span><br><span class="line"></span><br><span class="line">13.1.2　数据源 322</span><br><span class="line"></span><br><span class="line">13.1.3　工程 323</span><br><span class="line"></span><br><span class="line">13.1.4　系统组件 324</span><br><span class="line"></span><br><span class="line">13.1.5　TipDM数据挖掘建模平台的本地化部署 326</span><br><span class="line"></span><br><span class="line">13.2　快速构建数据挖掘工程 327</span><br><span class="line"></span><br><span class="line">13.2.1　导入数据 329</span><br><span class="line"></span><br><span class="line">13.2.2　配置输入源组件 331</span><br><span class="line"></span><br><span class="line">13.2.3　配置缺失值处理组件 332</span><br><span class="line"></span><br><span class="line">13.2.4　配置记录选择组件 334</span><br><span class="line"></span><br><span class="line">13.2.5　配置数据标准化组件 334</span><br><span class="line"></span><br><span class="line">13.2.6　配置K-Means组件 336</span><br><span class="line"></span><br><span class="line">13.3　小结 339</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python数据科学手册 PDF</title>
    <url>/posts/3fcdce0e/</url>
    <content><![CDATA[<h4 id="《Python数据科学手册》"><a href="#《Python数据科学手册》" class="headerlink" title="《Python数据科学手册》"></a>《Python数据科学手册》</h4><h6 id="链接-https-pan-baidu-com-s-1400rpIEK3VQhbNrFyztjRw-提取码-qyqh"><a href="#链接-https-pan-baidu-com-s-1400rpIEK3VQhbNrFyztjRw-提取码-qyqh" class="headerlink" title="链接: https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw 提取码: qyqh"></a>链接: <a href="https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw">https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw</a> 提取码: qyqh</h6><p>Python语言拥有大量可用于存储、操作和洞察数据的程序库，已然成为深受数据科学研究人员推崇的工具。本书以IPython、NumPy、Pandas、Matplotlib和Scikit-Learn这5个能完成数据科学大部分工作的基础工具为主，从实战角度出发，讲授如何清洗和可视化数据、如何用数据建立各种统计学或机器学习模型等常见数据科学任务，旨在让各领域与数据处理相关的工作人员具备发现问题、解决问题的能力。·IPython和Jupyter:为使用Python提供计算环境·NumPy：用ndarray等<br><a id="more"></a></p>
<p>《Python数据科学手册》是对以数据深度需求为中心的科学、研究以及针对计算和统计方法的参考书。本书共五章，每章介绍一到Python数据科学中的重点工具包。首先从IPython和Jupyter开始，它们提供了数据科学家需要的计算环境；第 2章讲解能提供ndarray对象的NumPy，它可以用Python高效地存储和操作大型数组；第3章主要涉及提供DataFrame对象的Pandas，它可以用Python高效地存储和操作带标签的 列式数据；第4章的主角是Matplotlib，它为Python提供了许多数据可视化功能；第5章以Scikit-Learn为主，这个程序库为重要的机器学习算法提供了高效整洁的Python版实现。《Python数据科学手册》适合有编程背景，并打算将开源Python工具用作分析、操作、可视化以及学习数据的数据科学研究人员。</p>
<p><img src="/images/73d736804d6ebff38df133093e91a88f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">●译者序ii</span><br><span class="line"></span><br><span class="line">●前言xv</span><br><span class="line"></span><br><span class="line">●章IPython：Python1</span><br><span class="line"></span><br><span class="line">●1.1shell还是Notebook1</span><br><span class="line"></span><br><span class="line">●1.1.1启动IPythonshell2</span><br><span class="line"></span><br><span class="line">●1.1.2启动JupyterNotebook2</span><br><span class="line"></span><br><span class="line">●1.2IPython的帮助和文档3</span><br><span class="line"></span><br><span class="line">●1.2.1用符号获取文档3</span><br><span class="line"></span><br><span class="line">●1.2.2通过符号获取源代码4</span><br><span class="line"></span><br><span class="line">●1.2.3用Tab补全的方式探索模块5</span><br><span class="line"></span><br><span class="line">●1.3IPythonshell中的快捷键7</span><br><span class="line"></span><br><span class="line">●1.3.1导航快捷键7</span><br><span class="line"></span><br><span class="line">●1.3.2文本输入快捷键7</span><br><span class="line"></span><br><span class="line">●1.3.3命令历史快捷键8</span><br><span class="line"></span><br><span class="line">●1.3.4其他快捷键9</span><br><span class="line"></span><br><span class="line">●1.4IPython魔法命令9</span><br><span class="line"></span><br><span class="line">●1.4.1粘贴代码块：%paste和%cpaste9</span><br><span class="line"></span><br><span class="line">●1.4.2执行外部代码：%run10</span><br><span class="line"></span><br><span class="line">●1.4.3计算代码运行时间：%timeit11</span><br><span class="line"></span><br><span class="line">●1.4.4魔法函数的帮助：、%magic和%lsmagic11</span><br><span class="line"></span><br><span class="line">●部分目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python数据可视化编程实战 PDF</title>
    <url>/posts/48cafe98/</url>
    <content><![CDATA[<h4 id="《Python数据可视化编程实战》"><a href="#《Python数据可视化编程实战》" class="headerlink" title="《Python数据可视化编程实战》"></a>《Python数据可视化编程实战》</h4><h6 id="链接-https-pan-baidu-com-s-1b-36vxf3t-8ut5P5qHapaw-提取码-b3sb"><a href="#链接-https-pan-baidu-com-s-1b-36vxf3t-8ut5P5qHapaw-提取码-b3sb" class="headerlink" title="链接: https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw 提取码: b3sb"></a>链接: <a href="https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw">https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw</a> 提取码: b3sb</h6><p>本书是一本使用Python实现数据可视化编程的实战指南，介绍了如何使用Python很流行的库，通过60余种方法创建美观的数据可视化效果。<br><a id="more"></a></p>
<p>全书共8章，分别介绍了准备工作环境、了解数据、绘制并定制化图表、学习更多图表和定制化、创建3D可视化图表、用图像和地图绘制图表、使用正确的图表理解数据以及更多matplotlib知识。</p>
<p><img src="/images/fdb1a1852c676bcaa7d4262262a01ebe1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">章  准备工作环境</span><br><span class="line"></span><br><span class="line">●1.1  介绍</span><br><span class="line"></span><br><span class="line">●1.2  安装matplotlib、Numpy和Scipy库</span><br><span class="line"></span><br><span class="line">●1.2.1  准备工作</span><br><span class="line"></span><br><span class="line">●1.2.2  操作步骤</span><br><span class="line"></span><br><span class="line">●1.2.3  工作原理</span><br><span class="line"></span><br><span class="line">●1.2.4  补充说明</span><br><span class="line"></span><br><span class="line">●1.3  安装virtualenv和virtualenvwrapper</span><br><span class="line"></span><br><span class="line">●1.3.1  准备工作</span><br><span class="line"></span><br><span class="line">●1.3.2  操作步骤</span><br><span class="line"></span><br><span class="line">●1.4  在Mac  OS  X上安装matplotlib</span><br><span class="line"></span><br><span class="line">●1.4.1  准备工作</span><br><span class="line"></span><br><span class="line">●1.4.2  操作步骤</span><br><span class="line"></span><br><span class="line">●1.5  在Windows上安装matplotlib</span><br><span class="line"></span><br><span class="line">●1.5.1  准备工作</span><br><span class="line"></span><br><span class="line">●1.5.2  操作步骤</span><br><span class="line"></span><br><span class="line">●1.5.3  补充说明</span><br><span class="line"></span><br><span class="line">●1.6  安装图像处理工具：Python图像库（PIL）</span><br><span class="line"></span><br><span class="line">●1.6.1  操作步骤</span><br><span class="line"></span><br><span class="line">●1.6.2  安装过程说明</span><br><span class="line"></span><br><span class="line">●部分目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python网络编程基础 PDF</title>
    <url>/posts/280d777d/</url>
    <content><![CDATA[<h4 id="《Python网络编程基础》"><a href="#《Python网络编程基础》" class="headerlink" title="《Python网络编程基础》"></a>《Python网络编程基础》</h4><h6 id="链接-https-pan-baidu-com-s-1EsiWhQFss66W5p5-7PS8DA-提取码-vy2t"><a href="#链接-https-pan-baidu-com-s-1EsiWhQFss66W5p5-7PS8DA-提取码-vy2t" class="headerlink" title="链接: https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA 提取码: vy2t"></a>链接: <a href="https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA">https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA</a> 提取码: vy2t</h6><p>《Python网络编程基础》全面介绍了使用Python语言进行网络编程的基础知识，主要内容包括网络基础知识、高级网络劋作、WebServices、解析HTML和XHTML、XML、E-服务、FTP、使用Python劋作数据库、SSL、几种服务器端框架（包括Socket服务器、SimpleXMLRPCServer、CGI和mod_python），以及多任务处理（包括Forking、线程和异步通信）等。本书实用性强，共提供了大约175个实例，6600行以上的代码，是帮助读者全面而快速地学习Python语言、编写网络程序的佳实践。本书可以作为各层次Python、Web和网络程序的开发人员的参考书，在实际工作中使用书中的技术，效果更佳。本书部分讨论了客户端和服务器的设计，这是所有网络应用程序的基础。您将学到如何利用IPv6的优点来编写应用程序，如何与域名服务器通信，以及如何获取网页等。本书第2部分将向您演示如何编写发送和接收E—的程序、提供静态和动态网页的程序、传输文件以及其他网络程序。您将学到如何使用Apach1e的mod_python模块来建立基于Web的Python应用程序。本书后一部分侧重于Python网络编程高级应用方面的知识，讲解了如何使用多任务处理和无阻塞的I／O来编写可以同时处理上千个客户端的服务器程序。在这个过程中，您将学到编写很多成功网络程序的奥秘。重要的是，通过对超过6600行独立的、现成的代码的学习，您将能够立刻把您学到的知识应用到实践中去。…<br><a id="more"></a></p>
<p><img src="/images/5d00f3a9491cae157a8f1504138afc8e1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">Contents</span><br><span class="line"></span><br><span class="line">章客户&#x2F;服务器网络介绍\\t3</span><br><span class="line"></span><br><span class="line">理解TCP基础\\t3</span><br><span class="line"></span><br><span class="line">寻址\\t4</span><br><span class="line"></span><br><span class="line">可靠性\\t4</span><br><span class="line"></span><br><span class="line">路由\\t5</span><br><span class="line"></span><br><span class="line">安全\\t6</span><br><span class="line"></span><br><span class="line">使用客户&#x2F;服务器模式\\t6</span><br><span class="line"></span><br><span class="line">服务器端端口号\\t7</span><br><span class="line"></span><br><span class="line">客户端端口号\\t7</span><br><span class="line"></span><br><span class="line">理解UDP\\t7</span><br><span class="line"></span><br><span class="line">理解物理传输和以太网\\t9</span><br><span class="line"></span><br><span class="line">Python网络编程\\t9</span><br><span class="line"></span><br><span class="line">底层接口\\t10</span><br><span class="line"></span><br><span class="line">基本客户端劋作\\t10</span><br><span class="line"></span><br><span class="line">错误和异常\\t11</span><br><span class="line"></span><br><span class="line">文件类对象\\t12</span><br><span class="line"></span><br><span class="line">基本服务器劋作\\t13</span><br><span class="line"></span><br><span class="line">高级接口\\t15</span><br><span class="line"></span><br><span class="line">总结\\t17</span><br><span class="line"></span><br><span class="line">第2章网络客户端\\t19</span><br><span class="line"></span><br><span class="line">理解Sockets\\t19</span><br><span class="line"></span><br><span class="line">建立Sockets\\t20</span><br><span class="line"></span><br><span class="line">寻找端口号\\t21</span><br><span class="line"></span><br><span class="line">从Socekt获取信息\\t22</span><br><span class="line"></span><br><span class="line">利用Sockets通信\\t23</span><br><span class="line"></span><br><span class="line">处理错误\\t23</span><br><span class="line"></span><br><span class="line">Socket异常\\t24</span><br><span class="line"></span><br><span class="line">遗漏的错误\\t26</span><br><span class="line"></span><br><span class="line">文件类对象引起的错误\\t29</span><br><span class="line"></span><br><span class="line">使用UDP\\t31</span><br><span class="line"></span><br><span class="line">总结\\t34</span><br><span class="line"></span><br><span class="line">第3章网络服务器\\t35</span><br><span class="line"></span><br><span class="line">准备连接\\t35</span><br><span class="line"></span><br><span class="line">建立Socket对象\\t36</span><br><span class="line"></span><br><span class="line">设置和得到Socket选项\\t36</span><br><span class="line"></span><br><span class="line">绑定Socket\\t39</span><br><span class="line"></span><br><span class="line">侦听连接\\t39</span><br><span class="line"></span><br><span class="line">接受连接\\t40</span><br><span class="line"></span><br><span class="line">处理错误\\t41</span><br><span class="line"></span><br><span class="line">使用UDP\\t43</span><br><span class="line"></span><br><span class="line">使用id或d\\t45</span><br><span class="line"></span><br><span class="line">配置id\\t47</span><br><span class="line"></span><br><span class="line">配置d\\t48</span><br><span class="line"></span><br><span class="line">运行例子\\t50</span><br><span class="line"></span><br><span class="line">通过id使用Socket对象\\t51</span><br><span class="line"></span><br><span class="line">通过id使用UDP\\t51</span><br><span class="line"></span><br><span class="line">和id相关的错误处理\\t54</span><br><span class="line"></span><br><span class="line">什么时候不应该使用id\\t55</span><br><span class="line"></span><br><span class="line">通过syslog来记录日志\\t55</span><br><span class="line"></span><br><span class="line">在Python中使用syslog\\t56</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习手册 PDF</title>
    <url>/posts/5f0a47eb/</url>
    <content><![CDATA[<h4 id="《Python学习手册》"><a href="#《Python学习手册》" class="headerlink" title="《Python学习手册》"></a>《Python学习手册》</h4><h6 id="链接-https-pan-baidu-com-s-1xQQ41VNvDxk-Fd-7Pq-x-w-提取码-gea5"><a href="#链接-https-pan-baidu-com-s-1xQQ41VNvDxk-Fd-7Pq-x-w-提取码-gea5" class="headerlink" title="链接: https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w 提取码: gea5"></a>链接: <a href="https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w">https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w</a> 提取码: gea5</h6><p>《Python学习手册(第4版)》学习Python的主要内建对象类型：数字、列表和字典。使用Python语句创建和处理对象，并且学习Python的通用语法模型。使用函数构造和重用代码，函数是Python的基本过程工具。学习Python模块：封装语句、函数以及其他工具，以便构建较大的组件。学习Python的面向对象编程工具，用于组织程序代码。学习异常处理模型，以及用于编写较大程序的开发工具。了解不错Python工具，如装饰器、描述器、元类和Unicode处理等。<br><a id="more"></a></p>
<p><img src="/images/3530705b76daa1364c9353431d1ef2ea1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言1</span><br><span class="line"></span><br><span class="line">部分 使用入门</span><br><span class="line"></span><br><span class="line">章 问答环节19</span><br><span class="line"></span><br><span class="line">人们为何使用Python19</span><br><span class="line"></span><br><span class="line">软件质量20</span><br><span class="line"></span><br><span class="line">开发效率21</span><br><span class="line"></span><br><span class="line">Python是“脚本语言”吗21</span><br><span class="line"></span><br><span class="line">好吧，Python的缺点是什么呢23</span><br><span class="line"></span><br><span class="line">如今谁在使用Python23</span><br><span class="line"></span><br><span class="line">使用Python可以做些什么24</span><br><span class="line"></span><br><span class="line">系统编程25</span><br><span class="line"></span><br><span class="line">用户图形接口25</span><br><span class="line"></span><br><span class="line">Internet脚本25</span><br><span class="line"></span><br><span class="line">组件集成26</span><br><span class="line"></span><br><span class="line">数据库编程26</span><br><span class="line"></span><br><span class="line">快速原型27</span><br><span class="line"></span><br><span class="line">数值计算和科学计算编程27</span><br><span class="line"></span><br><span class="line">游戏、图像、人工智能、XML、机器人等27</span><br><span class="line"></span><br><span class="line">Python如何获得支持28</span><br><span class="line"></span><br><span class="line">Python有哪些技术上的优点28</span><br><span class="line"></span><br><span class="line">面向对象28</span><br><span class="line"></span><br><span class="line">免费29</span><br><span class="line"></span><br><span class="line">可移植29</span><br><span class="line"></span><br><span class="line">功能强大30</span><br><span class="line"></span><br><span class="line">可混合31</span><br><span class="line"></span><br><span class="line">简单易用31</span><br><span class="line"></span><br><span class="line">简单易学32</span><br><span class="line"></span><br><span class="line">Python和其他语言比较起来怎么样32</span><br><span class="line"></span><br><span class="line">本章小结33</span><br><span class="line"></span><br><span class="line">本章习题33</span><br><span class="line"></span><br><span class="line">习题解答34</span><br><span class="line"></span><br><span class="line">Python是工程，不是艺术34</span><br><span class="line"></span><br><span class="line">第2章 Python如何运行程序36</span><br><span class="line"></span><br><span class="line">Python解释器简介36</span><br><span class="line"></span><br><span class="line">程序执行37</span><br><span class="line"></span><br><span class="line">程序员的视角37</span><br><span class="line"></span><br><span class="line">Python的视角39</span><br><span class="line"></span><br><span class="line">执行模块的变体41</span><br><span class="line"></span><br><span class="line">Python实现的替代者42</span><br><span class="line"></span><br><span class="line">执行优化工具43</span><br><span class="line"></span><br><span class="line">冻结二进制文件44</span><br><span class="line"></span><br><span class="line">其他执行选项45</span><br><span class="line"></span><br><span class="line">未来的可能性46</span><br><span class="line"></span><br><span class="line">本章小结46</span><br><span class="line"></span><br><span class="line">本章习题47</span><br><span class="line"></span><br><span class="line">习题解答47</span><br><span class="line"></span><br><span class="line">第3章 如何运行程序48</span><br><span class="line"></span><br><span class="line">交互提示模式下编写代码48</span><br><span class="line"></span><br><span class="line">交互地运行代码49</span><br><span class="line"></span><br><span class="line">为什么使用交互提示模式51</span><br><span class="line"></span><br><span class="line">使用交互提示模式52</span><br><span class="line"></span><br><span class="line">系统命令行和文件54</span><br><span class="line"></span><br><span class="line">段脚本55</span><br><span class="line"></span><br><span class="line">使用命令行运行文件56</span><br><span class="line"></span><br><span class="line">使用命令行和文件57</span><br><span class="line"></span><br><span class="line">UNIX可执行脚本(#!)58</span><br><span class="line"></span><br><span class="line">UNIX env查找技巧59</span><br><span class="line"></span><br><span class="line">点击文件图标60</span><br><span class="line"></span><br><span class="line">在Windows中点击图标60</span><br><span class="line"></span><br><span class="line">input的技巧61</span><br><span class="line"></span><br><span class="line">图标点击的其他63</span><br><span class="line"></span><br><span class="line">模块导入和重载63</span><br><span class="line"></span><br><span class="line">模块的显要特性：属性65</span><br><span class="line"></span><br><span class="line">import和reload的使用注意事项68</span><br><span class="line"></span><br><span class="line">使用exec运行模块文件69</span><br><span class="line"></span><br><span class="line">IDLE用户界面70</span><br><span class="line"></span><br><span class="line">IDLE基础71</span><br><span class="line"></span><br><span class="line">使用IDLE72</span><br><span class="line"></span><br><span class="line">不错IDLE工具74</span><br><span class="line"></span><br><span class="line">其他的IDE74</span><br><span class="line"></span><br><span class="line">其他启动选项76</span><br><span class="line"></span><br><span class="line">嵌入式调用76</span><br><span class="line"></span><br><span class="line">冻结二进制的可执行性77</span><br><span class="line"></span><br><span class="line">文本编辑器启动的选择77</span><br><span class="line"></span><br><span class="line">其他的启动选择77</span><br><span class="line"></span><br><span class="line">未来的可能77</span><br><span class="line"></span><br><span class="line">我应该选用哪种78</span><br><span class="line"></span><br><span class="line">调试Python代码78</span><br><span class="line"></span><br><span class="line">本章小结80</span><br><span class="line"></span><br><span class="line">本章习题80</span><br><span class="line"></span><br><span class="line">习题解答80</span><br><span class="line"></span><br><span class="line">部分 练习题81</span><br><span class="line"></span><br><span class="line">第二部分 类型和运算</span><br><span class="line"></span><br><span class="line">第4章 介绍Python对象类型87</span><br><span class="line"></span><br><span class="line">为什么使用内置类型88</span><br><span class="line"></span><br><span class="line">Python的核心数据类型88</span><br><span class="line"></span><br><span class="line">数字90</span><br><span class="line"></span><br><span class="line">字符串92</span><br><span class="line"></span><br><span class="line">序列的操作92</span><br><span class="line"></span><br><span class="line">不可变性94</span><br><span class="line"></span><br><span class="line">类型特定的方法94</span><br><span class="line"></span><br><span class="line">寻求帮助96</span><br><span class="line"></span><br><span class="line">编写字符串的其他方法97</span><br><span class="line"></span><br><span class="line">模式匹配98</span><br><span class="line"></span><br><span class="line">列表98</span><br><span class="line"></span><br><span class="line">序列操作98</span><br><span class="line"></span><br><span class="line">类型特定的操作99</span><br><span class="line"></span><br><span class="line">边界检查100</span><br><span class="line"></span><br><span class="line">嵌套100</span><br><span class="line"></span><br><span class="line">列表解析101</span><br><span class="line"></span><br><span class="line">字典103</span><br><span class="line"></span><br><span class="line">映射操作103</span><br><span class="line"></span><br><span class="line">重访嵌套104</span><br><span class="line"></span><br><span class="line">键的排序：for 循环105</span><br><span class="line"></span><br><span class="line">迭代和优化107</span><br><span class="line"></span><br><span class="line">不存在的键：if 测试107</span><br><span class="line"></span><br><span class="line">元组109</span><br><span class="line"></span><br><span class="line">为什么要用元组109</span><br><span class="line"></span><br><span class="line">文件110</span><br><span class="line"></span><br><span class="line">其他文件类工具111</span><br><span class="line"></span><br><span class="line">其他核心类型111</span><br><span class="line"></span><br><span class="line">如何破坏代码的灵活性113</span><br><span class="line"></span><br><span class="line">用户定义的类114</span><br><span class="line"></span><br><span class="line">剩余的内容115</span><br><span class="line"></span><br><span class="line">本章小结115</span><br><span class="line"></span><br><span class="line">本章习题116</span><br><span class="line"></span><br><span class="line">习题解答116</span><br><span class="line"></span><br><span class="line">第5章 数字117</span><br><span class="line"></span><br><span class="line">Python的数字类型117</span><br><span class="line"></span><br><span class="line">数字常量118</span><br><span class="line"></span><br><span class="line">内置数学工具和扩展119</span><br><span class="line"></span><br><span class="line">Python表达式操作符120</span><br><span class="line"></span><br><span class="line">在实际应用中的数字125</span><br><span class="line"></span><br><span class="line">变量和基本的表达式125</span><br><span class="line"></span><br><span class="line">数字显示的格式126</span><br><span class="line"></span><br><span class="line">比较：一般的和连续的127</span><br><span class="line"></span><br><span class="line">str和repr显示格式128</span><br><span class="line"></span><br><span class="line">除法： 传统除法、Floor除法和真除法129</span><br><span class="line"></span><br><span class="line">整数精度133</span><br><span class="line"></span><br><span class="line">复数133</span><br><span class="line"></span><br><span class="line">十六进制、八进制和二进制记数134</span><br><span class="line"></span><br><span class="line">位操作136</span><br><span class="line"></span><br><span class="line">其他的内置数学工具137</span><br><span class="line"></span><br><span class="line">其他数字类型139</span><br><span class="line"></span><br><span class="line">小数数字139</span><br><span class="line"></span><br><span class="line">分数类型141</span><br><span class="line"></span><br><span class="line">集合145</span><br><span class="line"></span><br><span class="line">布尔型151</span><br><span class="line"></span><br><span class="line">数字扩展152</span><br><span class="line"></span><br><span class="line">本章小结153</span><br><span class="line"></span><br><span class="line">本章习题153</span><br><span class="line"></span><br><span class="line">习题解答153</span><br><span class="line"></span><br><span class="line">第6章 动态类型简介155</span><br><span class="line"></span><br><span class="line">缺少类型声明语句的情况155</span><br><span class="line"></span><br><span class="line">变量、对象和引用156</span><br><span class="line"></span><br><span class="line">类型属于对象，而不是变量157</span><br><span class="line"></span><br><span class="line">对象的垃圾收集158</span><br><span class="line"></span><br><span class="line">共享引用159</span><br><span class="line"></span><br><span class="line">共享引用和在原处修改161</span><br><span class="line"></span><br><span class="line">共享引用和相等163</span><br><span class="line"></span><br><span class="line">动态类型随处可见1</span><br><span class="line"></span><br><span class="line">本章小结165</span><br><span class="line"></span><br><span class="line">本章习题165</span><br><span class="line"></span><br><span class="line">习题解答165</span><br><span class="line"></span><br><span class="line">第7章 字符串167</span><br><span class="line"></span><br><span class="line">字符串常量169</span><br><span class="line"></span><br><span class="line">单双引号字符串是一样的170</span><br><span class="line"></span><br><span class="line">用转义序列代表特殊字节171</span><br><span class="line"></span><br><span class="line">raw字符串抑制转义173</span><br><span class="line"></span><br><span class="line">三重引号编写多行字符串块175</span><br><span class="line"></span><br><span class="line">实际应用中的字符串176</span><br><span class="line"></span><br><span class="line">基本操作176</span><br><span class="line"></span><br><span class="line">索引和分片177</span><br><span class="line"></span><br><span class="line">为什么要在意：分片181</span><br><span class="line"></span><br><span class="line">字符串转换工具181</span><br><span class="line"></span><br><span class="line">修改字符串184</span><br><span class="line"></span><br><span class="line">字符串方法185</span><br><span class="line"></span><br><span class="line">字符串方法实例：修改字符串187</span><br><span class="line"></span><br><span class="line">字符串方法实例：文本解析189</span><br><span class="line"></span><br><span class="line">实际应用中的其他常见字符串方法190</span><br><span class="line"></span><br><span class="line">初的字符串模块（在Python 3.0中删除）191</span><br><span class="line"></span><br><span class="line">字符串格式化表达式192</span><br><span class="line"></span><br><span class="line">更不错的字符串格式化表达式194</span><br><span class="line"></span><br><span class="line">基于字典的字符串格式化196</span><br><span class="line"></span><br><span class="line">字符串格式化调用方法196</span><br><span class="line"></span><br><span class="line">基础知识197</span><br><span class="line"></span><br><span class="line">添加键、属性和偏移量198</span><br><span class="line"></span><br><span class="line">添加具体格式化198</span><br><span class="line"></span><br><span class="line">与%格式化表达式比较200</span><br><span class="line"></span><br><span class="line">为什么用新的格式化方法203</span><br><span class="line"></span><br><span class="line">通常意义下的类型分类206</span><br><span class="line"></span><br><span class="line">同样分类的类型共享其操作集合206</span><br><span class="line"></span><br><span class="line">可变类型能够在原处修改207</span><br><span class="line"></span><br><span class="line">本章小结208</span><br><span class="line"></span><br><span class="line">本章习题208</span><br><span class="line"></span><br><span class="line">习题解答208</span><br><span class="line"></span><br><span class="line">第8章 列表与字典210</span><br><span class="line"></span><br><span class="line">列表210</span><br><span class="line"></span><br><span class="line">实际应用中的列表213</span><br><span class="line"></span><br><span class="line">基本列表操作213</span><br><span class="line"></span><br><span class="line">列表迭代和解析213</span><br><span class="line"></span><br><span class="line">索引、分片和矩阵214</span><br><span class="line"></span><br><span class="line">原处修改列表215</span><br><span class="line"></span><br><span class="line">字典220</span><br><span class="line"></span><br><span class="line">实际应用中的字典222</span><br><span class="line"></span><br><span class="line">字典的基本操作222</span><br><span class="line"></span><br><span class="line">原处修改字典223</span><br><span class="line"></span><br><span class="line">其他字典方法224</span><br><span class="line"></span><br><span class="line">语言表225</span><br><span class="line"></span><br><span class="line">字典用法注意事项226</span><br><span class="line"></span><br><span class="line">为什么要在意字典接口229</span><br><span class="line"></span><br><span class="line">创建字典的其他方法230</span><br><span class="line"></span><br><span class="line">Python 3.0中的字典变化231</span><br><span class="line"></span><br><span class="line">本章小结237</span><br><span class="line"></span><br><span class="line">本章习题237</span><br><span class="line"></span><br><span class="line">习题解答237</span><br><span class="line"></span><br><span class="line">第9章 元组、文件及其他239</span><br><span class="line"></span><br><span class="line">元组239</span><br><span class="line"></span><br><span class="line">实际应用中的元组241</span><br><span class="line"></span><br><span class="line">为什么有了列表还要元组243</span><br><span class="line"></span><br><span class="line">文件243</span><br><span class="line"></span><br><span class="line">打开文件244</span><br><span class="line"></span><br><span class="line">使用文件245</span><br><span class="line"></span><br><span class="line">实际应用中的文件246</span><br><span class="line"></span><br><span class="line">其他文件工具252</span><br><span class="line"></span><br><span class="line">重访类型分类254</span><br><span class="line"></span><br><span class="line">为什么要在意操作符重载255</span><br><span class="line"></span><br><span class="line">对象灵活性255</span><br><span class="line"></span><br><span class="line">引用 VS 拷贝256</span><br><span class="line"></span><br><span class="line">比较、相等性和真值258</span><br><span class="line"></span><br><span class="line">Python 3.0的字典比较260</span><br><span class="line"></span><br><span class="line">Python中真和假的含义261</span><br><span class="line"></span><br><span class="line">Python的类型层次263</span><br><span class="line"></span><br><span class="line">Type对象263</span><br><span class="line"></span><br><span class="line">Python中的其他类型265</span><br><span class="line"></span><br><span class="line">内置类型陷阱265</span><br><span class="line"></span><br><span class="line">赋值生成引用，而不是拷贝265</span><br><span class="line"></span><br><span class="line">重复能够增加层次深度266</span><br><span class="line"></span><br><span class="line">留意循环数据结构266</span><br><span class="line"></span><br><span class="line">不可变类型不可以在原处改变267</span><br><span class="line"></span><br><span class="line">本章小结267</span><br><span class="line"></span><br><span class="line">本章习题268</span><br><span class="line"></span><br><span class="line">习题解答268</span><br><span class="line"></span><br><span class="line">第二部分练习题269</span><br><span class="line"></span><br><span class="line">第三部分 语句和语法</span><br><span class="line"></span><br><span class="line">0章 Python语句简介275</span><br><span class="line"></span><br><span class="line">重访Python程序结构275</span><br><span class="line"></span><br><span class="line">Python的语句276</span><br><span class="line"></span><br><span class="line">if的故事278</span><br><span class="line"></span><br><span class="line">Python增加了什么279</span><br><span class="line"></span><br><span class="line">Python删除了什么279</span><br><span class="line"></span><br><span class="line">为什么使用缩进语法281</span><br><span class="line"></span><br><span class="line">几个特殊实例283</span><br><span class="line"></span><br><span class="line">简短实例：交互循环285</span><br><span class="line"></span><br><span class="line">一个简单的交互式循环285</span><br><span class="line"></span><br><span class="line">对用户输入数据做数学运算287</span><br><span class="line"></span><br><span class="line">用测试输入数据来处理错误288</span><br><span class="line"></span><br><span class="line">用try语句处理错误289</span><br><span class="line"></span><br><span class="line">嵌套代码三层290</span><br><span class="line"></span><br><span class="line">本章小结290</span><br><span class="line"></span><br><span class="line">本章习题291</span><br><span class="line"></span><br><span class="line">习题解答291</span><br><span class="line"></span><br><span class="line">1章 赋值、表达式和打印292</span><br><span class="line"></span><br><span class="line">赋值语句292</span><br><span class="line"></span><br><span class="line">赋值语句的形式293</span><br><span class="line"></span><br><span class="line">序列赋值294</span><br><span class="line"></span><br><span class="line">Python 3.0中的扩展序列解包297</span><br><span class="line"></span><br><span class="line">多目标赋值语句301</span><br><span class="line"></span><br><span class="line">增强赋值语句302</span><br><span class="line"></span><br><span class="line">变量命名规则305</span><br><span class="line"></span><br><span class="line">Python的废弃协议306</span><br><span class="line"></span><br><span class="line">表达式语句308</span><br><span class="line"></span><br><span class="line">表达式语句和在原处的修改309</span><br><span class="line"></span><br><span class="line">打印操作310</span><br><span class="line"></span><br><span class="line">Python 3.0的print函数311</span><br><span class="line"></span><br><span class="line">Python 2.6 print语句313</span><br><span class="line"></span><br><span class="line">打印流重定向315</span><br><span class="line"></span><br><span class="line">版本独立的打印318</span><br><span class="line"></span><br><span class="line">为什么要注意print和stdout319</span><br><span class="line"></span><br><span class="line">本章小结320</span><br><span class="line"></span><br><span class="line">本章习题321</span><br><span class="line"></span><br><span class="line">习题解答321</span><br><span class="line"></span><br><span class="line">2章 if测试和语法规则322</span><br><span class="line"></span><br><span class="line">if语句322</span><br><span class="line"></span><br><span class="line">通用格式322</span><br><span class="line"></span><br><span class="line">基本例子323</span><br><span class="line"></span><br><span class="line">多路分支323</span><br><span class="line"></span><br><span class="line">Python语法规则325</span><br><span class="line"></span><br><span class="line">代码块分隔符326</span><br><span class="line"></span><br><span class="line">语句的分隔符328</span><br><span class="line"></span><br><span class="line">一些特殊情况329</span><br><span class="line"></span><br><span class="line">真值测试330</span><br><span class="line"></span><br><span class="line">if&#x2F;else三元表达式332</span><br><span class="line"></span><br><span class="line">为什么要在意布尔值334</span><br><span class="line"></span><br><span class="line">本章小结335</span><br><span class="line"></span><br><span class="line">本章习题335</span><br><span class="line"></span><br><span class="line">习题解答335</span><br><span class="line"></span><br><span class="line">3章 while和for循环336</span><br><span class="line"></span><br><span class="line">while循环336</span><br><span class="line"></span><br><span class="line">一般格式336</span><br><span class="line"></span><br><span class="line">例子337</span><br><span class="line"></span><br><span class="line">break、continue、pass和循环else338</span><br><span class="line"></span><br><span class="line">一般循环格式338</span><br><span class="line"></span><br><span class="line">pass338</span><br><span class="line"></span><br><span class="line">continue340</span><br><span class="line"></span><br><span class="line">break340</span><br><span class="line"></span><br><span class="line">循环else341</span><br><span class="line"></span><br><span class="line">为什么要在意“模拟C 语言的while循环”342</span><br><span class="line"></span><br><span class="line">for循环343</span><br><span class="line"></span><br><span class="line">一般格式343</span><br><span class="line"></span><br><span class="line">例子344</span><br><span class="line"></span><br><span class="line">为什么要在意“文件扫描”349</span><br><span class="line"></span><br><span class="line">编写循环的技巧350</span><br><span class="line"></span><br><span class="line">循环计数器：while和range351</span><br><span class="line"></span><br><span class="line">非完备遍历：range和分片352</span><br><span class="line"></span><br><span class="line">修改列表：range353</span><br><span class="line"></span><br><span class="line">并行遍历：zip和map354</span><br><span class="line"></span><br><span class="line">产生偏移和元素：enumerate357</span><br><span class="line"></span><br><span class="line">本章小结358</span><br><span class="line"></span><br><span class="line">本章习题358</span><br><span class="line"></span><br><span class="line">习题解答359</span><br><span class="line"></span><br><span class="line">4章 迭代器和解析，部分360</span><br><span class="line"></span><br><span class="line">迭代器：初探360</span><br><span class="line"></span><br><span class="line">文件迭代器361</span><br><span class="line"></span><br><span class="line">手动迭代：iter和next363</span><br><span class="line"></span><br><span class="line">其他内置类型迭代器365</span><br><span class="line"></span><br><span class="line">列表解析：初探367</span><br><span class="line"></span><br><span class="line">列表解析基础知识368</span><br><span class="line"></span><br><span class="line">在文件上使用列表解析369</span><br><span class="line"></span><br><span class="line">扩展的列表解析语法370</span><br><span class="line"></span><br><span class="line">其他迭代环境371</span><br><span class="line"></span><br><span class="line">Python 3.0中的新的可迭代对象375</span><br><span class="line"></span><br><span class="line">range迭代器376</span><br><span class="line"></span><br><span class="line">map、zip和filter迭代器377</span><br><span class="line"></span><br><span class="line">多个迭代器 VS单个迭代器378</span><br><span class="line"></span><br><span class="line">字典视图迭代器379</span><br><span class="line"></span><br><span class="line">其他迭代器主题381</span><br><span class="line"></span><br><span class="line">本章小结381</span><br><span class="line"></span><br><span class="line">本章习题381</span><br><span class="line"></span><br><span class="line">习题解答382</span><br><span class="line"></span><br><span class="line">5章 文档383</span><br><span class="line"></span><br><span class="line">Python文档资源383</span><br><span class="line"></span><br><span class="line">#注释384</span><br><span class="line"></span><br><span class="line">dir函数384</span><br><span class="line"></span><br><span class="line">文档字符串：__doc__385</span><br><span class="line"></span><br><span class="line">PyDoc：help函数388</span><br><span class="line"></span><br><span class="line">PyDoc：HTML报表390</span><br><span class="line"></span><br><span class="line">标准手册集393</span><br><span class="line"></span><br><span class="line">网络资源394</span><br><span class="line"></span><br><span class="line">已出版的书籍394</span><br><span class="line"></span><br><span class="line">常见编写代码的陷阱395</span><br><span class="line"></span><br><span class="line">本章小结397</span><br><span class="line"></span><br><span class="line">本章习题397</span><br><span class="line"></span><br><span class="line">习题解答397</span><br><span class="line"></span><br><span class="line">第三部分练习题398</span><br><span class="line"></span><br><span class="line">第四部分 函数</span><br><span class="line"></span><br><span class="line">6章 函数基础403</span><br><span class="line"></span><br><span class="line">为何使用函数404</span><br><span class="line"></span><br><span class="line">编写函数405</span><br><span class="line"></span><br><span class="line">def语句406</span><br><span class="line"></span><br><span class="line">def语句是实时执行的407</span><br><span class="line"></span><br><span class="line">个例子：定义和调用408</span><br><span class="line"></span><br><span class="line">定义408</span><br><span class="line"></span><br><span class="line">调用408</span><br><span class="line"></span><br><span class="line">Python中的多态409</span><br><span class="line"></span><br><span class="line">第二个例子：寻找序列的交集410</span><br><span class="line"></span><br><span class="line">定义410</span><br><span class="line"></span><br><span class="line">调用411</span><br><span class="line"></span><br><span class="line">重访多态411</span><br><span class="line"></span><br><span class="line">本地变量412</span><br><span class="line"></span><br><span class="line">本章小结413</span><br><span class="line"></span><br><span class="line">本章习题413</span><br><span class="line"></span><br><span class="line">习题解答413</span><br><span class="line"></span><br><span class="line">7章 作用域415</span><br><span class="line"></span><br><span class="line">Python作用域基础415</span><br><span class="line"></span><br><span class="line">作用域法则416</span><br><span class="line"></span><br><span class="line">变量名解析：LEGB原则418</span><br><span class="line"></span><br><span class="line">作用域实例419</span><br><span class="line"></span><br><span class="line">内置作用域420</span><br><span class="line"></span><br><span class="line">在Python 2.6中违反通用性422</span><br><span class="line"></span><br><span class="line">global语句422</span><br><span class="line"></span><br><span class="line">小化全局变量423</span><br><span class="line"></span><br><span class="line">小化文件间的修改424</span><br><span class="line"></span><br><span class="line">其他访问全局变量的方法426</span><br><span class="line"></span><br><span class="line">作用域和嵌套函数427</span><br><span class="line"></span><br><span class="line">嵌套作用域的细节427</span><br><span class="line"></span><br><span class="line">嵌套作用域举例427</span><br><span class="line"></span><br><span class="line">nonlocal语句433</span><br><span class="line"></span><br><span class="line">nonlocal基础433</span><br><span class="line"></span><br><span class="line">nonlocal应用435</span><br><span class="line"></span><br><span class="line">为什么使用nonlocal437</span><br><span class="line"></span><br><span class="line">本章小结440</span><br><span class="line"></span><br><span class="line">本章习题441</span><br><span class="line"></span><br><span class="line">习题解答442</span><br><span class="line"></span><br><span class="line">8章 参数444</span><br><span class="line"></span><br><span class="line">传递参数444</span><br><span class="line"></span><br><span class="line">参数和共享引用445</span><br><span class="line"></span><br><span class="line">避免可变参数的修改447</span><br><span class="line"></span><br><span class="line">对参数输出进行模拟448</span><br><span class="line"></span><br><span class="line">特定的参数匹配模型449</span><br><span class="line"></span><br><span class="line">基础知识449</span><br><span class="line"></span><br><span class="line">匹配语法450</span><br><span class="line"></span><br><span class="line">细节452</span><br><span class="line"></span><br><span class="line">关键字参数和默认参数的实例452</span><br><span class="line"></span><br><span class="line">任意参数的实例455</span><br><span class="line"></span><br><span class="line">Python 3.0 Keyword-Only参数459</span><br><span class="line"></span><br><span class="line">min调用462</span><br><span class="line"></span><br><span class="line">满分463</span><br><span class="line"></span><br><span class="line">加分点4</span><br><span class="line"></span><br><span class="line">结论465</span><br><span class="line"></span><br><span class="line">一个更有用的例子：通用set函数465</span><br><span class="line"></span><br><span class="line">模拟Python 3.0 print函数466</span><br><span class="line"></span><br><span class="line">使用Keyword-Only参数467</span><br><span class="line"></span><br><span class="line">为什么要在意：关键字参数469</span><br><span class="line"></span><br><span class="line">本章小结469</span><br><span class="line"></span><br><span class="line">本章习题470</span><br><span class="line"></span><br><span class="line">习题解答470</span><br><span class="line"></span><br><span class="line">9章 函数的不错话题472</span><br><span class="line"></span><br><span class="line">函数设计概念472</span><br><span class="line"></span><br><span class="line">递归函数474</span><br><span class="line"></span><br><span class="line">用递归求和474</span><br><span class="line"></span><br><span class="line">编码替代方案475</span><br><span class="line"></span><br><span class="line">循环语句VS递归476</span><br><span class="line"></span><br><span class="line">处理任意结构477</span><br><span class="line"></span><br><span class="line">函数对象：属性和注解478</span><br><span class="line"></span><br><span class="line">间接函数调用478</span><br><span class="line"></span><br><span class="line">函数内省479</span><br><span class="line"></span><br><span class="line">函数属性480</span><br><span class="line"></span><br><span class="line">Python 3.0中的函数注解481</span><br><span class="line"></span><br><span class="line">匿名函数： lambda483</span><br><span class="line"></span><br><span class="line">lambda表达式483</span><br><span class="line"></span><br><span class="line">为什么使用lambda484</span><br><span class="line"></span><br><span class="line">如何（不要）让Python代码变得晦涩难懂486</span><br><span class="line"></span><br><span class="line">嵌套lambda和作用域487</span><br><span class="line"></span><br><span class="line">为什么要在意：回调488</span><br><span class="line"></span><br><span class="line">在序列中映射函数：map489</span><br><span class="line"></span><br><span class="line">函数式编程工具：filter和reduce490</span><br><span class="line"></span><br><span class="line">本章小结492</span><br><span class="line"></span><br><span class="line">本章习题492</span><br><span class="line"></span><br><span class="line">习题解答492</span><br><span class="line"></span><br><span class="line">第20章 迭代和解析，第二部分494</span><br><span class="line"></span><br><span class="line">回顾列表解析：函数式编程工具494</span><br><span class="line"></span><br><span class="line">列表解析与map495</span><br><span class="line"></span><br><span class="line">增加测试和嵌套循环496</span><br><span class="line"></span><br><span class="line">列表解析和矩阵498</span><br><span class="line"></span><br><span class="line">理解列表解析499</span><br><span class="line"></span><br><span class="line">为什么要在意：列表解析和map500</span><br><span class="line"></span><br><span class="line">重访迭代器：生成器501</span><br><span class="line"></span><br><span class="line">生成器函数：yield VS return502</span><br><span class="line"></span><br><span class="line">生成器表达式：迭代器遇到列表解析506</span><br><span class="line"></span><br><span class="line">生成器函数 VS 生成器表达式507</span><br><span class="line"></span><br><span class="line">生成器是单迭代器对象508</span><br><span class="line"></span><br><span class="line">用迭代工具模拟zip和map510</span><br><span class="line"></span><br><span class="line">为什么你会留意：单次迭代514</span><br><span class="line"></span><br><span class="line">内置类型和类中的值生成515</span><br><span class="line"></span><br><span class="line">Python 3.0解析语法概括516</span><br><span class="line"></span><br><span class="line">解析集合和字典解析517</span><br><span class="line"></span><br><span class="line">针对集合和字典的扩展的解析语法517</span><br><span class="line"></span><br><span class="line">对迭代的各种方法进行计时518</span><br><span class="line"></span><br><span class="line">对模块计时519</span><br><span class="line"></span><br><span class="line">计时脚本519</span><br><span class="line"></span><br><span class="line">计时结果520</span><br><span class="line"></span><br><span class="line">计时模块替代方案523</span><br><span class="line"></span><br><span class="line">其他建议527</span><br><span class="line"></span><br><span class="line">函数陷阱528</span><br><span class="line"></span><br><span class="line">本地变量是静态检测的528</span><br><span class="line"></span><br><span class="line">默认和可变对象529</span><br><span class="line"></span><br><span class="line">没有return语句的函数531</span><br><span class="line"></span><br><span class="line">嵌套作用域的循环变量532</span><br><span class="line"></span><br><span class="line">本章小结532</span><br><span class="line"></span><br><span class="line">本章习题532</span><br><span class="line"></span><br><span class="line">习题解答533</span><br><span class="line"></span><br><span class="line">第四部分练习题533</span><br><span class="line"></span><br><span class="line">第五部分 模块</span><br><span class="line"></span><br><span class="line">第21章 模块：宏伟蓝图539</span><br><span class="line"></span><br><span class="line">为什么使用模块540</span><br><span class="line"></span><br><span class="line">Python程序架构540</span><br><span class="line"></span><br><span class="line">如何组织一个程序541</span><br><span class="line"></span><br><span class="line">导入和属性541</span><br><span class="line"></span><br><span class="line">标准库模块543</span><br><span class="line"></span><br><span class="line">import如何工作543</span><br><span class="line"></span><br><span class="line">1.搜索544</span><br><span class="line"></span><br><span class="line">2.编译（可选）544</span><br><span class="line"></span><br><span class="line">3.运行545</span><br><span class="line"></span><br><span class="line">模块搜索路径545</span><br><span class="line"></span><br><span class="line">配置搜索路径547</span><br><span class="line"></span><br><span class="line">搜索路径的变动548</span><br><span class="line"></span><br><span class="line">sys.path列表548</span><br><span class="line"></span><br><span class="line">模块文件选择549</span><br><span class="line"></span><br><span class="line">不错的模块选择概念550</span><br><span class="line"></span><br><span class="line">第三方工具：distutils550</span><br><span class="line"></span><br><span class="line">本章小结551</span><br><span class="line"></span><br><span class="line">本章习题551</span><br><span class="line"></span><br><span class="line">习题解答551</span><br><span class="line"></span><br><span class="line">第22章 模块代码编写基础553</span><br><span class="line"></span><br><span class="line">模块的创建553</span><br><span class="line"></span><br><span class="line">模块的使用554</span><br><span class="line"></span><br><span class="line">import语句554</span><br><span class="line"></span><br><span class="line">from语句555</span><br><span class="line"></span><br><span class="line">from *语句555</span><br><span class="line"></span><br><span class="line">导入只发生一次555</span><br><span class="line"></span><br><span class="line">import和from是赋值语句556</span><br><span class="line"></span><br><span class="line">文件间变量名的改变557</span><br><span class="line"></span><br><span class="line">import和from的对等性557</span><br><span class="line"></span><br><span class="line">from语句潜在的陷阱558</span><br><span class="line"></span><br><span class="line">模块命名空间560</span><br><span class="line"></span><br><span class="line">文件生成命名空间560</span><br><span class="line"></span><br><span class="line">属性名的点号运算562</span><br><span class="line"></span><br><span class="line">导入和作用域562</span><br><span class="line"></span><br><span class="line">命名空间的嵌套563</span><br><span class="line"></span><br><span class="line">重载模块5</span><br><span class="line"></span><br><span class="line">reload基础565</span><br><span class="line"></span><br><span class="line">reload实例566</span><br><span class="line"></span><br><span class="line">为什么要在意：模块重载567</span><br><span class="line"></span><br><span class="line">本章小结568</span><br><span class="line"></span><br><span class="line">本章习题568</span><br><span class="line"></span><br><span class="line">习题解答568</span><br><span class="line"></span><br><span class="line">第23章 模块包570</span><br><span class="line"></span><br><span class="line">包导入基础570</span><br><span class="line"></span><br><span class="line">包和搜索路径设置571</span><br><span class="line"></span><br><span class="line">__init__.py包文件572</span><br><span class="line"></span><br><span class="line">包导入实例573</span><br><span class="line"></span><br><span class="line">包对应的from语句和import语句574</span><br><span class="line"></span><br><span class="line">为什么要使用包导入575</span><br><span class="line"></span><br><span class="line">三个系统的传说576</span><br><span class="line"></span><br><span class="line">包相对导入578</span><br><span class="line"></span><br><span class="line">Python 3.0中的变化578</span><br><span class="line"></span><br><span class="line">相对导入基础知识579</span><br><span class="line"></span><br><span class="line">为什么使用相对导入581</span><br><span class="line"></span><br><span class="line">相对导入的作用域583</span><br><span class="line"></span><br><span class="line">模块查找规则总结583</span><br><span class="line"></span><br><span class="line">相对导入的应用584</span><br><span class="line"></span><br><span class="line">为什么要在意：模块包589</span><br><span class="line"></span><br><span class="line">本章小结590</span><br><span class="line"></span><br><span class="line">本章习题590</span><br><span class="line"></span><br><span class="line">习题解答590</span><br><span class="line"></span><br><span class="line">第24章 不错模块话题592</span><br><span class="line"></span><br><span class="line">在模块中隐藏数据592</span><br><span class="line"></span><br><span class="line">小化from *的破坏：_X和__all__593</span><br><span class="line"></span><br><span class="line">启用以后的语言特性593</span><br><span class="line"></span><br><span class="line">混合用法模式：__name__和__main__594</span><br><span class="line"></span><br><span class="line">以__name__进行单元测试595</span><br><span class="line"></span><br><span class="line">使用带有__name__的命令行参数596</span><br><span class="line"></span><br><span class="line">修改模块搜索路径599</span><br><span class="line"></span><br><span class="line">Import语句和from语句的as扩展599</span><br><span class="line"></span><br><span class="line">模块是对象：元程序600</span><br><span class="line"></span><br><span class="line">用名称字符串导入模块603</span><br><span class="line"></span><br><span class="line">过渡性模块重载604</span><br><span class="line"></span><br><span class="line">模块设计理念607</span><br><span class="line"></span><br><span class="line">模块陷阱607</span><br><span class="line"></span><br><span class="line">顶层代码的语句次序的重要性608</span><br><span class="line"></span><br><span class="line">from复制变量名，而不是连接609</span><br><span class="line"></span><br><span class="line">from *会让变量语义模糊610</span><br><span class="line"></span><br><span class="line">reload不会影响from导入610</span><br><span class="line"></span><br><span class="line">reload、from以及交互模式测试611</span><br><span class="line"></span><br><span class="line">递归形式的from导入无法工作612</span><br><span class="line"></span><br><span class="line">本章小结613</span><br><span class="line"></span><br><span class="line">本章习题613</span><br><span class="line"></span><br><span class="line">习题解答613</span><br><span class="line"></span><br><span class="line">第五部分练习题614</span><br><span class="line"></span><br><span class="line">第六部分 类和OOP</span><br><span class="line"></span><br><span class="line">第25章 OOP：宏伟蓝图619</span><br><span class="line"></span><br><span class="line">为何使用类620</span><br><span class="line"></span><br><span class="line">概览OOP621</span><br><span class="line"></span><br><span class="line">属性继承搜索621</span><br><span class="line"></span><br><span class="line">类和实例623</span><br><span class="line"></span><br><span class="line">类方法调用624</span><br><span class="line"></span><br><span class="line">编写类树624</span><br><span class="line"></span><br><span class="line">OOP是为了代码重用627</span><br><span class="line"></span><br><span class="line">本章小结629</span><br><span class="line"></span><br><span class="line">本章习题629</span><br><span class="line"></span><br><span class="line">习题解答630</span><br><span class="line"></span><br><span class="line">第26章 类代码编写基础631</span><br><span class="line"></span><br><span class="line">类产生多个实例对象631</span><br><span class="line"></span><br><span class="line">类对象提供默认行为632</span><br><span class="line"></span><br><span class="line">实例对象是具体的元素632</span><br><span class="line"></span><br><span class="line">个例子632</span><br><span class="line"></span><br><span class="line">类通过继承进行定制635</span><br><span class="line"></span><br><span class="line">第二个例子635</span><br><span class="line"></span><br><span class="line">类是模块内的属性637</span><br><span class="line"></span><br><span class="line">类可以截获Python运算符638</span><br><span class="line"></span><br><span class="line">第三个例子639</span><br><span class="line"></span><br><span class="line">为什么要使用运算符重载1</span><br><span class="line"></span><br><span class="line">世界上简单的Python类1</span><br><span class="line"></span><br><span class="line">类与字典的关系4</span><br><span class="line"></span><br><span class="line">本章小结6</span><br><span class="line"></span><br><span class="line">本章习题6</span><br><span class="line"></span><br><span class="line">习题解答6</span><br><span class="line"></span><br><span class="line">第27章 更多实例9</span><br><span class="line"></span><br><span class="line">步骤1：创建实例650</span><br><span class="line"></span><br><span class="line">编写构造函数650</span><br><span class="line"></span><br><span class="line">在进行中测试651</span><br><span class="line"></span><br><span class="line">以两种方式使用代码652</span><br><span class="line"></span><br><span class="line">版本差异提示654</span><br><span class="line"></span><br><span class="line">步骤2：添加行为方法654</span><br><span class="line"></span><br><span class="line">编写方法656</span><br><span class="line"></span><br><span class="line">步骤3：运算符重载658</span><br><span class="line"></span><br><span class="line">提供打印显示658</span><br><span class="line"></span><br><span class="line">步骤4：通过子类定制行为659</span><br><span class="line"></span><br><span class="line">编写子类660</span><br><span class="line"></span><br><span class="line">扩展方法：不好的方式660</span><br><span class="line"></span><br><span class="line">扩展方法：好的方式661</span><br><span class="line"></span><br><span class="line">多态的作用663</span><br><span class="line"></span><br><span class="line">继承、定制和扩展6</span><br><span class="line"></span><br><span class="line">OOP：大思路6</span><br><span class="line"></span><br><span class="line">步骤5：定制构造函数665</span><br><span class="line"></span><br><span class="line">OOP比我们认为的要简单666</span><br><span class="line"></span><br><span class="line">组合类的其他方式667</span><br><span class="line"></span><br><span class="line">在Python 3.0中捕获内置属性669</span><br><span class="line"></span><br><span class="line">步骤6：使用内省工具670</span><br><span class="line"></span><br><span class="line">特殊类属性670</span><br><span class="line"></span><br><span class="line">一种通用显示工具671</span><br><span class="line"></span><br><span class="line">实例与类属性的关系672</span><br><span class="line"></span><br><span class="line">工具类的命名考虑673</span><br><span class="line"></span><br><span class="line">类的终形式674</span><br><span class="line"></span><br><span class="line">步骤7（后一步）：把对象存储到数据库中676</span><br><span class="line"></span><br><span class="line">Pickle和Shelve676</span><br><span class="line"></span><br><span class="line">在shelve数据库中存储对象677</span><br><span class="line"></span><br><span class="line">交互地探索shelve678</span><br><span class="line"></span><br><span class="line">更新shelve中的对象680</span><br><span class="line"></span><br><span class="line">未来方向681</span><br><span class="line"></span><br><span class="line">本章小结683</span><br><span class="line"></span><br><span class="line">本章习题684</span><br><span class="line"></span><br><span class="line">习题解答684</span><br><span class="line"></span><br><span class="line">第28章 类代码编写细节686</span><br><span class="line"></span><br><span class="line">class语句686</span><br><span class="line"></span><br><span class="line">一般形式686</span><br><span class="line"></span><br><span class="line">例子687</span><br><span class="line"></span><br><span class="line">方法689</span><br><span class="line"></span><br><span class="line">例子690</span><br><span class="line"></span><br><span class="line">调用超类构造函数691</span><br><span class="line"></span><br><span class="line">其他方法调用的可能性691</span><br><span class="line"></span><br><span class="line">继承692</span><br><span class="line"></span><br><span class="line">属性树的构造692</span><br><span class="line"></span><br><span class="line">继承方法的专有化693</span><br><span class="line"></span><br><span class="line">类接口技术694</span><br><span class="line"></span><br><span class="line">抽象超类695</span><br><span class="line"></span><br><span class="line">Python 2.6和Python 3.0的抽象超类696</span><br><span class="line"></span><br><span class="line">命名空间：完整的内容698</span><br><span class="line"></span><br><span class="line">简单变量名：如果赋值就不是全局变量698</span><br><span class="line"></span><br><span class="line">属性名称：对象命名空间698</span><br><span class="line"></span><br><span class="line">Python命名空间的“禅”：赋值将变量名分类699</span><br><span class="line"></span><br><span class="line">命名空间字典701</span><br><span class="line"></span><br><span class="line">命名空间链接704</span><br><span class="line"></span><br><span class="line">回顾文档字符串706</span><br><span class="line"></span><br><span class="line">类与模块的关系707</span><br><span class="line"></span><br><span class="line">本章小结708</span><br><span class="line"></span><br><span class="line">本章习题708</span><br><span class="line"></span><br><span class="line">习题解答708</span><br><span class="line"></span><br><span class="line">第29章 运算符重载710</span><br><span class="line"></span><br><span class="line">基础知识710</span><br><span class="line"></span><br><span class="line">构造函数和表达式：__init__和__sub__711</span><br><span class="line"></span><br><span class="line">常见的运算符重载方法711</span><br><span class="line"></span><br><span class="line">索引和分片：__getitem__和__setitem__713</span><br><span class="line"></span><br><span class="line">拦截分片713</span><br><span class="line"></span><br><span class="line">Python 2.6中的分片和索引715</span><br><span class="line"></span><br><span class="line">索引迭代：__getitem__716</span><br><span class="line"></span><br><span class="line">迭代器对象：__iter__和__next__717</span><br><span class="line"></span><br><span class="line">用户定义的迭代器717</span><br><span class="line"></span><br><span class="line">有多个迭代器的对象719</span><br><span class="line"></span><br><span class="line">成员关系：__contains__、__iter__和__getitem__721</span><br><span class="line"></span><br><span class="line">属性引用：__getattr__和__setattr__723</span><br><span class="line"></span><br><span class="line">其他属性管理工具725</span><br><span class="line"></span><br><span class="line">模拟实例属性的私有性：部分725</span><br><span class="line"></span><br><span class="line">__repr__和__str__会返回字符串表达形式726</span><br><span class="line"></span><br><span class="line">右侧加法和原处加法：__radd__和__iadd__729</span><br><span class="line"></span><br><span class="line">原处加法730</span><br><span class="line"></span><br><span class="line">Call表达式：__call__731</span><br><span class="line"></span><br><span class="line">函数接口和回调代码732</span><br><span class="line"></span><br><span class="line">比较：__lt__、__gt__和其他方法734</span><br><span class="line"></span><br><span class="line">Python 2.6的__cmp__方法（已经从Python 3.0中移除了）734</span><br><span class="line"></span><br><span class="line">布尔测试：__bool__和__len__735</span><br><span class="line"></span><br><span class="line">Python 2.6中的布尔736</span><br><span class="line"></span><br><span class="line">对象析构函数：__del__738</span><br><span class="line"></span><br><span class="line">本章小结739</span><br><span class="line"></span><br><span class="line">本章习题739</span><br><span class="line"></span><br><span class="line">习题解答739</span><br><span class="line"></span><br><span class="line">第30章 类的设计741</span><br><span class="line"></span><br><span class="line">Python和OOP741</span><br><span class="line"></span><br><span class="line">通过调用标记进行重载（或不要）742</span><br><span class="line"></span><br><span class="line">OOP和继承：“是一个”关系743</span><br><span class="line"></span><br><span class="line">OOP和组合：“有一个”关系744</span><br><span class="line"></span><br><span class="line">重访流处理器746</span><br><span class="line"></span><br><span class="line">为什么要在意：类和持续性748</span><br><span class="line"></span><br><span class="line">OOP和委托：“包装”对象749</span><br><span class="line"></span><br><span class="line">类的伪私有属性751</span><br><span class="line"></span><br><span class="line">变量名压缩概览751</span><br><span class="line"></span><br><span class="line">为什么使用伪私有属性752</span><br><span class="line"></span><br><span class="line">方法是对象：绑定或无绑定754</span><br><span class="line"></span><br><span class="line">在Python 3.0中，无绑定方法是函数756</span><br><span class="line"></span><br><span class="line">绑定方法和其他可调用对象757</span><br><span class="line"></span><br><span class="line">为什么要在意：绑定方法和回调函数760</span><br><span class="line"></span><br><span class="line">多重继承：“混合”类760</span><br><span class="line"></span><br><span class="line">编写混合显示类761</span><br><span class="line"></span><br><span class="line">类是对象：通用对象的工厂771</span><br><span class="line"></span><br><span class="line">为什么有工厂772</span><br><span class="line"></span><br><span class="line">与设计相关的其他话题773</span><br><span class="line"></span><br><span class="line">本章小结773</span><br><span class="line"></span><br><span class="line">本章习题774</span><br><span class="line"></span><br><span class="line">习题解答774</span><br><span class="line"></span><br><span class="line">第31章 类的不错主题775</span><br><span class="line"></span><br><span class="line">扩展内置类型775</span><br><span class="line"></span><br><span class="line">通过嵌入扩展类型776</span><br><span class="line"></span><br><span class="line">通过子类扩展类型777</span><br><span class="line"></span><br><span class="line">新式类779</span><br><span class="line"></span><br><span class="line">新式类变化780</span><br><span class="line"></span><br><span class="line">类型模式变化781</span><br><span class="line"></span><br><span class="line">钻石继承变动785</span><br><span class="line"></span><br><span class="line">新式类的扩展789</span><br><span class="line"></span><br><span class="line">slots实例789</span><br><span class="line"></span><br><span class="line">类特性793</span><br><span class="line"></span><br><span class="line">__getattribute__和描述符795</span><br><span class="line"></span><br><span class="line">元类795</span><br><span class="line"></span><br><span class="line">静态方法和类方法796</span><br><span class="line"></span><br><span class="line">为什么使用特殊方法796</span><br><span class="line"></span><br><span class="line">Python 2.6和Python 3.0中的静态方法797</span><br><span class="line"></span><br><span class="line">静态方法替代方案799</span><br><span class="line"></span><br><span class="line">使用静态和类方法800</span><br><span class="line"></span><br><span class="line">使用静态方法统计实例801</span><br><span class="line"></span><br><span class="line">用类方法统计实例802</span><br><span class="line"></span><br><span class="line">装饰器和元类：部分805</span><br><span class="line"></span><br><span class="line">函数装饰器基础805</span><br><span class="line"></span><br><span class="line">装饰器例子806</span><br><span class="line"></span><br><span class="line">类装饰器和元类807</span><br><span class="line"></span><br><span class="line">更多详细信息808</span><br><span class="line"></span><br><span class="line">类陷阱809</span><br><span class="line"></span><br><span class="line">修改类属性的副作用809</span><br><span class="line"></span><br><span class="line">修改可变的类属性也可能产生副作用810</span><br><span class="line"></span><br><span class="line">多重继承：顺序很重要811</span><br><span class="line"></span><br><span class="line">类、方法以及嵌套作用域812</span><br><span class="line"></span><br><span class="line">Python中基于委托的类：__getattr__和内置函数814</span><br><span class="line"></span><br><span class="line">“过度包装”814</span><br><span class="line"></span><br><span class="line">本章小结815</span><br><span class="line"></span><br><span class="line">本章习题815</span><br><span class="line"></span><br><span class="line">习题解答815</span><br><span class="line"></span><br><span class="line">第六部分 练习题816</span><br><span class="line"></span><br><span class="line">为什么要在意：大师眼中的OOP821</span><br><span class="line"></span><br><span class="line">第七部分 异常和工具</span><br><span class="line"></span><br><span class="line">第32章 异常基础825</span><br><span class="line"></span><br><span class="line">为什么使用异常826</span><br><span class="line"></span><br><span class="line">异常的角色826</span><br><span class="line"></span><br><span class="line">异常处理：简明扼要827</span><br><span class="line"></span><br><span class="line">默认异常处理器827</span><br><span class="line"></span><br><span class="line">捕获异常828</span><br><span class="line"></span><br><span class="line">引发异常829</span><br><span class="line"></span><br><span class="line">用户定义的异常830</span><br><span class="line"></span><br><span class="line">终止行为830</span><br><span class="line"></span><br><span class="line">为什么要在意：错误检查832</span><br><span class="line"></span><br><span class="line">本章小结833</span><br><span class="line"></span><br><span class="line">本章习题833</span><br><span class="line"></span><br><span class="line">习题解答834</span><br><span class="line"></span><br><span class="line">第33章 异常编码细节835</span><br><span class="line"></span><br><span class="line">try&#x2F;except&#x2F;else语句835</span><br><span class="line"></span><br><span class="line">try语句分句836</span><br><span class="line"></span><br><span class="line">try&#x2F;else分句839</span><br><span class="line"></span><br><span class="line">例子：默认行为840</span><br><span class="line"></span><br><span class="line">例子：捕捉内置异常841</span><br><span class="line"></span><br><span class="line">try&#x2F;finally语句841</span><br><span class="line"></span><br><span class="line">例子：利用try&#x2F;finally编写终止行为842</span><br><span class="line"></span><br><span class="line">统一try&#x2F;except&#x2F;finally语句843</span><br><span class="line"></span><br><span class="line">统一try语句语法845</span><br><span class="line"></span><br><span class="line">通过嵌套合并finally和except845</span><br><span class="line"></span><br><span class="line">合并try的例子846</span><br><span class="line"></span><br><span class="line">raise语句847</span><br><span class="line"></span><br><span class="line">利用raise传递异常849</span><br><span class="line"></span><br><span class="line">Python 3.0异常链：raise from849</span><br><span class="line"></span><br><span class="line">assert语句850</span><br><span class="line"></span><br><span class="line">例子：收集约束条件（但不是错误）850</span><br><span class="line"></span><br><span class="line">with&#x2F;as环境管理器851</span><br><span class="line"></span><br><span class="line">基本使用852</span><br><span class="line"></span><br><span class="line">环境管理协议853</span><br><span class="line"></span><br><span class="line">本章小结855</span><br><span class="line"></span><br><span class="line">本章习题855</span><br><span class="line"></span><br><span class="line">习题解答856</span><br><span class="line"></span><br><span class="line">第34章 异常对象857</span><br><span class="line"></span><br><span class="line">异常：回到未来858</span><br><span class="line"></span><br><span class="line">字符串异常很简单858</span><br><span class="line"></span><br><span class="line">基于类的异常858</span><br><span class="line"></span><br><span class="line">类异常例子859</span><br><span class="line"></span><br><span class="line">为什么使用类异常861</span><br><span class="line"></span><br><span class="line">内置Exception类8</span><br><span class="line"></span><br><span class="line">内置异常分类865</span><br><span class="line"></span><br><span class="line">默认打印和状态866</span><br><span class="line"></span><br><span class="line">定制打印显示867</span><br><span class="line"></span><br><span class="line">定制数据和行为868</span><br><span class="line"></span><br><span class="line">提供异常细节868</span><br><span class="line"></span><br><span class="line">提供异常方法869</span><br><span class="line"></span><br><span class="line">本章小结870</span><br><span class="line"></span><br><span class="line">本章习题870</span><br><span class="line"></span><br><span class="line">习题解答870</span><br><span class="line"></span><br><span class="line">第35章 异常的设计872</span><br><span class="line"></span><br><span class="line">嵌套异常处理器872</span><br><span class="line"></span><br><span class="line">例子：控制流程嵌套873</span><br><span class="line"></span><br><span class="line">例子：语法嵌套化874</span><br><span class="line"></span><br><span class="line">异常的习惯用法876</span><br><span class="line"></span><br><span class="line">异常不总是错误876</span><br><span class="line"></span><br><span class="line">函数信号条件和raise876</span><br><span class="line"></span><br><span class="line">关闭文件和服务器连接877</span><br><span class="line"></span><br><span class="line">在try外进行调试878</span><br><span class="line"></span><br><span class="line">运行进程中的测试879</span><br><span class="line"></span><br><span class="line">关于sys.exc_info879</span><br><span class="line"></span><br><span class="line">与异常有关的技巧880</span><br><span class="line"></span><br><span class="line">应该包装什么881</span><br><span class="line"></span><br><span class="line">捕捉太多：避免空except语句881</span><br><span class="line"></span><br><span class="line">捕捉过少：使用基于类的分类883</span><br><span class="line"></span><br><span class="line">核心语言总结884</span><br><span class="line"></span><br><span class="line">Python工具集884</span><br><span class="line"></span><br><span class="line">大型项目的开发工具885</span><br><span class="line"></span><br><span class="line">本章小结888</span><br><span class="line"></span><br><span class="line">第七部分练习题889</span><br><span class="line"></span><br><span class="line">第八部分 不错话题注1</span><br><span class="line"></span><br><span class="line">第36章 Unicode和字节字符串893</span><br><span class="line"></span><br><span class="line">Python 3.0中的字符串修改894</span><br><span class="line"></span><br><span class="line">字符串基础知识895</span><br><span class="line"></span><br><span class="line">字符编码方法895</span><br><span class="line"></span><br><span class="line">Python的字符串类型897</span><br><span class="line"></span><br><span class="line">文本和二进制文件899</span><br><span class="line"></span><br><span class="line">Python 3.0中的字符串应用900</span><br><span class="line"></span><br><span class="line">常量和基本属性900</span><br><span class="line"></span><br><span class="line">转换901</span><br><span class="line"></span><br><span class="line">编码Unicode字符串903</span><br><span class="line"></span><br><span class="line">编码ASCII文本903</span><br><span class="line"></span><br><span class="line">编码非ASCII文本904</span><br><span class="line"></span><br><span class="line">编码和解码非ASCII文本904</span><br><span class="line"></span><br><span class="line">其他Unicode编码技术905</span><br><span class="line"></span><br><span class="line">转换编码907</span><br><span class="line"></span><br><span class="line">在Python 2.6中编码Unicode字符串908</span><br><span class="line"></span><br><span class="line">源文件字符集编码声明910</span><br><span class="line"></span><br><span class="line">使用Python 3.0 Bytes对象911</span><br><span class="line"></span><br><span class="line">方法调用912</span><br><span class="line"></span><br><span class="line">序列操作913</span><br><span class="line"></span><br><span class="line">创建bytes对象的其他方式913</span><br><span class="line"></span><br><span class="line">混合字符串类型914</span><br><span class="line"></span><br><span class="line">使用Python 3.0（和Python 2.6）bytearray对象915</span><br><span class="line"></span><br><span class="line">使用文本文件和二进制文件918</span><br><span class="line"></span><br><span class="line">文本文件基础919</span><br><span class="line"></span><br><span class="line">Python 3.0中的文本和二进制模式919</span><br><span class="line"></span><br><span class="line">类型和内容错误匹配921</span><br><span class="line"></span><br><span class="line">使用Unicode文件922</span><br><span class="line"></span><br><span class="line">在Python 3.0中读取和写入Unicode922</span><br><span class="line"></span><br><span class="line">在Python 3.0中处理BOM924</span><br><span class="line"></span><br><span class="line">Python 2.6中的Unicode文件927</span><br><span class="line"></span><br><span class="line">Python 3.0中其他字符串工具的变化927</span><br><span class="line"></span><br><span class="line">re模式匹配模块927</span><br><span class="line"></span><br><span class="line">Struct二进制数据模块928</span><br><span class="line"></span><br><span class="line">pickle对象序列化模块931</span><br><span class="line"></span><br><span class="line">XML解析工具932</span><br><span class="line"></span><br><span class="line">本章小结935</span><br><span class="line"></span><br><span class="line">本章习题935</span><br><span class="line"></span><br><span class="line">习题解答936</span><br><span class="line"></span><br><span class="line">第37章 管理属性938</span><br><span class="line"></span><br><span class="line">为什么管理属性938</span><br><span class="line"></span><br><span class="line">插入在属性访问时运行的代码939</span><br><span class="line"></span><br><span class="line">特性940</span><br><span class="line"></span><br><span class="line">基础知识940</span><br><span class="line"></span><br><span class="line">个例子941</span><br><span class="line"></span><br><span class="line">计算的属性942</span><br><span class="line"></span><br><span class="line">使用装饰器编写特性943</span><br><span class="line"></span><br><span class="line">描述符944</span><br><span class="line"></span><br><span class="line">基础知识945</span><br><span class="line"></span><br><span class="line">个示例947</span><br><span class="line"></span><br><span class="line">计算的属性949</span><br><span class="line"></span><br><span class="line">在描述符中使用状态信息950</span><br><span class="line"></span><br><span class="line">特性和描述符是如何相关的952</span><br><span class="line"></span><br><span class="line">__getattr__和__getattribute__953</span><br><span class="line"></span><br><span class="line">基础知识954</span><br><span class="line"></span><br><span class="line">个示例956</span><br><span class="line"></span><br><span class="line">计算属性958</span><br><span class="line"></span><br><span class="line">__getattr__和__getattribute__比较959</span><br><span class="line"></span><br><span class="line">管理技术比较960</span><br><span class="line"></span><br><span class="line">拦截内置操作属性963</span><br><span class="line"></span><br><span class="line">重访基于委托的Manager967</span><br><span class="line"></span><br><span class="line">示例：属性验证970</span><br><span class="line"></span><br><span class="line">使用特性来验证971</span><br><span class="line"></span><br><span class="line">使用描述符验证973</span><br><span class="line"></span><br><span class="line">使用__getattr__来验证974</span><br><span class="line"></span><br><span class="line">使用__getattribute__验证976</span><br><span class="line"></span><br><span class="line">本章小结977</span><br><span class="line"></span><br><span class="line">本章习题977</span><br><span class="line"></span><br><span class="line">习题解答977</span><br><span class="line"></span><br><span class="line">第38章 装饰器979</span><br><span class="line"></span><br><span class="line">什么是装饰器979</span><br><span class="line"></span><br><span class="line">管理调用和实例980</span><br><span class="line"></span><br><span class="line">管理函数和类980</span><br><span class="line"></span><br><span class="line">使用和定义装饰器981</span><br><span class="line"></span><br><span class="line">为什么使用装饰器981</span><br><span class="line"></span><br><span class="line">基础知识982</span><br><span class="line"></span><br><span class="line">函数装饰器982</span><br><span class="line"></span><br><span class="line">类装饰器986</span><br><span class="line"></span><br><span class="line">装饰器嵌套988</span><br><span class="line"></span><br><span class="line">装饰器参数990</span><br><span class="line"></span><br><span class="line">装饰器管理函数和类991</span><br><span class="line"></span><br><span class="line">编写函数装饰器991</span><br><span class="line"></span><br><span class="line">跟踪调用992</span><br><span class="line"></span><br><span class="line">状态信息保持选项993</span><br><span class="line"></span><br><span class="line">类错误之一：装饰类方法997</span><br><span class="line"></span><br><span class="line">计时调用1002</span><br><span class="line"></span><br><span class="line">添加装饰器参数1004</span><br><span class="line"></span><br><span class="line">编写类装饰器1007</span><br><span class="line"></span><br><span class="line">单体类1007</span><br><span class="line"></span><br><span class="line">跟踪对象接口1009</span><br><span class="line"></span><br><span class="line">类错误之二：保持多个实例1012</span><br><span class="line"></span><br><span class="line">装饰器与管理器函数的关系1013</span><br><span class="line"></span><br><span class="line">为什么使用装饰器（重访）1015</span><br><span class="line"></span><br><span class="line">直接管理函数和类1016</span><br><span class="line"></span><br><span class="line">示例：“私有”和“公有”属性1018</span><br><span class="line"></span><br><span class="line">实现私有属性1019</span><br><span class="line"></span><br><span class="line">实现细节之一1021</span><br><span class="line"></span><br><span class="line">公有声明的泛化1022</span><br><span class="line"></span><br><span class="line">实现细节之二1024</span><br><span class="line"></span><br><span class="line">开放问题1025</span><br><span class="line"></span><br><span class="line">Python不是关于控制1029</span><br><span class="line"></span><br><span class="line">示例：验证函数参数1030</span><br><span class="line"></span><br><span class="line">目标1030</span><br><span class="line"></span><br><span class="line">针对位置参数的一个基本范围测试装饰器1031</span><br><span class="line"></span><br><span class="line">针对关键字和默认泛化1033</span><br><span class="line"></span><br><span class="line">实现细节1036</span><br><span class="line"></span><br><span class="line">开放问题1038</span><br><span class="line"></span><br><span class="line">装饰器参数 VS 函数注解1039</span><br><span class="line"></span><br><span class="line">其他应用程序：类型测试1041</span><br><span class="line"></span><br><span class="line">本章小结1042</span><br><span class="line"></span><br><span class="line">本章习题1042</span><br><span class="line"></span><br><span class="line">习题解答1043</span><br><span class="line"></span><br><span class="line">第39章 元类1046</span><br><span class="line"></span><br><span class="line">要么是元类，要么不是元类1046</span><br><span class="line"></span><br><span class="line">提高魔力层次1047</span><br><span class="line"></span><br><span class="line">“辅助”函数的缺点1049</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：回合1051</span><br><span class="line"></span><br><span class="line">元类模型1053</span><br><span class="line"></span><br><span class="line">类是类型的实例1053</span><br><span class="line"></span><br><span class="line">元类是Type的子类1055</span><br><span class="line"></span><br><span class="line">Class语句协议1056</span><br><span class="line"></span><br><span class="line">声明元类1057</span><br><span class="line"></span><br><span class="line">编写元类1058</span><br><span class="line"></span><br><span class="line">基本元类1058</span><br><span class="line"></span><br><span class="line">定制构建和初始化1059</span><br><span class="line"></span><br><span class="line">其他元类编程技巧1060</span><br><span class="line"></span><br><span class="line">实例与继承的关系1063</span><br><span class="line"></span><br><span class="line">示例：向类添加方法10</span><br><span class="line"></span><br><span class="line">手动扩展10</span><br><span class="line"></span><br><span class="line">基于元类的扩展1065</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：第二回合1067</span><br><span class="line"></span><br><span class="line">示例：对方法应用装饰器1070</span><br><span class="line"></span><br><span class="line">用装饰器手动跟踪1070</span><br><span class="line"></span><br><span class="line">用元类和装饰器跟踪1071</span><br><span class="line"></span><br><span class="line">把任何装饰器应用于方法1073</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：第三回合1074</span><br><span class="line"></span><br><span class="line">“可选的”语言功能1076</span><br><span class="line"></span><br><span class="line">本章小结1078</span><br><span class="line"></span><br><span class="line">本章习题1078</span><br><span class="line"></span><br><span class="line">习题解答1078</span><br><span class="line"></span><br><span class="line">第九部分 附录注2</span><br><span class="line"></span><br><span class="line">附录A 安装和配置1083</span><br><span class="line"></span><br><span class="line">附录B 各部分练习题的解答 1093</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习手册(第4版) PDF</title>
    <url>/posts/cfb55a7a/</url>
    <content><![CDATA[<h4 id="《Python学习手册-第4版-》"><a href="#《Python学习手册-第4版-》" class="headerlink" title="《Python学习手册(第4版)》"></a>《Python学习手册(第4版)》</h4><h6 id="链接-https-pan-baidu-com-s-17jJCAPuZfjoeiTlYr8Ijjg-提取码-arcd"><a href="#链接-https-pan-baidu-com-s-17jJCAPuZfjoeiTlYr8Ijjg-提取码-arcd" class="headerlink" title="链接: https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg 提取码: arcd"></a>链接: <a href="https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg">https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg</a> 提取码: arcd</h6><p>Google和YouTube由于PythonF的高可适应性、易于维护以及适合于快速开发而采用它。《Python学习手册(第4版)》将帮助你使用Python编写出高质量、高效的并且易于与其他语言和工具集成的代码。《Python学习手册(第4版)》根据Python专家MarkLutz的有名培训课程编写而成，是易于掌握和自学的Python教程。<br><a id="more"></a></p>
<p>《Python学习手册(第4版)》每一章都对Python语言的关键内容做单独讲解，并且配有章首习题，便于你学习新的技能并巩固加深自己的理解。书中配等</p>
<p>《Python学习手册(第4版)》学习Python的主要内建对象类型：数字、列表和字典。使用Python语句创建和处理对象，并且学习Python的通用语法模型。使用函数构造和重用代码，函数是Python的基本过程工具。学习Python模块：封装语句、函数以及其他工具，以便构建较大的组件。学习Python的面向对象编程工具，用于组织程序代码。学习异常处理模型，以及用于编写较大程序的开发工具。了解不错Python工具，如装饰器、描述器、元类和Unicode处理等</p>
<p><img src="/images/d29e9d83b6572c175b238fcaaee1940c1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言1</span><br><span class="line"></span><br><span class="line">部分 使用入门</span><br><span class="line"></span><br><span class="line">章 问答环节19</span><br><span class="line"></span><br><span class="line">人们为何使用Python19</span><br><span class="line"></span><br><span class="line">软件质量20</span><br><span class="line"></span><br><span class="line">开发效率21</span><br><span class="line"></span><br><span class="line">Python是“脚本语言”吗21</span><br><span class="line"></span><br><span class="line">好吧，Python的缺点是什么呢23</span><br><span class="line"></span><br><span class="line">如今谁在使用Python23</span><br><span class="line"></span><br><span class="line">使用Python可以做些什么24</span><br><span class="line"></span><br><span class="line">系统编程25</span><br><span class="line"></span><br><span class="line">用户图形接口25</span><br><span class="line"></span><br><span class="line">Internet脚本25</span><br><span class="line"></span><br><span class="line">组件集成26</span><br><span class="line"></span><br><span class="line">数据库编程26</span><br><span class="line"></span><br><span class="line">快速原型27</span><br><span class="line"></span><br><span class="line">数值计算和科学计算编程27</span><br><span class="line"></span><br><span class="line">游戏、图像、人工智能、XML、机器人等27</span><br><span class="line"></span><br><span class="line">Python如何获得支持28</span><br><span class="line"></span><br><span class="line">Python有哪些技术上的优点28</span><br><span class="line"></span><br><span class="line">面向对象28</span><br><span class="line"></span><br><span class="line">免费29</span><br><span class="line"></span><br><span class="line">可移植29</span><br><span class="line"></span><br><span class="line">功能强大30</span><br><span class="line"></span><br><span class="line">可混合31</span><br><span class="line"></span><br><span class="line">简单易用31</span><br><span class="line"></span><br><span class="line">简单易学32</span><br><span class="line"></span><br><span class="line">Python和其他语言比较起来怎么样32</span><br><span class="line"></span><br><span class="line">本章小结33</span><br><span class="line"></span><br><span class="line">本章习题33</span><br><span class="line"></span><br><span class="line">习题解答34</span><br><span class="line"></span><br><span class="line">Python是工程，不是艺术34</span><br><span class="line"></span><br><span class="line">第2章 Python如何运行程序36</span><br><span class="line"></span><br><span class="line">Python解释器简介36</span><br><span class="line"></span><br><span class="line">程序执行37</span><br><span class="line"></span><br><span class="line">程序员的视角37</span><br><span class="line"></span><br><span class="line">Python的视角39</span><br><span class="line"></span><br><span class="line">执行模块的变体41</span><br><span class="line"></span><br><span class="line">Python实现的替代者42</span><br><span class="line"></span><br><span class="line">执行优化工具43</span><br><span class="line"></span><br><span class="line">冻结二进制文件44</span><br><span class="line"></span><br><span class="line">其他执行选项45</span><br><span class="line"></span><br><span class="line">未来的可能性46</span><br><span class="line"></span><br><span class="line">本章小结46</span><br><span class="line"></span><br><span class="line">本章习题47</span><br><span class="line"></span><br><span class="line">习题解答47</span><br><span class="line"></span><br><span class="line">第3章 如何运行程序48</span><br><span class="line"></span><br><span class="line">交互提示模式下编写代码48</span><br><span class="line"></span><br><span class="line">交互地运行代码49</span><br><span class="line"></span><br><span class="line">为什么使用交互提示模式51</span><br><span class="line"></span><br><span class="line">使用交互提示模式52</span><br><span class="line"></span><br><span class="line">系统命令行和文件54</span><br><span class="line"></span><br><span class="line">段脚本55</span><br><span class="line"></span><br><span class="line">使用命令行运行文件56</span><br><span class="line"></span><br><span class="line">使用命令行和文件57</span><br><span class="line"></span><br><span class="line">UNIX可执行脚本(#!)58</span><br><span class="line"></span><br><span class="line">UNIX env查找技巧59</span><br><span class="line"></span><br><span class="line">点击文件图标60</span><br><span class="line"></span><br><span class="line">在Windows中点击图标60</span><br><span class="line"></span><br><span class="line">input的技巧61</span><br><span class="line"></span><br><span class="line">图标点击的其他63</span><br><span class="line"></span><br><span class="line">模块导入和重载63</span><br><span class="line"></span><br><span class="line">模块的显要特性：属性65</span><br><span class="line"></span><br><span class="line">import和reload的使用注意事项68</span><br><span class="line"></span><br><span class="line">使用exec运行模块文件69</span><br><span class="line"></span><br><span class="line">IDLE用户界面70</span><br><span class="line"></span><br><span class="line">IDLE基础71</span><br><span class="line"></span><br><span class="line">使用IDLE72</span><br><span class="line"></span><br><span class="line">不错IDLE工具74</span><br><span class="line"></span><br><span class="line">其他的IDE74</span><br><span class="line"></span><br><span class="line">其他启动选项76</span><br><span class="line"></span><br><span class="line">嵌入式调用76</span><br><span class="line"></span><br><span class="line">冻结二进制的可执行性77</span><br><span class="line"></span><br><span class="line">文本编辑器启动的选择77</span><br><span class="line"></span><br><span class="line">其他的启动选择77</span><br><span class="line"></span><br><span class="line">未来的可能77</span><br><span class="line"></span><br><span class="line">我应该选用哪种78</span><br><span class="line"></span><br><span class="line">调试Python代码78</span><br><span class="line"></span><br><span class="line">本章小结80</span><br><span class="line"></span><br><span class="line">本章习题80</span><br><span class="line"></span><br><span class="line">习题解答80</span><br><span class="line"></span><br><span class="line">部分 练习题81</span><br><span class="line"></span><br><span class="line">第二部分 类型和运算</span><br><span class="line"></span><br><span class="line">第4章 介绍Python对象类型87</span><br><span class="line"></span><br><span class="line">为什么使用内置类型88</span><br><span class="line"></span><br><span class="line">Python的核心数据类型88</span><br><span class="line"></span><br><span class="line">数字90</span><br><span class="line"></span><br><span class="line">字符串92</span><br><span class="line"></span><br><span class="line">序列的操作92</span><br><span class="line"></span><br><span class="line">不可变性94</span><br><span class="line"></span><br><span class="line">类型特定的方法94</span><br><span class="line"></span><br><span class="line">寻求帮助96</span><br><span class="line"></span><br><span class="line">编写字符串的其他方法97</span><br><span class="line"></span><br><span class="line">模式匹配98</span><br><span class="line"></span><br><span class="line">列表98</span><br><span class="line"></span><br><span class="line">序列操作98</span><br><span class="line"></span><br><span class="line">类型特定的操作99</span><br><span class="line"></span><br><span class="line">边界检查100</span><br><span class="line"></span><br><span class="line">嵌套100</span><br><span class="line"></span><br><span class="line">列表解析101</span><br><span class="line"></span><br><span class="line">字典103</span><br><span class="line"></span><br><span class="line">映射操作103</span><br><span class="line"></span><br><span class="line">重访嵌套104</span><br><span class="line"></span><br><span class="line">键的排序：for 循环105</span><br><span class="line"></span><br><span class="line">迭代和优化107</span><br><span class="line"></span><br><span class="line">不存在的键：if 测试107</span><br><span class="line"></span><br><span class="line">元组109</span><br><span class="line"></span><br><span class="line">为什么要用元组109</span><br><span class="line"></span><br><span class="line">文件110</span><br><span class="line"></span><br><span class="line">其他文件类工具111</span><br><span class="line"></span><br><span class="line">其他核心类型111</span><br><span class="line"></span><br><span class="line">如何破坏代码的灵活性113</span><br><span class="line"></span><br><span class="line">用户定义的类114</span><br><span class="line"></span><br><span class="line">剩余的内容115</span><br><span class="line"></span><br><span class="line">本章小结115</span><br><span class="line"></span><br><span class="line">本章习题116</span><br><span class="line"></span><br><span class="line">习题解答116</span><br><span class="line"></span><br><span class="line">第5章 数字117</span><br><span class="line"></span><br><span class="line">Python的数字类型117</span><br><span class="line"></span><br><span class="line">数字常量118</span><br><span class="line"></span><br><span class="line">内置数学工具和扩展119</span><br><span class="line"></span><br><span class="line">Python表达式操作符120</span><br><span class="line"></span><br><span class="line">在实际应用中的数字125</span><br><span class="line"></span><br><span class="line">变量和基本的表达式125</span><br><span class="line"></span><br><span class="line">数字显示的格式126</span><br><span class="line"></span><br><span class="line">比较：一般的和连续的127</span><br><span class="line"></span><br><span class="line">str和repr显示格式128</span><br><span class="line"></span><br><span class="line">除法： 传统除法、Floor除法和真除法129</span><br><span class="line"></span><br><span class="line">整数精度133</span><br><span class="line"></span><br><span class="line">复数133</span><br><span class="line"></span><br><span class="line">十六进制、八进制和二进制记数134</span><br><span class="line"></span><br><span class="line">位操作136</span><br><span class="line"></span><br><span class="line">其他的内置数学工具137</span><br><span class="line"></span><br><span class="line">其他数字类型139</span><br><span class="line"></span><br><span class="line">小数数字139</span><br><span class="line"></span><br><span class="line">分数类型141</span><br><span class="line"></span><br><span class="line">集合145</span><br><span class="line"></span><br><span class="line">布尔型151</span><br><span class="line"></span><br><span class="line">数字扩展152</span><br><span class="line"></span><br><span class="line">本章小结153</span><br><span class="line"></span><br><span class="line">本章习题153</span><br><span class="line"></span><br><span class="line">习题解答153</span><br><span class="line"></span><br><span class="line">第6章 动态类型简介155</span><br><span class="line"></span><br><span class="line">缺少类型声明语句的情况155</span><br><span class="line"></span><br><span class="line">变量、对象和引用156</span><br><span class="line"></span><br><span class="line">类型属于对象，而不是变量157</span><br><span class="line"></span><br><span class="line">对象的垃圾收集158</span><br><span class="line"></span><br><span class="line">共享引用159</span><br><span class="line"></span><br><span class="line">共享引用和在原处修改161</span><br><span class="line"></span><br><span class="line">共享引用和相等163</span><br><span class="line"></span><br><span class="line">动态类型随处可见1</span><br><span class="line"></span><br><span class="line">本章小结165</span><br><span class="line"></span><br><span class="line">本章习题165</span><br><span class="line"></span><br><span class="line">习题解答165</span><br><span class="line"></span><br><span class="line">第7章 字符串167</span><br><span class="line"></span><br><span class="line">字符串常量169</span><br><span class="line"></span><br><span class="line">单双引号字符串是一样的170</span><br><span class="line"></span><br><span class="line">用转义序列代表特殊字节171</span><br><span class="line"></span><br><span class="line">raw字符串抑制转义173</span><br><span class="line"></span><br><span class="line">三重引号编写多行字符串块175</span><br><span class="line"></span><br><span class="line">实际应用中的字符串176</span><br><span class="line"></span><br><span class="line">基本操作176</span><br><span class="line"></span><br><span class="line">索引和分片177</span><br><span class="line"></span><br><span class="line">为什么要在意：分片181</span><br><span class="line"></span><br><span class="line">字符串转换工具181</span><br><span class="line"></span><br><span class="line">修改字符串184</span><br><span class="line"></span><br><span class="line">字符串方法185</span><br><span class="line"></span><br><span class="line">字符串方法实例：修改字符串187</span><br><span class="line"></span><br><span class="line">字符串方法实例：文本解析189</span><br><span class="line"></span><br><span class="line">实际应用中的其他常见字符串方法190</span><br><span class="line"></span><br><span class="line">初的字符串模块（在Python 3.0中删除）191</span><br><span class="line"></span><br><span class="line">字符串格式化表达式192</span><br><span class="line"></span><br><span class="line">更不错的字符串格式化表达式194</span><br><span class="line"></span><br><span class="line">基于字典的字符串格式化196</span><br><span class="line"></span><br><span class="line">字符串格式化调用方法196</span><br><span class="line"></span><br><span class="line">基础知识197</span><br><span class="line"></span><br><span class="line">添加键、属性和偏移量198</span><br><span class="line"></span><br><span class="line">添加具体格式化198</span><br><span class="line"></span><br><span class="line">与%格式化表达式比较200</span><br><span class="line"></span><br><span class="line">为什么用新的格式化方法203</span><br><span class="line"></span><br><span class="line">通常意义下的类型分类206</span><br><span class="line"></span><br><span class="line">同样分类的类型共享其操作集合206</span><br><span class="line"></span><br><span class="line">可变类型能够在原处修改207</span><br><span class="line"></span><br><span class="line">本章小结208</span><br><span class="line"></span><br><span class="line">本章习题208</span><br><span class="line"></span><br><span class="line">习题解答208</span><br><span class="line"></span><br><span class="line">第8章 列表与字典210</span><br><span class="line"></span><br><span class="line">列表210</span><br><span class="line"></span><br><span class="line">实际应用中的列表213</span><br><span class="line"></span><br><span class="line">基本列表操作213</span><br><span class="line"></span><br><span class="line">列表迭代和解析213</span><br><span class="line"></span><br><span class="line">索引、分片和矩阵214</span><br><span class="line"></span><br><span class="line">原处修改列表215</span><br><span class="line"></span><br><span class="line">字典220</span><br><span class="line"></span><br><span class="line">实际应用中的字典222</span><br><span class="line"></span><br><span class="line">字典的基本操作222</span><br><span class="line"></span><br><span class="line">原处修改字典223</span><br><span class="line"></span><br><span class="line">其他字典方法224</span><br><span class="line"></span><br><span class="line">语言表225</span><br><span class="line"></span><br><span class="line">字典用法注意事项226</span><br><span class="line"></span><br><span class="line">为什么要在意字典接口229</span><br><span class="line"></span><br><span class="line">创建字典的其他方法230</span><br><span class="line"></span><br><span class="line">Python 3.0中的字典变化231</span><br><span class="line"></span><br><span class="line">本章小结237</span><br><span class="line"></span><br><span class="line">本章习题237</span><br><span class="line"></span><br><span class="line">习题解答237</span><br><span class="line"></span><br><span class="line">第9章 元组、文件及其他239</span><br><span class="line"></span><br><span class="line">元组239</span><br><span class="line"></span><br><span class="line">实际应用中的元组241</span><br><span class="line"></span><br><span class="line">为什么有了列表还要元组243</span><br><span class="line"></span><br><span class="line">文件243</span><br><span class="line"></span><br><span class="line">打开文件244</span><br><span class="line"></span><br><span class="line">使用文件245</span><br><span class="line"></span><br><span class="line">实际应用中的文件246</span><br><span class="line"></span><br><span class="line">其他文件工具252</span><br><span class="line"></span><br><span class="line">重访类型分类254</span><br><span class="line"></span><br><span class="line">为什么要在意操作符重载255</span><br><span class="line"></span><br><span class="line">对象灵活性255</span><br><span class="line"></span><br><span class="line">引用 VS 拷贝256</span><br><span class="line"></span><br><span class="line">比较、相等性和真值258</span><br><span class="line"></span><br><span class="line">Python 3.0的字典比较260</span><br><span class="line"></span><br><span class="line">Python中真和假的含义261</span><br><span class="line"></span><br><span class="line">Python的类型层次263</span><br><span class="line"></span><br><span class="line">Type对象263</span><br><span class="line"></span><br><span class="line">Python中的其他类型265</span><br><span class="line"></span><br><span class="line">内置类型陷阱265</span><br><span class="line"></span><br><span class="line">赋值生成引用，而不是拷贝265</span><br><span class="line"></span><br><span class="line">重复能够增加层次深度266</span><br><span class="line"></span><br><span class="line">留意循环数据结构266</span><br><span class="line"></span><br><span class="line">不可变类型不可以在原处改变267</span><br><span class="line"></span><br><span class="line">本章小结267</span><br><span class="line"></span><br><span class="line">本章习题268</span><br><span class="line"></span><br><span class="line">习题解答268</span><br><span class="line"></span><br><span class="line">第二部分练习题269</span><br><span class="line"></span><br><span class="line">第三部分 语句和语法</span><br><span class="line"></span><br><span class="line">0章 Python语句简介275</span><br><span class="line"></span><br><span class="line">重访Python程序结构275</span><br><span class="line"></span><br><span class="line">Python的语句276</span><br><span class="line"></span><br><span class="line">if的故事278</span><br><span class="line"></span><br><span class="line">Python增加了什么279</span><br><span class="line"></span><br><span class="line">Python删除了什么279</span><br><span class="line"></span><br><span class="line">为什么使用缩进语法281</span><br><span class="line"></span><br><span class="line">几个特殊实例283</span><br><span class="line"></span><br><span class="line">简短实例：交互循环285</span><br><span class="line"></span><br><span class="line">一个简单的交互式循环285</span><br><span class="line"></span><br><span class="line">对用户输入数据做数学运算287</span><br><span class="line"></span><br><span class="line">用测试输入数据来处理错误288</span><br><span class="line"></span><br><span class="line">用try语句处理错误289</span><br><span class="line"></span><br><span class="line">嵌套代码三层290</span><br><span class="line"></span><br><span class="line">本章小结290</span><br><span class="line"></span><br><span class="line">本章习题291</span><br><span class="line"></span><br><span class="line">习题解答291</span><br><span class="line"></span><br><span class="line">1章 赋值、表达式和打印292</span><br><span class="line"></span><br><span class="line">赋值语句292</span><br><span class="line"></span><br><span class="line">赋值语句的形式293</span><br><span class="line"></span><br><span class="line">序列赋值294</span><br><span class="line"></span><br><span class="line">Python 3.0中的扩展序列解包297</span><br><span class="line"></span><br><span class="line">多目标赋值语句301</span><br><span class="line"></span><br><span class="line">增强赋值语句302</span><br><span class="line"></span><br><span class="line">变量命名规则305</span><br><span class="line"></span><br><span class="line">Python的废弃协议306</span><br><span class="line"></span><br><span class="line">表达式语句308</span><br><span class="line"></span><br><span class="line">表达式语句和在原处的修改309</span><br><span class="line"></span><br><span class="line">打印操作310</span><br><span class="line"></span><br><span class="line">Python 3.0的print函数311</span><br><span class="line"></span><br><span class="line">Python 2.6 print语句313</span><br><span class="line"></span><br><span class="line">打印流重定向315</span><br><span class="line"></span><br><span class="line">版本独立的打印318</span><br><span class="line"></span><br><span class="line">为什么要注意print和stdout319</span><br><span class="line"></span><br><span class="line">本章小结320</span><br><span class="line"></span><br><span class="line">本章习题321</span><br><span class="line"></span><br><span class="line">习题解答321</span><br><span class="line"></span><br><span class="line">2章 if测试和语法规则322</span><br><span class="line"></span><br><span class="line">if语句322</span><br><span class="line"></span><br><span class="line">通用格式322</span><br><span class="line"></span><br><span class="line">基本例子323</span><br><span class="line"></span><br><span class="line">多路分支323</span><br><span class="line"></span><br><span class="line">Python语法规则325</span><br><span class="line"></span><br><span class="line">代码块分隔符326</span><br><span class="line"></span><br><span class="line">语句的分隔符328</span><br><span class="line"></span><br><span class="line">一些特殊情况329</span><br><span class="line"></span><br><span class="line">真值测试330</span><br><span class="line"></span><br><span class="line">if&#x2F;else三元表达式332</span><br><span class="line"></span><br><span class="line">为什么要在意布尔值334</span><br><span class="line"></span><br><span class="line">本章小结335</span><br><span class="line"></span><br><span class="line">本章习题335</span><br><span class="line"></span><br><span class="line">习题解答335</span><br><span class="line"></span><br><span class="line">3章 while和for循环336</span><br><span class="line"></span><br><span class="line">while循环336</span><br><span class="line"></span><br><span class="line">一般格式336</span><br><span class="line"></span><br><span class="line">例子337</span><br><span class="line"></span><br><span class="line">break、continue、pass和循环else338</span><br><span class="line"></span><br><span class="line">一般循环格式338</span><br><span class="line"></span><br><span class="line">pass338</span><br><span class="line"></span><br><span class="line">continue340</span><br><span class="line"></span><br><span class="line">break340</span><br><span class="line"></span><br><span class="line">循环else341</span><br><span class="line"></span><br><span class="line">为什么要在意“模拟C 语言的while循环”342</span><br><span class="line"></span><br><span class="line">for循环343</span><br><span class="line"></span><br><span class="line">一般格式343</span><br><span class="line"></span><br><span class="line">例子344</span><br><span class="line"></span><br><span class="line">为什么要在意“文件扫描”349</span><br><span class="line"></span><br><span class="line">编写循环的技巧350</span><br><span class="line"></span><br><span class="line">循环计数器：while和range351</span><br><span class="line"></span><br><span class="line">非完备遍历：range和分片352</span><br><span class="line"></span><br><span class="line">修改列表：range353</span><br><span class="line"></span><br><span class="line">并行遍历：zip和map354</span><br><span class="line"></span><br><span class="line">产生偏移和元素：enumerate357</span><br><span class="line"></span><br><span class="line">本章小结358</span><br><span class="line"></span><br><span class="line">本章习题358</span><br><span class="line"></span><br><span class="line">习题解答359</span><br><span class="line"></span><br><span class="line">4章 迭代器和解析，部分360</span><br><span class="line"></span><br><span class="line">迭代器：初探360</span><br><span class="line"></span><br><span class="line">文件迭代器361</span><br><span class="line"></span><br><span class="line">手动迭代：iter和next363</span><br><span class="line"></span><br><span class="line">其他内置类型迭代器365</span><br><span class="line"></span><br><span class="line">列表解析：初探367</span><br><span class="line"></span><br><span class="line">列表解析基础知识368</span><br><span class="line"></span><br><span class="line">在文件上使用列表解析369</span><br><span class="line"></span><br><span class="line">扩展的列表解析语法370</span><br><span class="line"></span><br><span class="line">其他迭代环境371</span><br><span class="line"></span><br><span class="line">Python 3.0中的新的可迭代对象375</span><br><span class="line"></span><br><span class="line">range迭代器376</span><br><span class="line"></span><br><span class="line">map、zip和filter迭代器377</span><br><span class="line"></span><br><span class="line">多个迭代器 VS单个迭代器378</span><br><span class="line"></span><br><span class="line">字典视图迭代器379</span><br><span class="line"></span><br><span class="line">其他迭代器主题381</span><br><span class="line"></span><br><span class="line">本章小结381</span><br><span class="line"></span><br><span class="line">本章习题381</span><br><span class="line"></span><br><span class="line">习题解答382</span><br><span class="line"></span><br><span class="line">5章 文档383</span><br><span class="line"></span><br><span class="line">Python文档资源383</span><br><span class="line"></span><br><span class="line">#注释384</span><br><span class="line"></span><br><span class="line">dir函数384</span><br><span class="line"></span><br><span class="line">文档字符串：__doc__385</span><br><span class="line"></span><br><span class="line">PyDoc：help函数388</span><br><span class="line"></span><br><span class="line">PyDoc：HTML报表390</span><br><span class="line"></span><br><span class="line">标准手册集393</span><br><span class="line"></span><br><span class="line">网络资源394</span><br><span class="line"></span><br><span class="line">已出版的书籍394</span><br><span class="line"></span><br><span class="line">常见编写代码的陷阱395</span><br><span class="line"></span><br><span class="line">本章小结397</span><br><span class="line"></span><br><span class="line">本章习题397</span><br><span class="line"></span><br><span class="line">习题解答397</span><br><span class="line"></span><br><span class="line">第三部分练习题398</span><br><span class="line"></span><br><span class="line">第四部分 函数</span><br><span class="line"></span><br><span class="line">6章 函数基础403</span><br><span class="line"></span><br><span class="line">为何使用函数404</span><br><span class="line"></span><br><span class="line">编写函数405</span><br><span class="line"></span><br><span class="line">def语句406</span><br><span class="line"></span><br><span class="line">def语句是实时执行的407</span><br><span class="line"></span><br><span class="line">个例子：定义和调用408</span><br><span class="line"></span><br><span class="line">定义408</span><br><span class="line"></span><br><span class="line">调用408</span><br><span class="line"></span><br><span class="line">Python中的多态409</span><br><span class="line"></span><br><span class="line">第二个例子：寻找序列的交集410</span><br><span class="line"></span><br><span class="line">定义410</span><br><span class="line"></span><br><span class="line">调用411</span><br><span class="line"></span><br><span class="line">重访多态411</span><br><span class="line"></span><br><span class="line">本地变量412</span><br><span class="line"></span><br><span class="line">本章小结413</span><br><span class="line"></span><br><span class="line">本章习题413</span><br><span class="line"></span><br><span class="line">习题解答413</span><br><span class="line"></span><br><span class="line">7章 作用域415</span><br><span class="line"></span><br><span class="line">Python作用域基础415</span><br><span class="line"></span><br><span class="line">作用域法则416</span><br><span class="line"></span><br><span class="line">变量名解析：LEGB原则418</span><br><span class="line"></span><br><span class="line">作用域实例419</span><br><span class="line"></span><br><span class="line">内置作用域420</span><br><span class="line"></span><br><span class="line">在Python 2.6中违反通用性422</span><br><span class="line"></span><br><span class="line">global语句422</span><br><span class="line"></span><br><span class="line">小化全局变量423</span><br><span class="line"></span><br><span class="line">小化文件间的修改424</span><br><span class="line"></span><br><span class="line">其他访问全局变量的方法426</span><br><span class="line"></span><br><span class="line">作用域和嵌套函数427</span><br><span class="line"></span><br><span class="line">嵌套作用域的细节427</span><br><span class="line"></span><br><span class="line">嵌套作用域举例427</span><br><span class="line"></span><br><span class="line">nonlocal语句433</span><br><span class="line"></span><br><span class="line">nonlocal基础433</span><br><span class="line"></span><br><span class="line">nonlocal应用435</span><br><span class="line"></span><br><span class="line">为什么使用nonlocal437</span><br><span class="line"></span><br><span class="line">本章小结440</span><br><span class="line"></span><br><span class="line">本章习题441</span><br><span class="line"></span><br><span class="line">习题解答442</span><br><span class="line"></span><br><span class="line">8章 参数444</span><br><span class="line"></span><br><span class="line">传递参数444</span><br><span class="line"></span><br><span class="line">参数和共享引用445</span><br><span class="line"></span><br><span class="line">避免可变参数的修改447</span><br><span class="line"></span><br><span class="line">对参数输出进行模拟448</span><br><span class="line"></span><br><span class="line">特定的参数匹配模型449</span><br><span class="line"></span><br><span class="line">基础知识449</span><br><span class="line"></span><br><span class="line">匹配语法450</span><br><span class="line"></span><br><span class="line">细节452</span><br><span class="line"></span><br><span class="line">关键字参数和默认参数的实例452</span><br><span class="line"></span><br><span class="line">任意参数的实例455</span><br><span class="line"></span><br><span class="line">Python 3.0 Keyword-Only参数459</span><br><span class="line"></span><br><span class="line">min调用462</span><br><span class="line"></span><br><span class="line">满分463</span><br><span class="line"></span><br><span class="line">加分点4</span><br><span class="line"></span><br><span class="line">结论465</span><br><span class="line"></span><br><span class="line">一个更有用的例子：通用set函数465</span><br><span class="line"></span><br><span class="line">模拟Python 3.0 print函数466</span><br><span class="line"></span><br><span class="line">使用Keyword-Only参数467</span><br><span class="line"></span><br><span class="line">为什么要在意：关键字参数469</span><br><span class="line"></span><br><span class="line">本章小结469</span><br><span class="line"></span><br><span class="line">本章习题470</span><br><span class="line"></span><br><span class="line">习题解答470</span><br><span class="line"></span><br><span class="line">9章 函数的不错话题472</span><br><span class="line"></span><br><span class="line">函数设计概念472</span><br><span class="line"></span><br><span class="line">递归函数474</span><br><span class="line"></span><br><span class="line">用递归求和474</span><br><span class="line"></span><br><span class="line">编码替代方案475</span><br><span class="line"></span><br><span class="line">循环语句VS递归476</span><br><span class="line"></span><br><span class="line">处理任意结构477</span><br><span class="line"></span><br><span class="line">函数对象：属性和注解478</span><br><span class="line"></span><br><span class="line">间接函数调用478</span><br><span class="line"></span><br><span class="line">函数内省479</span><br><span class="line"></span><br><span class="line">函数属性480</span><br><span class="line"></span><br><span class="line">Python 3.0中的函数注解481</span><br><span class="line"></span><br><span class="line">匿名函数： lambda483</span><br><span class="line"></span><br><span class="line">lambda表达式483</span><br><span class="line"></span><br><span class="line">为什么使用lambda484</span><br><span class="line"></span><br><span class="line">如何（不要）让Python代码变得晦涩难懂486</span><br><span class="line"></span><br><span class="line">嵌套lambda和作用域487</span><br><span class="line"></span><br><span class="line">为什么要在意：回调488</span><br><span class="line"></span><br><span class="line">在序列中映射函数：map489</span><br><span class="line"></span><br><span class="line">函数式编程工具：filter和reduce490</span><br><span class="line"></span><br><span class="line">本章小结492</span><br><span class="line"></span><br><span class="line">本章习题492</span><br><span class="line"></span><br><span class="line">习题解答492</span><br><span class="line"></span><br><span class="line">第20章 迭代和解析，第二部分494</span><br><span class="line"></span><br><span class="line">回顾列表解析：函数式编程工具494</span><br><span class="line"></span><br><span class="line">列表解析与map495</span><br><span class="line"></span><br><span class="line">增加测试和嵌套循环496</span><br><span class="line"></span><br><span class="line">列表解析和矩阵498</span><br><span class="line"></span><br><span class="line">理解列表解析499</span><br><span class="line"></span><br><span class="line">为什么要在意：列表解析和map500</span><br><span class="line"></span><br><span class="line">重访迭代器：生成器501</span><br><span class="line"></span><br><span class="line">生成器函数：yield VS return502</span><br><span class="line"></span><br><span class="line">生成器表达式：迭代器遇到列表解析506</span><br><span class="line"></span><br><span class="line">生成器函数 VS 生成器表达式507</span><br><span class="line"></span><br><span class="line">生成器是单迭代器对象508</span><br><span class="line"></span><br><span class="line">用迭代工具模拟zip和map510</span><br><span class="line"></span><br><span class="line">为什么你会留意：单次迭代514</span><br><span class="line"></span><br><span class="line">内置类型和类中的值生成515</span><br><span class="line"></span><br><span class="line">Python 3.0解析语法概括516</span><br><span class="line"></span><br><span class="line">解析集合和字典解析517</span><br><span class="line"></span><br><span class="line">针对集合和字典的扩展的解析语法517</span><br><span class="line"></span><br><span class="line">对迭代的各种方法进行计时518</span><br><span class="line"></span><br><span class="line">对模块计时519</span><br><span class="line"></span><br><span class="line">计时脚本519</span><br><span class="line"></span><br><span class="line">计时结果520</span><br><span class="line"></span><br><span class="line">计时模块替代方案523</span><br><span class="line"></span><br><span class="line">其他建议527</span><br><span class="line"></span><br><span class="line">函数陷阱528</span><br><span class="line"></span><br><span class="line">本地变量是静态检测的528</span><br><span class="line"></span><br><span class="line">默认和可变对象529</span><br><span class="line"></span><br><span class="line">没有return语句的函数531</span><br><span class="line"></span><br><span class="line">嵌套作用域的循环变量532</span><br><span class="line"></span><br><span class="line">本章小结532</span><br><span class="line"></span><br><span class="line">本章习题532</span><br><span class="line"></span><br><span class="line">习题解答533</span><br><span class="line"></span><br><span class="line">第四部分练习题533</span><br><span class="line"></span><br><span class="line">第五部分 模块</span><br><span class="line"></span><br><span class="line">第21章 模块：宏伟蓝图539</span><br><span class="line"></span><br><span class="line">为什么使用模块540</span><br><span class="line"></span><br><span class="line">Python程序架构540</span><br><span class="line"></span><br><span class="line">如何组织一个程序541</span><br><span class="line"></span><br><span class="line">导入和属性541</span><br><span class="line"></span><br><span class="line">标准库模块543</span><br><span class="line"></span><br><span class="line">import如何工作543</span><br><span class="line"></span><br><span class="line">1.搜索544</span><br><span class="line"></span><br><span class="line">2.编译（可选）544</span><br><span class="line"></span><br><span class="line">3.运行545</span><br><span class="line"></span><br><span class="line">模块搜索路径545</span><br><span class="line"></span><br><span class="line">配置搜索路径547</span><br><span class="line"></span><br><span class="line">搜索路径的变动548</span><br><span class="line"></span><br><span class="line">sys.path列表548</span><br><span class="line"></span><br><span class="line">模块文件选择549</span><br><span class="line"></span><br><span class="line">不错的模块选择概念550</span><br><span class="line"></span><br><span class="line">第三方工具：distutils550</span><br><span class="line"></span><br><span class="line">本章小结551</span><br><span class="line"></span><br><span class="line">本章习题551</span><br><span class="line"></span><br><span class="line">习题解答551</span><br><span class="line"></span><br><span class="line">第22章 模块代码编写基础553</span><br><span class="line"></span><br><span class="line">模块的创建553</span><br><span class="line"></span><br><span class="line">模块的使用554</span><br><span class="line"></span><br><span class="line">import语句554</span><br><span class="line"></span><br><span class="line">from语句555</span><br><span class="line"></span><br><span class="line">from *语句555</span><br><span class="line"></span><br><span class="line">导入只发生一次555</span><br><span class="line"></span><br><span class="line">import和from是赋值语句556</span><br><span class="line"></span><br><span class="line">文件间变量名的改变557</span><br><span class="line"></span><br><span class="line">import和from的对等性557</span><br><span class="line"></span><br><span class="line">from语句潜在的陷阱558</span><br><span class="line"></span><br><span class="line">模块命名空间560</span><br><span class="line"></span><br><span class="line">文件生成命名空间560</span><br><span class="line"></span><br><span class="line">属性名的点号运算562</span><br><span class="line"></span><br><span class="line">导入和作用域562</span><br><span class="line"></span><br><span class="line">命名空间的嵌套563</span><br><span class="line"></span><br><span class="line">重载模块5</span><br><span class="line"></span><br><span class="line">reload基础565</span><br><span class="line"></span><br><span class="line">reload实例566</span><br><span class="line"></span><br><span class="line">为什么要在意：模块重载567</span><br><span class="line"></span><br><span class="line">本章小结568</span><br><span class="line"></span><br><span class="line">本章习题568</span><br><span class="line"></span><br><span class="line">习题解答568</span><br><span class="line"></span><br><span class="line">第23章 模块包570</span><br><span class="line"></span><br><span class="line">包导入基础570</span><br><span class="line"></span><br><span class="line">包和搜索路径设置571</span><br><span class="line"></span><br><span class="line">__init__.py包文件572</span><br><span class="line"></span><br><span class="line">包导入实例573</span><br><span class="line"></span><br><span class="line">包对应的from语句和import语句574</span><br><span class="line"></span><br><span class="line">为什么要使用包导入575</span><br><span class="line"></span><br><span class="line">三个系统的传说576</span><br><span class="line"></span><br><span class="line">包相对导入578</span><br><span class="line"></span><br><span class="line">Python 3.0中的变化578</span><br><span class="line"></span><br><span class="line">相对导入基础知识579</span><br><span class="line"></span><br><span class="line">为什么使用相对导入581</span><br><span class="line"></span><br><span class="line">相对导入的作用域583</span><br><span class="line"></span><br><span class="line">模块查找规则总结583</span><br><span class="line"></span><br><span class="line">相对导入的应用584</span><br><span class="line"></span><br><span class="line">为什么要在意：模块包589</span><br><span class="line"></span><br><span class="line">本章小结590</span><br><span class="line"></span><br><span class="line">本章习题590</span><br><span class="line"></span><br><span class="line">习题解答590</span><br><span class="line"></span><br><span class="line">第24章 不错模块话题592</span><br><span class="line"></span><br><span class="line">在模块中隐藏数据592</span><br><span class="line"></span><br><span class="line">小化from *的破坏：_X和__all__593</span><br><span class="line"></span><br><span class="line">启用以后的语言特性593</span><br><span class="line"></span><br><span class="line">混合用法模式：__name__和__main__594</span><br><span class="line"></span><br><span class="line">以__name__进行单元测试595</span><br><span class="line"></span><br><span class="line">使用带有__name__的命令行参数596</span><br><span class="line"></span><br><span class="line">修改模块搜索路径599</span><br><span class="line"></span><br><span class="line">Import语句和from语句的as扩展599</span><br><span class="line"></span><br><span class="line">模块是对象：元程序600</span><br><span class="line"></span><br><span class="line">用名称字符串导入模块603</span><br><span class="line"></span><br><span class="line">过渡性模块重载604</span><br><span class="line"></span><br><span class="line">模块设计理念607</span><br><span class="line"></span><br><span class="line">模块陷阱607</span><br><span class="line"></span><br><span class="line">顶层代码的语句次序的重要性608</span><br><span class="line"></span><br><span class="line">from复制变量名，而不是连接609</span><br><span class="line"></span><br><span class="line">from *会让变量语义模糊610</span><br><span class="line"></span><br><span class="line">reload不会影响from导入610</span><br><span class="line"></span><br><span class="line">reload、from以及交互模式测试611</span><br><span class="line"></span><br><span class="line">递归形式的from导入无法工作612</span><br><span class="line"></span><br><span class="line">本章小结613</span><br><span class="line"></span><br><span class="line">本章习题613</span><br><span class="line"></span><br><span class="line">习题解答613</span><br><span class="line"></span><br><span class="line">第五部分练习题614</span><br><span class="line"></span><br><span class="line">第六部分 类和OOP</span><br><span class="line"></span><br><span class="line">第25章 OOP：宏伟蓝图619</span><br><span class="line"></span><br><span class="line">为何使用类620</span><br><span class="line"></span><br><span class="line">概览OOP621</span><br><span class="line"></span><br><span class="line">属性继承搜索621</span><br><span class="line"></span><br><span class="line">类和实例623</span><br><span class="line"></span><br><span class="line">类方法调用624</span><br><span class="line"></span><br><span class="line">编写类树624</span><br><span class="line"></span><br><span class="line">OOP是为了代码重用627</span><br><span class="line"></span><br><span class="line">本章小结629</span><br><span class="line"></span><br><span class="line">本章习题629</span><br><span class="line"></span><br><span class="line">习题解答630</span><br><span class="line"></span><br><span class="line">第26章 类代码编写基础631</span><br><span class="line"></span><br><span class="line">类产生多个实例对象631</span><br><span class="line"></span><br><span class="line">类对象提供默认行为632</span><br><span class="line"></span><br><span class="line">实例对象是具体的元素632</span><br><span class="line"></span><br><span class="line">个例子632</span><br><span class="line"></span><br><span class="line">类通过继承进行定制635</span><br><span class="line"></span><br><span class="line">第二个例子635</span><br><span class="line"></span><br><span class="line">类是模块内的属性637</span><br><span class="line"></span><br><span class="line">类可以截获Python运算符638</span><br><span class="line"></span><br><span class="line">第三个例子639</span><br><span class="line"></span><br><span class="line">为什么要使用运算符重载1</span><br><span class="line"></span><br><span class="line">世界上简单的Python类1</span><br><span class="line"></span><br><span class="line">类与字典的关系4</span><br><span class="line"></span><br><span class="line">本章小结6</span><br><span class="line"></span><br><span class="line">本章习题6</span><br><span class="line"></span><br><span class="line">习题解答6</span><br><span class="line"></span><br><span class="line">第27章 更多实例9</span><br><span class="line"></span><br><span class="line">步骤1：创建实例650</span><br><span class="line"></span><br><span class="line">编写构造函数650</span><br><span class="line"></span><br><span class="line">在进行中测试651</span><br><span class="line"></span><br><span class="line">以两种方式使用代码652</span><br><span class="line"></span><br><span class="line">版本差异提示654</span><br><span class="line"></span><br><span class="line">步骤2：添加行为方法654</span><br><span class="line"></span><br><span class="line">编写方法656</span><br><span class="line"></span><br><span class="line">步骤3：运算符重载658</span><br><span class="line"></span><br><span class="line">提供打印显示658</span><br><span class="line"></span><br><span class="line">步骤4：通过子类定制行为659</span><br><span class="line"></span><br><span class="line">编写子类660</span><br><span class="line"></span><br><span class="line">扩展方法：不好的方式660</span><br><span class="line"></span><br><span class="line">扩展方法：好的方式661</span><br><span class="line"></span><br><span class="line">多态的作用663</span><br><span class="line"></span><br><span class="line">继承、定制和扩展6</span><br><span class="line"></span><br><span class="line">OOP：大思路6</span><br><span class="line"></span><br><span class="line">步骤5：定制构造函数665</span><br><span class="line"></span><br><span class="line">OOP比我们认为的要简单666</span><br><span class="line"></span><br><span class="line">组合类的其他方式667</span><br><span class="line"></span><br><span class="line">在Python 3.0中捕获内置属性669</span><br><span class="line"></span><br><span class="line">步骤6：使用内省工具670</span><br><span class="line"></span><br><span class="line">特殊类属性670</span><br><span class="line"></span><br><span class="line">一种通用显示工具671</span><br><span class="line"></span><br><span class="line">实例与类属性的关系672</span><br><span class="line"></span><br><span class="line">工具类的命名考虑673</span><br><span class="line"></span><br><span class="line">类的终形式674</span><br><span class="line"></span><br><span class="line">步骤7（后一步）：把对象存储到数据库中676</span><br><span class="line"></span><br><span class="line">Pickle和Shelve676</span><br><span class="line"></span><br><span class="line">在shelve数据库中存储对象677</span><br><span class="line"></span><br><span class="line">交互地探索shelve678</span><br><span class="line"></span><br><span class="line">更新shelve中的对象680</span><br><span class="line"></span><br><span class="line">未来方向681</span><br><span class="line"></span><br><span class="line">本章小结683</span><br><span class="line"></span><br><span class="line">本章习题684</span><br><span class="line"></span><br><span class="line">习题解答684</span><br><span class="line"></span><br><span class="line">第28章 类代码编写细节686</span><br><span class="line"></span><br><span class="line">class语句686</span><br><span class="line"></span><br><span class="line">一般形式686</span><br><span class="line"></span><br><span class="line">例子687</span><br><span class="line"></span><br><span class="line">方法689</span><br><span class="line"></span><br><span class="line">例子690</span><br><span class="line"></span><br><span class="line">调用超类构造函数691</span><br><span class="line"></span><br><span class="line">其他方法调用的可能性691</span><br><span class="line"></span><br><span class="line">继承692</span><br><span class="line"></span><br><span class="line">属性树的构造692</span><br><span class="line"></span><br><span class="line">继承方法的专有化693</span><br><span class="line"></span><br><span class="line">类接口技术694</span><br><span class="line"></span><br><span class="line">抽象超类695</span><br><span class="line"></span><br><span class="line">Python 2.6和Python 3.0的抽象超类696</span><br><span class="line"></span><br><span class="line">命名空间：完整的内容698</span><br><span class="line"></span><br><span class="line">简单变量名：如果赋值就不是全局变量698</span><br><span class="line"></span><br><span class="line">属性名称：对象命名空间698</span><br><span class="line"></span><br><span class="line">Python命名空间的“禅”：赋值将变量名分类699</span><br><span class="line"></span><br><span class="line">命名空间字典701</span><br><span class="line"></span><br><span class="line">命名空间链接704</span><br><span class="line"></span><br><span class="line">回顾文档字符串706</span><br><span class="line"></span><br><span class="line">类与模块的关系707</span><br><span class="line"></span><br><span class="line">本章小结708</span><br><span class="line"></span><br><span class="line">本章习题708</span><br><span class="line"></span><br><span class="line">习题解答708</span><br><span class="line"></span><br><span class="line">第29章 运算符重载710</span><br><span class="line"></span><br><span class="line">基础知识710</span><br><span class="line"></span><br><span class="line">构造函数和表达式：__init__和__sub__711</span><br><span class="line"></span><br><span class="line">常见的运算符重载方法711</span><br><span class="line"></span><br><span class="line">索引和分片：__getitem__和__setitem__713</span><br><span class="line"></span><br><span class="line">拦截分片713</span><br><span class="line"></span><br><span class="line">Python 2.6中的分片和索引715</span><br><span class="line"></span><br><span class="line">索引迭代：__getitem__716</span><br><span class="line"></span><br><span class="line">迭代器对象：__iter__和__next__717</span><br><span class="line"></span><br><span class="line">用户定义的迭代器717</span><br><span class="line"></span><br><span class="line">有多个迭代器的对象719</span><br><span class="line"></span><br><span class="line">成员关系：__contains__、__iter__和__getitem__721</span><br><span class="line"></span><br><span class="line">属性引用：__getattr__和__setattr__723</span><br><span class="line"></span><br><span class="line">其他属性管理工具725</span><br><span class="line"></span><br><span class="line">模拟实例属性的私有性：部分725</span><br><span class="line"></span><br><span class="line">__repr__和__str__会返回字符串表达形式726</span><br><span class="line"></span><br><span class="line">右侧加法和原处加法：__radd__和__iadd__729</span><br><span class="line"></span><br><span class="line">原处加法730</span><br><span class="line"></span><br><span class="line">Call表达式：__call__731</span><br><span class="line"></span><br><span class="line">函数接口和回调代码732</span><br><span class="line"></span><br><span class="line">比较：__lt__、__gt__和其他方法734</span><br><span class="line"></span><br><span class="line">Python 2.6的__cmp__方法（已经从Python 3.0中移除了）734</span><br><span class="line"></span><br><span class="line">布尔测试：__bool__和__len__735</span><br><span class="line"></span><br><span class="line">Python 2.6中的布尔736</span><br><span class="line"></span><br><span class="line">对象析构函数：__del__738</span><br><span class="line"></span><br><span class="line">本章小结739</span><br><span class="line"></span><br><span class="line">本章习题739</span><br><span class="line"></span><br><span class="line">习题解答739</span><br><span class="line"></span><br><span class="line">第30章 类的设计741</span><br><span class="line"></span><br><span class="line">Python和OOP741</span><br><span class="line"></span><br><span class="line">通过调用标记进行重载（或不要）742</span><br><span class="line"></span><br><span class="line">OOP和继承：“是一个”关系743</span><br><span class="line"></span><br><span class="line">OOP和组合：“有一个”关系744</span><br><span class="line"></span><br><span class="line">重访流处理器746</span><br><span class="line"></span><br><span class="line">为什么要在意：类和持续性748</span><br><span class="line"></span><br><span class="line">OOP和委托：“包装”对象749</span><br><span class="line"></span><br><span class="line">类的伪私有属性751</span><br><span class="line"></span><br><span class="line">变量名压缩概览751</span><br><span class="line"></span><br><span class="line">为什么使用伪私有属性752</span><br><span class="line"></span><br><span class="line">方法是对象：绑定或无绑定754</span><br><span class="line"></span><br><span class="line">在Python 3.0中，无绑定方法是函数756</span><br><span class="line"></span><br><span class="line">绑定方法和其他可调用对象757</span><br><span class="line"></span><br><span class="line">为什么要在意：绑定方法和回调函数760</span><br><span class="line"></span><br><span class="line">多重继承：“混合”类760</span><br><span class="line"></span><br><span class="line">编写混合显示类761</span><br><span class="line"></span><br><span class="line">类是对象：通用对象的工厂771</span><br><span class="line"></span><br><span class="line">为什么有工厂772</span><br><span class="line"></span><br><span class="line">与设计相关的其他话题773</span><br><span class="line"></span><br><span class="line">本章小结773</span><br><span class="line"></span><br><span class="line">本章习题774</span><br><span class="line"></span><br><span class="line">习题解答774</span><br><span class="line"></span><br><span class="line">第31章 类的不错主题775</span><br><span class="line"></span><br><span class="line">扩展内置类型775</span><br><span class="line"></span><br><span class="line">通过嵌入扩展类型776</span><br><span class="line"></span><br><span class="line">通过子类扩展类型777</span><br><span class="line"></span><br><span class="line">新式类779</span><br><span class="line"></span><br><span class="line">新式类变化780</span><br><span class="line"></span><br><span class="line">类型模式变化781</span><br><span class="line"></span><br><span class="line">钻石继承变动785</span><br><span class="line"></span><br><span class="line">新式类的扩展789</span><br><span class="line"></span><br><span class="line">slots实例789</span><br><span class="line"></span><br><span class="line">类特性793</span><br><span class="line"></span><br><span class="line">__getattribute__和描述符795</span><br><span class="line"></span><br><span class="line">元类795</span><br><span class="line"></span><br><span class="line">静态方法和类方法796</span><br><span class="line"></span><br><span class="line">为什么使用特殊方法796</span><br><span class="line"></span><br><span class="line">Python 2.6和Python 3.0中的静态方法797</span><br><span class="line"></span><br><span class="line">静态方法替代方案799</span><br><span class="line"></span><br><span class="line">使用静态和类方法800</span><br><span class="line"></span><br><span class="line">使用静态方法统计实例801</span><br><span class="line"></span><br><span class="line">用类方法统计实例802</span><br><span class="line"></span><br><span class="line">装饰器和元类：部分805</span><br><span class="line"></span><br><span class="line">函数装饰器基础805</span><br><span class="line"></span><br><span class="line">装饰器例子806</span><br><span class="line"></span><br><span class="line">类装饰器和元类807</span><br><span class="line"></span><br><span class="line">更多详细信息808</span><br><span class="line"></span><br><span class="line">类陷阱809</span><br><span class="line"></span><br><span class="line">修改类属性的副作用809</span><br><span class="line"></span><br><span class="line">修改可变的类属性也可能产生副作用810</span><br><span class="line"></span><br><span class="line">多重继承：顺序很重要811</span><br><span class="line"></span><br><span class="line">类、方法以及嵌套作用域812</span><br><span class="line"></span><br><span class="line">Python中基于委托的类：__getattr__和内置函数814</span><br><span class="line"></span><br><span class="line">“过度包装”814</span><br><span class="line"></span><br><span class="line">本章小结815</span><br><span class="line"></span><br><span class="line">本章习题815</span><br><span class="line"></span><br><span class="line">习题解答815</span><br><span class="line"></span><br><span class="line">第六部分 练习题816</span><br><span class="line"></span><br><span class="line">为什么要在意：大师眼中的OOP821</span><br><span class="line"></span><br><span class="line">第七部分 异常和工具</span><br><span class="line"></span><br><span class="line">第32章 异常基础825</span><br><span class="line"></span><br><span class="line">为什么使用异常826</span><br><span class="line"></span><br><span class="line">异常的角色826</span><br><span class="line"></span><br><span class="line">异常处理：简明扼要827</span><br><span class="line"></span><br><span class="line">默认异常处理器827</span><br><span class="line"></span><br><span class="line">捕获异常828</span><br><span class="line"></span><br><span class="line">引发异常829</span><br><span class="line"></span><br><span class="line">用户定义的异常830</span><br><span class="line"></span><br><span class="line">终止行为830</span><br><span class="line"></span><br><span class="line">为什么要在意：错误检查832</span><br><span class="line"></span><br><span class="line">本章小结833</span><br><span class="line"></span><br><span class="line">本章习题833</span><br><span class="line"></span><br><span class="line">习题解答834</span><br><span class="line"></span><br><span class="line">第33章 异常编码细节835</span><br><span class="line"></span><br><span class="line">try&#x2F;except&#x2F;else语句835</span><br><span class="line"></span><br><span class="line">try语句分句836</span><br><span class="line"></span><br><span class="line">try&#x2F;else分句839</span><br><span class="line"></span><br><span class="line">例子：默认行为840</span><br><span class="line"></span><br><span class="line">例子：捕捉内置异常841</span><br><span class="line"></span><br><span class="line">try&#x2F;finally语句841</span><br><span class="line"></span><br><span class="line">例子：利用try&#x2F;finally编写终止行为842</span><br><span class="line"></span><br><span class="line">统一try&#x2F;except&#x2F;finally语句843</span><br><span class="line"></span><br><span class="line">统一try语句语法845</span><br><span class="line"></span><br><span class="line">通过嵌套合并finally和except845</span><br><span class="line"></span><br><span class="line">合并try的例子846</span><br><span class="line"></span><br><span class="line">raise语句847</span><br><span class="line"></span><br><span class="line">利用raise传递异常849</span><br><span class="line"></span><br><span class="line">Python 3.0异常链：raise from849</span><br><span class="line"></span><br><span class="line">assert语句850</span><br><span class="line"></span><br><span class="line">例子：收集约束条件（但不是错误）850</span><br><span class="line"></span><br><span class="line">with&#x2F;as环境管理器851</span><br><span class="line"></span><br><span class="line">基本使用852</span><br><span class="line"></span><br><span class="line">环境管理协议853</span><br><span class="line"></span><br><span class="line">本章小结855</span><br><span class="line"></span><br><span class="line">本章习题855</span><br><span class="line"></span><br><span class="line">习题解答856</span><br><span class="line"></span><br><span class="line">第34章 异常对象857</span><br><span class="line"></span><br><span class="line">异常：回到未来858</span><br><span class="line"></span><br><span class="line">字符串异常很简单858</span><br><span class="line"></span><br><span class="line">基于类的异常858</span><br><span class="line"></span><br><span class="line">类异常例子859</span><br><span class="line"></span><br><span class="line">为什么使用类异常861</span><br><span class="line"></span><br><span class="line">内置Exception类8</span><br><span class="line"></span><br><span class="line">内置异常分类865</span><br><span class="line"></span><br><span class="line">默认打印和状态866</span><br><span class="line"></span><br><span class="line">定制打印显示867</span><br><span class="line"></span><br><span class="line">定制数据和行为868</span><br><span class="line"></span><br><span class="line">提供异常细节868</span><br><span class="line"></span><br><span class="line">提供异常方法869</span><br><span class="line"></span><br><span class="line">本章小结870</span><br><span class="line"></span><br><span class="line">本章习题870</span><br><span class="line"></span><br><span class="line">习题解答870</span><br><span class="line"></span><br><span class="line">第35章 异常的设计872</span><br><span class="line"></span><br><span class="line">嵌套异常处理器872</span><br><span class="line"></span><br><span class="line">例子：控制流程嵌套873</span><br><span class="line"></span><br><span class="line">例子：语法嵌套化874</span><br><span class="line"></span><br><span class="line">异常的习惯用法876</span><br><span class="line"></span><br><span class="line">异常不总是错误876</span><br><span class="line"></span><br><span class="line">函数信号条件和raise876</span><br><span class="line"></span><br><span class="line">关闭文件和服务器连接877</span><br><span class="line"></span><br><span class="line">在try外进行调试878</span><br><span class="line"></span><br><span class="line">运行进程中的测试879</span><br><span class="line"></span><br><span class="line">关于sys.exc_info879</span><br><span class="line"></span><br><span class="line">与异常有关的技巧880</span><br><span class="line"></span><br><span class="line">应该包装什么881</span><br><span class="line"></span><br><span class="line">捕捉太多：避免空except语句881</span><br><span class="line"></span><br><span class="line">捕捉过少：使用基于类的分类883</span><br><span class="line"></span><br><span class="line">核心语言总结884</span><br><span class="line"></span><br><span class="line">Python工具集884</span><br><span class="line"></span><br><span class="line">大型项目的开发工具885</span><br><span class="line"></span><br><span class="line">本章小结888</span><br><span class="line"></span><br><span class="line">第七部分练习题889</span><br><span class="line"></span><br><span class="line">第八部分 不错话题注1</span><br><span class="line"></span><br><span class="line">第36章 Unicode和字节字符串893</span><br><span class="line"></span><br><span class="line">Python 3.0中的字符串修改894</span><br><span class="line"></span><br><span class="line">字符串基础知识895</span><br><span class="line"></span><br><span class="line">字符编码方法895</span><br><span class="line"></span><br><span class="line">Python的字符串类型897</span><br><span class="line"></span><br><span class="line">文本和二进制文件899</span><br><span class="line"></span><br><span class="line">Python 3.0中的字符串应用900</span><br><span class="line"></span><br><span class="line">常量和基本属性900</span><br><span class="line"></span><br><span class="line">转换901</span><br><span class="line"></span><br><span class="line">编码Unicode字符串903</span><br><span class="line"></span><br><span class="line">编码ASCII文本903</span><br><span class="line"></span><br><span class="line">编码非ASCII文本904</span><br><span class="line"></span><br><span class="line">编码和解码非ASCII文本904</span><br><span class="line"></span><br><span class="line">其他Unicode编码技术905</span><br><span class="line"></span><br><span class="line">转换编码907</span><br><span class="line"></span><br><span class="line">在Python 2.6中编码Unicode字符串908</span><br><span class="line"></span><br><span class="line">源文件字符集编码声明910</span><br><span class="line"></span><br><span class="line">使用Python 3.0 Bytes对象911</span><br><span class="line"></span><br><span class="line">方法调用912</span><br><span class="line"></span><br><span class="line">序列操作913</span><br><span class="line"></span><br><span class="line">创建bytes对象的其他方式913</span><br><span class="line"></span><br><span class="line">混合字符串类型914</span><br><span class="line"></span><br><span class="line">使用Python 3.0（和Python 2.6）bytearray对象915</span><br><span class="line"></span><br><span class="line">使用文本文件和二进制文件918</span><br><span class="line"></span><br><span class="line">文本文件基础919</span><br><span class="line"></span><br><span class="line">Python 3.0中的文本和二进制模式919</span><br><span class="line"></span><br><span class="line">类型和内容错误匹配921</span><br><span class="line"></span><br><span class="line">使用Unicode文件922</span><br><span class="line"></span><br><span class="line">在Python 3.0中读取和写入Unicode922</span><br><span class="line"></span><br><span class="line">在Python 3.0中处理BOM924</span><br><span class="line"></span><br><span class="line">Python 2.6中的Unicode文件927</span><br><span class="line"></span><br><span class="line">Python 3.0中其他字符串工具的变化927</span><br><span class="line"></span><br><span class="line">re模式匹配模块927</span><br><span class="line"></span><br><span class="line">Struct二进制数据模块928</span><br><span class="line"></span><br><span class="line">pickle对象序列化模块931</span><br><span class="line"></span><br><span class="line">XML解析工具932</span><br><span class="line"></span><br><span class="line">本章小结935</span><br><span class="line"></span><br><span class="line">本章习题935</span><br><span class="line"></span><br><span class="line">习题解答936</span><br><span class="line"></span><br><span class="line">第37章 管理属性938</span><br><span class="line"></span><br><span class="line">为什么管理属性938</span><br><span class="line"></span><br><span class="line">插入在属性访问时运行的代码939</span><br><span class="line"></span><br><span class="line">特性940</span><br><span class="line"></span><br><span class="line">基础知识940</span><br><span class="line"></span><br><span class="line">个例子941</span><br><span class="line"></span><br><span class="line">计算的属性942</span><br><span class="line"></span><br><span class="line">使用装饰器编写特性943</span><br><span class="line"></span><br><span class="line">描述符944</span><br><span class="line"></span><br><span class="line">基础知识945</span><br><span class="line"></span><br><span class="line">个示例947</span><br><span class="line"></span><br><span class="line">计算的属性949</span><br><span class="line"></span><br><span class="line">在描述符中使用状态信息950</span><br><span class="line"></span><br><span class="line">特性和描述符是如何相关的952</span><br><span class="line"></span><br><span class="line">__getattr__和__getattribute__953</span><br><span class="line"></span><br><span class="line">基础知识954</span><br><span class="line"></span><br><span class="line">个示例956</span><br><span class="line"></span><br><span class="line">计算属性958</span><br><span class="line"></span><br><span class="line">__getattr__和__getattribute__比较959</span><br><span class="line"></span><br><span class="line">管理技术比较960</span><br><span class="line"></span><br><span class="line">拦截内置操作属性963</span><br><span class="line"></span><br><span class="line">重访基于委托的Manager967</span><br><span class="line"></span><br><span class="line">示例：属性验证970</span><br><span class="line"></span><br><span class="line">使用特性来验证971</span><br><span class="line"></span><br><span class="line">使用描述符验证973</span><br><span class="line"></span><br><span class="line">使用__getattr__来验证974</span><br><span class="line"></span><br><span class="line">使用__getattribute__验证976</span><br><span class="line"></span><br><span class="line">本章小结977</span><br><span class="line"></span><br><span class="line">本章习题977</span><br><span class="line"></span><br><span class="line">习题解答977</span><br><span class="line"></span><br><span class="line">第38章 装饰器979</span><br><span class="line"></span><br><span class="line">什么是装饰器979</span><br><span class="line"></span><br><span class="line">管理调用和实例980</span><br><span class="line"></span><br><span class="line">管理函数和类980</span><br><span class="line"></span><br><span class="line">使用和定义装饰器981</span><br><span class="line"></span><br><span class="line">为什么使用装饰器981</span><br><span class="line"></span><br><span class="line">基础知识982</span><br><span class="line"></span><br><span class="line">函数装饰器982</span><br><span class="line"></span><br><span class="line">类装饰器986</span><br><span class="line"></span><br><span class="line">装饰器嵌套988</span><br><span class="line"></span><br><span class="line">装饰器参数990</span><br><span class="line"></span><br><span class="line">装饰器管理函数和类991</span><br><span class="line"></span><br><span class="line">编写函数装饰器991</span><br><span class="line"></span><br><span class="line">跟踪调用992</span><br><span class="line"></span><br><span class="line">状态信息保持选项993</span><br><span class="line"></span><br><span class="line">类错误之一：装饰类方法997</span><br><span class="line"></span><br><span class="line">计时调用1002</span><br><span class="line"></span><br><span class="line">添加装饰器参数1004</span><br><span class="line"></span><br><span class="line">编写类装饰器1007</span><br><span class="line"></span><br><span class="line">单体类1007</span><br><span class="line"></span><br><span class="line">跟踪对象接口1009</span><br><span class="line"></span><br><span class="line">类错误之二：保持多个实例1012</span><br><span class="line"></span><br><span class="line">装饰器与管理器函数的关系1013</span><br><span class="line"></span><br><span class="line">为什么使用装饰器（重访）1015</span><br><span class="line"></span><br><span class="line">直接管理函数和类1016</span><br><span class="line"></span><br><span class="line">示例：“私有”和“公有”属性1018</span><br><span class="line"></span><br><span class="line">实现私有属性1019</span><br><span class="line"></span><br><span class="line">实现细节之一1021</span><br><span class="line"></span><br><span class="line">公有声明的泛化1022</span><br><span class="line"></span><br><span class="line">实现细节之二1024</span><br><span class="line"></span><br><span class="line">开放问题1025</span><br><span class="line"></span><br><span class="line">Python不是关于控制1029</span><br><span class="line"></span><br><span class="line">示例：验证函数参数1030</span><br><span class="line"></span><br><span class="line">目标1030</span><br><span class="line"></span><br><span class="line">针对位置参数的一个基本范围测试装饰器1031</span><br><span class="line"></span><br><span class="line">针对关键字和默认泛化1033</span><br><span class="line"></span><br><span class="line">实现细节1036</span><br><span class="line"></span><br><span class="line">开放问题1038</span><br><span class="line"></span><br><span class="line">装饰器参数 VS 函数注解1039</span><br><span class="line"></span><br><span class="line">其他应用程序：类型测试1041</span><br><span class="line"></span><br><span class="line">本章小结1042</span><br><span class="line"></span><br><span class="line">本章习题1042</span><br><span class="line"></span><br><span class="line">习题解答1043</span><br><span class="line"></span><br><span class="line">第39章 元类1046</span><br><span class="line"></span><br><span class="line">要么是元类，要么不是元类1046</span><br><span class="line"></span><br><span class="line">提高魔力层次1047</span><br><span class="line"></span><br><span class="line">“辅助”函数的缺点1049</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：回合1051</span><br><span class="line"></span><br><span class="line">元类模型1053</span><br><span class="line"></span><br><span class="line">类是类型的实例1053</span><br><span class="line"></span><br><span class="line">元类是Type的子类1055</span><br><span class="line"></span><br><span class="line">Class语句协议1056</span><br><span class="line"></span><br><span class="line">声明元类1057</span><br><span class="line"></span><br><span class="line">编写元类1058</span><br><span class="line"></span><br><span class="line">基本元类1058</span><br><span class="line"></span><br><span class="line">定制构建和初始化1059</span><br><span class="line"></span><br><span class="line">其他元类编程技巧1060</span><br><span class="line"></span><br><span class="line">实例与继承的关系1063</span><br><span class="line"></span><br><span class="line">示例：向类添加方法10</span><br><span class="line"></span><br><span class="line">手动扩展10</span><br><span class="line"></span><br><span class="line">基于元类的扩展1065</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：第二回合1067</span><br><span class="line"></span><br><span class="line">示例：对方法应用装饰器1070</span><br><span class="line"></span><br><span class="line">用装饰器手动跟踪1070</span><br><span class="line"></span><br><span class="line">用元类和装饰器跟踪1071</span><br><span class="line"></span><br><span class="line">把任何装饰器应用于方法1073</span><br><span class="line"></span><br><span class="line">元类与类装饰器的关系：第三回合1074</span><br><span class="line"></span><br><span class="line">“可选的”语言功能1076</span><br><span class="line"></span><br><span class="line">本章小结1078</span><br><span class="line"></span><br><span class="line">本章习题1078</span><br><span class="line"></span><br><span class="line">习题解答1078</span><br><span class="line"></span><br><span class="line">第九部分 附录注2</span><br><span class="line"></span><br><span class="line">附录A 安装和配置1083</span><br><span class="line"></span><br><span class="line">附录B 各部分练习题的解答 1093</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>PYTHON自然语言处理中文版 PDF</title>
    <url>/posts/b8b26aec/</url>
    <content><![CDATA[<h4 id="《PYTHON自然语言处理中文版》"><a href="#《PYTHON自然语言处理中文版》" class="headerlink" title="《PYTHON自然语言处理中文版》"></a>《PYTHON自然语言处理中文版》</h4><h6 id="链接-https-pan-baidu-com-s-17LqxjzAmtX8UVMjOuwrVxA-提取码-k8bs"><a href="#链接-https-pan-baidu-com-s-17LqxjzAmtX8UVMjOuwrVxA-提取码-k8bs" class="headerlink" title="链接: https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA 提取码: k8bs"></a>链接: <a href="https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA">https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA</a> 提取码: k8bs</h6><p>通过钻研本书，你将学到：<br><a id="more"></a></p>
<p>十分简单的程序如何就能帮你处理和分析语言数据，以及如何写这些程序</p>
<p>NLP与语言学的关键概念是如何用来描述和分析语言的</p>
<p>NLP中的数据结构和算法是怎样的</p>
<p>语言数据是如何存储为标准格式，以及如何使用数据来评估NLP技术的性</p>
<p>书前几章按照概念的难易程度编排。先是实用性很强的语言处理的入门介绍， 讲述如</p>
<p>何使用很短的 Python程序分析感兴趣的文本信息 （ 1-3章）。接着是结构化程序设计章节 （ 第</p>
<p>4章），用来巩固散布在前面几章中的编程要点。之后， 速度加快，我们用一系列章节讲述</p>
<p>语言处理的主要内容： 标注、分类和信息提取（ 5-7章）。接下来的三章探索分析句子、识</p>
<p>别句法结构和构建表示句意的方法（ 8-10章）。最后一章讲述如何有效管理语言数据（第 1</p>
<p>1章）。本书结尾处的后记简要讨论了 NLP的过去和未来</p>
<p><img src="/images/b82f0d1ecf0ec97f11ae0b5352950b8e1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">PYTHON自然语言处理中文翻译</span><br><span class="line"></span><br><span class="line">译者的话</span><br><span class="line"></span><br><span class="line">PYTHON自然语言处理</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言. 15</span><br><span class="line"></span><br><span class="line">读者</span><br><span class="line"></span><br><span class="line">强调</span><br><span class="line"></span><br><span class="line">你将学到什么？ </span><br><span class="line"></span><br><span class="line">篇章结构</span><br><span class="line"></span><br><span class="line">为什么使用Python？ </span><br><span class="line"></span><br><span class="line">软件安装需求</span><br><span class="line"></span><br><span class="line">自然语言工具包（ NLTK） </span><br><span class="line"></span><br><span class="line">教师请看</span><br><span class="line"></span><br><span class="line">本书使用的约定</span><br><span class="line"></span><br><span class="line">使用例子代码</span><br><span class="line"></span><br><span class="line">Safari®联机丛书</span><br><span class="line"></span><br><span class="line">如何联系我们</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">版税</span><br><span class="line"></span><br><span class="line">第1章 语言处理与Python</span><br><span class="line"></span><br><span class="line">1.1 语言计算：文本和单词</span><br><span class="line"></span><br><span class="line">Python入门</span><br><span class="line"></span><br><span class="line">NLTK入门</span><br><span class="line"></span><br><span class="line">搜索文本</span><br><span class="line"></span><br><span class="line">计数词汇</span><br><span class="line"></span><br><span class="line">1.2 近观 Python：将文本当做词链表</span><br><span class="line"></span><br><span class="line">链表</span><br><span class="line"></span><br><span class="line">索引列表</span><br><span class="line"></span><br><span class="line">变量</span><br><span class="line"></span><br><span class="line">字符串</span><br><span class="line"></span><br><span class="line">1.3 计算语言：简单的统计</span><br><span class="line"></span><br><span class="line">频率分布</span><br><span class="line"></span><br><span class="line">细粒度的选择词</span><br><span class="line"></span><br><span class="line">词语搭配和双连词（ bigrams） </span><br><span class="line"></span><br><span class="line">计数其他东西</span><br><span class="line"></span><br><span class="line">1.4 回到 Python:决策与控制</span><br><span class="line"></span><br><span class="line">条件</span><br><span class="line"></span><br><span class="line">对每个元素进行操作</span><br><span class="line"></span><br><span class="line">嵌套代码块</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入Linux内核架构 PDF</title>
    <url>/posts/21bb3b56/</url>
    <content><![CDATA[<h4 id="《深入Linux内核架构》"><a href="#《深入Linux内核架构》" class="headerlink" title="《深入Linux内核架构》"></a>《深入Linux内核架构》</h4><h4 id="图灵程序设计丛书LinuxUNIX系列"><a href="#图灵程序设计丛书LinuxUNIX系列" class="headerlink" title="图灵程序设计丛书LinuxUNIX系列"></a>图灵程序设计丛书LinuxUNIX系列</h4><h6 id="链接-https-pan-baidu-com-s-1mLoBn3tndC9HcCGneJMgIg-提取码-ktff"><a href="#链接-https-pan-baidu-com-s-1mLoBn3tndC9HcCGneJMgIg-提取码-ktff" class="headerlink" title="链接: https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg 提取码: ktff"></a>链接: <a href="https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg">https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg</a> 提取码: ktff</h6><a id="more"></a>
<p>　《深入Linux内核架构》讨论了Linux内核的概念、结构和实现。主要内容包括多任务、调度和进程管理，物理内存的管理以及内核与相关硬件的交互，用户空间的进程如何访问虚拟内存，如何编写设备驱动程序，模块机制以及虚拟文件系统，Ext文件系统属性和访问控制表的实现方式，内核中网络的实现，系统调用的实现方式，内核对时间相关功能的处理，页面回收和页交换的相关机制以及审计的实现等。此外，《深入Linux内核架构》借助内核源代码中关键的部分进行讲解，帮助读者掌握重要的知识点，从而在运用中充分展现Linux系统的魅力。《深入Linux内核架构》适合Linux内核爱好者阅读。</p>
<p><img src="/images/6ca9f5bc326101d9679e602f9edeb4501.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 简介和概述1</span><br><span class="line"></span><br><span class="line">1.1 内核的任务2</span><br><span class="line"></span><br><span class="line">1.2 实现策略2</span><br><span class="line"></span><br><span class="line">1.3 内核的组成部分3</span><br><span class="line"></span><br><span class="line">1.3.1 进程、进程切换、调度3</span><br><span class="line"></span><br><span class="line">1.3.2 UNIX进程4</span><br><span class="line"></span><br><span class="line">1.3.3 地址空间与特权级别6</span><br><span class="line"></span><br><span class="line">1.3.4 页表9</span><br><span class="line"></span><br><span class="line">1.3.5 物理内存的分配11</span><br><span class="line"></span><br><span class="line">1.3.6 计时13</span><br><span class="line"></span><br><span class="line">1.3.7 系统调用13</span><br><span class="line"></span><br><span class="line">1.3.8 设备驱动程序、块设备和字符设备14</span><br><span class="line"></span><br><span class="line">1.3.9 网络14</span><br><span class="line"></span><br><span class="line">1.3.10 文件系统14</span><br><span class="line"></span><br><span class="line">1.3.11 模块和热插拔15</span><br><span class="line"></span><br><span class="line">1.3.12 缓存16</span><br><span class="line"></span><br><span class="line">1.3.13 链表处理16</span><br><span class="line"></span><br><span class="line">1.3.14 对象管理和引用计数17</span><br><span class="line"></span><br><span class="line">1.3.15 数据类型20</span><br><span class="line"></span><br><span class="line">1.3.16 本书的局限性22</span><br><span class="line"></span><br><span class="line">1.4 为什么内核是特别的23</span><br><span class="line"></span><br><span class="line">1.5 行文注记23</span><br><span class="line"></span><br><span class="line">1.6 小结27</span><br><span class="line"></span><br><span class="line">第2章 进程管理和调度28</span><br><span class="line"></span><br><span class="line">2.1 进程优先级28</span><br><span class="line"></span><br><span class="line">2.2 进程生命周期30</span><br><span class="line"></span><br><span class="line">2.3 进程表示32</span><br><span class="line"></span><br><span class="line">2.3.1 进程类型37</span><br><span class="line"></span><br><span class="line">2.3.2 命名空间37</span><br><span class="line"></span><br><span class="line">2.3.3 进程ID号43</span><br><span class="line"></span><br><span class="line">2.3.4 进程关系49</span><br><span class="line"></span><br><span class="line">2.4 进程管理相关的系统调用50</span><br><span class="line"></span><br><span class="line">2.4.1 进程复制50</span><br><span class="line"></span><br><span class="line">2.4.2 内核线程62</span><br><span class="line"></span><br><span class="line">2.4.3 启动新程序63</span><br><span class="line"></span><br><span class="line">2.4.4 退出进程66</span><br><span class="line"></span><br><span class="line">2.5 调度器的实现67</span><br><span class="line"></span><br><span class="line">2.5.1 概观67</span><br><span class="line"></span><br><span class="line">2.5.2 数据结构69</span><br><span class="line"></span><br><span class="line">2.5.3 处理优先级74</span><br><span class="line"></span><br><span class="line">2.5.4 核心调度器79</span><br><span class="line"></span><br><span class="line">2.6 完全公平调度类84</span><br><span class="line"></span><br><span class="line">2.6.1 数据结构85</span><br><span class="line"></span><br><span class="line">2.6.2 CFS操作85</span><br><span class="line"></span><br><span class="line">2.6.3 队列操作89</span><br><span class="line"></span><br><span class="line">2.6.4 选择下一个进程91</span><br><span class="line"></span><br><span class="line">2.6.5 处理周期性调度器92</span><br><span class="line"></span><br><span class="line">2.6.6 唤醒抢占93</span><br><span class="line"></span><br><span class="line">2.6.7 处理新进程93</span><br><span class="line"></span><br><span class="line">2.7 实时调度类94</span><br><span class="line"></span><br><span class="line">2.7.1 性质94</span><br><span class="line"></span><br><span class="line">2.7.2 数据结构95</span><br><span class="line"></span><br><span class="line">2.7.3 调度器操作96</span><br><span class="line"></span><br><span class="line">2.8 调度器增强97</span><br><span class="line"></span><br><span class="line">2.8.1 SMP调度97</span><br><span class="line"></span><br><span class="line">2.8.2 调度域和控制组101</span><br><span class="line"></span><br><span class="line">2.8.3 内核抢占和低延迟相关工作102</span><br><span class="line"></span><br><span class="line">2.9 小结106</span><br><span class="line"></span><br><span class="line">第3章 内存管理107</span><br><span class="line"></span><br><span class="line">3.1 概述107</span><br><span class="line"></span><br><span class="line">3.2 (N)UMA模型中的内存组织109</span><br><span class="line"></span><br><span class="line">3.2.1 概述109</span><br><span class="line"></span><br><span class="line">3.2.2 数据结构111</span><br><span class="line"></span><br><span class="line">3.3 页表123</span><br><span class="line"></span><br><span class="line">3.3.1 数据结构124</span><br><span class="line"></span><br><span class="line">3.3.2 页表项的创建和操作129</span><br><span class="line"></span><br><span class="line">3.4 初始化内存管理129</span><br><span class="line"></span><br><span class="line">3.4.1 建立数据结构130</span><br><span class="line"></span><br><span class="line">3.4.2 特定于体系结构的设置135</span><br><span class="line"></span><br><span class="line">3.4.3 启动过程期间的内存管理153</span><br><span class="line"></span><br><span class="line">3.5 物理内存的管理159</span><br><span class="line"></span><br><span class="line">3.5.1 伙伴系统的结构159</span><br><span class="line"></span><br><span class="line">3.5.2 避免碎片161</span><br><span class="line"></span><br><span class="line">3.5.3 初始化内存域和结点数据结构167</span><br><span class="line"></span><br><span class="line">3.5.4 分配器API172</span><br><span class="line"></span><br><span class="line">3.5.5 分配页177</span><br><span class="line"></span><br><span class="line">3.5.6 释放页192</span><br><span class="line"></span><br><span class="line">3.5.7 内核中不连续页的分配195</span><br><span class="line"></span><br><span class="line">3.5.8 内核映射201</span><br><span class="line"></span><br><span class="line">3.6 slab分配器205</span><br><span class="line"></span><br><span class="line">3.6.1 备选分配器206</span><br><span class="line"></span><br><span class="line">3.6.2 内核中的内存管理207</span><br><span class="line"></span><br><span class="line">3.6.3 slab分配的原理209</span><br><span class="line"></span><br><span class="line">3.6.4 实现212</span><br><span class="line"></span><br><span class="line">3.6.5 通用缓存226</span><br><span class="line"></span><br><span class="line">3.7 处理器高速缓存和TLB控制228</span><br><span class="line"></span><br><span class="line">3.8 小结230</span><br><span class="line"></span><br><span class="line">第4章 进程虚拟内存231</span><br><span class="line"></span><br><span class="line">4.1 简介231</span><br><span class="line"></span><br><span class="line">4.2 进程虚拟地址空间231</span><br><span class="line"></span><br><span class="line">4.2.1 进程地址空间的布局232</span><br><span class="line"></span><br><span class="line">4.2.2 建立布局234</span><br><span class="line"></span><br><span class="line">4.3 内存映射的原理237</span><br><span class="line"></span><br><span class="line">4.4 数据结构238</span><br><span class="line"></span><br><span class="line">4.4.1 树和链表238</span><br><span class="line"></span><br><span class="line">4.4.2 虚拟内存区域的表示239</span><br><span class="line"></span><br><span class="line">4.4.3 优先查找树241</span><br><span class="line"></span><br><span class="line">4.5 对区域的操作244</span><br><span class="line"></span><br><span class="line">4.5.1 将虚拟地址关联到区域245</span><br><span class="line"></span><br><span class="line">4.5.2 区域合并246</span><br><span class="line"></span><br><span class="line">4.5.3 插入区域247</span><br><span class="line"></span><br><span class="line">4.5.4 创建区域248</span><br><span class="line"></span><br><span class="line">4.6 地址空间250</span><br><span class="line"></span><br><span class="line">4.7 内存映射251</span><br><span class="line"></span><br><span class="line">4.7.1 创建映射251</span><br><span class="line"></span><br><span class="line">4.7.2 删除映射253</span><br><span class="line"></span><br><span class="line">4.7.3 非线性映射254</span><br><span class="line"></span><br><span class="line">4.8 反向映射257</span><br><span class="line"></span><br><span class="line">4.8.1 数据结构258</span><br><span class="line"></span><br><span class="line">4.8.2 建立逆向映射259</span><br><span class="line"></span><br><span class="line">4.8.3 使用逆向映射259</span><br><span class="line"></span><br><span class="line">4.9 堆的管理261</span><br><span class="line"></span><br><span class="line">4.10 缺页异常的处理263</span><br><span class="line"></span><br><span class="line">4.11 用户空间缺页异常的校正268</span><br><span class="line"></span><br><span class="line">4.11.1 按需分配&#x2F;调页269</span><br><span class="line"></span><br><span class="line">4.11.2 匿名页271</span><br><span class="line"></span><br><span class="line">4.11.3 写时复制271</span><br><span class="line"></span><br><span class="line">4.11.4 获取非线性映射272</span><br><span class="line"></span><br><span class="line">4.12 内核缺页异常272</span><br><span class="line"></span><br><span class="line">4.13 在内核和用户空间之间复制数据274</span><br><span class="line"></span><br><span class="line">4.14 小结276</span><br><span class="line"></span><br><span class="line">第5章 锁与进程间通信277</span><br><span class="line"></span><br><span class="line">5.1 控制机制277</span><br><span class="line"></span><br><span class="line">5.1.1 竞态条件277</span><br><span class="line"></span><br><span class="line">5.1.2 临界区278</span><br><span class="line"></span><br><span class="line">5.2 内核锁机制279</span><br><span class="line"></span><br><span class="line">5.2.1 对整数的原子操作280</span><br><span class="line"></span><br><span class="line">5.2.2 自旋锁282</span><br><span class="line"></span><br><span class="line">5.2.3 信号量283</span><br><span class="line"></span><br><span class="line">5.2.4 RCU机制284</span><br><span class="line"></span><br><span class="line">5.2.5 内存和优化屏障286</span><br><span class="line"></span><br><span class="line">5.2.6 读者&#x2F;写者锁287</span><br><span class="line"></span><br><span class="line">5.2.7 大内核锁288</span><br><span class="line"></span><br><span class="line">5.2.8 互斥量288</span><br><span class="line"></span><br><span class="line">5.2.9 近似的per-CPU计数器290</span><br><span class="line"></span><br><span class="line">5.2.10 锁竞争与细粒度锁291</span><br><span class="line"></span><br><span class="line">5.3 SystemV进程间通信292</span><br><span class="line"></span><br><span class="line">5.3.1 SystemV机制292</span><br><span class="line"></span><br><span class="line">5.3.2 信号量292</span><br><span class="line"></span><br><span class="line">5.3.3 消息队列300</span><br><span class="line"></span><br><span class="line">5.3.4 共享内存303</span><br><span class="line"></span><br><span class="line">5.4 其他IPC机制303</span><br><span class="line"></span><br><span class="line">5.4.1 信号303</span><br><span class="line"></span><br><span class="line">5.4.2 管道和套接字310</span><br><span class="line"></span><br><span class="line">5.5 小结311</span><br><span class="line"></span><br><span class="line">第6章 设备驱动程序312</span><br><span class="line"></span><br><span class="line">6.1 I&#x2F;O体系结构312</span><br><span class="line"></span><br><span class="line">6.2 访问设备316</span><br><span class="line"></span><br><span class="line">6.2.1 设备文件316</span><br><span class="line"></span><br><span class="line">6.2.2 字符设备、块设备和其他设备317</span><br><span class="line"></span><br><span class="line">6.2.3 使用ioctl进行设备寻址319</span><br><span class="line"></span><br><span class="line">6.2.4 主从设备号的表示320</span><br><span class="line"></span><br><span class="line">6.2.5 注册321</span><br><span class="line"></span><br><span class="line">6.3 与文件系统关联324</span><br><span class="line"></span><br><span class="line">6.3.1 inode中的设备文件成员324</span><br><span class="line"></span><br><span class="line">6.3.2 标准文件操作325</span><br><span class="line"></span><br><span class="line">6.3.3 用于字符设备的标准操作325</span><br><span class="line"></span><br><span class="line">6.3.4 用于块设备的标准操作325</span><br><span class="line"></span><br><span class="line">6.4 字符设备操作326</span><br><span class="line"></span><br><span class="line">6.4.1 表示字符设备326</span><br><span class="line"></span><br><span class="line">6.4.2 打开设备文件326</span><br><span class="line"></span><br><span class="line">6.4.3 读写操作328</span><br><span class="line"></span><br><span class="line">6.5 块设备操作329</span><br><span class="line"></span><br><span class="line">6.5.1 块设备的表示330</span><br><span class="line"></span><br><span class="line">6.5.2 数据结构331</span><br><span class="line"></span><br><span class="line">6.5.3 向系统添加磁盘和分区338</span><br><span class="line"></span><br><span class="line">6.5.4 打开块设备文件339</span><br><span class="line"></span><br><span class="line">6.5.5 请求结构341</span><br><span class="line"></span><br><span class="line">6.5.6 BIO343</span><br><span class="line"></span><br><span class="line">6.5.7 提交请求345</span><br><span class="line"></span><br><span class="line">6.5.8 I&#x2F;O调度350</span><br><span class="line"></span><br><span class="line">6.5.9 ioctl的实现352</span><br><span class="line"></span><br><span class="line">6.6 资源分配353</span><br><span class="line"></span><br><span class="line">6.6.1 资源管理353</span><br><span class="line"></span><br><span class="line">6.6.2 I&#x2F;O内存355</span><br><span class="line"></span><br><span class="line">6.6.3 I&#x2F;O端口357</span><br><span class="line"></span><br><span class="line">6.7 总线系统358</span><br><span class="line"></span><br><span class="line">6.7.1 通用驱动程序模型358</span><br><span class="line"></span><br><span class="line">6.7.2 PCI总线363</span><br><span class="line"></span><br><span class="line">6.7.3 USB370</span><br><span class="line"></span><br><span class="line">6.8 小结376</span><br><span class="line"></span><br><span class="line">第7章 模块377</span><br><span class="line"></span><br><span class="line">7.1 概述377</span><br><span class="line"></span><br><span class="line">7.2 使用模块378</span><br><span class="line"></span><br><span class="line">7.2.1 添加和移除378</span><br><span class="line"></span><br><span class="line">7.2.2 依赖关系380</span><br><span class="line"></span><br><span class="line">7.2.3 查询模块信息381</span><br><span class="line"></span><br><span class="line">7.2.4 自动加载382</span><br><span class="line"></span><br><span class="line">7.3 插入和删除模块384</span><br><span class="line"></span><br><span class="line">7.3.1 模块的表示385</span><br><span class="line"></span><br><span class="line">7.3.2 依赖关系和引用389</span><br><span class="line"></span><br><span class="line">7.3.3 模块的二进制结构391</span><br><span class="line"></span><br><span class="line">7.3.4 插入模块396</span><br><span class="line"></span><br><span class="line">7.3.5 移除模块403</span><br><span class="line"></span><br><span class="line">7.4 自动化与热插拔404</span><br><span class="line"></span><br><span class="line">7.4.1 kmod实现的自动加载404</span><br><span class="line"></span><br><span class="line">7.4.2 热插拔405</span><br><span class="line"></span><br><span class="line">7.5 版本控制408</span><br><span class="line"></span><br><span class="line">7.5.1 校验和方法408</span><br><span class="line"></span><br><span class="line">7.5.2 版本控制函数411</span><br><span class="line"></span><br><span class="line">7.6 小结412</span><br><span class="line"></span><br><span class="line">第8章 虚拟文件系统413</span><br><span class="line"></span><br><span class="line">8.1 文件系统类型413</span><br><span class="line"></span><br><span class="line">8.2 通用文件模型414</span><br><span class="line"></span><br><span class="line">8.2.1 inode415</span><br><span class="line"></span><br><span class="line">8.2.2 链接416</span><br><span class="line"></span><br><span class="line">8.2.3 编程接口416</span><br><span class="line"></span><br><span class="line">8.2.4 将文件作为通用接口417</span><br><span class="line"></span><br><span class="line">8.3 VFS的结构417</span><br><span class="line"></span><br><span class="line">8.3.1 结构概观418</span><br><span class="line"></span><br><span class="line">8.3.2 inode419</span><br><span class="line"></span><br><span class="line">8.3.3 特定于进程的信息423</span><br><span class="line"></span><br><span class="line">8.3.4 文件操作427</span><br><span class="line"></span><br><span class="line">8.3.5 目录项缓存431</span><br><span class="line"></span><br><span class="line">8.4 处理VFS对象436</span><br><span class="line"></span><br><span class="line">8.4.1 文件系统操作436</span><br><span class="line"></span><br><span class="line">8.4.2 文件操作450</span><br><span class="line"></span><br><span class="line">8.5 标准函数456</span><br><span class="line"></span><br><span class="line">8.5.1 通用读取例程457</span><br><span class="line"></span><br><span class="line">8.5.2 失效机制459</span><br><span class="line"></span><br><span class="line">8.5.3 权限检查461</span><br><span class="line"></span><br><span class="line">8.6 小结463</span><br><span class="line"></span><br><span class="line">第9章 Ext文件系统族464</span><br><span class="line"></span><br><span class="line">9.1 简介464</span><br><span class="line"></span><br><span class="line">9.2 Ext2文件系统465</span><br><span class="line"></span><br><span class="line">9.2.1 物理结构465</span><br><span class="line"></span><br><span class="line">9.2.2 数据结构470</span><br><span class="line"></span><br><span class="line">9.2.3 创建文件系统484</span><br><span class="line"></span><br><span class="line">9.2.4 文件系统操作485</span><br><span class="line"></span><br><span class="line">9.3 Ext3文件系统507</span><br><span class="line"></span><br><span class="line">9.3.1 概念508</span><br><span class="line"></span><br><span class="line">9.3.2 数据结构509</span><br><span class="line"></span><br><span class="line">9.4 小结511</span><br><span class="line"></span><br><span class="line">第10章 无持久存储的文件系统512</span><br><span class="line"></span><br><span class="line">10.1 proc文件系统512</span><br><span class="line"></span><br><span class="line">10.1.1 &#x2F;proc的内容513</span><br><span class="line"></span><br><span class="line">10.1.2 数据结构519</span><br><span class="line"></span><br><span class="line">10.1.3 初始化522</span><br><span class="line"></span><br><span class="line">10.1.4 装载proc文件系统523</span><br><span class="line"></span><br><span class="line">10.1.5 管理&#x2F;proc数据项525</span><br><span class="line"></span><br><span class="line">10.1.6 读取和写入信息528</span><br><span class="line"></span><br><span class="line">10.1.7 进程相关的信息530</span><br><span class="line"></span><br><span class="line">10.1.8 系统控制机制535</span><br><span class="line"></span><br><span class="line">10.2 简单的文件系统542</span><br><span class="line"></span><br><span class="line">10.2.1 顺序文件542</span><br><span class="line"></span><br><span class="line">10.2.2 用libfs编写文件系统546</span><br><span class="line"></span><br><span class="line">10.2.3 调试文件系统547</span><br><span class="line"></span><br><span class="line">10.2.4 伪文件系统549</span><br><span class="line"></span><br><span class="line">10.3 sysfs549</span><br><span class="line"></span><br><span class="line">10.3.1 概述550</span><br><span class="line"></span><br><span class="line">10.3.2 数据结构550</span><br><span class="line"></span><br><span class="line">10.3.3 装载文件系统554</span><br><span class="line"></span><br><span class="line">10.3.4 文件和目录操作556</span><br><span class="line"></span><br><span class="line">10.3.5 向sysfs添加内容562</span><br><span class="line"></span><br><span class="line">10.4 小结564</span><br><span class="line"></span><br><span class="line">第11章 扩展属性和访问控制表565</span><br><span class="line"></span><br><span class="line">11.1 扩展属性565</span><br><span class="line"></span><br><span class="line">11.1.1 到虚拟文件系统的接口566</span><br><span class="line"></span><br><span class="line">11.1.2 Ext3中的实现570</span><br><span class="line"></span><br><span class="line">11.1.3 Ext2中的实现576</span><br><span class="line"></span><br><span class="line">11.2 访问控制表577</span><br><span class="line"></span><br><span class="line">11.2.1 通用实现577</span><br><span class="line"></span><br><span class="line">11.2.2 Ext3中的实现580</span><br><span class="line"></span><br><span class="line">11.2.3 Ext2中的实现585</span><br><span class="line"></span><br><span class="line">11.3 小结585</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第12章 网络586</span><br><span class="line"></span><br><span class="line">第13章 系统调用655</span><br><span class="line"></span><br><span class="line">第14章 内核活动678</span><br><span class="line"></span><br><span class="line">第15章 时间管理714</span><br><span class="line"></span><br><span class="line">第16章 页缓存和块缓存761</span><br><span class="line"></span><br><span class="line">第17章 数据同步793</span><br><span class="line"></span><br><span class="line">第18章 页面回收和页交换821</span><br><span class="line"></span><br><span class="line">第19章 审计882</span><br><span class="line"></span><br><span class="line">附录A 体系结构相关知识899</span><br><span class="line"></span><br><span class="line">附录B 使用源代码919</span><br><span class="line"></span><br><span class="line">附录C 有关C语言的注记947</span><br><span class="line"></span><br><span class="line">附录D 系统启动985</span><br><span class="line"></span><br><span class="line">附录E ELF二进制格式</span><br><span class="line"></span><br><span class="line">附录F 内核开发过程</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>神经网络与机器学习 PDF</title>
    <url>/posts/56bc0bc0/</url>
    <content><![CDATA[<h4 id="《神经网络与机器学习》"><a href="#《神经网络与机器学习》" class="headerlink" title="《神经网络与机器学习》"></a>《神经网络与机器学习》</h4><h6 id="链接-https-pan-baidu-com-s-1qs9wAX-lYBwwE-bO4nhiNg-提取码-5py4"><a href="#链接-https-pan-baidu-com-s-1qs9wAX-lYBwwE-bO4nhiNg-提取码-5py4" class="headerlink" title="链接: https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg 提取码: 5py4"></a>链接: <a href="https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg">https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg</a> 提取码: 5py4</h6><p>神经网络是计算智能和机器学习的重要分支，在诸多领域都取得了很大的成功。在众多神经网络著作中，影响较为广泛的是Simon Haykin的《神经网络原理》（第3版更名为《神经网络与机器学习》）。在本书中，作者结合近年来神经网络和机器学习的新进展，从理论和实际应用出发，全面、系统地介绍了神经网络的基本模型、方法和技术，并将神经网络和机器学习有机地结合在一起。<br><a id="more"></a></p>
<p>《神经网络与机器学习》不但注重对数学分析方法和理论的探讨，而且也非常关注神经网络在模式识别、信号处理以及控制系统等实际工程问题的应用。本书的可读性非常强，作者举重若轻地对神经网络的基本模型和主要学习理论进行了深入探讨和分析，通过大量的试验报告、例题和习题来帮助读者更好地学习神经网络。</p>
<p>本版在前一版的基础上进行了广泛修订，提供了神经网络和机器学习这两个越来越重要的学科的新分析。</p>
<p>本书特色：</p>
<ol>
<li><p>基于随机梯度下降的在线学习算法；小规模和大规模学习问题。</p>
</li>
<li><p>核方法，包括支持向量机和表达定理。</p>
</li>
<li><p>信息论学习模型，包括连接、独立分量分析（ICA）、一致独立分量分析和信息瓶颈。</p>
</li>
<li><p>随机动态规划，包括逼近和神经动态规划。</p>
</li>
<li><p>逐次状态估计算法，包括卡尔曼和粒子滤波器。</p>
</li>
<li><p>利用逐次状态估计算法训练递归神经网络。</p>
</li>
<li><p>富有洞察力的面向计算机的试验。</p>
</li>
</ol>
<p><img src="/images/cc1ddb738e58c4a3ab568ed87bfeb8e71.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">出版者的话</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">缩写和符号</span><br><span class="line"></span><br><span class="line">术语</span><br><span class="line"></span><br><span class="line">第0章 导言</span><br><span class="line"></span><br><span class="line">0.1 什么是神经网络</span><br><span class="line"></span><br><span class="line">0.2 人类大脑</span><br><span class="line"></span><br><span class="line">0.3 神经元模型</span><br><span class="line"></span><br><span class="line">0.4 被看作有向图的神经网络</span><br><span class="line"></span><br><span class="line">0.5 反馈</span><br><span class="line"></span><br><span class="line">0.6 网络结构</span><br><span class="line"></span><br><span class="line">0.7 知识表示</span><br><span class="line"></span><br><span class="line">0.8 学习过程</span><br><span class="line"></span><br><span class="line">0.9 学习任务</span><br><span class="line"></span><br><span class="line">0.10 结束语</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">第1章 Rosenblatt感知器</span><br><span class="line"></span><br><span class="line">1.1 引言</span><br><span class="line"></span><br><span class="line">1.2 感知器</span><br><span class="line"></span><br><span class="line">1.3 感知器收敛定理</span><br><span class="line"></span><br><span class="line">1.4 高斯环境下感知器与贝叶斯分类器的关系</span><br><span class="line"></span><br><span class="line">1.5 计算机实验：模式分类</span><br><span class="line"></span><br><span class="line">1.6 批量感知器算法</span><br><span class="line"></span><br><span class="line">1.7 小结和讨论</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">第2章 通过回归建立模型</span><br><span class="line"></span><br><span class="line">2.1 引言</span><br><span class="line"></span><br><span class="line">2.2 线性回归模型：初步考虑</span><br><span class="line"></span><br><span class="line">2.3 参数向量的最大后验估计</span><br><span class="line"></span><br><span class="line">2.4 正则最小二乘估计和MAP估计之间的关系</span><br><span class="line"></span><br><span class="line">2.5 计算机实验：模式分类</span><br><span class="line"></span><br><span class="line">2.6 最小描述长度原则</span><br><span class="line"></span><br><span class="line">2.7 固定样本大小考虑</span><br><span class="line"></span><br><span class="line">2.8 工具变量方法</span><br><span class="line"></span><br><span class="line">2.9 小结和讨论</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">习题55</span><br><span class="line"></span><br><span class="line">第3章 最小均方算法</span><br><span class="line"></span><br><span class="line">3.1 引言</span><br><span class="line"></span><br><span class="line">3.2 LMS算法的滤波结构</span><br><span class="line"></span><br><span class="line">3.3 无约束最优化：回顾</span><br><span class="line"></span><br><span class="line">3.4 维纳滤波器</span><br><span class="line"></span><br><span class="line">3.5 最小均方算法</span><br><span class="line"></span><br><span class="line">3.6 用马尔可夫模型来描画LMS算法和维纳滤波器的偏差</span><br><span class="line"></span><br><span class="line">3.7 朗之万方程：布朗运动的特点</span><br><span class="line"></span><br><span class="line">3.8 Kushner直接平均法</span><br><span class="line"></span><br><span class="line">3.9 小学习率参数下统计LMS学习理论</span><br><span class="line"></span><br><span class="line">3.10 计算机实验Ⅰ：线性预测</span><br><span class="line"></span><br><span class="line">3.11 计算机实验Ⅱ：模式分类</span><br><span class="line"></span><br><span class="line">3.12 LMS算法的优点和局限</span><br><span class="line"></span><br><span class="line">3.13 学习率退火方案</span><br><span class="line"></span><br><span class="line">3.14 小结和讨论</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">第4章 多层感知器</span><br><span class="line"></span><br><span class="line">4.1 引言</span><br><span class="line"></span><br><span class="line">4.2 一些预备知识</span><br><span class="line"></span><br><span class="line">4.3 批量学习和在线学习</span><br><span class="line"></span><br><span class="line">4.4 反向传播算法</span><br><span class="line"></span><br><span class="line">4.5 异或问题</span><br><span class="line"></span><br><span class="line">4.6 改善反向传播算法性能的试探法</span><br><span class="line"></span><br><span class="line">4.7 计算机实验：模式分类</span><br><span class="line"></span><br><span class="line">4.8 反向传播和微分</span><br><span class="line"></span><br><span class="line">4.9 Hessian矩阵及其在在线学习中的规则</span><br><span class="line"></span><br><span class="line">4.10 学习率的最优退火和自适应控制</span><br><span class="line"></span><br><span class="line">4.11 泛化</span><br><span class="line"></span><br><span class="line">4.12 函数逼近</span><br><span class="line"></span><br><span class="line">4.13 交叉验证</span><br><span class="line"></span><br><span class="line">4.14 复杂度正则化和网络修剪</span><br><span class="line"></span><br><span class="line">4.15 反向传播学习的优点和局限</span><br><span class="line"></span><br><span class="line">4.16 作为最优化问题看待的监督学习</span><br><span class="line"></span><br><span class="line">4.17 卷积网络</span><br><span class="line"></span><br><span class="line">4.18 非线性滤波</span><br><span class="line"></span><br><span class="line">4.19 小规模和大规模学习问题</span><br><span class="line"></span><br><span class="line">4.20 小结和讨论</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">第5章 核方法和径向基函数网络</span><br><span class="line"></span><br><span class="line">5.1 引言</span><br><span class="line"></span><br><span class="line">5.2 模式可分性的Cover定理</span><br><span class="line"></span><br><span class="line">5.3 插值问题</span><br><span class="line"></span><br><span class="line">5.4 径向基函数网络</span><br><span class="line"></span><br><span class="line">5.5 K-均值聚类</span><br><span class="line"></span><br><span class="line">5.6 权向量的递归最小二乘估计</span><br><span class="line"></span><br><span class="line">5.7 RBF网络的混合学习过程</span><br><span class="line"></span><br><span class="line">5.8 计算机实验：模式分类</span><br><span class="line"></span><br><span class="line">5.9 高斯隐藏单元的解释</span><br><span class="line"></span><br><span class="line">5.10 核回归及其与RBF网络的关系</span><br><span class="line"></span><br><span class="line">5.11 小结和讨论</span><br><span class="line"></span><br><span class="line">注释和参考文献</span><br><span class="line"></span><br><span class="line">习题</span><br><span class="line"></span><br><span class="line">第6章 支持向量机</span><br><span class="line"></span><br><span class="line">第7章 正则化理论</span><br><span class="line"></span><br><span class="line">第8章 主分量分析</span><br><span class="line"></span><br><span class="line">第9章 自组织映射</span><br><span class="line"></span><br><span class="line">第10章 信息论学习模型</span><br><span class="line"></span><br><span class="line">第11章 植根于统计力学的随机方法</span><br><span class="line"></span><br><span class="line">第12章 动态规划</span><br><span class="line"></span><br><span class="line">第13章 神经动力学</span><br><span class="line"></span><br><span class="line">第14章 动态系统状态估计的贝叶斯滤波</span><br><span class="line"></span><br><span class="line">第15章 动态驱动递归网络</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据科学入门 PDF</title>
    <url>/posts/c8d89e63/</url>
    <content><![CDATA[<h4 id="《数据科学入门》"><a href="#《数据科学入门》" class="headerlink" title="《数据科学入门》"></a>《数据科学入门》</h4><h6 id="链接-https-pan-baidu-com-s-1HAp6Q8pqPeLcyDwXdQsagA-提取码-71b3"><a href="#链接-https-pan-baidu-com-s-1HAp6Q8pqPeLcyDwXdQsagA-提取码-71b3" class="headerlink" title="链接: https://pan.baidu.com/s/1HAp6Q8pqPeLcyDwXdQsagA 提取码: 71b3"></a>链接: <a href="https://pan.baidu.com/s/1HAp6Q8pqPeLcyDwXdQsagA">https://pan.baidu.com/s/1HAp6Q8pqPeLcyDwXdQsagA</a> 提取码: 71b3</h6><p>1.全能数据科学家成长指南，长居美亚机器学习热销榜；<br><a id="more"></a></p>
<p>2.新版基于Python 3.6，新引入了类型注释等许多功能；</p>
<p>3.根据数据科学近几年的发展，新增了关于深度学习、统计学和自然语言处理等主题，让图书内容与时俱进。</p>
<ul>
<li><p>学到一堂Python速成课。</p>
</li>
<li><p>学习线性代数、统计学和概率论的基础知识，并能将其灵活地用于数据科学项目。</p>
</li>
<li><p>掌握如何获取、探索、清洗、处理和调整数据。</p>
</li>
<li><p>深入理解机器学习概念，尤其是深度学习概念。</p>
</li>
<li><p>运用k最近邻法、朴素贝叶斯、线性回归、逻辑回归、决策树、神经网络和聚类等算法实现数据模型。</p>
</li>
<li><p>探索自然语言处理、网络分析、推荐系统、数据库与SQL、MapReduce。</p>
</li>
</ul>
<p>无论你身处哪个行业，数据都能成为你的好帮手。善于从凌乱的数据中提取有用的信息，你就能在面对业务难题时游刃有余，用数据说话，为决策找到有力的支撑。</p>
<p>欢迎进入数据科学世界！在本书中，你将化身为虚构公司DataSciencester的员工，从零开始数据科学工作，亲手构建工具、实现算法，最终从数据科学新手蜕变为全能的数据科学家。在第1版的基础上，本书升级了所有代码示例，并新增了深度学习、统计学、自然语言处理等相关内容。</p>
<p><img src="/images/c937eb877fdf410406c1f2f7c31d4f961.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 2版前言　xiii</span><br><span class="line"></span><br><span class="line">第　1版前言 xvii</span><br><span class="line"></span><br><span class="line">第　1章 导论　1</span><br><span class="line"></span><br><span class="line">1．1　数据的崛起　1</span><br><span class="line"></span><br><span class="line">1．2　什么是数据科学　1</span><br><span class="line"></span><br><span class="line">1．3　激励假设：DataSciencester　2</span><br><span class="line"></span><br><span class="line">1．3．1　寻找关键联系人　3</span><br><span class="line"></span><br><span class="line">1．3．2　你可能知道的数据科学家　5</span><br><span class="line"></span><br><span class="line">1．3．3　工资和工作年限　8</span><br><span class="line"></span><br><span class="line">1．3．4　付费账户　10</span><br><span class="line"></span><br><span class="line">1．3．5　感兴趣的主题　10</span><br><span class="line"></span><br><span class="line">1．3．6　展望　12</span><br><span class="line"></span><br><span class="line">第　2章 Python速成　13</span><br><span class="line"></span><br><span class="line">2．1　Python之禅　13</span><br><span class="line"></span><br><span class="line">2．2　获取Python　14</span><br><span class="line"></span><br><span class="line">2．3　虚拟环境　14</span><br><span class="line"></span><br><span class="line">2．4　空白格式　15</span><br><span class="line"></span><br><span class="line">2．5　模块　16</span><br><span class="line"></span><br><span class="line">2．6　函数　17</span><br><span class="line"></span><br><span class="line">2．7　字符串　18</span><br><span class="line"></span><br><span class="line">2．8　异常　19</span><br><span class="line"></span><br><span class="line">2．9　列表　19</span><br><span class="line"></span><br><span class="line">2．10　元组　21</span><br><span class="line"></span><br><span class="line">2．11　字典　22</span><br><span class="line"></span><br><span class="line">2．12　计数器　24</span><br><span class="line"></span><br><span class="line">2．13　集　24</span><br><span class="line"></span><br><span class="line">2．14　控制流　25</span><br><span class="line"></span><br><span class="line">2．15　真和假　26</span><br><span class="line"></span><br><span class="line">2．16　排序　27</span><br><span class="line"></span><br><span class="line">2．17　列表解析　27</span><br><span class="line"></span><br><span class="line">2．18　自动化测试和断言　28</span><br><span class="line"></span><br><span class="line">2．19　面向对象编程　29</span><br><span class="line"></span><br><span class="line">2．20　迭代器和生成器　31</span><br><span class="line"></span><br><span class="line">2．21　随机性 ．．32</span><br><span class="line"></span><br><span class="line">2．22　正则表达式　33</span><br><span class="line"></span><br><span class="line">2．23　函数式编程　34</span><br><span class="line"></span><br><span class="line">2．24　压缩和参数拆分　34</span><br><span class="line"></span><br><span class="line">2．25　args和kwargs　35</span><br><span class="line"></span><br><span class="line">2．26　类型注释　36</span><br><span class="line"></span><br><span class="line">2．27　欢迎来到DataSciencester　39</span><br><span class="line"></span><br><span class="line">2．28　进一步探索　39</span><br><span class="line"></span><br><span class="line">第3章　数据可视化　40</span><br><span class="line"></span><br><span class="line">3．1　matplotlib　40</span><br><span class="line"></span><br><span class="line">3．2　条形图　42</span><br><span class="line"></span><br><span class="line">3．3　线图　45</span><br><span class="line"></span><br><span class="line">3．4　散点图　46</span><br><span class="line"></span><br><span class="line">3．5　延伸学习　48</span><br><span class="line"></span><br><span class="line">第4章　线性代数　49</span><br><span class="line"></span><br><span class="line">4．1　向量　49</span><br><span class="line"></span><br><span class="line">4．2　矩阵　53</span><br><span class="line"></span><br><span class="line">4．3　延伸学习　56</span><br><span class="line"></span><br><span class="line">第5章　统计学　57</span><br><span class="line"></span><br><span class="line">5．1　描述单个数据集　57</span><br><span class="line"></span><br><span class="line">5．1．1　中心倾向　59</span><br><span class="line"></span><br><span class="line">5．1．2　离散度　61</span><br><span class="line"></span><br><span class="line">5．2　相关　62</span><br><span class="line"></span><br><span class="line">5．3　辛普森悖论　64</span><br><span class="line"></span><br><span class="line">5．4　相关系数的其他注意事项　65</span><br><span class="line"></span><br><span class="line">5．5　相关与因果　66</span><br><span class="line"></span><br><span class="line">5．6　延伸学习　66</span><br><span class="line"></span><br><span class="line">第6章　概率　68</span><br><span class="line"></span><br><span class="line">6．1　依赖和独立　68</span><br><span class="line"></span><br><span class="line">6．2　条件概率　69</span><br><span class="line"></span><br><span class="line">6．3　贝叶斯定理　71</span><br><span class="line"></span><br><span class="line">6．4　随机变量　72</span><br><span class="line"></span><br><span class="line">6．5　连续分布　72</span><br><span class="line"></span><br><span class="line">6．6　正态分布　73</span><br><span class="line"></span><br><span class="line">6．7　中心极限定理　76</span><br><span class="line"></span><br><span class="line">6．8　延伸学习　78</span><br><span class="line"></span><br><span class="line">第7章　假设和推论　79</span><br><span class="line"></span><br><span class="line">7．1　统计假设检验　79</span><br><span class="line"></span><br><span class="line">7．2　实例：掷硬币　79</span><br><span class="line"></span><br><span class="line">7．3　p值　82</span><br><span class="line"></span><br><span class="line">7．4　置信区间　84</span><br><span class="line"></span><br><span class="line">7．5　p-Hacking　84</span><br><span class="line"></span><br><span class="line">7．6　实例：运行A&#x2F;B 测试　85</span><br><span class="line"></span><br><span class="line">7．7　贝叶斯推断　86</span><br><span class="line"></span><br><span class="line">7．8　延伸学习　89</span><br><span class="line"></span><br><span class="line">第8章　梯度下降　90</span><br><span class="line"></span><br><span class="line">8．1　梯度下降的思想　90</span><br><span class="line"></span><br><span class="line">8．2　估算梯度　91</span><br><span class="line"></span><br><span class="line">8．3　使用梯度　94</span><br><span class="line"></span><br><span class="line">8．4　选择正确步长　94</span><br><span class="line"></span><br><span class="line">8．5　使用梯度下降拟合模型　95</span><br><span class="line"></span><br><span class="line">8．6　小批次梯度下降和随机梯度下降　96</span><br><span class="line"></span><br><span class="line">8．7　延伸学习　98</span><br><span class="line"></span><br><span class="line">第9章　获取数据　99</span><br><span class="line"></span><br><span class="line">9．1　stdin和stdout　99</span><br><span class="line"></span><br><span class="line">9．2　读取文件　101</span><br><span class="line"></span><br><span class="line">9．2．1　文本文件的基础　101</span><br><span class="line"></span><br><span class="line">9．2．2　限制的文件　102</span><br><span class="line"></span><br><span class="line">9．3　网络抓取　104</span><br><span class="line"></span><br><span class="line">9．4　使用API　106</span><br><span class="line"></span><br><span class="line">9．4．1　JSON和XML　106</span><br><span class="line"></span><br><span class="line">9．4．2　使用无验证的API　107</span><br><span class="line"></span><br><span class="line">9．4．3　寻找API　108</span><br><span class="line"></span><br><span class="line">9．5　实例：使用Twitter API　109</span><br><span class="line"></span><br><span class="line">9．6　延伸学习　112</span><br><span class="line"></span><br><span class="line">第　10章 数据工作　113</span><br><span class="line"></span><br><span class="line">10．1　探索数据　113</span><br><span class="line"></span><br><span class="line">10．1．1　探索一维数据　113</span><br><span class="line"></span><br><span class="line">10．1．2　两个维度　115</span><br><span class="line"></span><br><span class="line">10．1．3　多维数据　116</span><br><span class="line"></span><br><span class="line">10．2　使用NamedTuple　18</span><br><span class="line"></span><br><span class="line">10．3　数据类　119</span><br><span class="line"></span><br><span class="line">10．4　清洗和修改　120</span><br><span class="line"></span><br><span class="line">10．5　数据处理　122</span><br><span class="line"></span><br><span class="line">10．6　数据调整　25</span><br><span class="line"></span><br><span class="line">10．7　题外话：tqdm　126</span><br><span class="line"></span><br><span class="line">10．8　降维　127</span><br><span class="line"></span><br><span class="line">10．9　延伸学习　133</span><br><span class="line"></span><br><span class="line">第　11章 机器学习　134</span><br><span class="line"></span><br><span class="line">11．1　建模　134</span><br><span class="line"></span><br><span class="line">11．2　什么是机器学习　135</span><br><span class="line"></span><br><span class="line">11．3　过拟合与欠拟合　135</span><br><span class="line"></span><br><span class="line">11．4　正确性　138</span><br><span class="line"></span><br><span class="line">11．5　偏差–方差权衡　140</span><br><span class="line"></span><br><span class="line">11．6　特征提取与选择　141</span><br><span class="line"></span><br><span class="line">11．7　延伸学习　142</span><br><span class="line"></span><br><span class="line">第　12章 k最近邻法　143</span><br><span class="line"></span><br><span class="line">12．1　模型　143</span><br><span class="line"></span><br><span class="line">12．2　实例：鸢尾花数据集　145</span><br><span class="line"></span><br><span class="line">12．3　维数灾难　148</span><br><span class="line"></span><br><span class="line">12．4　进一步探索　152</span><br><span class="line"></span><br><span class="line">第　13章 朴素贝叶斯算法　153</span><br><span class="line"></span><br><span class="line">13．1　一个简易的垃圾邮件过滤器　153</span><br><span class="line"></span><br><span class="line">13．2　一个复杂的垃圾邮件过滤器　154</span><br><span class="line"></span><br><span class="line">13．3　算法实现　155</span><br><span class="line"></span><br><span class="line">13．4　测试模型　157</span><br><span class="line"></span><br><span class="line">13．5　使用模型　158</span><br><span class="line"></span><br><span class="line">13．6　延伸学习　161</span><br><span class="line"></span><br><span class="line">第　14章 简单线性回归　162</span><br><span class="line"></span><br><span class="line">14．1　模型　162</span><br><span class="line"></span><br><span class="line">14．2　使用梯度下降法　165</span><br><span class="line"></span><br><span class="line">14．3　最大似然估计　166</span><br><span class="line"></span><br><span class="line">14．4　延伸学习　166</span><br><span class="line"></span><br><span class="line">第　15章 多元回归　167</span><br><span class="line"></span><br><span class="line">15．1　模型　167</span><br><span class="line"></span><br><span class="line">15．2　最小二乘模型的进一步假设　168</span><br><span class="line"></span><br><span class="line">15．3　拟合模型　169</span><br><span class="line"></span><br><span class="line">15．4　解释模型　171</span><br><span class="line"></span><br><span class="line">15．5　拟合优度　171</span><br><span class="line"></span><br><span class="line">15．6　题外话：Bootstrap　172</span><br><span class="line"></span><br><span class="line">15．7　回归系数的标准误差　173</span><br><span class="line"></span><br><span class="line">15．8　正则化　175</span><br><span class="line"></span><br><span class="line">15．9　延伸学习　177</span><br><span class="line"></span><br><span class="line">第　16章 逻辑回归　178</span><br><span class="line"></span><br><span class="line">16．1　问题　178</span><br><span class="line"></span><br><span class="line">16．2　logistic函数　180</span><br><span class="line"></span><br><span class="line">16．3　应用模型　183</span><br><span class="line"></span><br><span class="line">16．4　拟合优度　184</span><br><span class="line"></span><br><span class="line">16．5　支持向量机　185</span><br><span class="line"></span><br><span class="line">16．6　延伸学习　188</span><br><span class="line"></span><br><span class="line">第　17章 决策树　89</span><br><span class="line"></span><br><span class="line">17．1　什么是决策树　189</span><br><span class="line"></span><br><span class="line">17．2　熵　191</span><br><span class="line"></span><br><span class="line">17．3　分割的熵　193</span><br><span class="line"></span><br><span class="line">17．4　创建决策树　194</span><br><span class="line"></span><br><span class="line">17．5　综合运用　196</span><br><span class="line"></span><br><span class="line">17．6　随机森林　199</span><br><span class="line"></span><br><span class="line">17．7　延伸学习　199</span><br><span class="line"></span><br><span class="line">第　18章 神经网络　200</span><br><span class="line"></span><br><span class="line">18．1　感知器　200</span><br><span class="line"></span><br><span class="line">18．2　前馈神经网络　202</span><br><span class="line"></span><br><span class="line">18．3　反向传播　205</span><br><span class="line"></span><br><span class="line">18．4　实例：Fizz Buzz　207</span><br><span class="line"></span><br><span class="line">18．5　延伸学习　210</span><br><span class="line"></span><br><span class="line">第　19章 深度学习　211</span><br><span class="line"></span><br><span class="line">19．1　张量　211</span><br><span class="line"></span><br><span class="line">19．2　层抽象　213</span><br><span class="line"></span><br><span class="line">19．3　线性层　215</span><br><span class="line"></span><br><span class="line">19．4　把神经网络作为层序列　218</span><br><span class="line"></span><br><span class="line">19．5　损失函数与优化器　219</span><br><span class="line"></span><br><span class="line">19．6　实例：重新设计异或网络　221</span><br><span class="line"></span><br><span class="line">19．7　其他激活函数　222</span><br><span class="line"></span><br><span class="line">19．8　实例：重新解决Fizz Buzz问题　223</span><br><span class="line"></span><br><span class="line">19．9　softmax函数和交叉熵　224</span><br><span class="line"></span><br><span class="line">19．10　丢弃　227</span><br><span class="line"></span><br><span class="line">19．11　实例：MNIST　227</span><br><span class="line"></span><br><span class="line">19．12　保存和加载模型　231</span><br><span class="line"></span><br><span class="line">19．13　延伸学习　232</span><br><span class="line"></span><br><span class="line">第　20章 聚类分析　233</span><br><span class="line"></span><br><span class="line">20．1　原理　233</span><br><span class="line"></span><br><span class="line">20．2　模型　234</span><br><span class="line"></span><br><span class="line">20．3　实例：聚会　236</span><br><span class="line"></span><br><span class="line">20．4　选择聚类数目k　238</span><br><span class="line"></span><br><span class="line">20．5　实例：色彩聚类　239</span><br><span class="line"></span><br><span class="line">20．6　自下而上的分层聚类　241</span><br><span class="line"></span><br><span class="line">20．7　延伸学习　246</span><br><span class="line"></span><br><span class="line">第　21章 自然语言处理　247</span><br><span class="line"></span><br><span class="line">21．1　词云　247</span><br><span class="line"></span><br><span class="line">21．2　n-gram 语言模型　249</span><br><span class="line"></span><br><span class="line">21．3　语法　252</span><br><span class="line"></span><br><span class="line">21．4　题外话：吉布斯采样　254</span><br><span class="line"></span><br><span class="line">21．5　主题建模　255</span><br><span class="line"></span><br><span class="line">21．6　词向量　260</span><br><span class="line"></span><br><span class="line">21．7　递归神经网络　268</span><br><span class="line"></span><br><span class="line">21．8　实例：使用字符级RNN　271</span><br><span class="line"></span><br><span class="line">21．9　延伸学习　274</span><br><span class="line"></span><br><span class="line">第　22章 网络分析　275</span><br><span class="line"></span><br><span class="line">22．1　中介中心性　275</span><br><span class="line"></span><br><span class="line">22．2　特征向量中心性　280</span><br><span class="line"></span><br><span class="line">22．2．1　矩阵乘法　280</span><br><span class="line"></span><br><span class="line">22．2．2　中心性　282</span><br><span class="line"></span><br><span class="line">22．3　有向图与PageRank　283</span><br><span class="line"></span><br><span class="line">22．4　延伸学习　286</span><br><span class="line"></span><br><span class="line">第　23章 推荐系统　287</span><br><span class="line"></span><br><span class="line">23．1　人工管理　288</span><br><span class="line"></span><br><span class="line">23．2　推荐流行事务　288</span><br><span class="line"></span><br><span class="line">23．3　基于用户的协同过滤　289</span><br><span class="line"></span><br><span class="line">23．4　基于项目的协同过滤　292</span><br><span class="line"></span><br><span class="line">23．5　矩阵分解　294</span><br><span class="line"></span><br><span class="line">23．6　延伸学习　298</span><br><span class="line"></span><br><span class="line">第　24章 数据库与SQL　299</span><br><span class="line"></span><br><span class="line">24．1　CREATE TABLE与INSERT　299</span><br><span class="line"></span><br><span class="line">24．2　UPDATE　302</span><br><span class="line"></span><br><span class="line">24．3　DELETE　303</span><br><span class="line"></span><br><span class="line">24．4　SELECT　304</span><br><span class="line"></span><br><span class="line">24．5　GROUP BY　306</span><br><span class="line"></span><br><span class="line">24．6　ORDER BY　308</span><br><span class="line"></span><br><span class="line">24．7　JOIN　309</span><br><span class="line"></span><br><span class="line">24．8　子查询　311</span><br><span class="line"></span><br><span class="line">24．9　索引　312</span><br><span class="line"></span><br><span class="line">24．10　查询优化　312</span><br><span class="line"></span><br><span class="line">24．11　NoSQL　313</span><br><span class="line"></span><br><span class="line">24．12　延伸学习　313</span><br><span class="line"></span><br><span class="line">第　25章 MapReduce　314</span><br><span class="line"></span><br><span class="line">25．1　实例：单词计数　315</span><br><span class="line"></span><br><span class="line">25．2　为什么是MapReduce　316</span><br><span class="line"></span><br><span class="line">25．3　更一般化的MapReduce　317</span><br><span class="line"></span><br><span class="line">25．4　实例：状态分析更新　318</span><br><span class="line"></span><br><span class="line">25．5　实例：矩阵乘法　320</span><br><span class="line"></span><br><span class="line">25．6　题外话：组合器　321</span><br><span class="line"></span><br><span class="line">25．7　延伸学习　322</span><br><span class="line"></span><br><span class="line">第　26章 数据伦理　323</span><br><span class="line"></span><br><span class="line">26．1　什么是数据伦理　323</span><br><span class="line"></span><br><span class="line">26．2　讲真的，什么是数据伦理　324</span><br><span class="line"></span><br><span class="line">26．3　是否应该关注数据伦理　324</span><br><span class="line"></span><br><span class="line">26．4　建立不良数据产品　325</span><br><span class="line"></span><br><span class="line">26．5　精确与公平之间的较量　325</span><br><span class="line"></span><br><span class="line">26．6　合作　327</span><br><span class="line"></span><br><span class="line">26．7　可解释性　327</span><br><span class="line"></span><br><span class="line">26．8　推荐　327</span><br><span class="line"></span><br><span class="line">26．9　异常数据　328</span><br><span class="line"></span><br><span class="line">26．10　数据保护　329</span><br><span class="line"></span><br><span class="line">26．11　小结　329</span><br><span class="line"></span><br><span class="line">26．12　延伸学习　329</span><br><span class="line"></span><br><span class="line">第　27章 数据科学前瞻　330</span><br><span class="line"></span><br><span class="line">27．1　IPython　330</span><br><span class="line"></span><br><span class="line">27．2　数学　331</span><br><span class="line"></span><br><span class="line">27．3　不从零开始　331</span><br><span class="line"></span><br><span class="line">27．3．1　NumPy　331</span><br><span class="line"></span><br><span class="line">27．3．2　pandas　331</span><br><span class="line"></span><br><span class="line">27．3．3　scikit-learn　331</span><br><span class="line"></span><br><span class="line">27．3．4　可视化　332</span><br><span class="line"></span><br><span class="line">27．3．5　R　332</span><br><span class="line"></span><br><span class="line">27．3．6　深度学习　332</span><br><span class="line"></span><br><span class="line">27．4　寻找数据　333</span><br><span class="line"></span><br><span class="line">27．5　从事数据科学工作　333</span><br><span class="line"></span><br><span class="line">27．5．1　Hacker News　333</span><br><span class="line"></span><br><span class="line">27．5．2　消防车　333</span><br><span class="line"></span><br><span class="line">27．5．3　T恤　334</span><br><span class="line"></span><br><span class="line">27．5．4　地球仪上的推文　334</span><br><span class="line"></span><br><span class="line">27．5．5　你的发现　335</span><br><span class="line"></span><br><span class="line">关于作者　336</span><br><span class="line"></span><br><span class="line">关于封面　336</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘-实用机器学习技术中文第二版 PDF</title>
    <url>/posts/bfdfaef5/</url>
    <content><![CDATA[<h4 id="《数据挖掘-实用机器学习技术中文第二版》"><a href="#《数据挖掘-实用机器学习技术中文第二版》" class="headerlink" title="《数据挖掘-实用机器学习技术中文第二版》"></a>《数据挖掘-实用机器学习技术中文第二版》</h4><h6 id="链接-https-pan-baidu-com-s-1bvuhDW4kkkYOhvTnzXx16g-提取码-ek29"><a href="#链接-https-pan-baidu-com-s-1bvuhDW4kkkYOhvTnzXx16g-提取码-ek29" class="headerlink" title="链接: https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g 提取码: ek29"></a>链接: <a href="https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g">https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g</a> 提取码: ek29</h6><p>《数据挖掘：概念与技术（原书第3版）》完整全面地讲述数据挖掘的概念、方法、技术和全新研究进展。本书对前两版做了全面修订，加强和重新组织了全书的技术内容，重点论述了数据预处理、频繁模式挖掘、分类和聚类等的内容，还全面讲述了OLAP和离群点检测，并研讨了挖掘网络、复杂数据类型以及重要应用领域。<br><a id="more"></a></p>
<p>　　《数据挖掘：概念与技术（原书第3版）》是数据挖掘和知识发现领域内的所有教师、研究人员、开发人员和用户都必读的参考书，是一本适用于数据分析、数据挖掘和知识发现课程的优秀教材，可以用做高年级本科生或者一年级研究生的数据挖掘导论教材。</p>
<p><img src="/images/ac48857d7b4a6e2f34dd0a37622de3211.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">出版者的话</span><br><span class="line"></span><br><span class="line">中文版序</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">译者简介</span><br><span class="line"></span><br><span class="line">第3版序</span><br><span class="line"></span><br><span class="line">第2版序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">作者简介</span><br><span class="line"></span><br><span class="line">第1章　引论</span><br><span class="line"></span><br><span class="line">1.1　为什么进行数据挖掘</span><br><span class="line"></span><br><span class="line">1.1.1　迈向信息时代</span><br><span class="line"></span><br><span class="line">1.1.2　数据挖掘是信息技术的进化</span><br><span class="line"></span><br><span class="line">1.2　什么是数据挖掘</span><br><span class="line"></span><br><span class="line">1.3　可以挖掘什么类型的数据</span><br><span class="line"></span><br><span class="line">1.3.1　数据库数据</span><br><span class="line"></span><br><span class="line">1.3.2　数据仓库</span><br><span class="line"></span><br><span class="line">1.3.3　事务数据</span><br><span class="line"></span><br><span class="line">1.3.4　其他类型的数据</span><br><span class="line"></span><br><span class="line">1.4　可以挖掘什么类型的模式</span><br><span class="line"></span><br><span class="line">1.4.1　类&#x2F;概念描述：特征化与区分</span><br><span class="line"></span><br><span class="line">1.4.2　挖掘频繁模式、关联和相关性</span><br><span class="line"></span><br><span class="line">1.4.3　用于预测分析的分类与回归</span><br><span class="line"></span><br><span class="line">1.4.4　聚类分析</span><br><span class="line"></span><br><span class="line">1.4.5　离群点分析</span><br><span class="line"></span><br><span class="line">1.4.6　所有模式都是有趣的吗</span><br><span class="line"></span><br><span class="line">1.5　使用什么技术</span><br><span class="line"></span><br><span class="line">1.5.1　统计学</span><br><span class="line"></span><br><span class="line">1.5.2　机器学习</span><br><span class="line"></span><br><span class="line">1.5.3　数据库系统与数据仓库</span><br><span class="line"></span><br><span class="line">1.5.4　信息检索</span><br><span class="line"></span><br><span class="line">1.6　面向什么类型的应用</span><br><span class="line"></span><br><span class="line">1.6.1　商务智能</span><br><span class="line"></span><br><span class="line">1.6.2　Web搜索引擎</span><br><span class="line"></span><br><span class="line">1.7　数据挖掘的主要问题</span><br><span class="line"></span><br><span class="line">1.7.1　挖掘方法</span><br><span class="line"></span><br><span class="line">1.7.2　用户界面</span><br><span class="line"></span><br><span class="line">1.7.3　有效性和可伸缩性</span><br><span class="line"></span><br><span class="line">1.7.4　数据库类型的多样性</span><br><span class="line"></span><br><span class="line">1.7.5　数据挖掘与社会</span><br><span class="line"></span><br><span class="line">1.8　小结</span><br><span class="line"></span><br><span class="line">1.9　习题</span><br><span class="line"></span><br><span class="line">1.10　文献注释</span><br><span class="line"></span><br><span class="line">第2章　认识数据</span><br><span class="line"></span><br><span class="line">2.1　数据对象与属性类型</span><br><span class="line"></span><br><span class="line">2.1.1　什么是属性</span><br><span class="line"></span><br><span class="line">2.1.2　标称属性</span><br><span class="line"></span><br><span class="line">2.1.3　二元属性</span><br><span class="line"></span><br><span class="line">2.1.4　序数属性</span><br><span class="line"></span><br><span class="line">2.1.5　数值属性</span><br><span class="line"></span><br><span class="line">2.1.6　离散属性与连续属性</span><br><span class="line"></span><br><span class="line">2.2　数据的基本统计描述</span><br><span class="line"></span><br><span class="line">2.2.1　中心趋势度量：均值、中位数和众数</span><br><span class="line"></span><br><span class="line">2.2.2　度量数据散布：极差、四分位数、方差、标准差和四分位数极差</span><br><span class="line"></span><br><span class="line">2.2.3　数据的基本统计描述的图形显示</span><br><span class="line"></span><br><span class="line">2.3　数据可视化</span><br><span class="line"></span><br><span class="line">2.3.1　基于像素的可视化技术</span><br><span class="line"></span><br><span class="line">2.3.2　几何投影可视化技术</span><br><span class="line"></span><br><span class="line">2.3.3　基于图符的可视化技术</span><br><span class="line"></span><br><span class="line">2.3.4　层次可视化技术</span><br><span class="line"></span><br><span class="line">2.3.5　可视化复杂对象和关系</span><br><span class="line"></span><br><span class="line">2.4　度量数据的相似性和相异性</span><br><span class="line"></span><br><span class="line">2.4.1　数据矩阵与相异性矩阵</span><br><span class="line"></span><br><span class="line">2.4.2　标称属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.3　二元属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.4　数值属性的相异性：闵可夫斯基距离</span><br><span class="line"></span><br><span class="line">2.4.5　序数属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.6　混合类型属性的相异性</span><br><span class="line"></span><br><span class="line">2.4.7　余弦相似性</span><br><span class="line"></span><br><span class="line">2.5　小结</span><br><span class="line"></span><br><span class="line">2.6　习题</span><br><span class="line"></span><br><span class="line">2.7　文献注释</span><br><span class="line"></span><br><span class="line">第3章　数据预处理</span><br><span class="line"></span><br><span class="line">3.1　数据预处理：概述</span><br><span class="line"></span><br><span class="line">3.1.1　数据质量：为什么要对数据预处理</span><br><span class="line"></span><br><span class="line">3.1.2　数据预处理的主要任务</span><br><span class="line"></span><br><span class="line">3.2　数据清理</span><br><span class="line"></span><br><span class="line">3.2.1　缺失值</span><br><span class="line"></span><br><span class="line">3.2.2　噪声数据</span><br><span class="line"></span><br><span class="line">3.2.3　数据清理作为一个过程</span><br><span class="line"></span><br><span class="line">3.3　数据集成</span><br><span class="line"></span><br><span class="line">3.3.1　实体识别问题</span><br><span class="line"></span><br><span class="line">3.3.2　冗余和相关分析</span><br><span class="line"></span><br><span class="line">3.3.3　元组重复</span><br><span class="line"></span><br><span class="line">3.3.4　数据值冲突的检测与处理</span><br><span class="line"></span><br><span class="line">3.4　数据归约</span><br><span class="line"></span><br><span class="line">3.4.1　数据归约策略概述</span><br><span class="line"></span><br><span class="line">3.4.2　小波变换</span><br><span class="line"></span><br><span class="line">3.4.3　主成分分析</span><br><span class="line"></span><br><span class="line">3.4.4　属性子集选择</span><br><span class="line"></span><br><span class="line">3.4.5　回归和对数线性模型：参数化数据归约</span><br><span class="line"></span><br><span class="line">3.4.6　直方图</span><br><span class="line"></span><br><span class="line">3.4.7　聚类</span><br><span class="line"></span><br><span class="line">3.4.8　抽样</span><br><span class="line"></span><br><span class="line">3.4.9　数据立方体聚集</span><br><span class="line"></span><br><span class="line">3.5　数据变换与数据离散化</span><br><span class="line"></span><br><span class="line">3.5.1　数据变换策略概述</span><br><span class="line"></span><br><span class="line">3.5.2　通过规范化变换数据</span><br><span class="line"></span><br><span class="line">3.5.3　通过分箱离散化</span><br><span class="line"></span><br><span class="line">3.5.4　通过直方图分析离散化</span><br><span class="line"></span><br><span class="line">3.5.5　通过聚类、决策树和相关分析离散化</span><br><span class="line"></span><br><span class="line">3.5.6　标称数据的概念分层产生</span><br><span class="line"></span><br><span class="line">3.6　小结</span><br><span class="line"></span><br><span class="line">3.7　习题</span><br><span class="line"></span><br><span class="line">3.8　文献注释</span><br><span class="line"></span><br><span class="line">第4章　数据仓库与联机分析处理</span><br><span class="line"></span><br><span class="line">4.1　数据仓库：基本概念</span><br><span class="line"></span><br><span class="line">4.1.1　什么是数据仓库</span><br><span class="line"></span><br><span class="line">4.1.2　操作数据库系统与数据仓库的区别</span><br><span class="line"></span><br><span class="line">4.1.3　为什么需要分离的数据仓库</span><br><span class="line"></span><br><span class="line">4.1.4　数据仓库：一种多层体系结构</span><br><span class="line"></span><br><span class="line">4.1.5　数据仓库模型：企业仓库、数据集市和虚拟仓库</span><br><span class="line"></span><br><span class="line">4.1.6　数据提取、变换和装入</span><br><span class="line"></span><br><span class="line">4.1.7　元数据库</span><br><span class="line"></span><br><span class="line">4.2　数据仓库建模：数据立方体与OLAP</span><br><span class="line"></span><br><span class="line">4.2.1　数据立方体：一种多维数据模型</span><br><span class="line"></span><br><span class="line">4.2.2　星形、雪花形和事实星座：多维数据模型的模式</span><br><span class="line"></span><br><span class="line">4.2.3　维：概念分层的作用</span><br><span class="line"></span><br><span class="line">4.2.4　度量的分类和计算</span><br><span class="line"></span><br><span class="line">4.2.5　典型的OLAP操作</span><br><span class="line"></span><br><span class="line">4.2.6　查询多维数据库的星网查询模型</span><br><span class="line"></span><br><span class="line">4.3　数据仓库的设计与使用</span><br><span class="line"></span><br><span class="line">4.3.1　数据仓库的设计的商务分析框架</span><br><span class="line"></span><br><span class="line">4.3.2　数据仓库的设计过程</span><br><span class="line"></span><br><span class="line">4.3.3　数据仓库用于信息处理</span><br><span class="line"></span><br><span class="line">4.3.4　从联机分析处理到多维数据挖掘</span><br><span class="line"></span><br><span class="line">4.4　数据仓库的实现</span><br><span class="line"></span><br><span class="line">4.4.1　数据立方体的有效计算：概述</span><br><span class="line"></span><br><span class="line">4.4.2　索引OLAP数据：位图索引和连接索引</span><br><span class="line"></span><br><span class="line">4.4.3　OLAP查询的有效处理</span><br><span class="line"></span><br><span class="line">4.4.4　OLAP服务器结构：ROLAP、MOLAP、HOLAP的比较</span><br><span class="line"></span><br><span class="line">4.5　数据泛化：面向属性的归纳</span><br><span class="line"></span><br><span class="line">4.5.1　数据特征的面向属性的归纳</span><br><span class="line"></span><br><span class="line">4.5.2　面向属性归纳的有效实现</span><br><span class="line"></span><br><span class="line">4.5.3　类比较的面向属性归纳</span><br><span class="line"></span><br><span class="line">4.6　小结</span><br><span class="line"></span><br><span class="line">4.7　习题</span><br><span class="line"></span><br><span class="line">4.8　文献注释</span><br><span class="line"></span><br><span class="line">第5章　数据立方体技术</span><br><span class="line"></span><br><span class="line">5.1　数据立方体计算：基本概念</span><br><span class="line"></span><br><span class="line">5.1.1　立方体物化：完全立方体、冰山立方体、闭立方体和立方体外壳</span><br><span class="line"></span><br><span class="line">5.1.2　数据立方体计算的一般策略</span><br><span class="line"></span><br><span class="line">5.2　数据立方体计算方法</span><br><span class="line"></span><br><span class="line">5.2.1　完全立方体计算的多路数组聚集</span><br><span class="line"></span><br><span class="line">5.2.2　BUC：从顶点方体向下计算冰山立方体</span><br><span class="line"></span><br><span class="line">5.2.3　Star-Cubing：使用动态星树结构计算冰山立方体</span><br><span class="line"></span><br><span class="line">5.2.4　为快速高维OLAP预计算壳片段</span><br><span class="line"></span><br><span class="line">5.3　使用探索立方体技术处理高级查询</span><br><span class="line"></span><br><span class="line">5.3.1　抽样立方体：样本数据上基于OLAP的挖掘</span><br><span class="line"></span><br><span class="line">5.3.2　排序立方体：top-k查询的有效计算</span><br><span class="line"></span><br><span class="line">5.4　数据立方体空间的多维数据分析</span><br><span class="line"></span><br><span class="line">5.4.1　预测立方体：立方体空间的预测挖掘</span><br><span class="line"></span><br><span class="line">5.4.2　多特征立方体：多粒度上的复杂聚集</span><br><span class="line"></span><br><span class="line">5.4.3　基于异常的、发现驱动的立方体空间探查</span><br><span class="line"></span><br><span class="line">5.5　小结</span><br><span class="line"></span><br><span class="line">5.6　习题</span><br><span class="line"></span><br><span class="line">5.7　文献注释</span><br><span class="line"></span><br><span class="line">第6章　挖掘频繁模式、关联和相关性：基本概念和方法</span><br><span class="line"></span><br><span class="line">6.1　基本概念</span><br><span class="line"></span><br><span class="line">6.1.1　购物篮分析：一个诱发例子</span><br><span class="line"></span><br><span class="line">6.1.2　频繁项集、闭项集和关联规则</span><br><span class="line"></span><br><span class="line">6.2　频繁项集挖掘方法</span><br><span class="line"></span><br><span class="line">6.2.1　Apriori算法：通过限制候选产生发现频繁项集</span><br><span class="line"></span><br><span class="line">6.2.2　由频繁项集产生关联规则</span><br><span class="line"></span><br><span class="line">6.2.3　提高Apriori算法的效率</span><br><span class="line"></span><br><span class="line">6.2.4　挖掘频繁项集的模式增长方法</span><br><span class="line"></span><br><span class="line">6.2.5　使用垂直数据格式挖掘频繁项集</span><br><span class="line"></span><br><span class="line">6.2.6　挖掘闭模式和极大模式</span><br><span class="line"></span><br><span class="line">6.3　哪些模式是有趣的：模式评估方法</span><br><span class="line"></span><br><span class="line">6.3.1　强规则不一定是有趣的</span><br><span class="line"></span><br><span class="line">6.3.2　从关联分析到相关分析</span><br><span class="line"></span><br><span class="line">6.3.3　模式评估度量比较</span><br><span class="line"></span><br><span class="line">6.4　小结</span><br><span class="line"></span><br><span class="line">6.5　习题</span><br><span class="line"></span><br><span class="line">6.6　文献注释</span><br><span class="line"></span><br><span class="line">第7章　高级模式挖掘</span><br><span class="line"></span><br><span class="line">7.1　模式挖掘：一个路线图</span><br><span class="line"></span><br><span class="line">7.2　多层、多维空间中的模式挖掘</span><br><span class="line"></span><br><span class="line">7.2.1　挖掘多层关联规则</span><br><span class="line"></span><br><span class="line">7.2.2　挖掘多维关联规则</span><br><span class="line"></span><br><span class="line">7.2.3　挖掘量化关联规则</span><br><span class="line"></span><br><span class="line">7.2.4　挖掘稀有模式和负模式</span><br><span class="line"></span><br><span class="line">7.3　基于约束的频繁模式挖掘</span><br><span class="line"></span><br><span class="line">7.3.1　关联规则的元规则制导挖掘</span><br><span class="line"></span><br><span class="line">7.3.2　基于约束的模式产生：模式空间剪枝和数据空间剪枝</span><br><span class="line"></span><br><span class="line">7.4　挖掘高维数据和巨型模式</span><br><span class="line"></span><br><span class="line">7.5　挖掘压缩或近似模式</span><br><span class="line"></span><br><span class="line">7.5.1　通过模式聚类挖掘压缩模式</span><br><span class="line"></span><br><span class="line">7.5.2　提取感知冗余的top-k模式</span><br><span class="line"></span><br><span class="line">7.6　模式探索与应用</span><br><span class="line"></span><br><span class="line">7.6.1　频繁模式的语义注解</span><br><span class="line"></span><br><span class="line">7.6.2　模式挖掘的应用</span><br><span class="line"></span><br><span class="line">7.7　小结</span><br><span class="line"></span><br><span class="line">7.8　习题</span><br><span class="line"></span><br><span class="line">7.9　文献注释</span><br><span class="line"></span><br><span class="line">第8章　分类：基本概念</span><br><span class="line"></span><br><span class="line">8.1　基本概念</span><br><span class="line"></span><br><span class="line">8.1.1　什么是分类</span><br><span class="line"></span><br><span class="line">8.1.2　分类的一般方法</span><br><span class="line"></span><br><span class="line">8.2　决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.1　决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.2　属性选择度量</span><br><span class="line"></span><br><span class="line">8.2.3　树剪枝</span><br><span class="line"></span><br><span class="line">8.2.4　可伸缩性与决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.5　决策树归纳的可视化挖掘</span><br><span class="line"></span><br><span class="line">8.3　贝叶斯分类方法</span><br><span class="line"></span><br><span class="line">8.3.1　贝叶斯定理</span><br><span class="line"></span><br><span class="line">8.3.2　朴素贝叶斯分类</span><br><span class="line"></span><br><span class="line">8.4　基于规则的分类</span><br><span class="line"></span><br><span class="line">8.4.1　使用IF-THEN规则分类</span><br><span class="line"></span><br><span class="line">8.4.2　由决策树提取规则</span><br><span class="line"></span><br><span class="line">8.4.3　使用顺序覆盖算法的规则归纳</span><br><span class="line"></span><br><span class="line">8.5　模型评估与选择</span><br><span class="line"></span><br><span class="line">8.5.1　评估分类器性能的度量</span><br><span class="line"></span><br><span class="line">8.5.2　保持方法和随机二次抽样</span><br><span class="line"></span><br><span class="line">8.5.3　交叉验证</span><br><span class="line"></span><br><span class="line">8.5.4　自助法</span><br><span class="line"></span><br><span class="line">8.5.5　使用统计显著性检验选择模型</span><br><span class="line"></span><br><span class="line">8.5.6　基于成本效益和ROC曲线比较分类器</span><br><span class="line"></span><br><span class="line">8.6　提高分类准确率的技术</span><br><span class="line"></span><br><span class="line">8.6.1　组合分类方法简介</span><br><span class="line"></span><br><span class="line">8.6.2　装袋</span><br><span class="line"></span><br><span class="line">8.6.3　提升和AdaBoost</span><br><span class="line"></span><br><span class="line">8.6.4　随机森林</span><br><span class="line"></span><br><span class="line">8.6.5　提高类不平衡数据的分类准确率</span><br><span class="line"></span><br><span class="line">8.7　小结</span><br><span class="line"></span><br><span class="line">8.8　习题</span><br><span class="line"></span><br><span class="line">8.9　文献注释</span><br><span class="line"></span><br><span class="line">第9章　分类：高级方法</span><br><span class="line"></span><br><span class="line">9.1　贝叶斯信念网络</span><br><span class="line"></span><br><span class="line">9.1.1　概念和机制</span><br><span class="line"></span><br><span class="line">9.1.2　训练贝叶斯信念网络</span><br><span class="line"></span><br><span class="line">9.2　用后向传播分类</span><br><span class="line"></span><br><span class="line">9.2.1　多层前馈神经网络</span><br><span class="line"></span><br><span class="line">9.2.2　定义网络拓扑</span><br><span class="line"></span><br><span class="line">9.2.3　后向传播</span><br><span class="line"></span><br><span class="line">9.2.4　黑盒内部：后向传播和可解释性</span><br><span class="line"></span><br><span class="line">9.3　支持向量机</span><br><span class="line"></span><br><span class="line">9.3.1　数据线性可分的情况</span><br><span class="line"></span><br><span class="line">9.3.2　数据非线性可分的情况</span><br><span class="line"></span><br><span class="line">9.4　使用频繁模式分类</span><br><span class="line"></span><br><span class="line">9.4.1　关联分类</span><br><span class="line"></span><br><span class="line">9.4.2　基于有区别力的频繁模式分类</span><br><span class="line"></span><br><span class="line">9.5　惰性学习法(或从近邻学习）</span><br><span class="line"></span><br><span class="line">9.5.1　k-最近邻分类</span><br><span class="line"></span><br><span class="line">9.5.2　基于案例的推理</span><br><span class="line"></span><br><span class="line">9.6　其他分类方法</span><br><span class="line"></span><br><span class="line">9.6.1　遗传算法</span><br><span class="line"></span><br><span class="line">9.6.2　粗糙集方法</span><br><span class="line"></span><br><span class="line">9.6.3　模糊集方法</span><br><span class="line"></span><br><span class="line">9.7　关于分类的其他问题</span><br><span class="line"></span><br><span class="line">9.7.1　多类分类</span><br><span class="line"></span><br><span class="line">9.7.2　半监督分类</span><br><span class="line"></span><br><span class="line">9.7.3　主动学习</span><br><span class="line"></span><br><span class="line">9.7.4　迁移学习</span><br><span class="line"></span><br><span class="line">9.8　小结</span><br><span class="line"></span><br><span class="line">9.9　习题</span><br><span class="line"></span><br><span class="line">9.10　文献注释</span><br><span class="line"></span><br><span class="line">第10章　聚类分析：基本概念和方法</span><br><span class="line"></span><br><span class="line">10.1　聚类分析</span><br><span class="line"></span><br><span class="line">10.1.1　什么是聚类分析</span><br><span class="line"></span><br><span class="line">10.1.2　对聚类分析的要求</span><br><span class="line"></span><br><span class="line">10.1.3　基本聚类方法概述</span><br><span class="line"></span><br><span class="line">10.2　划分方法</span><br><span class="line"></span><br><span class="line">10.2.1　k-均值：一种基于形心的技术</span><br><span class="line"></span><br><span class="line">10.2.2　k-中心点：一种基于代表对象的技术</span><br><span class="line"></span><br><span class="line">10.3　层次方法</span><br><span class="line"></span><br><span class="line">10.3.1　凝聚的与分裂的层次聚类</span><br><span class="line"></span><br><span class="line">10.3.2　算法方法的距离度量</span><br><span class="line"></span><br><span class="line">10.3.3　BIRCH：使用聚类特征树的多阶段聚类</span><br><span class="line"></span><br><span class="line">10.3.4　Chameleon：使用动态建模的多阶段层次聚类</span><br><span class="line"></span><br><span class="line">10.3.5　概率层次聚类</span><br><span class="line"></span><br><span class="line">10.4　基于密度的方法</span><br><span class="line"></span><br><span class="line">10.4.1　DBSCAN：一种基于高密度连通区域的基于密度的聚类</span><br><span class="line"></span><br><span class="line">10.4.2　OPTICS：通过点排序识别聚类结构</span><br><span class="line"></span><br><span class="line">10.4.3　DENCLUE：基于密度分布函数的聚类</span><br><span class="line"></span><br><span class="line">10.5　基于网格的方法</span><br><span class="line"></span><br><span class="line">10.5.1　STING：统计信息网格</span><br><span class="line"></span><br><span class="line">10.5.2　CLIQUE：一种类似于Apriori的子空间聚类方法</span><br><span class="line"></span><br><span class="line">10.6　聚类评估</span><br><span class="line"></span><br><span class="line">10.6.1　估计聚类趋势</span><br><span class="line"></span><br><span class="line">10.6.2　确定簇数</span><br><span class="line"></span><br><span class="line">10.6.3　测定聚类质量</span><br><span class="line"></span><br><span class="line">10.7　小结</span><br><span class="line"></span><br><span class="line">10.8　习题</span><br><span class="line"></span><br><span class="line">10.9　文献注释</span><br><span class="line"></span><br><span class="line">第11章　高级聚类分析</span><br><span class="line"></span><br><span class="line">11.1　基于概率模型的聚类</span><br><span class="line"></span><br><span class="line">11.1.1　模糊簇</span><br><span class="line"></span><br><span class="line">11.1.2　基于概率模型的聚类</span><br><span class="line"></span><br><span class="line">11.1.3　期望最大化算法</span><br><span class="line"></span><br><span class="line">11.2　聚类高维数据</span><br><span class="line"></span><br><span class="line">11.2.1　聚类高维数据：问题、挑战和主要方法</span><br><span class="line"></span><br><span class="line">11.2.2　子空间聚类方法</span><br><span class="line"></span><br><span class="line">11.2.3　双聚类</span><br><span class="line"></span><br><span class="line">11.2.4　维归约方法和谱聚类</span><br><span class="line"></span><br><span class="line">11.3　聚类图和网络数据</span><br><span class="line"></span><br><span class="line">11.3.1　应用与挑战</span><br><span class="line"></span><br><span class="line">11.3.2　相似性度量</span><br><span class="line"></span><br><span class="line">11.3.3　图聚类方法</span><br><span class="line"></span><br><span class="line">11.4　具有约束的聚类</span><br><span class="line"></span><br><span class="line">11.4.1　约束的分类</span><br><span class="line"></span><br><span class="line">11.4.2　具有约束的聚类方法</span><br><span class="line"></span><br><span class="line">11.5　小结</span><br><span class="line"></span><br><span class="line">11.6　习题</span><br><span class="line"></span><br><span class="line">11.7　文献注释</span><br><span class="line"></span><br><span class="line">第12章　离群点检测</span><br><span class="line"></span><br><span class="line">12.1　离群点和离群点分析</span><br><span class="line"></span><br><span class="line">12.1.1　什么是离群点</span><br><span class="line"></span><br><span class="line">12.1.2　离群点的类型</span><br><span class="line"></span><br><span class="line">12.1.3　离群点检测的挑战</span><br><span class="line"></span><br><span class="line">12.2　离群点检测方法</span><br><span class="line"></span><br><span class="line">12.2.1　监督、半监督和无监督方法</span><br><span class="line"></span><br><span class="line">12.2.2　统计方法、基于邻近性的方法和基于聚类的方法</span><br><span class="line"></span><br><span class="line">12.3　统计学方法</span><br><span class="line"></span><br><span class="line">12.3.1　参数方法</span><br><span class="line"></span><br><span class="line">12.3.2　非参数方法</span><br><span class="line"></span><br><span class="line">12.4　基于邻近性的方法</span><br><span class="line"></span><br><span class="line">12.4.1　基于距离的离群点检测和嵌套循环方法</span><br><span class="line"></span><br><span class="line">12.4.2　基于网格的方法</span><br><span class="line"></span><br><span class="line">12.4.3　基于密度的离群点检测</span><br><span class="line"></span><br><span class="line">12.5　基于聚类的方法</span><br><span class="line"></span><br><span class="line">12.6　基于分类的方法</span><br><span class="line"></span><br><span class="line">12.7　挖掘情境离群点和集体离群点</span><br><span class="line"></span><br><span class="line">12.7.1　把情境离群点检测转换成传统的离群点检测</span><br><span class="line"></span><br><span class="line">12.7.2　关于情境对正常行为建模</span><br><span class="line"></span><br><span class="line">12.7.3　挖掘集体离群点</span><br><span class="line"></span><br><span class="line">12.8　高维数据中的离群点检测</span><br><span class="line"></span><br><span class="line">12.8.1　扩充的传统离群点检测</span><br><span class="line"></span><br><span class="line">12.8.2　发现子空间中的离群点</span><br><span class="line"></span><br><span class="line">12.8.3　高维离群点建模</span><br><span class="line"></span><br><span class="line">12.9　小结</span><br><span class="line"></span><br><span class="line">12.10　习题</span><br><span class="line"></span><br><span class="line">12.11　文献注释</span><br><span class="line"></span><br><span class="line">第13章　数据挖掘的发展趋势和研究前沿</span><br><span class="line"></span><br><span class="line">13.1　挖掘复杂的数据类型</span><br><span class="line"></span><br><span class="line">13.1.1　挖掘序列数据：时间序列、符号序列和生物学序列</span><br><span class="line"></span><br><span class="line">13.1.2　挖掘图和网络</span><br><span class="line"></span><br><span class="line">13.1.3　挖掘其他类型的数据</span><br><span class="line"></span><br><span class="line">13.2　数据挖掘的其他方法</span><br><span class="line"></span><br><span class="line">13.2.1　统计学数据挖掘</span><br><span class="line"></span><br><span class="line">13.2.2　关于数据挖掘基础的观点</span><br><span class="line"></span><br><span class="line">13.2.3　可视和听觉数据挖掘</span><br><span class="line"></span><br><span class="line">13.3　数据挖掘应用</span><br><span class="line"></span><br><span class="line">13.3.1　金融数据分析的数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.2　零售和电信业的数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.3　科学与工程数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.4　入侵检测和预防数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.5　数据挖掘与推荐系统</span><br><span class="line"></span><br><span class="line">13.4　数据挖掘与社会</span><br><span class="line"></span><br><span class="line">13.4.1　普适的和无形的数据挖掘</span><br><span class="line"></span><br><span class="line">13.4.2　数据挖掘的隐私、安全和社会影响</span><br><span class="line"></span><br><span class="line">13.5　数据挖掘的发展趋势</span><br><span class="line"></span><br><span class="line">13.6　小结</span><br><span class="line"></span><br><span class="line">13.7　习题</span><br><span class="line"></span><br><span class="line">13.8　文献注释</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘-数据-模型-算法 PDF</title>
    <url>/posts/26d6ff4f/</url>
    <content><![CDATA[<h4 id="《数据挖掘-数据-模型-算法》"><a href="#《数据挖掘-数据-模型-算法》" class="headerlink" title="《数据挖掘-数据-模型-算法》"></a>《数据挖掘-数据-模型-算法》</h4><h6 id="链接-https-pan-baidu-com-s-1sUWIK-GlV1SOz9y5aXhtNg-提取码-iwde"><a href="#链接-https-pan-baidu-com-s-1sUWIK-GlV1SOz9y5aXhtNg-提取码-iwde" class="headerlink" title="链接: https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg 提取码: iwde"></a>链接: <a href="https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg">https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg</a> 提取码: iwde</h6><p>作为一本教科书，本书全面讲述了数据挖掘的概念、模型、方法和算法。本书共包括13章和2个附录，全面、详细地讲述了从数据挖掘的基本概念到数据挖掘的整个过程，以及数据挖掘工具及其典型应用领域。本书编写严谨、内容、结构合理、科学规范、语言流畅，特别适合作为高等院校数据挖掘课程的教科书，还适合作为数据挖掘研究人员的参考书。<br><a id="more"></a></p>
<p><img src="/images/f24cbf72de68a9024aba0600222718901.jpg" width="50%" height="50%"></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘概念与技术(中文版) PDF</title>
    <url>/posts/51d1cfd9/</url>
    <content><![CDATA[<h4 id="《数据挖掘概念与技术-中文版-》"><a href="#《数据挖掘概念与技术-中文版-》" class="headerlink" title="《数据挖掘概念与技术(中文版)》"></a>《数据挖掘概念与技术(中文版)》</h4><h6 id="链接-https-pan-baidu-com-s-1aN-UitC-loKtgtGWlNIKQ-提取码-44c4"><a href="#链接-https-pan-baidu-com-s-1aN-UitC-loKtgtGWlNIKQ-提取码-44c4" class="headerlink" title="链接: https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ 提取码: 44c4"></a>链接: <a href="https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ">https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ</a> 提取码: 44c4</h6><p>　　《数据挖掘：概念与技术（原书第3版）》完整全面地讲述数据挖掘的概念、方法、技术和全新研究进展。本书对前两版做了全面修订，加强和重新组织了全书的技术内容，重点论述了数据预处理、频繁模式挖掘、分类和聚类等的内容，还全面讲述了OLAP和离群点检测，并研讨了挖掘网络、复杂数据类型以及重要应用领域。<br><a id="more"></a></p>
<p>　　《数据挖掘：概念与技术（原书第3版）》是数据挖掘和知识发现领域内的所有教师、研究人员、开发人员和用户都必读的参考书，是一本适用于数据分析、数据挖掘和知识发现课程的优秀教材，可以用做高年级本科生或者一年级研究生的数据挖掘导论教材。</p>
<p><img src="/images/210e749788767721bd832b8addecca7f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">出版者的话</span><br><span class="line"></span><br><span class="line">中文版序</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">译者简介</span><br><span class="line"></span><br><span class="line">第3版序</span><br><span class="line"></span><br><span class="line">第2版序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">作者简介</span><br><span class="line"></span><br><span class="line">第1章　引论</span><br><span class="line"></span><br><span class="line">1.1　为什么进行数据挖掘</span><br><span class="line"></span><br><span class="line">1.1.1　迈向信息时代</span><br><span class="line"></span><br><span class="line">1.1.2　数据挖掘是信息技术的进化</span><br><span class="line"></span><br><span class="line">1.2　什么是数据挖掘</span><br><span class="line"></span><br><span class="line">1.3　可以挖掘什么类型的数据</span><br><span class="line"></span><br><span class="line">1.3.1　数据库数据</span><br><span class="line"></span><br><span class="line">1.3.2　数据仓库</span><br><span class="line"></span><br><span class="line">1.3.3　事务数据</span><br><span class="line"></span><br><span class="line">1.3.4　其他类型的数据</span><br><span class="line"></span><br><span class="line">1.4　可以挖掘什么类型的模式</span><br><span class="line"></span><br><span class="line">1.4.1　类&#x2F;概念描述：特征化与区分</span><br><span class="line"></span><br><span class="line">1.4.2　挖掘频繁模式、关联和相关性</span><br><span class="line"></span><br><span class="line">1.4.3　用于预测分析的分类与回归</span><br><span class="line"></span><br><span class="line">1.4.4　聚类分析</span><br><span class="line"></span><br><span class="line">1.4.5　离群点分析</span><br><span class="line"></span><br><span class="line">1.4.6　所有模式都是有趣的吗</span><br><span class="line"></span><br><span class="line">1.5　使用什么技术</span><br><span class="line"></span><br><span class="line">1.5.1　统计学</span><br><span class="line"></span><br><span class="line">1.5.2　机器学习</span><br><span class="line"></span><br><span class="line">1.5.3　数据库系统与数据仓库</span><br><span class="line"></span><br><span class="line">1.5.4　信息检索</span><br><span class="line"></span><br><span class="line">1.6　面向什么类型的应用</span><br><span class="line"></span><br><span class="line">1.6.1　商务智能</span><br><span class="line"></span><br><span class="line">1.6.2　Web搜索引擎</span><br><span class="line"></span><br><span class="line">1.7　数据挖掘的主要问题</span><br><span class="line"></span><br><span class="line">1.7.1　挖掘方法</span><br><span class="line"></span><br><span class="line">1.7.2　用户界面</span><br><span class="line"></span><br><span class="line">1.7.3　有效性和可伸缩性</span><br><span class="line"></span><br><span class="line">1.7.4　数据库类型的多样性</span><br><span class="line"></span><br><span class="line">1.7.5　数据挖掘与社会</span><br><span class="line"></span><br><span class="line">1.8　小结</span><br><span class="line"></span><br><span class="line">1.9　习题</span><br><span class="line"></span><br><span class="line">1.10　文献注释</span><br><span class="line"></span><br><span class="line">第2章　认识数据</span><br><span class="line"></span><br><span class="line">2.1　数据对象与属性类型</span><br><span class="line"></span><br><span class="line">2.1.1　什么是属性</span><br><span class="line"></span><br><span class="line">2.1.2　标称属性</span><br><span class="line"></span><br><span class="line">2.1.3　二元属性</span><br><span class="line"></span><br><span class="line">2.1.4　序数属性</span><br><span class="line"></span><br><span class="line">2.1.5　数值属性</span><br><span class="line"></span><br><span class="line">2.1.6　离散属性与连续属性</span><br><span class="line"></span><br><span class="line">2.2　数据的基本统计描述</span><br><span class="line"></span><br><span class="line">2.2.1　中心趋势度量：均值、中位数和众数</span><br><span class="line"></span><br><span class="line">2.2.2　度量数据散布：极差、四分位数、方差、标准差和四分位数极差</span><br><span class="line"></span><br><span class="line">2.2.3　数据的基本统计描述的图形显示</span><br><span class="line"></span><br><span class="line">2.3　数据可视化</span><br><span class="line"></span><br><span class="line">2.3.1　基于像素的可视化技术</span><br><span class="line"></span><br><span class="line">2.3.2　几何投影可视化技术</span><br><span class="line"></span><br><span class="line">2.3.3　基于图符的可视化技术</span><br><span class="line"></span><br><span class="line">2.3.4　层次可视化技术</span><br><span class="line"></span><br><span class="line">2.3.5　可视化复杂对象和关系</span><br><span class="line"></span><br><span class="line">2.4　度量数据的相似性和相异性</span><br><span class="line"></span><br><span class="line">2.4.1　数据矩阵与相异性矩阵</span><br><span class="line"></span><br><span class="line">2.4.2　标称属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.3　二元属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.4　数值属性的相异性：闵可夫斯基距离</span><br><span class="line"></span><br><span class="line">2.4.5　序数属性的邻近性度量</span><br><span class="line"></span><br><span class="line">2.4.6　混合类型属性的相异性</span><br><span class="line"></span><br><span class="line">2.4.7　余弦相似性</span><br><span class="line"></span><br><span class="line">2.5　小结</span><br><span class="line"></span><br><span class="line">2.6　习题</span><br><span class="line"></span><br><span class="line">2.7　文献注释</span><br><span class="line"></span><br><span class="line">第3章　数据预处理</span><br><span class="line"></span><br><span class="line">3.1　数据预处理：概述</span><br><span class="line"></span><br><span class="line">3.1.1　数据质量：为什么要对数据预处理</span><br><span class="line"></span><br><span class="line">3.1.2　数据预处理的主要任务</span><br><span class="line"></span><br><span class="line">3.2　数据清理</span><br><span class="line"></span><br><span class="line">3.2.1　缺失值</span><br><span class="line"></span><br><span class="line">3.2.2　噪声数据</span><br><span class="line"></span><br><span class="line">3.2.3　数据清理作为一个过程</span><br><span class="line"></span><br><span class="line">3.3　数据集成</span><br><span class="line"></span><br><span class="line">3.3.1　实体识别问题</span><br><span class="line"></span><br><span class="line">3.3.2　冗余和相关分析</span><br><span class="line"></span><br><span class="line">3.3.3　元组重复</span><br><span class="line"></span><br><span class="line">3.3.4　数据值冲突的检测与处理</span><br><span class="line"></span><br><span class="line">3.4　数据归约</span><br><span class="line"></span><br><span class="line">3.4.1　数据归约策略概述</span><br><span class="line"></span><br><span class="line">3.4.2　小波变换</span><br><span class="line"></span><br><span class="line">3.4.3　主成分分析</span><br><span class="line"></span><br><span class="line">3.4.4　属性子集选择</span><br><span class="line"></span><br><span class="line">3.4.5　回归和对数线性模型：参数化数据归约</span><br><span class="line"></span><br><span class="line">3.4.6　直方图</span><br><span class="line"></span><br><span class="line">3.4.7　聚类</span><br><span class="line"></span><br><span class="line">3.4.8　抽样</span><br><span class="line"></span><br><span class="line">3.4.9　数据立方体聚集</span><br><span class="line"></span><br><span class="line">3.5　数据变换与数据离散化</span><br><span class="line"></span><br><span class="line">3.5.1　数据变换策略概述</span><br><span class="line"></span><br><span class="line">3.5.2　通过规范化变换数据</span><br><span class="line"></span><br><span class="line">3.5.3　通过分箱离散化</span><br><span class="line"></span><br><span class="line">3.5.4　通过直方图分析离散化</span><br><span class="line"></span><br><span class="line">3.5.5　通过聚类、决策树和相关分析离散化</span><br><span class="line"></span><br><span class="line">3.5.6　标称数据的概念分层产生</span><br><span class="line"></span><br><span class="line">3.6　小结</span><br><span class="line"></span><br><span class="line">3.7　习题</span><br><span class="line"></span><br><span class="line">3.8　文献注释</span><br><span class="line"></span><br><span class="line">第4章　数据仓库与联机分析处理</span><br><span class="line"></span><br><span class="line">4.1　数据仓库：基本概念</span><br><span class="line"></span><br><span class="line">4.1.1　什么是数据仓库</span><br><span class="line"></span><br><span class="line">4.1.2　操作数据库系统与数据仓库的区别</span><br><span class="line"></span><br><span class="line">4.1.3　为什么需要分离的数据仓库</span><br><span class="line"></span><br><span class="line">4.1.4　数据仓库：一种多层体系结构</span><br><span class="line"></span><br><span class="line">4.1.5　数据仓库模型：企业仓库、数据集市和虚拟仓库</span><br><span class="line"></span><br><span class="line">4.1.6　数据提取、变换和装入</span><br><span class="line"></span><br><span class="line">4.1.7　元数据库</span><br><span class="line"></span><br><span class="line">4.2　数据仓库建模：数据立方体与OLAP</span><br><span class="line"></span><br><span class="line">4.2.1　数据立方体：一种多维数据模型</span><br><span class="line"></span><br><span class="line">4.2.2　星形、雪花形和事实星座：多维数据模型的模式</span><br><span class="line"></span><br><span class="line">4.2.3　维：概念分层的作用</span><br><span class="line"></span><br><span class="line">4.2.4　度量的分类和计算</span><br><span class="line"></span><br><span class="line">4.2.5　典型的OLAP操作</span><br><span class="line"></span><br><span class="line">4.2.6　查询多维数据库的星网查询模型</span><br><span class="line"></span><br><span class="line">4.3　数据仓库的设计与使用</span><br><span class="line"></span><br><span class="line">4.3.1　数据仓库的设计的商务分析框架</span><br><span class="line"></span><br><span class="line">4.3.2　数据仓库的设计过程</span><br><span class="line"></span><br><span class="line">4.3.3　数据仓库用于信息处理</span><br><span class="line"></span><br><span class="line">4.3.4　从联机分析处理到多维数据挖掘</span><br><span class="line"></span><br><span class="line">4.4　数据仓库的实现</span><br><span class="line"></span><br><span class="line">4.4.1　数据立方体的有效计算：概述</span><br><span class="line"></span><br><span class="line">4.4.2　索引OLAP数据：位图索引和连接索引</span><br><span class="line"></span><br><span class="line">4.4.3　OLAP查询的有效处理</span><br><span class="line"></span><br><span class="line">4.4.4　OLAP服务器结构：ROLAP、MOLAP、HOLAP的比较</span><br><span class="line"></span><br><span class="line">4.5　数据泛化：面向属性的归纳</span><br><span class="line"></span><br><span class="line">4.5.1　数据特征的面向属性的归纳</span><br><span class="line"></span><br><span class="line">4.5.2　面向属性归纳的有效实现</span><br><span class="line"></span><br><span class="line">4.5.3　类比较的面向属性归纳</span><br><span class="line"></span><br><span class="line">4.6　小结</span><br><span class="line"></span><br><span class="line">4.7　习题</span><br><span class="line"></span><br><span class="line">4.8　文献注释</span><br><span class="line"></span><br><span class="line">第5章　数据立方体技术</span><br><span class="line"></span><br><span class="line">5.1　数据立方体计算：基本概念</span><br><span class="line"></span><br><span class="line">5.1.1　立方体物化：完全立方体、冰山立方体、闭立方体和立方体外壳</span><br><span class="line"></span><br><span class="line">5.1.2　数据立方体计算的一般策略</span><br><span class="line"></span><br><span class="line">5.2　数据立方体计算方法</span><br><span class="line"></span><br><span class="line">5.2.1　完全立方体计算的多路数组聚集</span><br><span class="line"></span><br><span class="line">5.2.2　BUC：从顶点方体向下计算冰山立方体</span><br><span class="line"></span><br><span class="line">5.2.3　Star-Cubing：使用动态星树结构计算冰山立方体</span><br><span class="line"></span><br><span class="line">5.2.4　为快速高维OLAP预计算壳片段</span><br><span class="line"></span><br><span class="line">5.3　使用探索立方体技术处理高级查询</span><br><span class="line"></span><br><span class="line">5.3.1　抽样立方体：样本数据上基于OLAP的挖掘</span><br><span class="line"></span><br><span class="line">5.3.2　排序立方体：top-k查询的有效计算</span><br><span class="line"></span><br><span class="line">5.4　数据立方体空间的多维数据分析</span><br><span class="line"></span><br><span class="line">5.4.1　预测立方体：立方体空间的预测挖掘</span><br><span class="line"></span><br><span class="line">5.4.2　多特征立方体：多粒度上的复杂聚集</span><br><span class="line"></span><br><span class="line">5.4.3　基于异常的、发现驱动的立方体空间探查</span><br><span class="line"></span><br><span class="line">5.5　小结</span><br><span class="line"></span><br><span class="line">5.6　习题</span><br><span class="line"></span><br><span class="line">5.7　文献注释</span><br><span class="line"></span><br><span class="line">第6章　挖掘频繁模式、关联和相关性：基本概念和方法</span><br><span class="line"></span><br><span class="line">6.1　基本概念</span><br><span class="line"></span><br><span class="line">6.1.1　购物篮分析：一个诱发例子</span><br><span class="line"></span><br><span class="line">6.1.2　频繁项集、闭项集和关联规则</span><br><span class="line"></span><br><span class="line">6.2　频繁项集挖掘方法</span><br><span class="line"></span><br><span class="line">6.2.1　Apriori算法：通过限制候选产生发现频繁项集</span><br><span class="line"></span><br><span class="line">6.2.2　由频繁项集产生关联规则</span><br><span class="line"></span><br><span class="line">6.2.3　提高Apriori算法的效率</span><br><span class="line"></span><br><span class="line">6.2.4　挖掘频繁项集的模式增长方法</span><br><span class="line"></span><br><span class="line">6.2.5　使用垂直数据格式挖掘频繁项集</span><br><span class="line"></span><br><span class="line">6.2.6　挖掘闭模式和极大模式</span><br><span class="line"></span><br><span class="line">6.3　哪些模式是有趣的：模式评估方法</span><br><span class="line"></span><br><span class="line">6.3.1　强规则不一定是有趣的</span><br><span class="line"></span><br><span class="line">6.3.2　从关联分析到相关分析</span><br><span class="line"></span><br><span class="line">6.3.3　模式评估度量比较</span><br><span class="line"></span><br><span class="line">6.4　小结</span><br><span class="line"></span><br><span class="line">6.5　习题</span><br><span class="line"></span><br><span class="line">6.6　文献注释</span><br><span class="line"></span><br><span class="line">第7章　高级模式挖掘</span><br><span class="line"></span><br><span class="line">7.1　模式挖掘：一个路线图</span><br><span class="line"></span><br><span class="line">7.2　多层、多维空间中的模式挖掘</span><br><span class="line"></span><br><span class="line">7.2.1　挖掘多层关联规则</span><br><span class="line"></span><br><span class="line">7.2.2　挖掘多维关联规则</span><br><span class="line"></span><br><span class="line">7.2.3　挖掘量化关联规则</span><br><span class="line"></span><br><span class="line">7.2.4　挖掘稀有模式和负模式</span><br><span class="line"></span><br><span class="line">7.3　基于约束的频繁模式挖掘</span><br><span class="line"></span><br><span class="line">7.3.1　关联规则的元规则制导挖掘</span><br><span class="line"></span><br><span class="line">7.3.2　基于约束的模式产生：模式空间剪枝和数据空间剪枝</span><br><span class="line"></span><br><span class="line">7.4　挖掘高维数据和巨型模式</span><br><span class="line"></span><br><span class="line">7.5　挖掘压缩或近似模式</span><br><span class="line"></span><br><span class="line">7.5.1　通过模式聚类挖掘压缩模式</span><br><span class="line"></span><br><span class="line">7.5.2　提取感知冗余的top-k模式</span><br><span class="line"></span><br><span class="line">7.6　模式探索与应用</span><br><span class="line"></span><br><span class="line">7.6.1　频繁模式的语义注解</span><br><span class="line"></span><br><span class="line">7.6.2　模式挖掘的应用</span><br><span class="line"></span><br><span class="line">7.7　小结</span><br><span class="line"></span><br><span class="line">7.8　习题</span><br><span class="line"></span><br><span class="line">7.9　文献注释</span><br><span class="line"></span><br><span class="line">第8章　分类：基本概念</span><br><span class="line"></span><br><span class="line">8.1　基本概念</span><br><span class="line"></span><br><span class="line">8.1.1　什么是分类</span><br><span class="line"></span><br><span class="line">8.1.2　分类的一般方法</span><br><span class="line"></span><br><span class="line">8.2　决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.1　决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.2　属性选择度量</span><br><span class="line"></span><br><span class="line">8.2.3　树剪枝</span><br><span class="line"></span><br><span class="line">8.2.4　可伸缩性与决策树归纳</span><br><span class="line"></span><br><span class="line">8.2.5　决策树归纳的可视化挖掘</span><br><span class="line"></span><br><span class="line">8.3　贝叶斯分类方法</span><br><span class="line"></span><br><span class="line">8.3.1　贝叶斯定理</span><br><span class="line"></span><br><span class="line">8.3.2　朴素贝叶斯分类</span><br><span class="line"></span><br><span class="line">8.4　基于规则的分类</span><br><span class="line"></span><br><span class="line">8.4.1　使用IF-THEN规则分类</span><br><span class="line"></span><br><span class="line">8.4.2　由决策树提取规则</span><br><span class="line"></span><br><span class="line">8.4.3　使用顺序覆盖算法的规则归纳</span><br><span class="line"></span><br><span class="line">8.5　模型评估与选择</span><br><span class="line"></span><br><span class="line">8.5.1　评估分类器性能的度量</span><br><span class="line"></span><br><span class="line">8.5.2　保持方法和随机二次抽样</span><br><span class="line"></span><br><span class="line">8.5.3　交叉验证</span><br><span class="line"></span><br><span class="line">8.5.4　自助法</span><br><span class="line"></span><br><span class="line">8.5.5　使用统计显著性检验选择模型</span><br><span class="line"></span><br><span class="line">8.5.6　基于成本效益和ROC曲线比较分类器</span><br><span class="line"></span><br><span class="line">8.6　提高分类准确率的技术</span><br><span class="line"></span><br><span class="line">8.6.1　组合分类方法简介</span><br><span class="line"></span><br><span class="line">8.6.2　装袋</span><br><span class="line"></span><br><span class="line">8.6.3　提升和AdaBoost</span><br><span class="line"></span><br><span class="line">8.6.4　随机森林</span><br><span class="line"></span><br><span class="line">8.6.5　提高类不平衡数据的分类准确率</span><br><span class="line"></span><br><span class="line">8.7　小结</span><br><span class="line"></span><br><span class="line">8.8　习题</span><br><span class="line"></span><br><span class="line">8.9　文献注释</span><br><span class="line"></span><br><span class="line">第9章　分类：高级方法</span><br><span class="line"></span><br><span class="line">9.1　贝叶斯信念网络</span><br><span class="line"></span><br><span class="line">9.1.1　概念和机制</span><br><span class="line"></span><br><span class="line">9.1.2　训练贝叶斯信念网络</span><br><span class="line"></span><br><span class="line">9.2　用后向传播分类</span><br><span class="line"></span><br><span class="line">9.2.1　多层前馈神经网络</span><br><span class="line"></span><br><span class="line">9.2.2　定义网络拓扑</span><br><span class="line"></span><br><span class="line">9.2.3　后向传播</span><br><span class="line"></span><br><span class="line">9.2.4　黑盒内部：后向传播和可解释性</span><br><span class="line"></span><br><span class="line">9.3　支持向量机</span><br><span class="line"></span><br><span class="line">9.3.1　数据线性可分的情况</span><br><span class="line"></span><br><span class="line">9.3.2　数据非线性可分的情况</span><br><span class="line"></span><br><span class="line">9.4　使用频繁模式分类</span><br><span class="line"></span><br><span class="line">9.4.1　关联分类</span><br><span class="line"></span><br><span class="line">9.4.2　基于有区别力的频繁模式分类</span><br><span class="line"></span><br><span class="line">9.5　惰性学习法(或从近邻学习）</span><br><span class="line"></span><br><span class="line">9.5.1　k-最近邻分类</span><br><span class="line"></span><br><span class="line">9.5.2　基于案例的推理</span><br><span class="line"></span><br><span class="line">9.6　其他分类方法</span><br><span class="line"></span><br><span class="line">9.6.1　遗传算法</span><br><span class="line"></span><br><span class="line">9.6.2　粗糙集方法</span><br><span class="line"></span><br><span class="line">9.6.3　模糊集方法</span><br><span class="line"></span><br><span class="line">9.7　关于分类的其他问题</span><br><span class="line"></span><br><span class="line">9.7.1　多类分类</span><br><span class="line"></span><br><span class="line">9.7.2　半监督分类</span><br><span class="line"></span><br><span class="line">9.7.3　主动学习</span><br><span class="line"></span><br><span class="line">9.7.4　迁移学习</span><br><span class="line"></span><br><span class="line">9.8　小结</span><br><span class="line"></span><br><span class="line">9.9　习题</span><br><span class="line"></span><br><span class="line">9.10　文献注释</span><br><span class="line"></span><br><span class="line">第10章　聚类分析：基本概念和方法</span><br><span class="line"></span><br><span class="line">10.1　聚类分析</span><br><span class="line"></span><br><span class="line">10.1.1　什么是聚类分析</span><br><span class="line"></span><br><span class="line">10.1.2　对聚类分析的要求</span><br><span class="line"></span><br><span class="line">10.1.3　基本聚类方法概述</span><br><span class="line"></span><br><span class="line">10.2　划分方法</span><br><span class="line"></span><br><span class="line">10.2.1　k-均值：一种基于形心的技术</span><br><span class="line"></span><br><span class="line">10.2.2　k-中心点：一种基于代表对象的技术</span><br><span class="line"></span><br><span class="line">10.3　层次方法</span><br><span class="line"></span><br><span class="line">10.3.1　凝聚的与分裂的层次聚类</span><br><span class="line"></span><br><span class="line">10.3.2　算法方法的距离度量</span><br><span class="line"></span><br><span class="line">10.3.3　BIRCH：使用聚类特征树的多阶段聚类</span><br><span class="line"></span><br><span class="line">10.3.4　Chameleon：使用动态建模的多阶段层次聚类</span><br><span class="line"></span><br><span class="line">10.3.5　概率层次聚类</span><br><span class="line"></span><br><span class="line">10.4　基于密度的方法</span><br><span class="line"></span><br><span class="line">10.4.1　DBSCAN：一种基于高密度连通区域的基于密度的聚类</span><br><span class="line"></span><br><span class="line">10.4.2　OPTICS：通过点排序识别聚类结构</span><br><span class="line"></span><br><span class="line">10.4.3　DENCLUE：基于密度分布函数的聚类</span><br><span class="line"></span><br><span class="line">10.5　基于网格的方法</span><br><span class="line"></span><br><span class="line">10.5.1　STING：统计信息网格</span><br><span class="line"></span><br><span class="line">10.5.2　CLIQUE：一种类似于Apriori的子空间聚类方法</span><br><span class="line"></span><br><span class="line">10.6　聚类评估</span><br><span class="line"></span><br><span class="line">10.6.1　估计聚类趋势</span><br><span class="line"></span><br><span class="line">10.6.2　确定簇数</span><br><span class="line"></span><br><span class="line">10.6.3　测定聚类质量</span><br><span class="line"></span><br><span class="line">10.7　小结</span><br><span class="line"></span><br><span class="line">10.8　习题</span><br><span class="line"></span><br><span class="line">10.9　文献注释</span><br><span class="line"></span><br><span class="line">第11章　高级聚类分析</span><br><span class="line"></span><br><span class="line">11.1　基于概率模型的聚类</span><br><span class="line"></span><br><span class="line">11.1.1　模糊簇</span><br><span class="line"></span><br><span class="line">11.1.2　基于概率模型的聚类</span><br><span class="line"></span><br><span class="line">11.1.3　期望最大化算法</span><br><span class="line"></span><br><span class="line">11.2　聚类高维数据</span><br><span class="line"></span><br><span class="line">11.2.1　聚类高维数据：问题、挑战和主要方法</span><br><span class="line"></span><br><span class="line">11.2.2　子空间聚类方法</span><br><span class="line"></span><br><span class="line">11.2.3　双聚类</span><br><span class="line"></span><br><span class="line">11.2.4　维归约方法和谱聚类</span><br><span class="line"></span><br><span class="line">11.3　聚类图和网络数据</span><br><span class="line"></span><br><span class="line">11.3.1　应用与挑战</span><br><span class="line"></span><br><span class="line">11.3.2　相似性度量</span><br><span class="line"></span><br><span class="line">11.3.3　图聚类方法</span><br><span class="line"></span><br><span class="line">11.4　具有约束的聚类</span><br><span class="line"></span><br><span class="line">11.4.1　约束的分类</span><br><span class="line"></span><br><span class="line">11.4.2　具有约束的聚类方法</span><br><span class="line"></span><br><span class="line">11.5　小结</span><br><span class="line"></span><br><span class="line">11.6　习题</span><br><span class="line"></span><br><span class="line">11.7　文献注释</span><br><span class="line"></span><br><span class="line">第12章　离群点检测</span><br><span class="line"></span><br><span class="line">12.1　离群点和离群点分析</span><br><span class="line"></span><br><span class="line">12.1.1　什么是离群点</span><br><span class="line"></span><br><span class="line">12.1.2　离群点的类型</span><br><span class="line"></span><br><span class="line">12.1.3　离群点检测的挑战</span><br><span class="line"></span><br><span class="line">12.2　离群点检测方法</span><br><span class="line"></span><br><span class="line">12.2.1　监督、半监督和无监督方法</span><br><span class="line"></span><br><span class="line">12.2.2　统计方法、基于邻近性的方法和基于聚类的方法</span><br><span class="line"></span><br><span class="line">12.3　统计学方法</span><br><span class="line"></span><br><span class="line">12.3.1　参数方法</span><br><span class="line"></span><br><span class="line">12.3.2　非参数方法</span><br><span class="line"></span><br><span class="line">12.4　基于邻近性的方法</span><br><span class="line"></span><br><span class="line">12.4.1　基于距离的离群点检测和嵌套循环方法</span><br><span class="line"></span><br><span class="line">12.4.2　基于网格的方法</span><br><span class="line"></span><br><span class="line">12.4.3　基于密度的离群点检测</span><br><span class="line"></span><br><span class="line">12.5　基于聚类的方法</span><br><span class="line"></span><br><span class="line">12.6　基于分类的方法</span><br><span class="line"></span><br><span class="line">12.7　挖掘情境离群点和集体离群点</span><br><span class="line"></span><br><span class="line">12.7.1　把情境离群点检测转换成传统的离群点检测</span><br><span class="line"></span><br><span class="line">12.7.2　关于情境对正常行为建模</span><br><span class="line"></span><br><span class="line">12.7.3　挖掘集体离群点</span><br><span class="line"></span><br><span class="line">12.8　高维数据中的离群点检测</span><br><span class="line"></span><br><span class="line">12.8.1　扩充的传统离群点检测</span><br><span class="line"></span><br><span class="line">12.8.2　发现子空间中的离群点</span><br><span class="line"></span><br><span class="line">12.8.3　高维离群点建模</span><br><span class="line"></span><br><span class="line">12.9　小结</span><br><span class="line"></span><br><span class="line">12.10　习题</span><br><span class="line"></span><br><span class="line">12.11　文献注释</span><br><span class="line"></span><br><span class="line">第13章　数据挖掘的发展趋势和研究前沿</span><br><span class="line"></span><br><span class="line">13.1　挖掘复杂的数据类型</span><br><span class="line"></span><br><span class="line">13.1.1　挖掘序列数据：时间序列、符号序列和生物学序列</span><br><span class="line"></span><br><span class="line">13.1.2　挖掘图和网络</span><br><span class="line"></span><br><span class="line">13.1.3　挖掘其他类型的数据</span><br><span class="line"></span><br><span class="line">13.2　数据挖掘的其他方法</span><br><span class="line"></span><br><span class="line">13.2.1　统计学数据挖掘</span><br><span class="line"></span><br><span class="line">13.2.2　关于数据挖掘基础的观点</span><br><span class="line"></span><br><span class="line">13.2.3　可视和听觉数据挖掘</span><br><span class="line"></span><br><span class="line">13.3　数据挖掘应用</span><br><span class="line"></span><br><span class="line">13.3.1　金融数据分析的数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.2　零售和电信业的数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.3　科学与工程数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.4　入侵检测和预防数据挖掘</span><br><span class="line"></span><br><span class="line">13.3.5　数据挖掘与推荐系统</span><br><span class="line"></span><br><span class="line">13.4　数据挖掘与社会</span><br><span class="line"></span><br><span class="line">13.4.1　普适的和无形的数据挖掘</span><br><span class="line"></span><br><span class="line">13.4.2　数据挖掘的隐私、安全和社会影响</span><br><span class="line"></span><br><span class="line">13.5　数据挖掘的发展趋势</span><br><span class="line"></span><br><span class="line">13.6　小结</span><br><span class="line"></span><br><span class="line">13.7　习题</span><br><span class="line"></span><br><span class="line">13.8　文献注释</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数据挖掘实用案例分析 PDF</title>
    <url>/posts/32024be/</url>
    <content><![CDATA[<h4 id="《数据挖掘实用案例分析》"><a href="#《数据挖掘实用案例分析》" class="headerlink" title="《数据挖掘实用案例分析》"></a>《数据挖掘实用案例分析》</h4><h6 id="链接-https-pan-baidu-com-s-1eEtpfuMhsyKoiu9gJn2yRQ-提取码-d6fx"><a href="#链接-https-pan-baidu-com-s-1eEtpfuMhsyKoiu9gJn2yRQ-提取码-d6fx" class="headerlink" title="链接: https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ 提取码: d6fx"></a>链接: <a href="https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ">https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ</a> 提取码: d6fx</h6><p>数据挖掘已经广泛应用于各行各业,并催生了数据分析师的兴起。本书结合项目实践，首先对数据挖掘的核心问题进行了总结，并以保险推荐为例说明数据挖掘过程中每个步骤需要关注之处； 然后，结合香水销售分析，讨论可视化图形的基本应用。为增强本书的实用性，提高读者的动手能力，后续章节详细地分析了数据挖掘在银行信用卡、餐饮、商务酒店、制造业、公安等领域的应用。此外，本书还介绍了卷积神经网络在音频数据处理方面的实际应用。<br><a id="more"></a></p>
<p>本书内容深入浅出，案例生动形象，可以作为高校相关专业“数据挖掘”“机器学习”“商务数据分析”等课程的实验教材，也可以供学习数据分析的社会人士参考。</p>
<p><img src="/images/37b29bee247a10ac31ac59dcc418dab01.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章数据分析过程的主要问题</span><br><span class="line"></span><br><span class="line">1.1业务理解</span><br><span class="line"></span><br><span class="line">1.2数据理解</span><br><span class="line"></span><br><span class="line">1.3数据质量问题与预处理</span><br><span class="line"></span><br><span class="line">1.4数据分析常见陷阱</span><br><span class="line"></span><br><span class="line">1.5数据分析方法的选择</span><br><span class="line"></span><br><span class="line">1.5.1分类算法</span><br><span class="line"></span><br><span class="line">1.5.2聚类算法</span><br><span class="line"></span><br><span class="line">1.5.3关联分析</span><br><span class="line"></span><br><span class="line">1.5.4回归分析</span><br><span class="line"></span><br><span class="line">1.5.5深度学习</span><br><span class="line"></span><br><span class="line">1.5.6统计方法</span><br><span class="line"></span><br><span class="line">1.6数据分析结果的评价</span><br><span class="line"></span><br><span class="line">1.6.1分类算法的评价</span><br><span class="line"></span><br><span class="line">1.6.2聚类结果的评价</span><br><span class="line"></span><br><span class="line">1.6.3关联分析的评价</span><br><span class="line"></span><br><span class="line">1.6.4回归分析结果的评价</span><br><span class="line"></span><br><span class="line">1.6.5深度学习的评价</span><br><span class="line"></span><br><span class="line">1.7数据分析团队的组建</span><br><span class="line"></span><br><span class="line">1.7.1项目经理</span><br><span class="line"></span><br><span class="line">1.7.2业务专家</span><br><span class="line"></span><br><span class="line">1.7.3数据工程师</span><br><span class="line"></span><br><span class="line">1.7.4数据建模人员</span><br><span class="line"></span><br><span class="line">1.7.5可视化人员</span><br><span class="line"></span><br><span class="line">1.7.6评估人员</span><br><span class="line"></span><br><span class="line">1.8数据分析人才培养的难题</span><br><span class="line"></span><br><span class="line">1.8.1数理要求高</span><br><span class="line"></span><br><span class="line">1.8.2跨学科综合能力</span><br><span class="line"></span><br><span class="line">1.8.3国内技术资料少</span><br><span class="line"></span><br><span class="line">1.8.4实践机会少</span><br><span class="line"></span><br><span class="line">第2章数据挖掘算法的选择——保险产品推荐</span><br><span class="line"></span><br><span class="line">2.1业务理解</span><br><span class="line"></span><br><span class="line">2.2数据分析目标</span><br><span class="line"></span><br><span class="line">2.3数据探索</span><br><span class="line"></span><br><span class="line">2.3.1数据质量评估</span><br><span class="line"></span><br><span class="line">2.3.2探索数据统计特性</span><br><span class="line"></span><br><span class="line">2.3.3数据降维</span><br><span class="line"></span><br><span class="line">2.4模型选择过程</span><br><span class="line"></span><br><span class="line">2.4.1算法初选</span><br><span class="line"></span><br><span class="line">2.4.2算法验证</span><br><span class="line"></span><br><span class="line">2.4.3算法优化</span><br><span class="line"></span><br><span class="line">2.4.4平衡数据集</span><br><span class="line"></span><br><span class="line">2.4.5修改模型参数</span><br><span class="line"></span><br><span class="line">2.5总结</span><br><span class="line"></span><br><span class="line">第3章常用可视化的多维分析</span><br><span class="line"></span><br><span class="line">3.1箱图</span><br><span class="line"></span><br><span class="line">3.2雷达图</span><br><span class="line"></span><br><span class="line">3.3标签云</span><br><span class="line"></span><br><span class="line">3.4气泡图</span><br><span class="line"></span><br><span class="line">3.5树图</span><br><span class="line"></span><br><span class="line">3.6地图</span><br><span class="line"></span><br><span class="line">3.7高低图</span><br><span class="line"></span><br><span class="line">3.8双轴图</span><br><span class="line"></span><br><span class="line">3.9关系图</span><br><span class="line"></span><br><span class="line">3.10热图</span><br><span class="line"></span><br><span class="line">第4章SPSSModeler建模组件介绍</span><br><span class="line"></span><br><span class="line">4.1数据预处理组件</span><br><span class="line"></span><br><span class="line">4.1.1数据清理组件</span><br><span class="line"></span><br><span class="line">4.1.2数据集成组件</span><br><span class="line"></span><br><span class="line">4.1.3数据选择组件</span><br><span class="line"></span><br><span class="line">4.1.4数据变换组件</span><br><span class="line"></span><br><span class="line">4.2数据挖掘建模组件</span><br><span class="line"></span><br><span class="line">4.2.1模型筛选</span><br><span class="line"></span><br><span class="line">4.2.2自动建模</span><br><span class="line"></span><br><span class="line">4.2.3决策树模型</span><br><span class="line"></span><br><span class="line">4.2.4贝叶斯网络模型</span><br><span class="line"></span><br><span class="line">4.2.5神经网络模型</span><br><span class="line"></span><br><span class="line">4.2.6支持向量机模型</span><br><span class="line"></span><br><span class="line">4.2.7时间序列模型</span><br><span class="line"></span><br><span class="line">4.2.8统计模型</span><br><span class="line"></span><br><span class="line">4.2.9聚类模型</span><br><span class="line"></span><br><span class="line">4.2.10关联分析</span><br><span class="line"></span><br><span class="line">4.2.11KNN模型</span><br><span class="line"></span><br><span class="line">4.2.12数据挖掘模式评估</span><br><span class="line"></span><br><span class="line">4.3知识表示</span><br><span class="line"></span><br><span class="line">4.3.1图形节点</span><br><span class="line"></span><br><span class="line">4.3.2数据输出</span><br><span class="line"></span><br><span class="line">4.3.3数据导出</span><br><span class="line"></span><br><span class="line">第5章香水销售分析</span><br><span class="line"></span><br><span class="line">5.1香水销售数据预处理</span><br><span class="line"></span><br><span class="line">5.2香水销售数据统计分析</span><br><span class="line"></span><br><span class="line">5.3影响香水销量的因素分析</span><br><span class="line"></span><br><span class="line">5.4香水适用场所关联分析</span><br><span class="line"></span><br><span class="line">5.5香水聚类分析</span><br><span class="line"></span><br><span class="line">5.6香水营销建议</span><br><span class="line"></span><br><span class="line">第6章银行信用卡欺诈与拖欠行为分析</span><br><span class="line"></span><br><span class="line">6.1客户信用等级影响因素</span><br><span class="line"></span><br><span class="line">6.1.1客户信用卡申请数据预处理</span><br><span class="line"></span><br><span class="line">6.1.2信用卡申请成功影响因素</span><br><span class="line"></span><br><span class="line">6.2信用卡客户信用等级影响因素</span><br><span class="line"></span><br><span class="line">6.3基于消费的信用等级影响因素</span><br><span class="line"></span><br><span class="line">6.4信用卡欺诈判断模型</span><br><span class="line"></span><br><span class="line">6.4.1基于Apriori算法的欺诈模型</span><br><span class="line"></span><br><span class="line">6.4.2基于判别的欺诈模型</span><br><span class="line"></span><br><span class="line">6.4.3基于分类算法的欺诈模型</span><br><span class="line"></span><br><span class="line">6.5欺诈人口属性分析</span><br><span class="line"></span><br><span class="line">6.5.1欺诈人口属性统计分析</span><br><span class="line"></span><br><span class="line">6.5.2基于逻辑回归的欺诈人口属性分析</span><br><span class="line"></span><br><span class="line">6.5.3逾期还款的客户特征</span><br><span class="line"></span><br><span class="line">6.5.4基于决策树分析逾期客户特征</span><br><span class="line"></span><br><span class="line">6.5.5基于回归分析逾期客户特征</span><br><span class="line"></span><br><span class="line">6.5.6根据消费历史分析客户特征</span><br><span class="line"></span><br><span class="line">6.5.7基于聚类分析客户特征</span><br><span class="line"></span><br><span class="line">6.5.8基于客户细分的聚类分析</span><br><span class="line"></span><br><span class="line">第7章海底捞火锅运营分析</span><br><span class="line"></span><br><span class="line">7.1火锅相关数据抓取</span><br><span class="line"></span><br><span class="line">7.2数据预处理</span><br><span class="line"></span><br><span class="line">7.3数据分析</span><br><span class="line"></span><br><span class="line">7.3.1海底捞运营分析</span><br><span class="line"></span><br><span class="line">7.3.2店铺选址分析</span><br><span class="line"></span><br><span class="line">7.4菜品关联分析</span><br><span class="line"></span><br><span class="line">7.5用户评论与评分的关联分析</span><br><span class="line"></span><br><span class="line">7.6顾客情感分析</span><br><span class="line"></span><br><span class="line">第8章商务宾馆竞争分析</span><br><span class="line"></span><br><span class="line">8.1目前经济型酒店行业竞争态势</span><br><span class="line"></span><br><span class="line">8.2用户相关数据准备</span><br><span class="line"></span><br><span class="line">8.3通过Python编程抓取评论</span><br><span class="line"></span><br><span class="line">8.4数据预处理</span><br><span class="line"></span><br><span class="line">8.5商务宾馆客户数据分析</span><br><span class="line"></span><br><span class="line">8.5.1酒店评分影响因素</span><br><span class="line"></span><br><span class="line">8.5.2酒店评分与酒店业绩关系</span><br><span class="line"></span><br><span class="line">8.5.3酒店评分分析</span><br><span class="line"></span><br><span class="line">8.5.4客户情感分析</span><br><span class="line"></span><br><span class="line">8.5.5竞争分析</span><br><span class="line"></span><br><span class="line">8.6建议</span><br><span class="line"></span><br><span class="line">第9章耐热导线工厂质量管理数据分析</span><br><span class="line"></span><br><span class="line">9.1项目概述</span><br><span class="line"></span><br><span class="line">9.2耐热导线生产质量数据预处理</span><br><span class="line"></span><br><span class="line">9.3耐热铝线质量检测数据分析</span><br><span class="line"></span><br><span class="line">第10章基于逻辑回归模型的高危人员分析</span><br><span class="line"></span><br><span class="line">10.1高危人员分析需求</span><br><span class="line"></span><br><span class="line">10.2高危人群相关数据收集与预处理</span><br><span class="line"></span><br><span class="line">10.3建立模型</span><br><span class="line"></span><br><span class="line">第11章卷积神经网络在音频质量评价领域的应用</span><br><span class="line"></span><br><span class="line">11.1深度学习基础</span><br><span class="line"></span><br><span class="line">11.1.1深度学习的发展过程</span><br><span class="line"></span><br><span class="line">11.1.2深度学习常用技术框架</span><br><span class="line"></span><br><span class="line">11.1.3常用的深度学习算法</span><br><span class="line"></span><br><span class="line">11.2音频质量评价</span><br><span class="line"></span><br><span class="line">11.2.1音频样本及特征预处理</span><br><span class="line"></span><br><span class="line">11.2.2音频特征选择</span><br><span class="line"></span><br><span class="line">11.2.3卷积神经网络模型训练</span><br><span class="line"></span><br><span class="line">11.2.4模型参数调优</span><br><span class="line"></span><br><span class="line">11.3性能验证</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>数学之美完整版 PDF</title>
    <url>/posts/74271428/</url>
    <content><![CDATA[<h4 id="《数学之美完整版》"><a href="#《数学之美完整版》" class="headerlink" title="《数学之美完整版》"></a>《数学之美完整版》</h4><h6 id="链接-https-pan-baidu-com-s-1-IGOG52cRgHM-7PMpTpTvA-提取码-a95d"><a href="#链接-https-pan-baidu-com-s-1-IGOG52cRgHM-7PMpTpTvA-提取码-a95d" class="headerlink" title="链接: https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA 提取码: a95d"></a>链接: <a href="https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA">https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA</a> 提取码: a95d</h6><p>八年前，“数学之美”系列文章原刊载于谷歌黑板报，获得上百万次点击，得到读者高度评价。读者说，读了“数学之美”，才发现大学时学的数学知识，比如马尔可夫链、矩阵计算，甚至余弦函数原来都如此亲切，并且栩栩如生，才发现自然语言和信息处理这么有趣。<br><a id="more"></a></p>
<p>在纸本书的创作中，作者几乎把所有文章都重写了一遍，为的是把高深的数学原理讲得更加通俗易懂，让非专业读者也能领略数学的魅力。读者通过具体的例子学到的是思考问题的方式 —— 如何化繁为简，如何用数学去解决工程问题，如何跳出固有思维不断去思考创新。</p>
<p>本书第一版荣获国家图书馆第八届文津图书奖。第二版增加了针对大数据和机器学习的内容。第三版增加了三章新内容，分别介绍当今非常热门的三个主题：区块链的数学基础，量子通信的原理，以及人工智能的数学极限。</p>
<p><img src="/images/b42bba8098ab4d753cec8fe8b3f363be1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">I 第二版序言</span><br><span class="line"></span><br><span class="line">III 第一版序言</span><br><span class="line"></span><br><span class="line">VI 第三版前言</span><br><span class="line"></span><br><span class="line">1 第1章 文字和语言 vs 数字和信息</span><br><span class="line"></span><br><span class="line">文字和语言与数学，从产生起原本就有相通性，虽然它们的发展一度分道扬镳，但是最终还是能走到一起。</span><br><span class="line"></span><br><span class="line">1　信息</span><br><span class="line"></span><br><span class="line">2　文字和数字</span><br><span class="line"></span><br><span class="line">3　文字和语言背后的数学</span><br><span class="line"></span><br><span class="line">15 第2章 自然语言处理——从规则到统计</span><br><span class="line"></span><br><span class="line">人类对机器理解自然语言的认识走了一条大弯路。早期的研究集中采用基于规则的方法，虽然解决了一些简单的问题，但是无法从根本上将自然语言理解实用化。直到20多年后，人们开始尝试用基于统计的方法进行自然语言处理，才有了突破性进展和实用的产品。</span><br><span class="line"></span><br><span class="line">1　机器智能</span><br><span class="line"></span><br><span class="line">2　从规则到统计</span><br><span class="line"></span><br><span class="line">27 第3章 统计语言模型</span><br><span class="line"></span><br><span class="line">统计语言模型是自然语言处理的基础，并且被广泛应用于机器翻译、语音识别、印刷体，或手写体识别、拼写纠错、汉字输入和文献查询。</span><br><span class="line"></span><br><span class="line">1　用数学的方法描述语言规律</span><br><span class="line"></span><br><span class="line">2　延伸阅读：统计语言模型的工程诀窍</span><br><span class="line"></span><br><span class="line">41 第4章 谈谈分词</span><br><span class="line"></span><br><span class="line">中文分词是中文信息处理的基础，它同样走过了一段弯路，目前依靠统计语言模型已经基本解决了这个问题。</span><br><span class="line"></span><br><span class="line">1　中文分词方法的演变</span><br><span class="line"></span><br><span class="line">2　延伸阅读：如何衡量分词的结果</span><br><span class="line"></span><br><span class="line">50 第5章 隐马尔可夫模型</span><br><span class="line"></span><br><span class="line">隐马尔可夫模型最初应用于通信领域，继而推广到语音和语言处理中，成为连接自然语言处理和通信的桥梁。同时，隐马尔可夫模型也是机器学习的主要工具之一。</span><br><span class="line"></span><br><span class="line">1　通信模型</span><br><span class="line"></span><br><span class="line">2　隐马尔可夫模型</span><br><span class="line"></span><br><span class="line">3　延伸阅读：隐马尔可夫模型的训练</span><br><span class="line"></span><br><span class="line">60 第6章 信息的度量和作用</span><br><span class="line"></span><br><span class="line">信息是可以量化度量的。信息熵不仅是对信息的量化度量，也是整个信息论的基础。它对于通信、数据压缩、自然语言处理都有很强的指导意义。</span><br><span class="line"></span><br><span class="line">1　信息熵</span><br><span class="line"></span><br><span class="line">2　信息的作用</span><br><span class="line"></span><br><span class="line">3　互信息</span><br><span class="line"></span><br><span class="line">4　延伸阅读：相对熵</span><br><span class="line"></span><br><span class="line">72 第7章 贾里尼克和现代语言处理</span><br><span class="line"></span><br><span class="line">作为现代自然语言处理的奠基者，贾里尼克教授成功地将数学原理应用于自然语言处理领域中，他的一生富于传奇色彩。</span><br><span class="line"></span><br><span class="line">1　早年生活</span><br><span class="line"></span><br><span class="line">2　从水门事件到莫妮卡·莱温斯基</span><br><span class="line"></span><br><span class="line">3　一位老人的奇迹</span><br><span class="line"></span><br><span class="line">82 第8章 简单之美——布尔代数和搜索引擎</span><br><span class="line"></span><br><span class="line">布尔代数虽然非常简单，却是计算机科学的基础，它不仅把逻辑和数学合二为一，而且给了我们一个全新的视角看待世界，开创了数字化时代。</span><br><span class="line"></span><br><span class="line">1　布尔代数</span><br><span class="line"></span><br><span class="line">2　索引</span><br><span class="line"></span><br><span class="line">89 第9章 图论和网络爬虫</span><br><span class="line"></span><br><span class="line">互联网搜索引擎在建立索引前需要用一个程序自动地将所有的网页下载到服务器上，这个程序称为网络爬虫，它的编写是基于离散数学中图论的原理。</span><br><span class="line"></span><br><span class="line">1　图论</span><br><span class="line"></span><br><span class="line">2　网络爬虫</span><br><span class="line"></span><br><span class="line">3　延伸阅读：图论的两点补充说明</span><br><span class="line"></span><br><span class="line">98 第10章 PageRank——Google的民主表决式网页排名技术</span><br><span class="line"></span><br><span class="line">网页排名技术PageRank是早期Google的杀手锏，它的出现使得网页搜索的质量上了一个大的台阶。它背后的原理是图论和线性代数的矩阵运算。</span><br><span class="line"></span><br><span class="line">1　PageRank算法的原理</span><br><span class="line"></span><br><span class="line">2　延伸阅读：PageRank的计算方法</span><br><span class="line"></span><br><span class="line">104 第11章 如何确定网页和查询的相关性</span><br><span class="line"></span><br><span class="line">确定网页和查询的相关性是网页搜索的根本问题，其中确定查询中每个关键词的重要性有多高是关键。TF-IDF是目前通用的关键词重要性的度量，其背后的原理是信息论。</span><br><span class="line"></span><br><span class="line">1　搜索关键词权重的科学度量TF-IDF</span><br><span class="line"></span><br><span class="line">2　延伸阅读：TF-IDF 的信息论依据</span><br><span class="line"></span><br><span class="line">111 第12章 有限状态机和动态规划——地图与本地搜索的核心技术</span><br><span class="line"></span><br><span class="line">地图与本地搜索中要用到有限状态机和动态规划技术。这两项技术是机器智能和机器学习的工具，它们的应用非常广泛，还包括语音识别、拼写和语法纠错、拼音输入法、工业控制和生物的序列分析等。</span><br><span class="line"></span><br><span class="line">1　地址分析和有限状态机</span><br><span class="line"></span><br><span class="line">2　全球导航和动态规划</span><br><span class="line"></span><br><span class="line">3　延伸阅读：有限状态传感器</span><br><span class="line"></span><br><span class="line">121 第13章 Google AK-47的设计者——阿米特·辛格博士</span><br><span class="line"></span><br><span class="line">在所有轻武器中最有名的是AK-47冲锋枪，因为它从不卡壳，不易损坏，可在任何环境下使用，可靠性好，杀伤力大并且操作简单。Google的产品就是按照上述原则设计的。</span><br><span class="line"></span><br><span class="line">127 第14章 余弦定理和新闻的分类</span><br><span class="line"></span><br><span class="line">计算机虽然读不懂新闻，却可以准确地对新闻进行分类。其数学工具是看似毫不相干的余弦定理。</span><br><span class="line"></span><br><span class="line">1　新闻的特征向量</span><br><span class="line"></span><br><span class="line">2　向量距离的度量</span><br><span class="line"></span><br><span class="line">3　延伸阅读：计算向量余弦的技巧</span><br><span class="line"></span><br><span class="line">136 第15章 矩阵运算和文本处理中的两个分类问题</span><br><span class="line"></span><br><span class="line">无论是词汇的聚类还是文本的分类，都可以通过线性代数中矩阵的奇异值分解来进行。这样一来，自然语言处理的问题就变成了一个数学问题。</span><br><span class="line"></span><br><span class="line">1　文本和词汇的矩阵</span><br><span class="line"></span><br><span class="line">2　延伸阅读：奇异值分解的方法和应用场景</span><br><span class="line"></span><br><span class="line">142 第16章 信息指纹及其应用</span><br><span class="line"></span><br><span class="line">世间万物都有一个唯一标识的特征，信息也是如此。每一条信息都有它特定的指纹，通过这个指纹可以区别不同的信息。</span><br><span class="line"></span><br><span class="line">1　信息指纹</span><br><span class="line"></span><br><span class="line">2　信息指纹的用途</span><br><span class="line"></span><br><span class="line">3　延伸阅读：信息指纹的重复性和相似哈希</span><br><span class="line"></span><br><span class="line">153 第17章 由电视剧《暗算》所想到的——谈谈密码学的数学原理</span><br><span class="line"></span><br><span class="line">密码学的根本是信息论和数学。没有信息论指导的密码是非常容易被破解的。只有在信息论被广泛应用于密码学后，密码才真正变得安全。</span><br><span class="line"></span><br><span class="line">1　密码学的自发时代</span><br><span class="line"></span><br><span class="line">2　信息论时代的密码学</span><br><span class="line"></span><br><span class="line">162 第18章 闪光的不一定是金子——谈谈搜索引擎反作弊问题和搜索结果的权威性问题</span><br><span class="line"></span><br><span class="line">闪光的不一定是金子，搜索引擎中排名靠前的网页也未必是有用的网页。消除这些作弊网页的原理和通信中过滤噪声的原理相同。这说明信息处理和通信的很多原理是相通的。</span><br><span class="line"></span><br><span class="line">1　搜索引擎的反作弊</span><br><span class="line"></span><br><span class="line">2　搜索结果的权威性</span><br><span class="line"></span><br><span class="line">171 第19章 谈谈数学模型的重要性</span><br><span class="line"></span><br><span class="line">正确的数学模型在科学和工程中至关重要，而发现正确模型的途径常常是曲折的。正确的模型在形式上通常是简单的。</span><br><span class="line"></span><br><span class="line">179 第20章 不要把鸡蛋放到一个篮子里——谈谈最大熵模型</span><br><span class="line"></span><br><span class="line">最大熵模型是一个完美的数学模型。它可以将各种信息整合到一个统一的模型中，在信息处理和机器学习中有着广泛的应用。它在形式上非常简单、优美，而在实现时需要有精深的数学基础和高超的技巧。</span><br><span class="line"></span><br><span class="line">1　最大熵原理和最大熵模型</span><br><span class="line"></span><br><span class="line">2　延伸阅读：最大熵模型的训练</span><br><span class="line"></span><br><span class="line">186 第21章 拼音输入法的数学原理</span><br><span class="line"></span><br><span class="line">汉字的输入过程本身就是人和计算机之间的通信。好的输入法会自觉或不自觉地遵循通信的数学模型。当然要做出最有效的输入法，应当自觉使用信息论做指导。</span><br><span class="line"></span><br><span class="line">1　输入法与编码</span><br><span class="line"></span><br><span class="line">2　输入一个汉字需要敲多少个键——谈谈香农第一定理</span><br><span class="line"></span><br><span class="line">3　拼音转汉字的算法</span><br><span class="line"></span><br><span class="line">4　延伸阅读：个性化的语言模型</span><br><span class="line"></span><br><span class="line">197 第22章 自然语言处理的教父马库斯和他的优秀弟子们</span><br><span class="line"></span><br><span class="line">将自然语言处理从基于规则的研究方法转到基于统计的研究方法上，宾夕法尼亚大学的教授米奇·马库斯功不可没。他创立了今天在学术界广泛使用的LCD语料库，同时培养了一大批精英人物。</span><br><span class="line"></span><br><span class="line">1　教父马库斯</span><br><span class="line"></span><br><span class="line">2　从宾夕法尼亚大学走出的精英们</span><br><span class="line"></span><br><span class="line">204 第23章 布隆过滤器</span><br><span class="line"></span><br><span class="line">日常生活中，经常要判断一个元素是否在一个集合中。布隆过滤器是计算机工程中解决这个问题最好的数学</span><br><span class="line"></span><br><span class="line">工具。</span><br><span class="line"></span><br><span class="line">1　布隆过滤器的原理</span><br><span class="line"></span><br><span class="line">2　延伸阅读：布隆过滤器的误识别问题</span><br><span class="line"></span><br><span class="line">209 第24章 马尔可夫链的扩展——贝叶斯网络</span><br><span class="line"></span><br><span class="line">贝叶斯网络是一个加权的有向图，是马尔可夫链的扩展。而从认识论的层面看：贝叶斯网络克服了马尔可夫链那种机械的线性约束，它可以把任何有关联的事件统一到它的框架下面。它在生物统计、图像处理、决策支持系统和博弈论中都有广泛的使用。</span><br><span class="line"></span><br><span class="line">1　贝叶斯网络</span><br><span class="line"></span><br><span class="line">2　贝叶斯网络在词分类中的应用</span><br><span class="line"></span><br><span class="line">3　延伸阅读：贝叶斯网络的训练</span><br><span class="line"></span><br><span class="line">217 第25章 条件随机场、文法分析及其他</span><br><span class="line"></span><br><span class="line">条件随机场是计算联合概率分布的有效模型，而句子的文法分析似乎是英文课上英语老师教的东西，这两者有什么联系呢？</span><br><span class="line"></span><br><span class="line">1　文法分析——计算机算法的演变</span><br><span class="line"></span><br><span class="line">2　条件随机场</span><br><span class="line"></span><br><span class="line">3　条件随机场在其他领域的应用</span><br><span class="line"></span><br><span class="line">227 第26章 维特比和他的维特比算法</span><br><span class="line"></span><br><span class="line">维特比算法是现代数字通信中使用最频繁的算法，也是很多自然语言处理采用的解码算法。可以毫不夸张地</span><br><span class="line"></span><br><span class="line">讲，维特比是对我们今天的生活影响力最大的科学家之一，因为基于CDMA的3G移动通信标准主要就是他和厄文·雅各布创办的高通公司制定的。</span><br><span class="line"></span><br><span class="line">1　维特比算法</span><br><span class="line"></span><br><span class="line">2　CDMA技术——3G移动通信的基础</span><br><span class="line"></span><br><span class="line">238 第27章 上帝的算法——期望最大化算法</span><br><span class="line"></span><br><span class="line">只要有一些训练数据，再定义一个最大化函数，采用EM算法，利用计算机经过若干次迭代，就可以得到所需要的模型。这实在是太美妙了，这也许是造物主刻意安排的，所以我把它称作上帝的算法。</span><br><span class="line"></span><br><span class="line">1　文本的自收敛分类</span><br><span class="line"></span><br><span class="line">2　延伸阅读：期望最大化和收敛的必然性</span><br><span class="line"></span><br><span class="line">244 第28章 逻辑回归和搜索广告</span><br><span class="line"></span><br><span class="line">逻辑回归模型是一种将影响概率的不同因素结合在一起的指数模型，它不仅在搜索广告中起着重要的作用，而且被广泛应用于信息处理和生物统计中。</span><br><span class="line"></span><br><span class="line">1　搜索广告的发展</span><br><span class="line"></span><br><span class="line">2　逻辑回归模型</span><br><span class="line"></span><br><span class="line">249 第29章 各个击破算法和Google云计算的基础</span><br><span class="line"></span><br><span class="line">Google颇为神秘的云计算中最重要的MapReduce工具，其原理就是计算机算法中常用的“各个击破”算法，它的原理原来这么简单——将复杂的大问题分解成很多小问题分别求解，然后再把小问题的解合并成原始问题的解。由此可见，在生活中大量用到的、真正有用的方法常常都是简单朴实的。</span><br><span class="line"></span><br><span class="line">1　分治算法的原理</span><br><span class="line"></span><br><span class="line">2　从分治算法到MapReduce</span><br><span class="line"></span><br><span class="line">254 第30章 Google大脑和人工神经网络</span><br><span class="line"></span><br><span class="line">Google大脑并不是一个什么都能思考的大脑，而是一个很能计算的人工神经网络。因此，与其说Google大脑很聪明,不如说它很能算。不过，换个角度来说，随着计算能力的不断提高，计算量大但简单的数学方法有时能够解决很复杂的问题。</span><br><span class="line"></span><br><span class="line">1　人工神经网络</span><br><span class="line"></span><br><span class="line">2　训练人工神经网络</span><br><span class="line"></span><br><span class="line">3　人工神经网络与贝叶斯网络的关系</span><br><span class="line"></span><br><span class="line">4　延伸阅读：Google大脑</span><br><span class="line"></span><br><span class="line">274 第31章 区块链的数学基础——椭圆曲线加密原理</span><br><span class="line"></span><br><span class="line">希尔伯特讲，“我们直到能够把一门自然科学的数学内核剥出并完全地揭示出来，才能够掌握它。”以比特币为代表的加密货币的基础是数学的算法，只有搞清楚加密货币的数学内核，我们才能了解它的本质。</span><br><span class="line"></span><br><span class="line">1　不对称、不透明之美</span><br><span class="line"></span><br><span class="line">2　椭圆曲线加密的原理</span><br><span class="line"></span><br><span class="line">282 第32章 大数据的威力——谈谈数据的重要性</span><br><span class="line"></span><br><span class="line">如果说在过去的40年里，主导全球IT产业发展的是摩尔定律，那么在今后的20年里，主导IT行业继续发展的动力则将来自于数据。</span><br><span class="line"></span><br><span class="line">1　数据的重要性</span><br><span class="line"></span><br><span class="line">2　数据的统计和信息技术</span><br><span class="line"></span><br><span class="line">3　为什么需要大数据</span><br><span class="line"></span><br><span class="line">304 第33章 随机性带来的好处——量子密钥分发的数学原理</span><br><span class="line"></span><br><span class="line">人们总是喜欢确定性而不喜欢随机性。但是从对确定性规律的把握上升到对随机性规律的把握，恰恰是近代数学进步的标志。量子通信就是建立在把握了有关随机性规律的基础之上。</span><br><span class="line"></span><br><span class="line">1　用（激光）量子的偏振方向传递信息</span><br><span class="line"></span><br><span class="line">2　利用随机性保证信息安全</span><br><span class="line"></span><br><span class="line">312 第34章 数学的极限——希尔伯特第十问题和机器智能的极限</span><br><span class="line"></span><br><span class="line">世界上只有一小部分问题是数学问题，而数学问题中又只有极小的一部分问题有解。在这些问题中，今天已经找到相应算法的少之又少。因此，数学不是万能的，我们需要了解数学的边界在哪里。</span><br><span class="line"></span><br><span class="line">1　图灵划定计算机可计算问题的边界</span><br><span class="line"></span><br><span class="line">2　希尔伯特划定有解数学问题的边界</span><br><span class="line"></span><br><span class="line">3　延伸阅读：关于图灵机</span><br><span class="line"></span><br><span class="line">323 附录 计算复杂度</span><br><span class="line"></span><br><span class="line">327 第三版后记</span><br><span class="line"></span><br><span class="line">333 索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>算法图解 PDF</title>
    <url>/posts/e49809b9/</url>
    <content><![CDATA[<h4 id="《算法图解》"><a href="#《算法图解》" class="headerlink" title="《算法图解》"></a>《算法图解》</h4><h6 id="链接-https-pan-baidu-com-s-138Di8I8K-iRkGr15PDswYQ-提取码-r7wa"><a href="#链接-https-pan-baidu-com-s-138Di8I8K-iRkGr15PDswYQ-提取码-r7wa" class="headerlink" title="链接: https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ 提取码: r7wa"></a>链接: <a href="https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ">https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ</a> 提取码: r7wa</h6><p>本书示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章将帮助你打下基础，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法，具体内容包括：面对具体问题时的解决技巧，比如，何时采用贪婪算法或动态规划；散列表的应用；图算法；Kzui近邻算法。<br><a id="more"></a></p>
<p><img src="/images/753ec00f4dfded3d79cbe139b96d9e401.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">关于本书</span><br><span class="line"></span><br><span class="line">第1　章 算法简介　1</span><br><span class="line"></span><br><span class="line">1．1　引言　1</span><br><span class="line"></span><br><span class="line">1．1．1　性能方面　1</span><br><span class="line"></span><br><span class="line">1．1．2　问题解决技巧　2</span><br><span class="line"></span><br><span class="line">1．2　二分查找　2</span><br><span class="line"></span><br><span class="line">1．2．1　更佳的查找方式　4</span><br><span class="line"></span><br><span class="line">1．2．2　运行时间　8</span><br><span class="line"></span><br><span class="line">1．3　大O 表示法　8</span><br><span class="line"></span><br><span class="line">1．3．1　算法的运行时间以不同的速度增加　9</span><br><span class="line"></span><br><span class="line">1．3．2　理解不同的大O运行时间　10</span><br><span class="line"></span><br><span class="line">1．3．3　大O 表示法指出了最糟情况下的运行时间　12</span><br><span class="line"></span><br><span class="line">1．3．4　一些常见的大O运行时间　12</span><br><span class="line"></span><br><span class="line">1．3．5　旅行商　13</span><br><span class="line"></span><br><span class="line">1．4　小结　15</span><br><span class="line"></span><br><span class="line">第2　章 选择排序　16</span><br><span class="line"></span><br><span class="line">2．1　内存的工作原理　16</span><br><span class="line"></span><br><span class="line">2．2　数组和链表　18</span><br><span class="line"></span><br><span class="line">2．2．1　链表　19</span><br><span class="line"></span><br><span class="line">2．2．2　数组　20</span><br><span class="line"></span><br><span class="line">2．2．3　术语　21</span><br><span class="line"></span><br><span class="line">2．2．4　在中间插入　22</span><br><span class="line"></span><br><span class="line">2．2．5　删除　23</span><br><span class="line"></span><br><span class="line">2．3　选择排序　25</span><br><span class="line"></span><br><span class="line">2．4　小结　28</span><br><span class="line"></span><br><span class="line">第3　章 递归　29</span><br><span class="line"></span><br><span class="line">3．1　递归　29</span><br><span class="line"></span><br><span class="line">3．2　基线条件和递归条件　32</span><br><span class="line"></span><br><span class="line">3．3　栈　33</span><br><span class="line"></span><br><span class="line">3．3．1　调用栈　34</span><br><span class="line"></span><br><span class="line">3．3．2　递归调用栈　36</span><br><span class="line"></span><br><span class="line">3．4　小结　40</span><br><span class="line"></span><br><span class="line">第4　章 快速排序　41</span><br><span class="line"></span><br><span class="line">4．1　分而治之　41</span><br><span class="line"></span><br><span class="line">4．2　快速排序　47</span><br><span class="line"></span><br><span class="line">4．3　再谈大O表示法　52</span><br><span class="line"></span><br><span class="line">4．3．1　比较合并排序和快速排序　53</span><br><span class="line"></span><br><span class="line">4．3．2　平均情况和最糟情况　54</span><br><span class="line"></span><br><span class="line">4．4　小结　57</span><br><span class="line"></span><br><span class="line">第5　章 散列表　58</span><br><span class="line"></span><br><span class="line">5．1　散列函数　60</span><br><span class="line"></span><br><span class="line">5．2　应用案例　63</span><br><span class="line"></span><br><span class="line">5．2．1　将散列表用于查找　63</span><br><span class="line"></span><br><span class="line">5．2．2　防止重复　64</span><br><span class="line"></span><br><span class="line">5．2．3　将散列表用作缓存　66</span><br><span class="line"></span><br><span class="line">5．2．4　小结　68</span><br><span class="line"></span><br><span class="line">5．3　冲突　69</span><br><span class="line"></span><br><span class="line">5．4　性能　71</span><br><span class="line"></span><br><span class="line">5．4．1　填装因子　72</span><br><span class="line"></span><br><span class="line">5．4．2　良好的散列函数　74</span><br><span class="line"></span><br><span class="line">5．5　小结　75</span><br><span class="line"></span><br><span class="line">第6　章 广度优先搜索　76</span><br><span class="line"></span><br><span class="line">6．1　图简介　77</span><br><span class="line"></span><br><span class="line">6．2　图是什么　79</span><br><span class="line"></span><br><span class="line">6．3　广度优先搜索　79</span><br><span class="line"></span><br><span class="line">6．3．1　查找最短路径　82</span><br><span class="line"></span><br><span class="line">6．3．2　队列　83</span><br><span class="line"></span><br><span class="line">6．4　实现图　84</span><br><span class="line"></span><br><span class="line">6．5　实现算法　86</span><br><span class="line"></span><br><span class="line">6．6　小结　93</span><br><span class="line"></span><br><span class="line">第7　章 狄克斯特拉算法　94</span><br><span class="line"></span><br><span class="line">7．1　使用狄克斯特拉算法　95</span><br><span class="line"></span><br><span class="line">7．2　术语　98</span><br><span class="line"></span><br><span class="line">7．3　换钢琴　100</span><br><span class="line"></span><br><span class="line">7．4　负权边　105</span><br><span class="line"></span><br><span class="line">7．5　实现　108</span><br><span class="line"></span><br><span class="line">7．6　小结　116</span><br><span class="line"></span><br><span class="line">第8　章 贪婪算法　117</span><br><span class="line"></span><br><span class="line">8．1　教室调度问题　117</span><br><span class="line"></span><br><span class="line">8．2　背包问题　119</span><br><span class="line"></span><br><span class="line">8．3　集合覆盖问题　121</span><br><span class="line"></span><br><span class="line">8．4　NP 完全问题　127</span><br><span class="line"></span><br><span class="line">8．4．1　旅行商问题详解　127</span><br><span class="line"></span><br><span class="line">8．4．2　如何识别NP 完全问题　131</span><br><span class="line"></span><br><span class="line">8．5　小结　133</span><br><span class="line"></span><br><span class="line">第9　章 动态规划　134</span><br><span class="line"></span><br><span class="line">9．1　背包问题　134</span><br><span class="line"></span><br><span class="line">9．1．1　简单算法　135</span><br><span class="line"></span><br><span class="line">9．1．2　动态规划　136</span><br><span class="line"></span><br><span class="line">9．2　背包问题FAQ　143</span><br><span class="line"></span><br><span class="line">9．2．1　再增加一件商品将如何呢　143</span><br><span class="line"></span><br><span class="line">9．2．2　行的排列顺序发生变化时结果将如何　145</span><br><span class="line"></span><br><span class="line">9．2．3　可以逐列而不是逐行填充网格吗　146</span><br><span class="line"></span><br><span class="line">9．2．4　增加一件更小的商品将如何呢　146</span><br><span class="line"></span><br><span class="line">9．2．5　可以偷商品的一部分吗　146</span><br><span class="line"></span><br><span class="line">9．2．6　旅游行程最优化　147</span><br><span class="line"></span><br><span class="line">9．2．7　处理相互依赖的情况　148</span><br><span class="line"></span><br><span class="line">9．2．8　计算最终的解时会涉及两个以上的子背包吗　148</span><br><span class="line"></span><br><span class="line">9．2．9　最优解可能导致背包没装满吗　149</span><br><span class="line"></span><br><span class="line">9．3　最长公共子串　149</span><br><span class="line"></span><br><span class="line">9．3．1　绘制网格　150</span><br><span class="line"></span><br><span class="line">9．3．2　填充网格　151</span><br><span class="line"></span><br><span class="line">9．3．3　揭晓答案　152</span><br><span class="line"></span><br><span class="line">9．3．4　最长公共子序列　153</span><br><span class="line"></span><br><span class="line">9．3．5　最长公共子序列之解决方案　154</span><br><span class="line"></span><br><span class="line">9．4　小结　155</span><br><span class="line"></span><br><span class="line">第10　章 K 最近邻算法　156</span><br><span class="line"></span><br><span class="line">10．1　橙子还是柚子　156</span><br><span class="line"></span><br><span class="line">10．2　创建推荐系统　158</span><br><span class="line"></span><br><span class="line">10．2．1　特征抽取　159</span><br><span class="line"></span><br><span class="line">10．2．2　回归　162</span><br><span class="line"></span><br><span class="line">10．2．3　挑选合适的特征　164</span><br><span class="line"></span><br><span class="line">10．3　机器学习简介　165</span><br><span class="line"></span><br><span class="line">10．3．1　OCR　165</span><br><span class="line"></span><br><span class="line">10．3．2　创建垃圾邮件过滤器　166</span><br><span class="line"></span><br><span class="line">10．3．3　预测股票市场　167</span><br><span class="line"></span><br><span class="line">10．4　小结　167</span><br><span class="line"></span><br><span class="line">第11　章 接下来如何做　168</span><br><span class="line"></span><br><span class="line">11．1　树　168</span><br><span class="line"></span><br><span class="line">11．2　反向索引　171</span><br><span class="line"></span><br><span class="line">11．3　傅里叶变换　171</span><br><span class="line"></span><br><span class="line">11．4　并行算法　172</span><br><span class="line"></span><br><span class="line">11．5　MapReduce　173</span><br><span class="line"></span><br><span class="line">11．5．1　分布式算法为何很有用　173</span><br><span class="line"></span><br><span class="line">11．5．2　映射函数　173</span><br><span class="line"></span><br><span class="line">11．5．3　归并函数　174</span><br><span class="line"></span><br><span class="line">11．6　布隆过滤器和HyperLogLog　174</span><br><span class="line"></span><br><span class="line">11．6．1　布隆过滤器　175</span><br><span class="line"></span><br><span class="line">11．6．2　HyperLogLog　176</span><br><span class="line"></span><br><span class="line">11．7　SHA 算法　176</span><br><span class="line"></span><br><span class="line">11．7．1　比较文件　177</span><br><span class="line"></span><br><span class="line">11．7．2　检查密码　178</span><br><span class="line"></span><br><span class="line">11．8　局部敏感的散列算法　178</span><br><span class="line"></span><br><span class="line">11．9　Diffie-Hellman 密钥交换　179</span><br><span class="line"></span><br><span class="line">11．10　线性规划　180</span><br><span class="line"></span><br><span class="line">11．11　结语　180</span><br><span class="line"></span><br><span class="line">练习答案　181</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>图解设计模式 PDF</title>
    <url>/posts/939f392f/</url>
    <content><![CDATA[<h4 id="《图解设计模式》"><a href="#《图解设计模式》" class="headerlink" title="《图解设计模式》"></a>《图解设计模式》</h4><h6 id="链接-https-pan-baidu-com-s-1S3jRtSGKvDVHDPP0QjApog-提取码-p3wn"><a href="#链接-https-pan-baidu-com-s-1S3jRtSGKvDVHDPP0QjApog-提取码-p3wn" class="headerlink" title="链接: https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog 提取码: p3wn"></a>链接: <a href="https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog">https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog</a> 提取码: p3wn</h6><p>本书以浅显易懂的语言逐一说明了GoF的23种设计模式。在讲解过程中，不仅搭配了丰富的图片，而且理论结合实例，用Java语言编写代码实现了设计模式的程序，让程序真正地运行起来，并提供了运用模式解决具体问题的练习题和答案。除此以外，本书在必要时还对Java语言的功能进行补充说明，以加深读者对Java的理解。<br><a id="more"></a></p>
<p><img src="/images/eb0190ae0daf6f7546847041d11254731.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1部分　适应设计模式　1</span><br><span class="line"></span><br><span class="line">第1章　Iterator模式——一个一个遍历　1</span><br><span class="line"></span><br><span class="line">1．1　Iterator模式　2</span><br><span class="line"></span><br><span class="line">1．2　示例程序　2</span><br><span class="line"></span><br><span class="line">Aggregate接口　3</span><br><span class="line"></span><br><span class="line">Iterator接口　5</span><br><span class="line"></span><br><span class="line">Book类　5</span><br><span class="line"></span><br><span class="line">BookShelf类　5</span><br><span class="line"></span><br><span class="line">BookShelfIteraotr类　6</span><br><span class="line"></span><br><span class="line">Main类　7</span><br><span class="line"></span><br><span class="line">1．3　Iterator模式中的登场角色　8</span><br><span class="line"></span><br><span class="line">1．4　拓展思路的要点　9</span><br><span class="line"></span><br><span class="line">不管实现如何变化，都可以使用Iterator　9</span><br><span class="line"></span><br><span class="line">难以理解抽象类和接口　9</span><br><span class="line"></span><br><span class="line">Aggregate和Iterator的对应　9</span><br><span class="line"></span><br><span class="line">容易弄错“下一个”　10</span><br><span class="line"></span><br><span class="line">还容易弄错　“最后一个”　10</span><br><span class="line"></span><br><span class="line">多个Iterator　10</span><br><span class="line"></span><br><span class="line">迭代器的种类多种多样　10</span><br><span class="line"></span><br><span class="line">不需要deleteIterator　10</span><br><span class="line"></span><br><span class="line">1．5　相关的设计模式　11</span><br><span class="line"></span><br><span class="line">1．6　本章所学知识　11</span><br><span class="line"></span><br><span class="line">1．7　练习题　11</span><br><span class="line"></span><br><span class="line">第2章　Adapter模式——加个“适配器”以便于复用　13</span><br><span class="line"></span><br><span class="line">2．1　Adapter模式　14</span><br><span class="line"></span><br><span class="line">2．2　示例程序（1）（使用继承的适配器）　14</span><br><span class="line"></span><br><span class="line">Banner类　15</span><br><span class="line"></span><br><span class="line">Print接口　16</span><br><span class="line"></span><br><span class="line">PrintBanner类　16</span><br><span class="line"></span><br><span class="line">Main类　16</span><br><span class="line"></span><br><span class="line">2．3　示例程序（2）（使用委托的示例程序）　17</span><br><span class="line"></span><br><span class="line">Print类　18</span><br><span class="line"></span><br><span class="line">PrintBanner类　18</span><br><span class="line"></span><br><span class="line">2．4　Adapter模式中的登场角色　18</span><br><span class="line"></span><br><span class="line">2．5　拓展思路的要点　19</span><br><span class="line"></span><br><span class="line">什么时候使用Adapter模式　19</span><br><span class="line"></span><br><span class="line">如果没有现成的代码　20</span><br><span class="line"></span><br><span class="line">版本升级与兼容性　20</span><br><span class="line"></span><br><span class="line">功能完全不同的类　20</span><br><span class="line"></span><br><span class="line">2．6　相关的设计模式　20</span><br><span class="line"></span><br><span class="line">2．7　本章所学知识　21</span><br><span class="line"></span><br><span class="line">2．8　练习题　21</span><br><span class="line"></span><br><span class="line">第2部分　交给子类　23</span><br><span class="line"></span><br><span class="line">第3章　Template Method模式——将具体处理交给子类　23</span><br><span class="line"></span><br><span class="line">3．1　Template Method模式　24</span><br><span class="line"></span><br><span class="line">什么是模板　24</span><br><span class="line"></span><br><span class="line">什么是Template　Method模式　24</span><br><span class="line"></span><br><span class="line">3．2　示例程序　24</span><br><span class="line"></span><br><span class="line">AbstractDisplay类　25</span><br><span class="line"></span><br><span class="line">CharDisplay类　26</span><br><span class="line"></span><br><span class="line">StringDisplay类　27</span><br><span class="line"></span><br><span class="line">Main类　28</span><br><span class="line"></span><br><span class="line">3．3　Template Method模式中的登场角色　28</span><br><span class="line"></span><br><span class="line">3．4　拓展思路的要点　29</span><br><span class="line"></span><br><span class="line">可以使逻辑处理通用化　29</span><br><span class="line"></span><br><span class="line">父类与子类之间的协作　29</span><br><span class="line"></span><br><span class="line">父类与子类的一致性　29</span><br><span class="line"></span><br><span class="line">3．5　相关的设计模式　30</span><br><span class="line"></span><br><span class="line">3．6　延伸阅读：类的层次与抽象类　30</span><br><span class="line"></span><br><span class="line">父类对子类的要求　30</span><br><span class="line"></span><br><span class="line">抽象类的意义　30</span><br><span class="line"></span><br><span class="line">父类与子类之间的协作　31</span><br><span class="line"></span><br><span class="line">3．7　本章所学知识　31</span><br><span class="line"></span><br><span class="line">3．8　练习题　31</span><br><span class="line"></span><br><span class="line">第4章　Factory Method模式——将实例的生成交给子类　33</span><br><span class="line"></span><br><span class="line">4．1　Factory Method模式　34</span><br><span class="line"></span><br><span class="line">4．2　示例程序　34</span><br><span class="line"></span><br><span class="line">Product类　35</span><br><span class="line"></span><br><span class="line">Factory类　35</span><br><span class="line"></span><br><span class="line">IDCard类　36</span><br><span class="line"></span><br><span class="line">IDCardFactory类　36</span><br><span class="line"></span><br><span class="line">Main类　37</span><br><span class="line"></span><br><span class="line">4．3　Factory Method模式中的登场角色　37</span><br><span class="line"></span><br><span class="line">4．4　拓展思路的要点　39</span><br><span class="line"></span><br><span class="line">框架与具体加工　39</span><br><span class="line"></span><br><span class="line">生成实例——方法的三种实现方式　39</span><br><span class="line"></span><br><span class="line">使用模式与开发人员之间的沟通　40</span><br><span class="line"></span><br><span class="line">4．5　相关的设计模式　40</span><br><span class="line"></span><br><span class="line">4．6　本章所学知识　41</span><br><span class="line"></span><br><span class="line">4．7　练习题　41</span><br><span class="line"></span><br><span class="line">第3部分　生成实例　43</span><br><span class="line"></span><br><span class="line">第5章　Singleton模式——只有一个实例　43</span><br><span class="line"></span><br><span class="line">5．1　Singleton模式　44</span><br><span class="line"></span><br><span class="line">5．2　示例程序　44</span><br><span class="line"></span><br><span class="line">Singleton类　44</span><br><span class="line"></span><br><span class="line">Main类　45</span><br><span class="line"></span><br><span class="line">5．3　Singleton模式中的登场角色　46</span><br><span class="line"></span><br><span class="line">5．4　拓展思路的要点　46</span><br><span class="line"></span><br><span class="line">为什么必须设置限制　46</span><br><span class="line"></span><br><span class="line">何时生成这个唯一的实例　46</span><br><span class="line"></span><br><span class="line">5．5　相关的设计模式　47</span><br><span class="line"></span><br><span class="line">5．6　本章所学知识　47</span><br><span class="line"></span><br><span class="line">5．7　练习题　47</span><br><span class="line"></span><br><span class="line">第6章　Prototype模式——通过复制生成实例　49</span><br><span class="line"></span><br><span class="line">6．1　Prototype模式　50</span><br><span class="line"></span><br><span class="line">6．2　示例程序　50</span><br><span class="line"></span><br><span class="line">Product接口　51</span><br><span class="line"></span><br><span class="line">Manager类　52</span><br><span class="line"></span><br><span class="line">MessageBox类　52</span><br><span class="line"></span><br><span class="line">UnderlinePen类　53</span><br><span class="line"></span><br><span class="line">Main类　54</span><br><span class="line"></span><br><span class="line">6．3　Prototype模式中的登场角色　55</span><br><span class="line"></span><br><span class="line">6．4　拓展思路的要点　56</span><br><span class="line"></span><br><span class="line">不能根据类来生成实例吗　56</span><br><span class="line"></span><br><span class="line">类名是束缚吗　56</span><br><span class="line"></span><br><span class="line">6．5　相关的设计模式　57</span><br><span class="line"></span><br><span class="line">6．6　延伸阅读：clone方法和java．lang．Clonable接口　57</span><br><span class="line"></span><br><span class="line">Java语言的clone　57</span><br><span class="line"></span><br><span class="line">clone方法是在哪里定义的　58</span><br><span class="line"></span><br><span class="line">需要实现Cloneable的哪些方法　58</span><br><span class="line"></span><br><span class="line">clone方法进行的是浅复制　58</span><br><span class="line"></span><br><span class="line">6．7　本章所学知识　58</span><br><span class="line"></span><br><span class="line">6．8　练习题　59</span><br><span class="line"></span><br><span class="line">第7章　Builder模式——组装复杂的实例　61</span><br><span class="line"></span><br><span class="line">7．1　Builder模式　62</span><br><span class="line"></span><br><span class="line">7．2　示例程序　62</span><br><span class="line"></span><br><span class="line">Builder类　63</span><br><span class="line"></span><br><span class="line">Director类　63</span><br><span class="line"></span><br><span class="line">TextBuilder类　64</span><br><span class="line"></span><br><span class="line">HTMLBuilder类　65</span><br><span class="line"></span><br><span class="line">Main类　65</span><br><span class="line"></span><br><span class="line">7．3　Builder模式中的登场角色　67</span><br><span class="line"></span><br><span class="line">7．4　相关的设计模式　69</span><br><span class="line"></span><br><span class="line">7．5　拓展思路的要点　69</span><br><span class="line"></span><br><span class="line">谁知道什么　69</span><br><span class="line"></span><br><span class="line">设计时能够决定的事情和不能决定的事情　70</span><br><span class="line"></span><br><span class="line">代码的阅读方法和修改方法　70</span><br><span class="line"></span><br><span class="line">7．6　本章所学知识　70</span><br><span class="line"></span><br><span class="line">7．7　练习题　70</span><br><span class="line"></span><br><span class="line">第8章　Abstract Factory模式——将关联零件组装成产品　73</span><br><span class="line"></span><br><span class="line">8．1　Abstract Factory模式　74</span><br><span class="line"></span><br><span class="line">8．2　示例程序　74</span><br><span class="line"></span><br><span class="line">抽象的零件：Item类　77</span><br><span class="line"></span><br><span class="line">抽象的零件：Link类　78</span><br><span class="line"></span><br><span class="line">抽象的零件：Tray类　78</span><br><span class="line"></span><br><span class="line">抽象的产品：Page类　79</span><br><span class="line"></span><br><span class="line">抽象的工厂：Factory类　79</span><br><span class="line"></span><br><span class="line">使用工厂将零件组装称为产品：Main类　80</span><br><span class="line"></span><br><span class="line">具体的工厂：ListFactory类　81</span><br><span class="line"></span><br><span class="line">具体的零件：ListLink类　82</span><br><span class="line"></span><br><span class="line">具体的零件：ListTray类　82</span><br><span class="line"></span><br><span class="line">具体的产品：ListPage类　83</span><br><span class="line"></span><br><span class="line">8．3　为示例程序增加其他工厂　84</span><br><span class="line"></span><br><span class="line">具体的工厂：TableFactory类　85</span><br><span class="line"></span><br><span class="line">具体的零件：TableLink类　86</span><br><span class="line"></span><br><span class="line">具体的零件：TableTray类　86</span><br><span class="line"></span><br><span class="line">具体的产品：TablePage类　87</span><br><span class="line"></span><br><span class="line">8．4　Abstract Factory模式中的登场角色　87</span><br><span class="line"></span><br><span class="line">8．5　拓展思路的要点　89</span><br><span class="line"></span><br><span class="line">易于增加具体的工厂　89</span><br><span class="line"></span><br><span class="line">难以增加新的零件　89</span><br><span class="line"></span><br><span class="line">8．6　相关的设计模式　89</span><br><span class="line"></span><br><span class="line">8．7　延伸阅读：各种生成实例的方法的介绍　90</span><br><span class="line"></span><br><span class="line">8．8　本章所学知识　91</span><br><span class="line"></span><br><span class="line">8．9　练习题　91</span><br><span class="line"></span><br><span class="line">第4部分　分开考虑　93</span><br><span class="line"></span><br><span class="line">第9章　Bridge模式——将类的功能层次结构与实现层次结构分离　93</span><br><span class="line"></span><br><span class="line">9．1　Bridge模式　94</span><br><span class="line"></span><br><span class="line">9．2　示例程序　95</span><br><span class="line"></span><br><span class="line">类的功能层次结构：Display类　96</span><br><span class="line"></span><br><span class="line">类的功能层次结构：CountDisplay类　97</span><br><span class="line"></span><br><span class="line">类的实现层次结构：DisplayImpl类　97</span><br><span class="line"></span><br><span class="line">类的实现层次结构：StringDisplayImpl类　98</span><br><span class="line"></span><br><span class="line">Main类　98</span><br><span class="line"></span><br><span class="line">9．3　Bridge模式中的登场角色　99</span><br><span class="line"></span><br><span class="line">9．4　拓展思路的要点　100</span><br><span class="line"></span><br><span class="line">分开后更容易扩展　100</span><br><span class="line"></span><br><span class="line">继承是强关联，委托是弱关联　100</span><br><span class="line"></span><br><span class="line">9．5　相关的设计模式　101</span><br><span class="line"></span><br><span class="line">9．6　本章所学知识　101</span><br><span class="line"></span><br><span class="line">9．7　练习题　102</span><br><span class="line"></span><br><span class="line">第10章　Strategy模式——整体地替换算法　103</span><br><span class="line"></span><br><span class="line">10．1　Strategy模式　104</span><br><span class="line"></span><br><span class="line">10．2　示例程序　104</span><br><span class="line"></span><br><span class="line">Hand类　105</span><br><span class="line"></span><br><span class="line">Strategy接口　106</span><br><span class="line"></span><br><span class="line">WinningStrategy类　106</span><br><span class="line"></span><br><span class="line">ProbStrategy类　107</span><br><span class="line"></span><br><span class="line">Player类　109</span><br><span class="line"></span><br><span class="line">Main类　109</span><br><span class="line"></span><br><span class="line">10．3　Strategy模式中的登场角色　111</span><br><span class="line"></span><br><span class="line">10．4　拓展思路的要点　112</span><br><span class="line"></span><br><span class="line">为什么需要特意编写Strategy角色　112</span><br><span class="line"></span><br><span class="line">程序运行中也可以切换策略　112</span><br><span class="line"></span><br><span class="line">10．5　相关的设计模式　113</span><br><span class="line"></span><br><span class="line">10．6　本章所学知识　113</span><br><span class="line"></span><br><span class="line">10．7　练习题　113</span><br><span class="line"></span><br><span class="line">第5部分　一致性　117</span><br><span class="line"></span><br><span class="line">第11章　Composite模式——容器与内容的一致性　117</span><br><span class="line"></span><br><span class="line">11．1　Composite模式　118</span><br><span class="line"></span><br><span class="line">11．2　示例程序　118</span><br><span class="line"></span><br><span class="line">Entry类　119</span><br><span class="line"></span><br><span class="line">File类　120</span><br><span class="line"></span><br><span class="line">Directory类　121</span><br><span class="line"></span><br><span class="line">FileTreatMentException类　122</span><br><span class="line"></span><br><span class="line">Main类　122</span><br><span class="line"></span><br><span class="line">11．3　Composite模式中的登场角色　124</span><br><span class="line"></span><br><span class="line">11．4　拓展思路的要点　125</span><br><span class="line"></span><br><span class="line">多个和单个的一致性　125</span><br><span class="line"></span><br><span class="line">Add方法应该放在哪里　126</span><br><span class="line"></span><br><span class="line">到处都存在递归结构　126</span><br><span class="line"></span><br><span class="line">11．5　相关的设计模式　126</span><br><span class="line"></span><br><span class="line">11．6　本章所学知识　127</span><br><span class="line"></span><br><span class="line">11．7　练习题　127</span><br><span class="line"></span><br><span class="line">第12章　Decorator模式——装饰边框与被装饰物的一致性　129</span><br><span class="line"></span><br><span class="line">12．1　Decorator模式　130</span><br><span class="line"></span><br><span class="line">12．2　示例程序　130</span><br><span class="line"></span><br><span class="line">Display类　131</span><br><span class="line"></span><br><span class="line">StringDisplay类　132</span><br><span class="line"></span><br><span class="line">Border类　132</span><br><span class="line"></span><br><span class="line">SideBorder类　133</span><br><span class="line"></span><br><span class="line">FullBorder类　134</span><br><span class="line"></span><br><span class="line">Main类　135</span><br><span class="line"></span><br><span class="line">12．3　Decorator模式中的登场角色　136</span><br><span class="line"></span><br><span class="line">12．4　拓展思路的要点　137</span><br><span class="line"></span><br><span class="line">接口（API）的透明性　137</span><br><span class="line"></span><br><span class="line">在不改变被装饰物的前提下增加功能　138</span><br><span class="line"></span><br><span class="line">可以动态地增加功能　138</span><br><span class="line"></span><br><span class="line">只需要一些装饰物即可添加许多功能　138</span><br><span class="line"></span><br><span class="line">java．io包与Decorator模式　138</span><br><span class="line"></span><br><span class="line">导致增加许多很小的类　139</span><br><span class="line"></span><br><span class="line">12．5　相关的设计模式　139</span><br><span class="line"></span><br><span class="line">12．6　延伸阅读：继承和委托中的一致性　140</span><br><span class="line"></span><br><span class="line">继承——父类和子类的一致性　140</span><br><span class="line"></span><br><span class="line">委托——自己和被委托对象的一致性　140</span><br><span class="line"></span><br><span class="line">12．7　本章所学知识　142</span><br><span class="line"></span><br><span class="line">12．8　练习题　142</span><br><span class="line"></span><br><span class="line">第6部分　访问数据结构　145</span><br><span class="line"></span><br><span class="line">第13章　Visitor模式——访问数据结构并处理数据　145</span><br><span class="line"></span><br><span class="line">13．1　Visitor模式　146</span><br><span class="line"></span><br><span class="line">13．2　示例程序　146</span><br><span class="line"></span><br><span class="line">Visitor类　147</span><br><span class="line"></span><br><span class="line">Element接口　148</span><br><span class="line"></span><br><span class="line">Entry类　148</span><br><span class="line"></span><br><span class="line">File类　148</span><br><span class="line"></span><br><span class="line">Directory类　149</span><br><span class="line"></span><br><span class="line">ListVisitor类　150</span><br><span class="line"></span><br><span class="line">FileTreatmentException类　151</span><br><span class="line"></span><br><span class="line">Main类　151</span><br><span class="line"></span><br><span class="line">Visitor与Element之间的相互调用　152</span><br><span class="line"></span><br><span class="line">13．3　Visitor模式中的登场角色　154</span><br><span class="line"></span><br><span class="line">13．4　拓展思路的要点　155</span><br><span class="line"></span><br><span class="line">双重分发　155</span><br><span class="line"></span><br><span class="line">为什么要弄得这么复杂　155</span><br><span class="line"></span><br><span class="line">开闭原则——对扩展开放，对修改关闭　155</span><br><span class="line"></span><br><span class="line">易于增加ConcreteVisitor角色　156</span><br><span class="line"></span><br><span class="line">难以增加ConcreteElement角色　156</span><br><span class="line"></span><br><span class="line">Visitor工作所需的条件　156</span><br><span class="line"></span><br><span class="line">13．5　相关的设计模式　157</span><br><span class="line"></span><br><span class="line">13．6　本章所学知识　157</span><br><span class="line"></span><br><span class="line">13．7　练习题　157</span><br><span class="line"></span><br><span class="line">第14章　Chain of Responsibility模式——推卸责任　161</span><br><span class="line"></span><br><span class="line">14．1　Chain of Responsibility模式　162</span><br><span class="line"></span><br><span class="line">14．2　示例程序　162</span><br><span class="line"></span><br><span class="line">Trouble类　163</span><br><span class="line"></span><br><span class="line">Support类　163</span><br><span class="line"></span><br><span class="line">NoSupport类　164</span><br><span class="line"></span><br><span class="line">LimitSupport类　164</span><br><span class="line"></span><br><span class="line">OddSupport类　165</span><br><span class="line"></span><br><span class="line">SpecialSupport类　165</span><br><span class="line"></span><br><span class="line">Main类　166</span><br><span class="line"></span><br><span class="line">14．3　Chain of Responsibility模式中的登场角色　167</span><br><span class="line"></span><br><span class="line">14．4　拓展思路的要点　168</span><br><span class="line"></span><br><span class="line">弱化了发出请求的人和处理请求的人之间的关系　168</span><br><span class="line"></span><br><span class="line">可以动态地改变职责链　168</span><br><span class="line"></span><br><span class="line">专注于自己的工作　169</span><br><span class="line"></span><br><span class="line">推卸请求会导致处理延迟吗　169</span><br><span class="line"></span><br><span class="line">14．5　相关的设计模式　169</span><br><span class="line"></span><br><span class="line">14．6　本章所学知识　169</span><br><span class="line"></span><br><span class="line">14．7　练习题　169</span><br><span class="line"></span><br><span class="line">第7部分　简单化　171</span><br><span class="line"></span><br><span class="line">第15章　Facade模式——简单窗口　171</span><br><span class="line"></span><br><span class="line">15．1　Facade模式　172</span><br><span class="line"></span><br><span class="line">15．2　示例程序　172</span><br><span class="line"></span><br><span class="line">Database类　173</span><br><span class="line"></span><br><span class="line">HtmlWriter类　174</span><br><span class="line"></span><br><span class="line">PageMaker类　175</span><br><span class="line"></span><br><span class="line">Main类　176</span><br><span class="line"></span><br><span class="line">15．3　Facade模式中的登场角色　176</span><br><span class="line"></span><br><span class="line">15．4　拓展思路的要点　177</span><br><span class="line"></span><br><span class="line">Facade角色到底做什么工作　177</span><br><span class="line"></span><br><span class="line">递归地使用Facade模式　178</span><br><span class="line"></span><br><span class="line">开发人员不愿意创建Facade角色的原因——心理原因　178</span><br><span class="line"></span><br><span class="line">15．5　相关的设计模式　178</span><br><span class="line"></span><br><span class="line">15．6　本章所学知识　178</span><br><span class="line"></span><br><span class="line">15．7　练习题　179</span><br><span class="line"></span><br><span class="line">第16章　Mediator模式——只有一个仲裁者　181</span><br><span class="line"></span><br><span class="line">16．1　Mediator模式　182</span><br><span class="line"></span><br><span class="line">16．2　示例程序　182</span><br><span class="line"></span><br><span class="line">Mediator接口　185</span><br><span class="line"></span><br><span class="line">Colleague接口　186</span><br><span class="line"></span><br><span class="line">ColleagueButton类　186</span><br><span class="line"></span><br><span class="line">ColleagueTextField类　187</span><br><span class="line"></span><br><span class="line">ColleagueCheckbox类　188</span><br><span class="line"></span><br><span class="line">LoginFrame类　188</span><br><span class="line"></span><br><span class="line">Main类　191</span><br><span class="line"></span><br><span class="line">16．3　Mediator模式中的登场角色　191</span><br><span class="line"></span><br><span class="line">16．4　拓展思路的要点　192</span><br><span class="line"></span><br><span class="line">当发生分散灾难时　192</span><br><span class="line"></span><br><span class="line">通信线路的增加　193</span><br><span class="line"></span><br><span class="line">哪些角色可以复用　193</span><br><span class="line"></span><br><span class="line">16．5　相关的设计模式　193</span><br><span class="line"></span><br><span class="line">16．6　本章所学知识　193</span><br><span class="line"></span><br><span class="line">16．7　练习题　194</span><br><span class="line"></span><br><span class="line">第8部分　管理状态　195</span><br><span class="line"></span><br><span class="line">第17章　Observer模式——发送状态变化通知　195</span><br><span class="line"></span><br><span class="line">17．1　Observer模式　196</span><br><span class="line"></span><br><span class="line">17．2　示例程序　196</span><br><span class="line"></span><br><span class="line">Observer接口　196</span><br><span class="line"></span><br><span class="line">NumberGenerator类　197</span><br><span class="line"></span><br><span class="line">RandomNumberGenerator类　198</span><br><span class="line"></span><br><span class="line">DigitObserver类　198</span><br><span class="line"></span><br><span class="line">GraphObserver类　199</span><br><span class="line"></span><br><span class="line">Main类　199</span><br><span class="line"></span><br><span class="line">17．3　Observer模式中的登场角色　200</span><br><span class="line"></span><br><span class="line">17．4　拓展思路的要点　201</span><br><span class="line"></span><br><span class="line">这里也出现了可替换性　201</span><br><span class="line"></span><br><span class="line">Observer的顺序　202</span><br><span class="line"></span><br><span class="line">当Observer的行为会对Subject产生影响时　202</span><br><span class="line"></span><br><span class="line">传递更新信息的方式　202</span><br><span class="line"></span><br><span class="line">从“观察”变为“通知”　203</span><br><span class="line"></span><br><span class="line">Model&#x2F;View&#x2F;Controller（MVC）　203</span><br><span class="line"></span><br><span class="line">17．5　延伸阅读：java．util．Observer接口　203</span><br><span class="line"></span><br><span class="line">17．6　相关的设计模式　204</span><br><span class="line"></span><br><span class="line">17．7　本章所学知识　204</span><br><span class="line"></span><br><span class="line">17．8　练习题　204</span><br><span class="line"></span><br><span class="line">第18章　Memento模式——保存对象状态　207</span><br><span class="line"></span><br><span class="line">18．1　Memento模式　208</span><br><span class="line"></span><br><span class="line">18．2　示例程序　208</span><br><span class="line"></span><br><span class="line">Memento类　209</span><br><span class="line"></span><br><span class="line">Gamer类　210</span><br><span class="line"></span><br><span class="line">Main类　211</span><br><span class="line"></span><br><span class="line">18．3　Memento模式中的登场角色　215</span><br><span class="line"></span><br><span class="line">18．4　拓展思路的要点　216</span><br><span class="line"></span><br><span class="line">两种接口（API）和可见性　216</span><br><span class="line"></span><br><span class="line">需要多少个Memento　217</span><br><span class="line"></span><br><span class="line">Memento的有效期限是多久　217</span><br><span class="line"></span><br><span class="line">划分Caretaker角色和Originator角色的意义　217</span><br><span class="line"></span><br><span class="line">18．5　相关的设计模式　218</span><br><span class="line"></span><br><span class="line">18．6　本章所学知识　218</span><br><span class="line"></span><br><span class="line">18．7　练习题　218</span><br><span class="line"></span><br><span class="line">第19章　State模式——用类表示状态　221</span><br><span class="line"></span><br><span class="line">19．1　State模式　222</span><br><span class="line"></span><br><span class="line">19．2　示例程序　222</span><br><span class="line"></span><br><span class="line">金库警报系统　222</span><br><span class="line"></span><br><span class="line">不使用State模式的伪代码　223</span><br><span class="line"></span><br><span class="line">使用了State模式的伪代码　224</span><br><span class="line"></span><br><span class="line">State接口　226</span><br><span class="line"></span><br><span class="line">DayState类　226</span><br><span class="line"></span><br><span class="line">NightState类　227</span><br><span class="line"></span><br><span class="line">Context接口　228</span><br><span class="line"></span><br><span class="line">SafeFrame类　228</span><br><span class="line"></span><br><span class="line">Main类　231</span><br><span class="line"></span><br><span class="line">19．3　State模式中的登场角色　232</span><br><span class="line"></span><br><span class="line">19．4　拓展思路的要点　233</span><br><span class="line"></span><br><span class="line">分而治之　233</span><br><span class="line"></span><br><span class="line">依赖于状态的处理　233</span><br><span class="line"></span><br><span class="line">应当是谁来管理状态迁移　233</span><br><span class="line"></span><br><span class="line">不会自相矛盾　234</span><br><span class="line"></span><br><span class="line">易于增加新的状态　234</span><br><span class="line"></span><br><span class="line">实例的多面性　235</span><br><span class="line"></span><br><span class="line">19．5　相关的设计模式　235</span><br><span class="line"></span><br><span class="line">19．6　本章所学知识　235</span><br><span class="line"></span><br><span class="line">19．7　练习题　236</span><br><span class="line"></span><br><span class="line">第9部分　避免浪费　237</span><br><span class="line"></span><br><span class="line">第20章　Flyweight模式——共享对象，避免浪费　237</span><br><span class="line"></span><br><span class="line">20．1　Flyweight模式　238</span><br><span class="line"></span><br><span class="line">20．2　示例程序　238</span><br><span class="line"></span><br><span class="line">BigChar类　240</span><br><span class="line"></span><br><span class="line">BigCharFactory类　241</span><br><span class="line"></span><br><span class="line">BigString类　242</span><br><span class="line"></span><br><span class="line">Main类　244</span><br><span class="line"></span><br><span class="line">20．3　Flyweight模式中的登场角色　244</span><br><span class="line"></span><br><span class="line">20．4　拓展思路的要点　245</span><br><span class="line"></span><br><span class="line">对多个地方产生影响　245</span><br><span class="line"></span><br><span class="line">Intrinsic与Extrinsic　246</span><br><span class="line"></span><br><span class="line">不要让被共享的实例被垃圾回收器回收了　246</span><br><span class="line"></span><br><span class="line">内存之外的其他资源　247</span><br><span class="line"></span><br><span class="line">20．5　相关的设计模式　247</span><br><span class="line"></span><br><span class="line">20．6　本章所学知识　247</span><br><span class="line"></span><br><span class="line">20．7　练习题　247</span><br><span class="line"></span><br><span class="line">第21章　Proxy模式——只在必要时生成实例　249</span><br><span class="line"></span><br><span class="line">21．1　Proxy模式　250</span><br><span class="line"></span><br><span class="line">21．2　示例程序　250</span><br><span class="line"></span><br><span class="line">Printer类　251</span><br><span class="line"></span><br><span class="line">Printable接口　252</span><br><span class="line"></span><br><span class="line">PrinterProxy类　253</span><br><span class="line"></span><br><span class="line">Main类　254</span><br><span class="line"></span><br><span class="line">21．3　Proxy模式中的登场角色　254</span><br><span class="line"></span><br><span class="line">21．4　拓展思路的要点　255</span><br><span class="line"></span><br><span class="line">使用代理人来提升处理速度　255</span><br><span class="line"></span><br><span class="line">有必要划分代理人和本人吗　256</span><br><span class="line"></span><br><span class="line">代理与委托　256</span><br><span class="line"></span><br><span class="line">透明性　256</span><br><span class="line"></span><br><span class="line">HTTP代理　256</span><br><span class="line"></span><br><span class="line">各种Proxy模式　257</span><br><span class="line"></span><br><span class="line">21．5　相关的设计模式　257</span><br><span class="line"></span><br><span class="line">21．6　本章所学知识　257</span><br><span class="line"></span><br><span class="line">21．7　练习题　257</span><br><span class="line"></span><br><span class="line">第10部分　用类来表现　259</span><br><span class="line"></span><br><span class="line">第22章　Command模式——命令也是类　259</span><br><span class="line"></span><br><span class="line">22．1　Command模式　260</span><br><span class="line"></span><br><span class="line">22．2　示例程序　260</span><br><span class="line"></span><br><span class="line">Command接口　261</span><br><span class="line"></span><br><span class="line">MacroCommand类　262</span><br><span class="line"></span><br><span class="line">DrawCommand类　263</span><br><span class="line"></span><br><span class="line">Drawable接口　263</span><br><span class="line"></span><br><span class="line">DrawCanvas类　264</span><br><span class="line"></span><br><span class="line">Main类　265</span><br><span class="line"></span><br><span class="line">22．3　Command模式中的登场角色　268</span><br><span class="line"></span><br><span class="line">22．4　拓展思路的要点　269</span><br><span class="line"></span><br><span class="line">命令中应该包含哪些信息　269</span><br><span class="line"></span><br><span class="line">保存历史记录　269</span><br><span class="line"></span><br><span class="line">适配器　269</span><br><span class="line"></span><br><span class="line">22．5　相关的设计模式　271</span><br><span class="line"></span><br><span class="line">22．6　本章所学知识　272</span><br><span class="line"></span><br><span class="line">22．7　练习题　272</span><br><span class="line"></span><br><span class="line">第23章　Interpreter模式——语法规则也是类　273</span><br><span class="line"></span><br><span class="line">23．1　Interpreter模式　274</span><br><span class="line"></span><br><span class="line">23．2　迷你语言　274</span><br><span class="line"></span><br><span class="line">迷你语言的命令　274</span><br><span class="line"></span><br><span class="line">迷你语言程序示例　275</span><br><span class="line"></span><br><span class="line">迷你语言的语法　278</span><br><span class="line"></span><br><span class="line">终结符表达式与非终结符表达式　279</span><br><span class="line"></span><br><span class="line">23．3　示例程序　279</span><br><span class="line"></span><br><span class="line">Node类　281</span><br><span class="line"></span><br><span class="line">ProgramNode类　281</span><br><span class="line"></span><br><span class="line">CommandListNode类　282</span><br><span class="line"></span><br><span class="line">CommandNode类　283</span><br><span class="line"></span><br><span class="line">RepeatCommandNode类　284</span><br><span class="line"></span><br><span class="line">PrimitiveCommandNode类　285</span><br><span class="line"></span><br><span class="line">Context类　285</span><br><span class="line"></span><br><span class="line">ParseException类　286</span><br><span class="line"></span><br><span class="line">Main类　287</span><br><span class="line"></span><br><span class="line">23．4　Interpreter模式中的登场角色　288</span><br><span class="line"></span><br><span class="line">23．5　拓展思路的要点　289</span><br><span class="line"></span><br><span class="line">还有其他哪些迷你语言　289</span><br><span class="line"></span><br><span class="line">跳过标记还是读取标记　290</span><br><span class="line"></span><br><span class="line">23．6　相关的设计模式　290</span><br><span class="line"></span><br><span class="line">23．7　本章所学知识以及本书的结束语　290</span><br><span class="line"></span><br><span class="line">23．8　练习题　290</span><br><span class="line"></span><br><span class="line">附　录　293</span><br><span class="line"></span><br><span class="line">附录A　习题解答　294</span><br><span class="line"></span><br><span class="line">附录B　示例程序的运行步骤　359</span><br><span class="line"></span><br><span class="line">附录C　GoF对设计模式的分类　361</span><br><span class="line"></span><br><span class="line">附录D　设计模式Q&amp;A　362</span><br><span class="line"></span><br><span class="line">附录E　参考书籍　365</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>学习Go语言(Golang) PDF</title>
    <url>/posts/a966895/</url>
    <content><![CDATA[<h4 id="《学习Go语言-Golang-》"><a href="#《学习Go语言-Golang-》" class="headerlink" title="《学习Go语言(Golang)》"></a>《学习Go语言(Golang)》</h4><h6 id="链接-https-pan-baidu-com-s-1bP3MTPuB8HKe-MSP2GqzkQ-提取码-vw22"><a href="#链接-https-pan-baidu-com-s-1bP3MTPuB8HKe-MSP2GqzkQ-提取码-vw22" class="headerlink" title="链接: https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ 提取码: vw22"></a>链接: <a href="https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ">https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ</a> 提取码: vw22</h6><p>Go语言适合用来进行服务器编程与网络编程，包括Web应用编程等。本书详细讲解了Go语言数据类型、关键字、字面量、基本语法等基础概念及Go项目的工程构建、测试、编译与运行等；深入讲解了协程（goroutine）和通道（channel）等与并发编程有关的概念；还介绍了系统标准库、网络编程和第三方包。读者掌握本书内容后，可以顺利进行实际项目开发。本书适合Go语言初学者和有一定经验的程序员阅<br><a id="more"></a></p>
<p><img src="/images/622489f1205f302e0c036c3946b941d51.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目       录</span><br><span class="line"></span><br><span class="line">出版说明</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">第1章  Go语言简介1</span><br><span class="line"></span><br><span class="line">1.1  为什么要学Go语言1</span><br><span class="line"></span><br><span class="line">1.2  Go语言安装1</span><br><span class="line"></span><br><span class="line">1.3  Go语言开发工具4</span><br><span class="line"></span><br><span class="line">第2章  Go语言编程基础6</span><br><span class="line"></span><br><span class="line">2.1  数据类型6</span><br><span class="line"></span><br><span class="line">2.2  变量9</span><br><span class="line"></span><br><span class="line">2.3  常量14</span><br><span class="line"></span><br><span class="line">2.4  运算符18</span><br><span class="line"></span><br><span class="line">2.5  字符串22</span><br><span class="line"></span><br><span class="line">2.6  流程控制26</span><br><span class="line"></span><br><span class="line">第3章  作用域37</span><br><span class="line"></span><br><span class="line">3.1  关于作用域37</span><br><span class="line"></span><br><span class="line">3.2  约定和惯例40</span><br><span class="line"></span><br><span class="line">第4章  代码结构化与项目管理43</span><br><span class="line"></span><br><span class="line">4.1  包（package）43</span><br><span class="line"></span><br><span class="line">4.2  Go项目开发与编译46</span><br><span class="line"></span><br><span class="line">第5章  复合数据类型54</span><br><span class="line"></span><br><span class="line">5.1  数组（array）54</span><br><span class="line"></span><br><span class="line">5.2  切片（slice）56</span><br><span class="line"></span><br><span class="line">5.3  字典（map）60</span><br><span class="line"></span><br><span class="line">第6章  type关键字63</span><br><span class="line"></span><br><span class="line">6.1  type自定义类型63</span><br><span class="line"></span><br><span class="line">6.2  type定义类型别名64</span><br><span class="line"></span><br><span class="line">第7章  错误处理与defer66</span><br><span class="line"></span><br><span class="line">7.1  错误处理66</span><br><span class="line"></span><br><span class="line">7.2  关于defer68</span><br><span class="line"></span><br><span class="line">第8章  函数74</span><br><span class="line"></span><br><span class="line">8.1  函数（function）74</span><br><span class="line"></span><br><span class="line">第9章  结构体和接口86</span><br><span class="line"></span><br><span class="line">9.1  结构体（struct）86</span><br><span class="line"></span><br><span class="line">9.2  接口（interface）94</span><br><span class="line"></span><br><span class="line">第10章  方法101</span><br><span class="line"></span><br><span class="line">10.1  方法的定义101</span><br><span class="line"></span><br><span class="line">10.2  指针方法与值方法108</span><br><span class="line"></span><br><span class="line">值方法111</span><br><span class="line"></span><br><span class="line">10.3  匿名类型的方法提升114</span><br><span class="line"></span><br><span class="line">第11章  面向对象与内存118</span><br><span class="line"></span><br><span class="line">11.1  面向对象118</span><br><span class="line"></span><br><span class="line">11.2  指针和内存119</span><br><span class="line"></span><br><span class="line">第12章  并发处理124</span><br><span class="line"></span><br><span class="line">12.1  协程124</span><br><span class="line"></span><br><span class="line">12.2  通道（channel）127</span><br><span class="line"></span><br><span class="line">12.3  同步与锁131</span><br><span class="line"></span><br><span class="line">第13章  测试与调优140</span><br><span class="line"></span><br><span class="line">13.1  测试140</span><br><span class="line"></span><br><span class="line">13.2  调优142</span><br><span class="line"></span><br><span class="line">第14章  系统标准库148</span><br><span class="line"></span><br><span class="line">14.1  reflect包148</span><br><span class="line"></span><br><span class="line">14.2  unsafe包155</span><br><span class="line"></span><br><span class="line">14.3  sort包160</span><br><span class="line"></span><br><span class="line">14.4  os包164</span><br><span class="line"></span><br><span class="line">14.5  fmt包167</span><br><span class="line"></span><br><span class="line">14.6  flag 包174</span><br><span class="line"></span><br><span class="line">14.7  文件操作与I&#x2F;O177</span><br><span class="line"></span><br><span class="line">第15章  网络服务186</span><br><span class="line"></span><br><span class="line">15.1  Socket186</span><br><span class="line"></span><br><span class="line">15.2  模板（Template）189</span><br><span class="line"></span><br><span class="line">15.3  net&#x2F;http包196</span><br><span class="line"></span><br><span class="line">15.4  context包214</span><br><span class="line"></span><br><span class="line">第16章  数据格式与存储221</span><br><span class="line"></span><br><span class="line">16.1  数据格式221</span><br><span class="line"></span><br><span class="line">结构体222</span><br><span class="line"></span><br><span class="line">16.2  MySQL数据库231</span><br><span class="line"></span><br><span class="line">16.3  LevelDB与BoltDB 数据库236</span><br><span class="line"></span><br><span class="line">第17章  网络爬虫244</span><br><span class="line"></span><br><span class="line">17.1  Colly网络爬虫框架244</span><br><span class="line"></span><br><span class="line">17.2  goquery HTML解析246</span><br><span class="line"></span><br><span class="line">第18章  Web框架—Gin250</span><br><span class="line"></span><br><span class="line">18.1  关于Gin250</span><br><span class="line"></span><br><span class="line">18.2  Gin实际应用251</span><br><span class="line"></span><br><span class="line">参考文献260</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>研磨设计模式 PDF</title>
    <url>/posts/7d915803/</url>
    <content><![CDATA[<h4 id="《研磨设计模式》"><a href="#《研磨设计模式》" class="headerlink" title="《研磨设计模式》"></a>《研磨设计模式》</h4><h6 id="链接-https-pan-baidu-com-s-1izMuD7GHYo39E7U4B9tkOg-提取码-nmyf"><a href="#链接-https-pan-baidu-com-s-1izMuD7GHYo39E7U4B9tkOg-提取码-nmyf" class="headerlink" title="链接: https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg 提取码: nmyf"></a>链接: <a href="https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg">https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg</a> 提取码: nmyf</h6><p>《研磨设计模式》完整覆盖GoF讲述的23个设计模式并加以细细研磨。初级内容从基本讲起，包括每个模式的定义、功能、思路、结构、基本实现、运行调用顺序、基本应用示例等，让读者能系统、完整、准确地掌握每个模式，培养正确的“设计观”；中高级内容则深入探讨如何理解这些模式，包括模式中蕴涵什么样的设计思想，模式的本质是什么，模式如何结合实际应用，模式的优缺点以及与其他模式的关系等，以期让读者尽量去理解和掌握每个设计模式的精髓所在。《研磨设计模式》在内容上深入、技术上实用、和实际开发结合程度很高，书中大部分的示例程序都是从实际项目中简化而来，因此很多例子都可以直接拿到实际项目中使用。如果你想要深入透彻地理解和掌握设计模式，并期望能真正把设计模式应用到项目中去，那么这是你不可错过的一本好书。《研磨设计模式》难度为初级到中级，适合于所有开发人员、设计人员或者即将成为开发人员的朋友。也可以作为高校学生深入学习设计模式的参考读物<br><a id="more"></a></p>
<p><img src="/images/87698cd0f5512ddccf22d638e6b80fe41.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">章 设计模式基础</span><br><span class="line"></span><br><span class="line">1.1 设计模式是什么</span><br><span class="line"></span><br><span class="line">1.1.1 什么是模式</span><br><span class="line"></span><br><span class="line">1.1.2 设计模式的概念</span><br><span class="line"></span><br><span class="line">1.1.3 设计模式的理解</span><br><span class="line"></span><br><span class="line">1.1.4 设计模式的历史</span><br><span class="line"></span><br><span class="line">1.2 设计模式有什么</span><br><span class="line"></span><br><span class="line">1.2.1 设计模式的组成</span><br><span class="line"></span><br><span class="line">1.2.2 设计模式的分类</span><br><span class="line"></span><br><span class="line">1.3 设计模式的学习</span><br><span class="line"></span><br><span class="line">1.3.1 为什么要学习设计模式</span><br><span class="line"></span><br><span class="line">1.3.2 学习设计模式的层次</span><br><span class="line"></span><br><span class="line">1.3.3 如何学习设计模式</span><br><span class="line"></span><br><span class="line">1.4 本书的组织方式</span><br><span class="line"></span><br><span class="line">1.4.1 本书所讲述的设计模式的提纲</span><br><span class="line"></span><br><span class="line">1.4.2 每个模式的讲述结构</span><br><span class="line"></span><br><span class="line">第2章 简单工厂</span><br><span class="line"></span><br><span class="line">2.1 场景问题</span><br><span class="line"></span><br><span class="line">2.1.1 接口回顾</span><br><span class="line"></span><br><span class="line">2.1.2 面向接口编程</span><br><span class="line"></span><br><span class="line">2.1.3 不用模式的解决方案</span><br><span class="line"></span><br><span class="line">2.1.4 有何问题</span><br><span class="line"></span><br><span class="line">2.2 解决方案</span><br><span class="line"></span><br><span class="line">2.2.1 使用简单工厂来解决问题</span><br><span class="line"></span><br><span class="line">2.2.2 简单工厂的结构和说明</span><br><span class="line"></span><br><span class="line">2.2.3 简单工厂示例代码</span><br><span class="line"></span><br><span class="line">2.2.4 使用简单工厂重写示例</span><br><span class="line"></span><br><span class="line">2.3 模式讲解</span><br><span class="line"></span><br><span class="line">2.3.1 典型疑问</span><br><span class="line"></span><br><span class="line">2.3.2 认识简单工厂</span><br><span class="line"></span><br><span class="line">2.3.3 简单工厂中方法的写法</span><br><span class="line"></span><br><span class="line">2.3.4 可配置的简单工厂</span><br><span class="line"></span><br><span class="line">2.3.5 简单工厂的优缺点</span><br><span class="line"></span><br><span class="line">2.3.6 思考简单工厂</span><br><span class="line"></span><br><span class="line">2.3.7 相关模式</span><br><span class="line"></span><br><span class="line">第3章 外观模式</span><br><span class="line"></span><br><span class="line">3.1 场景问题</span><br><span class="line"></span><br><span class="line">3.1.1 生活中的示例</span><br><span class="line"></span><br><span class="line">3.1.2 代码生成的应用</span><br><span class="line"></span><br><span class="line">3.1.3 不用模式的解决方案</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>用Python写网络爬虫 PDF</title>
    <url>/posts/e3f5cda0/</url>
    <content><![CDATA[<h4 id="《用Python写网络爬虫》"><a href="#《用Python写网络爬虫》" class="headerlink" title="《用Python写网络爬虫》"></a>《用Python写网络爬虫》</h4><h6 id="链接-https-pan-baidu-com-s-1RfU0ec096nUmIiRWM-D1SA-提取码-wm92"><a href="#链接-https-pan-baidu-com-s-1RfU0ec096nUmIiRWM-D1SA-提取码-wm92" class="headerlink" title="链接: https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA 提取码: wm92"></a>链接: <a href="https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA">https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA</a> 提取码: wm92</h6><p>《用Python写网络爬虫（第 2版》讲解了如何使用Python来编写网络爬虫程序，内容包括网络爬虫简介，从页面中抓取数据的3种方法，提取缓存中的数据，使用多个线程和进程进行并发抓取，抓取动态页面中的内容，与表单进行交互，处理页面中的验证码问题，以及使用Scarpy和Portia进行数据抓取，并在最后介绍了使用本书讲解的数据抓取技术对几个真实的网站进行抓取的实例，旨在帮助读者活学活用书中介绍的技术。<br><a id="more"></a></p>
<p>《用Python写网络爬虫（第 2版》适合有一定Python编程经验而且对爬虫技术感兴趣的读者阅读。</p>
<p><img src="/images/e8865005a7a07d78d3a0e61faec582c91.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 1章　网络爬虫简介 1</span><br><span class="line"></span><br><span class="line">1.1　网络爬虫何时有用　1</span><br><span class="line"></span><br><span class="line">1.2　网络爬虫是否合法　2</span><br><span class="line"></span><br><span class="line">1.3　Python 3　3</span><br><span class="line"></span><br><span class="line">1.4　背景调研　4</span><br><span class="line"></span><br><span class="line">1.4.1　检查robots.txt　4</span><br><span class="line"></span><br><span class="line">1.4.2　检查网站地图　5</span><br><span class="line"></span><br><span class="line">1.4.3　估算网站大小　6</span><br><span class="line"></span><br><span class="line">1.4.4　识别网站所用技术　7</span><br><span class="line"></span><br><span class="line">1.4.5　寻找网站所有者　9</span><br><span class="line"></span><br><span class="line">1.5　编写第 一个网络爬虫　11</span><br><span class="line"></span><br><span class="line">1.5.1　抓取与爬取的对比　11</span><br><span class="line"></span><br><span class="line">1.5.2　下载网页　12</span><br><span class="line"></span><br><span class="line">1.5.3　网站地图爬虫　15</span><br><span class="line"></span><br><span class="line">1.5.4　ID遍历爬虫　17</span><br><span class="line"></span><br><span class="line">1.5.5　链接爬虫　19</span><br><span class="line"></span><br><span class="line">1.5.6　使用requests库　28</span><br><span class="line"></span><br><span class="line">1.6　本章小结　30</span><br><span class="line"></span><br><span class="line">第　2章 数据抓取　31</span><br><span class="line"></span><br><span class="line">2.1　分析网页　32</span><br><span class="line"></span><br><span class="line">2.2　3种网页抓取方法　34</span><br><span class="line"></span><br><span class="line">2.2.1　正则表达式　35</span><br><span class="line"></span><br><span class="line">2.2.2　Beautiful Soup　37</span><br><span class="line"></span><br><span class="line">2.2.3　Lxml　39</span><br><span class="line"></span><br><span class="line">2.3　CSS选择器和浏览器控制台　41</span><br><span class="line"></span><br><span class="line">2.4　XPath选择器　43</span><br><span class="line"></span><br><span class="line">2.5　LXML和家族树　46</span><br><span class="line"></span><br><span class="line">2.6　性能对比　47</span><br><span class="line"></span><br><span class="line">2.7　抓取结果　49</span><br><span class="line"></span><br><span class="line">2.7.1　抓取总结　50</span><br><span class="line"></span><br><span class="line">2.7.2　为链接爬虫添加抓取回调　51</span><br><span class="line"></span><br><span class="line">2.8　本章小结　55</span><br><span class="line"></span><br><span class="line">第3章　下载缓存　56</span><br><span class="line"></span><br><span class="line">3.1　何时使用缓存　57</span><br><span class="line"></span><br><span class="line">3.2　为链接爬虫添加缓存支持　57</span><br><span class="line"></span><br><span class="line">3.3　磁盘缓存　60</span><br><span class="line"></span><br><span class="line">3.3.1　实现磁盘缓存　62</span><br><span class="line"></span><br><span class="line">3.3.2　缓存测试　64</span><br><span class="line"></span><br><span class="line">3.3.3　节省磁盘空间　65</span><br><span class="line"></span><br><span class="line">3.3.4　清理过期数据　66</span><br><span class="line"></span><br><span class="line">3.3.5　磁盘缓存缺点　68</span><br><span class="line"></span><br><span class="line">3.4　键值对存储缓存　69</span><br><span class="line"></span><br><span class="line">3.4.1　键值对存储是什么　69</span><br><span class="line"></span><br><span class="line">3.4.2　安装Redis　70</span><br><span class="line"></span><br><span class="line">3.4.3　Redis概述　71</span><br><span class="line"></span><br><span class="line">3.4.4　Redis缓存实现　72</span><br><span class="line"></span><br><span class="line">3.4.5　压缩　74</span><br><span class="line"></span><br><span class="line">3.4.6　测试缓存　75</span><br><span class="line"></span><br><span class="line">3.4.7　探索requests-cache　76</span><br><span class="line"></span><br><span class="line">3.5　本章小结　78</span><br><span class="line"></span><br><span class="line">第4章　并发下载　79</span><br><span class="line"></span><br><span class="line">4.1　100万个网页　79</span><br><span class="line"></span><br><span class="line">4.2　串行爬虫　82</span><br><span class="line"></span><br><span class="line">4.3　多线程爬虫　83</span><br><span class="line"></span><br><span class="line">4.4　线程和进程如何工作　83</span><br><span class="line"></span><br><span class="line">4.4.1　实现多线程爬虫　84</span><br><span class="line"></span><br><span class="line">4.4.2　多进程爬虫　87</span><br><span class="line"></span><br><span class="line">4.5　性能　91</span><br><span class="line"></span><br><span class="line">4.6　本章小结　94</span><br><span class="line"></span><br><span class="line">第5章　动态内容　95</span><br><span class="line"></span><br><span class="line">5.1　动态网页示例　95</span><br><span class="line"></span><br><span class="line">5.2　对动态网页进行逆向工程　98</span><br><span class="line"></span><br><span class="line">5.3　渲染动态网页　104</span><br><span class="line"></span><br><span class="line">5.3.1　PyQt还是PySide　105</span><br><span class="line"></span><br><span class="line">5.3.2　执行JavaScript　106</span><br><span class="line"></span><br><span class="line">5.3.3　使用WebKit与网站交互　108</span><br><span class="line"></span><br><span class="line">5.4　渲染类　111</span><br><span class="line"></span><br><span class="line">5.5　本章小结　117</span><br><span class="line"></span><br><span class="line">第6章　表单交互　119</span><br><span class="line"></span><br><span class="line">6.1　登录表单　120</span><br><span class="line"></span><br><span class="line">6.2　支持内容更新的登录脚本扩展　128</span><br><span class="line"></span><br><span class="line">6.3　使用Selenium实现自动化表单处理　132</span><br><span class="line"></span><br><span class="line">6.4　本章小结　135</span><br><span class="line"></span><br><span class="line">第7章　验证码处理　136</span><br><span class="line"></span><br><span class="line">7.1　注册账号　137</span><br><span class="line"></span><br><span class="line">7.2　光学字符识别　140</span><br><span class="line"></span><br><span class="line">7.3　处理复杂验证码　144</span><br><span class="line"></span><br><span class="line">7.4　使用验证码处理服务　144</span><br><span class="line"></span><br><span class="line">7.4.1　9kw入门　145</span><br><span class="line"></span><br><span class="line">7.4.2　报告错误　150</span><br><span class="line"></span><br><span class="line">7.4.3　与注册功能集成　151</span><br><span class="line"></span><br><span class="line">7.5　验证码与机器学习　153</span><br><span class="line"></span><br><span class="line">7.6　本章小结　153</span><br><span class="line"></span><br><span class="line">第8章　Scrapy　154</span><br><span class="line"></span><br><span class="line">8.1　安装Scrapy　154</span><br><span class="line"></span><br><span class="line">8.2　启动项目　155</span><br><span class="line"></span><br><span class="line">8.2.1　定义模型　156</span><br><span class="line"></span><br><span class="line">8.2.2　创建爬虫　157</span><br><span class="line"></span><br><span class="line">8.3　不同的爬虫类型　162</span><br><span class="line"></span><br><span class="line">8.4　使用shell命令抓取　163</span><br><span class="line"></span><br><span class="line">8.4.1　检查结果　165</span><br><span class="line"></span><br><span class="line">8.4.2　中断与恢复爬虫　167</span><br><span class="line"></span><br><span class="line">8.5　使用Portia编写可视化爬虫　170</span><br><span class="line"></span><br><span class="line">8.5.1　安装　170</span><br><span class="line"></span><br><span class="line">8.5.2　标注　172</span><br><span class="line"></span><br><span class="line">8.5.3　运行爬虫　176</span><br><span class="line"></span><br><span class="line">8.5.4　检查结果　176</span><br><span class="line"></span><br><span class="line">8.6　使用Scrapely实现自动化抓取　177</span><br><span class="line"></span><br><span class="line">8.7　本章小结　178</span><br><span class="line"></span><br><span class="line">第9章　综合应用　179</span><br><span class="line"></span><br><span class="line">9.1　Google搜索引擎　179</span><br><span class="line"></span><br><span class="line">9.2　Facebook　184</span><br><span class="line"></span><br><span class="line">9.2.1　网站　184</span><br><span class="line"></span><br><span class="line">9.2.2　Facebook API　186</span><br><span class="line"></span><br><span class="line">9.3　Gap　188</span><br><span class="line"></span><br><span class="line">9.4　宝马　192</span><br><span class="line"></span><br><span class="line">9.5　本章小结　196</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>浙江大学概率论与数理统计(第四版) PDF</title>
    <url>/posts/94f2fd36/</url>
    <content><![CDATA[<h4 id="《浙江大学概率论与数理统计-第四版-》"><a href="#《浙江大学概率论与数理统计-第四版-》" class="headerlink" title="《浙江大学概率论与数理统计(第四版)》"></a>《浙江大学概率论与数理统计(第四版)》</h4><h6 id="链接-https-pan-baidu-com-s-1MqI-2Ch2Hqbw25yib00u1g-提取码-zeda"><a href="#链接-https-pan-baidu-com-s-1MqI-2Ch2Hqbw25yib00u1g-提取码-zeda" class="headerlink" title="链接: https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g 提取码: zeda"></a>链接: <a href="https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g">https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g</a> 提取码: zeda</h6><p>内容简介<br><a id="more"></a></p>
<p> 《概率论与数理统计(第4版)》是普通高等教育“十一五”国家级规划教材，在2001年出版的《概率论与数理统计(第4版)》（第三版）的基础上增订而成。本次修订新增的内容有：在数理统计中应用Excel，bootstrap方法，户值检验法，箱线图等；同时吸收了国内外优秀教材的优点对习题的类型和数量进行了调整和充实。</p>
<p>《概率论与数理统计(第4版)》主要内容包括概率论、数理统计、随机过程三部分，每章附有习题；同时涵盖了《全国硕士研究生入学统一考试数学考试大纲》的所有知识点。《概率论与数理统计(第4版)》可作为高等学校工科、理科（非数学专业）各专业的教材和研究生入学考试的参考书，也可供工程技术人员、科技工作者参考。</p>
<p>《概率论与数理统计习题全解指南(浙大•第4版)》是浙江大学盛骤等编的《概率论与数理统计(第4版)》的配套辅导书，全书按照主教材的要求和章节顺序进行编排，与主教材习题一致。《概率论与数理统计习题全解指南(浙大•第4版)》对教材的全部300多道题目都给出了解答，少数题目是一题多解，有些作了题目分析、解题思路分析和解题方法归纳，并指出易犯的错误，究其原因，澄清不正确的想法。通过《概率论与数理统计习题全解指南(浙大•第4版)》的学习，可使读者提高分析问题和解题的能力，加深对基本内容的理解和掌握。可作为理工科和其他非数学类专业的学生学习概率论与数理统计的参考书。</p>
<p><img src="/images/f0d91efa89408be1a598c24f7380088b1.jpg" width="50%" height="50%"></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++编程规范-101条规则准则与最佳实践 PDF</title>
    <url>/posts/dfbac8c/</url>
    <content><![CDATA[<h4 id="《C-编程规范-101条规则准则与最佳实践》"><a href="#《C-编程规范-101条规则准则与最佳实践》" class="headerlink" title="《C++编程规范-101条规则准则与最佳实践》"></a>《C++编程规范-101条规则准则与最佳实践》</h4><h6 id="链接-https-pan-baidu-com-s-1pnMnVgmU6MYcxz7CSYyx7g-提取码-ufnu"><a href="#链接-https-pan-baidu-com-s-1pnMnVgmU6MYcxz7CSYyx7g-提取码-ufnu" class="headerlink" title="链接: https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g 提取码: ufnu"></a>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> 提取码: ufnu</h6><p>　在《C++编程规范：101条规则、准则与实践》中，两位知名的C++专家将全球C++界20年的集体智慧和经验凝结成一套编程规范。这些规范可以作为每一个开发团队制定实际开发规范的基础，更是每一位C++程序员应该遵循的行事准则。书中对每一条规范都给出了描述，并辅以实例说明；从类型定义到错误处理，都给出了C++实践，即使使用C++多年的程序员也会从本书中受益匪浅。<br><a id="more"></a></p>
<p><img src="/images/b02e670f24bc518ae5d114f57531db321.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第0条　不要拘泥于小节(又名：了解哪些东西不应该标准化)　2</span><br><span class="line"></span><br><span class="line">第1条　在高警告级别干净利落地进行编译　4</span><br><span class="line"></span><br><span class="line">第2条　使用自动构建系统　7</span><br><span class="line"></span><br><span class="line">第3条　使用版本控制系统　8</span><br><span class="line"></span><br><span class="line">第4条　做代码审查　9设计风格　11</span><br><span class="line"></span><br><span class="line">第5条　一个实体应该只有一个紧凑的职责　12</span><br><span class="line"></span><br><span class="line">第6条　正确、简单和清晰第一　13</span><br><span class="line"></span><br><span class="line">第7条　编程中应知道何时和如何考虑可伸缩性　14</span><br><span class="line"></span><br><span class="line">第8条　不要进行不成熟的优化　16</span><br><span class="line"></span><br><span class="line">第9条　不要进行不成熟的劣化　18</span><br><span class="line"></span><br><span class="line">第10条　尽量减少全局和共享数据　19</span><br><span class="line"></span><br><span class="line">第11条　隐藏信息　20</span><br><span class="line"></span><br><span class="line">第12条　懂得何时和如何进行并发性编程　21</span><br><span class="line"></span><br><span class="line">第13条　确保资源为对象所拥有。使用显式的RAII和智能指针　24</span><br><span class="line"></span><br><span class="line">编程风格　27</span><br><span class="line"></span><br><span class="line">第14条　宁要编译时和连接时错误，也不要运行时错误　28</span><br><span class="line"></span><br><span class="line">第15条　积极使用const　30</span><br><span class="line"></span><br><span class="line">第16条　避免使用宏　32</span><br><span class="line"></span><br><span class="line">第17条　避免使用“魔数”　34</span><br><span class="line"></span><br><span class="line">第18条　尽可能局部地声明变量　35</span><br><span class="line"></span><br><span class="line">第19条　总是初始化变量　36</span><br><span class="line"></span><br><span class="line">第20条　避免函数过长，避免嵌套过深　38</span><br><span class="line"></span><br><span class="line">第21条　避免跨编译单元的初始化依赖　39</span><br><span class="line"></span><br><span class="line">第22条　尽量减少定义性依赖。避免循环依赖　40</span><br><span class="line"></span><br><span class="line">第23条　头文件应该自给自足　42</span><br><span class="line"></span><br><span class="line">第24条　总是编写内部#include保护符，决不要编写外部#include保护符　43</span><br><span class="line"></span><br><span class="line">函数与操作符　45</span><br><span class="line"></span><br><span class="line">第25条　正确地选择通过值、(智能)指针或者引用传递参数　46</span><br><span class="line"></span><br><span class="line">第26条　保持重载操作符的自然语义　47</span><br><span class="line"></span><br><span class="line">第27条　优先使用算术操作符和赋值操作符的标准形式　48</span><br><span class="line"></span><br><span class="line">第28条　优先使用++和--的标准形式。优先调用前缀形式　50</span><br><span class="line"></span><br><span class="line">第29条　考虑重载以避免隐含类型转换　51</span><br><span class="line"></span><br><span class="line">第30条　避免重载&amp;&amp;、||或　，(逗号)　52</span><br><span class="line"></span><br><span class="line">第31条　不要编写依赖于函数参数求值顺序的代码　54</span><br><span class="line"></span><br><span class="line">类的设计与继承　55</span><br><span class="line"></span><br><span class="line">第32条　弄清所要编写的是哪种类　56</span><br><span class="line"></span><br><span class="line">第33条　用小类代替巨类　57</span><br><span class="line"></span><br><span class="line">第34条　用组合代替继承　58</span><br><span class="line"></span><br><span class="line">第35条　避免从并非要设计成基类的类中继承　60</span><br><span class="line"></span><br><span class="line">第36条　优先提供抽象接口　62</span><br><span class="line"></span><br><span class="line">第37条　公用继承即可替换性。继承，不是为了重用，而是为了被重用　64</span><br><span class="line"></span><br><span class="line">第38条　实施安全的覆盖　66</span><br><span class="line"></span><br><span class="line">第39条　考虑将虚拟函数声明为非公用的，将公用函数声明为非虚拟的　68</span><br><span class="line"></span><br><span class="line">第40条　要避免提供隐式转换　70</span><br><span class="line"></span><br><span class="line">第41条　将数据成员设为私有的，无行为的聚集(C语言形式的struct)除外　72</span><br><span class="line"></span><br><span class="line">第42条　不要公开内部数据　74</span><br><span class="line"></span><br><span class="line">第43条　明智地使用Pimpl　76</span><br><span class="line"></span><br><span class="line">第44条　优先编写非成员非友元函数　79</span><br><span class="line"></span><br><span class="line">第45条　总是一起提供new和delete　80</span><br><span class="line"></span><br><span class="line">第46条　如果提供类专门的new，应该提供所有标准形式(普通、就地和不抛出)　82</span><br><span class="line"></span><br><span class="line">构造、析构与复制　85</span><br><span class="line"></span><br><span class="line">第47条　以同样的顺序定义和初始化成员变量　86</span><br><span class="line"></span><br><span class="line">第48条　在构造函数中用初始化代替赋值　87</span><br><span class="line"></span><br><span class="line">第49条　避免在构造函数和析构函数中调用虚拟函数　88</span><br><span class="line"></span><br><span class="line">第50条　将基类析构函数设为公用且虚拟的，或者保护且非虚拟的　90</span><br><span class="line"></span><br><span class="line">第51条　析构函数、释放和交换绝对不能失败　92</span><br><span class="line"></span><br><span class="line">第52条　一致地进行复制和销毁　94</span><br><span class="line"></span><br><span class="line">第53条　显式地启用或者禁止复制　95</span><br><span class="line"></span><br><span class="line">第54条　避免切片。在基类中考虑用克隆代替复制　96</span><br><span class="line"></span><br><span class="line">第55条　使用赋值的标准形式　99</span><br><span class="line"></span><br><span class="line">第56条　只要可行，就提供不会失败的swap(而且要正确地提供)　100</span><br><span class="line"></span><br><span class="line">名字空间与模块　103</span><br><span class="line"></span><br><span class="line">第57条　将类型及其非成员函数接口置于同一名字空间中　104</span><br><span class="line"></span><br><span class="line">第58条　应该将类型和函数分别置于不同的名字空间中，除非有意想让它们一起工作　106</span><br><span class="line"></span><br><span class="line">第59条　不要在头文件中或者#include之前编写名字空间using　108</span><br><span class="line"></span><br><span class="line">第60条　要避免在不同的模块中分配和释放内存　111</span><br><span class="line"></span><br><span class="line">第61条　不要在头文件中定义具有链接的实体　112</span><br><span class="line"></span><br><span class="line">第62条　不要允许异常跨越模块边界传播　114</span><br><span class="line"></span><br><span class="line">第63条　在模块的接口中使用具有良好可移植性的类型　116</span><br><span class="line"></span><br><span class="line">模板与泛型　119</span><br><span class="line"></span><br><span class="line">第64条　理智地结合静态多态性和动态多态性　120</span><br><span class="line"></span><br><span class="line">第65条　有意地进行显式自定义　122</span><br><span class="line"></span><br><span class="line">第66条　不要特化函数模板　126</span><br><span class="line"></span><br><span class="line">第67条　不要无意地编写不通用的代码　128</span><br><span class="line"></span><br><span class="line">错误处理与异常　129</span><br><span class="line"></span><br><span class="line">第68条　广泛地使用断言记录内部假设和不变式　130</span><br><span class="line"></span><br><span class="line">第69条　建立合理的错误处理策略，并严格遵守　132</span><br><span class="line"></span><br><span class="line">第70条　区别错误与非错误　134</span><br><span class="line"></span><br><span class="line">第71条　设计和编写错误安全代码　137</span><br><span class="line"></span><br><span class="line">第72条　优先使用异常报告错误　140</span><br><span class="line"></span><br><span class="line">第73条　通过值抛出，通过引用捕获　144</span><br><span class="line"></span><br><span class="line">第74条　正确地报告、处理和转换错误　145</span><br><span class="line"></span><br><span class="line">第75条　避免使用异常规范　146</span><br><span class="line"></span><br><span class="line">STL：容器　149</span><br><span class="line"></span><br><span class="line">第76条　默认时使用vector。否则，选择其他合适的容器　150</span><br><span class="line"></span><br><span class="line">第77条　用vector和string代替数组　152</span><br><span class="line"></span><br><span class="line">第78条　使用vector(和string：：c_str)与非C++ API交换数据　153</span><br><span class="line"></span><br><span class="line">第79条　在容器中只存储值和智能指针　154</span><br><span class="line"></span><br><span class="line">第80条　用push_back代替其他扩展序列的方式　155</span><br><span class="line"></span><br><span class="line">第81条　多用范围操作，少用单元素操作　156</span><br><span class="line"></span><br><span class="line">第82条　使用公认的惯用法真正地压缩容量，真正地删除元素　157</span><br><span class="line"></span><br><span class="line">STL：算法　159</span><br><span class="line"></span><br><span class="line">第83条　使用带检查的STL实现　160</span><br><span class="line"></span><br><span class="line">第84条　用算法调用代替手工编写的循环　162</span><br><span class="line"></span><br><span class="line">第85条　使用正确的STL查找算法　165</span><br><span class="line"></span><br><span class="line">第86条　使用正确的STL排序算法　166</span><br><span class="line"></span><br><span class="line">第87条　使谓词成为纯函数　168</span><br><span class="line"></span><br><span class="line">第88条　算法和比较器的参数应多用函数对象少用函数　170</span><br><span class="line"></span><br><span class="line">第89条　正确编写函数对象　172</span><br><span class="line"></span><br><span class="line">类型安全　173</span><br><span class="line"></span><br><span class="line">第90条　避免使用类型分支，多使用多态　174</span><br><span class="line"></span><br><span class="line">第91条　依赖类型，而非其表示方式　176</span><br><span class="line"></span><br><span class="line">第92条　避免使用reinterpret_cast　177</span><br><span class="line"></span><br><span class="line">第93条　避免对指针使用static_cast　178</span><br><span class="line"></span><br><span class="line">第94条　避免强制转换const　179</span><br><span class="line"></span><br><span class="line">第95条　不要使用C风格的强制转换　180</span><br><span class="line"></span><br><span class="line">第96条　不要对非POD进行memcpy操作或者memcmp操作　182</span><br><span class="line"></span><br><span class="line">第97条　不要使用联合重新解释表示方式　183</span><br><span class="line"></span><br><span class="line">第98条　不要使用可变长参数(．．．)　184</span><br><span class="line"></span><br><span class="line">第99条　不要使用失效对象。不要使用不安全函数　185</span><br><span class="line"></span><br><span class="line">第100条　不要多态地处理数组　186</span><br><span class="line"></span><br><span class="line">参考文献　187</span><br><span class="line"></span><br><span class="line">摘要汇总　193</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++编程思想两卷合订本 PDF</title>
    <url>/posts/7afc9c1a/</url>
    <content><![CDATA[<h4 id="《C-编程思想两卷合订本》"><a href="#《C-编程思想两卷合订本》" class="headerlink" title="《C++编程思想两卷合订本》"></a>《C++编程思想两卷合订本》</h4><h6 id="链接-https-pan-baidu-com-s-1wo34avVpOBBx2WA6sEubrA-提取码-fxis"><a href="#链接-https-pan-baidu-com-s-1wo34avVpOBBx2WA6sEubrA-提取码-fxis" class="headerlink" title="链接: https://pan.baidu.com/s/1wo34avVpOBBx2WA6sEubrA 提取码: fxis"></a>链接: <a href="https://pan.baidu.com/s/1wo34avVpOBBx2WA6sEubrA">https://pan.baidu.com/s/1wo34avVpOBBx2WA6sEubrA</a> 提取码: fxis</h6><p>《c++编程思想（两卷合订本）》曾荣获美国《软件开发》杂志评选的1996年jolt生产力大奖，中文版自2000年推出以来，经久不衰，获得了读者的充分肯定和高度评价。<br><a id="more"></a></p>
<p>　　《c++编程思想（两卷合订本）》的第1卷是在第1版的基础上进行了更加深入的分析和修改后得到的第2版，其内容更加集中，可以供不同程度的读者选择阅读。本书第2卷介绍了c++实用的编程技术和**的实践方法，深入探究了异常处理方法和异常安全设计；介绍c++的字符串、输入输出流的现代用法；解释多重继承问题的难点，描述了典型的设计模式及其实现，特别介绍了多线程处理编程技术。</p>
<p>　　《c++编程思想（两卷合订本）》是c++领域内一本专业的著作，书中的内容、讲授方法、练习既适合课堂教学，又适合读者自学。本书适合作为高等院校计算机及相关专业的本科生、研究生的教材，也可供从事软件开发的研究人员和科技工作者参考。</p>
<p><img src="/images/ebdda78653c183748766050975094ba21.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1卷 标准c++导引</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第1章 对象导言</span><br><span class="line"></span><br><span class="line">1.1 抽象的过程</span><br><span class="line"></span><br><span class="line">1.2 对象有一个接口</span><br><span class="line"></span><br><span class="line">1.3 实现的隐藏</span><br><span class="line"></span><br><span class="line">1.4 实现的重用</span><br><span class="line"></span><br><span class="line">1.5 继承：重用接口</span><br><span class="line"></span><br><span class="line">1.5.1 is-a 关系和is-like-a 关系</span><br><span class="line"></span><br><span class="line">1.6 具有多态性的可互换对象</span><br><span class="line"></span><br><span class="line">1.7 创建和销毁对象</span><br><span class="line"></span><br><span class="line">1.8 异常处理：应对错误</span><br><span class="line"></span><br><span class="line">1.9 分析和设计</span><br><span class="line"></span><br><span class="line">1.9.1 第0阶段：制定计划</span><br><span class="line"></span><br><span class="line">1.9.2 第1阶段：我们在做什么</span><br><span class="line"></span><br><span class="line">1.9.3 第2阶段：我们将如何建立对象</span><br><span class="line"></span><br><span class="line">1.9.4 第3阶段：创建核心</span><br><span class="line"></span><br><span class="line">1.9.5 第4阶段：迭代用例</span><br><span class="line"></span><br><span class="line">1.9.6 第5阶段：进化</span><br><span class="line"></span><br><span class="line">1.9.7 计划的回报</span><br><span class="line"></span><br><span class="line">1.10 极限编程</span><br><span class="line"></span><br><span class="line">1.10.1 先写测试</span><br><span class="line"></span><br><span class="line">1.10.2 结对编程</span><br><span class="line"></span><br><span class="line">1.11 为什么c++会成功</span><br><span class="line"></span><br><span class="line">1.11.1 一个较好的c</span><br><span class="line"></span><br><span class="line">1.11.2 延续式的学习过程</span><br><span class="line"></span><br><span class="line">1.11.3 效率</span><br><span class="line"></span><br><span class="line">1.11.4 系统更容易表达和理解</span><br><span class="line"></span><br><span class="line">1.11.5 尽量使用库</span><br><span class="line"></span><br><span class="line">1.11.6 利用模板的源代码重用</span><br><span class="line"></span><br><span class="line">1.11.7 错误处理</span><br><span class="line"></span><br><span class="line">1.11.8 大型程序设计</span><br><span class="line"></span><br><span class="line">1.12 为向oop转变而采取的策略</span><br><span class="line"></span><br><span class="line">1.12.1 指导方针</span><br><span class="line"></span><br><span class="line">1.12.2 管理的障碍</span><br><span class="line"></span><br><span class="line">1.13 小结</span><br><span class="line"></span><br><span class="line">第2章 对象的创建与使用</span><br><span class="line"></span><br><span class="line">2.1 语言的翻译过程</span><br><span class="line"></span><br><span class="line">2.1.1 解释器</span><br><span class="line"></span><br><span class="line">2.1.2 编译器</span><br><span class="line"></span><br><span class="line">2.1.3 编译过程</span><br><span class="line"></span><br><span class="line">2.2 分段编译工具</span><br><span class="line"></span><br><span class="line">2.2.1 声明与定义</span><br><span class="line"></span><br><span class="line">2.2.2 连接</span><br><span class="line"></span><br><span class="line">2.2.3 使用库文件</span><br><span class="line"></span><br><span class="line">2.3 编写第一个c++程序</span><br><span class="line"></span><br><span class="line">2.3.1 使用iostream类</span><br><span class="line"></span><br><span class="line">2.3.2 名字空间</span><br><span class="line"></span><br><span class="line">2.3.3 程序的基本结构</span><br><span class="line"></span><br><span class="line">2.3.4 “hello， world！”</span><br><span class="line"></span><br><span class="line">2.3.5 运行编译器</span><br><span class="line"></span><br><span class="line">2.4 关于输入输出流</span><br><span class="line"></span><br><span class="line">2.4.1 字符数组的拼接</span><br><span class="line"></span><br><span class="line">2.4.2 读取输入数据</span><br><span class="line"></span><br><span class="line">2.4.3 调用其他程序</span><br><span class="line"></span><br><span class="line">2.5 字符串简介</span><br><span class="line"></span><br><span class="line">2.6 文件的读写</span><br><span class="line"></span><br><span class="line">2.7 vector简介</span><br><span class="line"></span><br><span class="line">2.8 小结</span><br><span class="line"></span><br><span class="line">2.9 练习</span><br><span class="line"></span><br><span class="line">第3章 c++中的c</span><br><span class="line"></span><br><span class="line">3.1 创建函数</span><br><span class="line"></span><br><span class="line">3.1.1 函数的返回值</span><br><span class="line"></span><br><span class="line">3.1.2 使用c的函数库</span><br><span class="line"></span><br><span class="line">3.1.3 通过库管理器创建自己的库</span><br><span class="line"></span><br><span class="line">3.2 执行控制语句</span><br><span class="line"></span><br><span class="line">3.2.1 真和假</span><br><span class="line"></span><br><span class="line">3.2.2 if-else语句</span><br><span class="line"></span><br><span class="line">3.2.3 while语句</span><br><span class="line"></span><br><span class="line">3.2.4 do-while语句</span><br><span class="line"></span><br><span class="line">3.2.5 for语句</span><br><span class="line"></span><br><span class="line">3.2.6 关键字break 和 continue</span><br><span class="line"></span><br><span class="line">3.2.7 switch语句</span><br><span class="line"></span><br><span class="line">3.2.8 使用和滥用goto</span><br><span class="line"></span><br><span class="line">3.2.9 递归</span><br><span class="line"></span><br><span class="line">3.3 运算符简介</span><br><span class="line"></span><br><span class="line">3.3.1 优先级</span><br><span class="line"></span><br><span class="line">3.3.2 自增和自减</span><br><span class="line"></span><br><span class="line">3.4 数据类型简介</span><br><span class="line"></span><br><span class="line">3.4.1 基本内建类型</span><br><span class="line"></span><br><span class="line">3.4.2 bool类型与true和false</span><br><span class="line"></span><br><span class="line">3.4.3 说明符</span><br><span class="line"></span><br><span class="line">3.4.4 指针简介</span><br><span class="line"></span><br><span class="line">3.4.5 修改外部对象</span><br><span class="line"></span><br><span class="line">3.4.6 c++引用简介</span><br><span class="line"></span><br><span class="line">3.4.7 用指针和引用作为修饰符</span><br><span class="line"></span><br><span class="line">3.5 作用域</span><br><span class="line"></span><br><span class="line">3.5.1 实时定义变量</span><br><span class="line"></span><br><span class="line">3.6 指定存储空间分配</span><br><span class="line"></span><br><span class="line">3.6.1 全局变量</span><br><span class="line"></span><br><span class="line">3.6.2 局部变量</span><br><span class="line"></span><br><span class="line">3.6.3 静态变量</span><br><span class="line"></span><br><span class="line">3.6.4 外部变量</span><br><span class="line"></span><br><span class="line">3.6.5 常量</span><br><span class="line"></span><br><span class="line">3.6.6 volatile变量</span><br><span class="line"></span><br><span class="line">3.7 运算符及其使用</span><br><span class="line"></span><br><span class="line">3.7.1 赋值</span><br><span class="line"></span><br><span class="line">3.7.2 数学运算符</span><br><span class="line"></span><br><span class="line">3.7.3 关系运算符</span><br><span class="line"></span><br><span class="line">3.7.4 逻辑运算符</span><br><span class="line"></span><br><span class="line">3.7.5 位运算符</span><br><span class="line"></span><br><span class="line">3.7.6 移位运算符</span><br><span class="line"></span><br><span class="line">3.7.7 一元运算符</span><br><span class="line"></span><br><span class="line">3.7.8 三元运算符</span><br><span class="line"></span><br><span class="line">3.7.9 逗号运算符</span><br><span class="line"></span><br><span class="line">3.7.10 使用运算符时的常见问题</span><br><span class="line"></span><br><span class="line">3.7.11 转换运算符</span><br><span class="line"></span><br><span class="line">3.7.12 c++的显式转换</span><br><span class="line"></span><br><span class="line">3.7.13 sizeof-独立运算符</span><br><span class="line"></span><br><span class="line">3.7.14 asm 关键字</span><br><span class="line"></span><br><span class="line">3.7.15 显式运算符</span><br><span class="line"></span><br><span class="line">3.8 创建复合类型</span><br><span class="line"></span><br><span class="line">3.8.1 用typedef命名别名</span><br><span class="line"></span><br><span class="line">3.8.2 用struct把变量结合在一起</span><br><span class="line"></span><br><span class="line">3.8.3 用enum提高程度清晰度</span><br><span class="line"></span><br><span class="line">3.8.4 用union节省内存</span><br><span class="line"></span><br><span class="line">3.8.5 数组</span><br><span class="line"></span><br><span class="line">3.9 调试技巧</span><br><span class="line"></span><br><span class="line">3.9.1 调试标记</span><br><span class="line"></span><br><span class="line">3.9.2 把变量和表达式转换成字符串</span><br><span class="line"></span><br><span class="line">3.9.3 c语言assert（ ）宏</span><br><span class="line"></span><br><span class="line">3.10 函数地址</span><br><span class="line"></span><br><span class="line">3.10.1 定义函数指针</span><br><span class="line"></span><br><span class="line">3.10.2 复杂的声明和定义</span><br><span class="line"></span><br><span class="line">3.10.3 使用函数指针</span><br><span class="line"></span><br><span class="line">3.10.4 指向函数的指针数组</span><br><span class="line"></span><br><span class="line">3.11 make：管理分段编译</span><br><span class="line"></span><br><span class="line">3.11.1 make的行为</span><br><span class="line"></span><br><span class="line">3.11.2 本书中的makefile</span><br><span class="line"></span><br><span class="line">3.11.3 makefile的一个例子</span><br><span class="line"></span><br><span class="line">3.12 小结</span><br><span class="line"></span><br><span class="line">3.13 练习</span><br><span class="line"></span><br><span class="line">第4章 数据抽象</span><br><span class="line"></span><br><span class="line">4.1 一个袖珍c库</span><br><span class="line"></span><br><span class="line">4.1.1 动态存储分配</span><br><span class="line"></span><br><span class="line">4.1.2 有害的猜测</span><br><span class="line"></span><br><span class="line">4.2 哪儿出问题</span><br><span class="line"></span><br><span class="line">4.3 基本对象</span><br><span class="line"></span><br><span class="line">4.4 什么是对象</span><br><span class="line"></span><br><span class="line">4.5 抽象数据类型</span><br><span class="line"></span><br><span class="line">4.6 对象细节</span><br><span class="line"></span><br><span class="line">4.7 头文件形式</span><br><span class="line"></span><br><span class="line">4.7.1 头文件的重要性</span><br><span class="line"></span><br><span class="line">4.7.2 多次声明问题</span><br><span class="line"></span><br><span class="line">4.7.3 预处理器指示#define、#ifdef</span><br><span class="line"></span><br><span class="line">和#endif</span><br><span class="line"></span><br><span class="line">4.7.4 头文件的标准</span><br><span class="line"></span><br><span class="line">4.7.5 头文件中的名字空间</span><br><span class="line"></span><br><span class="line">4.7.6 在项目中使用头文件</span><br><span class="line"></span><br><span class="line">4.8 嵌套结构</span><br><span class="line"></span><br><span class="line">4.8.1 全局作用域解析</span><br><span class="line"></span><br><span class="line">4.9 小结</span><br><span class="line"></span><br><span class="line">4.10 练习</span><br><span class="line"></span><br><span class="line">第5章 隐藏实现</span><br><span class="line"></span><br><span class="line">5.1 设置限制</span><br><span class="line"></span><br><span class="line">5.2 c++的访问控制</span><br><span class="line"></span><br><span class="line">5.2.1 protected说明符</span><br><span class="line"></span><br><span class="line">5.3 友元</span><br><span class="line"></span><br><span class="line">5.3.1 嵌套友元</span><br><span class="line"></span><br><span class="line">5.3.2 它是纯面向对象的吗</span><br><span class="line"></span><br><span class="line">5.4 对象布局</span><br><span class="line"></span><br><span class="line">5.5 类</span><br><span class="line"></span><br><span class="line">5.5.1 用访问控制来修改stash</span><br><span class="line"></span><br><span class="line">5.5.2 用访问控制来修改stack</span><br><span class="line"></span><br><span class="line">5.6 句柄类</span><br><span class="line"></span><br><span class="line">5.6.1 隐藏实现</span><br><span class="line"></span><br><span class="line">5.6.2 减少重复编译</span><br><span class="line"></span><br><span class="line">5.7 小结</span><br><span class="line"></span><br><span class="line">5.8 练习</span><br><span class="line"></span><br><span class="line">第6章 初始化与清除</span><br><span class="line"></span><br><span class="line">6.1 用构造函数确保初始化</span><br><span class="line"></span><br><span class="line">6.2 用析构函数确保清除</span><br><span class="line"></span><br><span class="line">6.3 清除定义块</span><br><span class="line"></span><br><span class="line">6.3.1 for循环</span><br><span class="line"></span><br><span class="line">6.3.2 内存分配</span><br><span class="line"></span><br><span class="line">6.4 带有构造函数和析构函数的stash</span><br><span class="line"></span><br><span class="line">6.5 带有构造函数和析构函数的stack</span><br><span class="line"></span><br><span class="line">6.6 聚合初始化</span><br><span class="line"></span><br><span class="line">6.7 默认构造函数</span><br><span class="line"></span><br><span class="line">6.8 小结</span><br><span class="line"></span><br><span class="line">6.9 练习</span><br><span class="line"></span><br><span class="line">第7章 函数重载与默认参数</span><br><span class="line"></span><br><span class="line">7.1 名字修饰</span><br><span class="line"></span><br><span class="line">7.1.1 用返回值重载</span><br><span class="line"></span><br><span class="line">7.1.2 类型安全连接</span><br><span class="line"></span><br><span class="line">7.2 重载的例子</span><br><span class="line"></span><br><span class="line">7.3 联合</span><br><span class="line"></span><br><span class="line">7.4 默认参数</span><br><span class="line"></span><br><span class="line">7.4.1 占位符参数</span><br><span class="line"></span><br><span class="line">7.5 选择重载还是默认参数</span><br><span class="line"></span><br><span class="line">7.6 小结</span><br><span class="line"></span><br><span class="line">7.7 练习</span><br><span class="line"></span><br><span class="line">第8章 常量</span><br><span class="line"></span><br><span class="line">8.1 值替代</span><br><span class="line"></span><br><span class="line">8.1.1 头文件里的const</span><br><span class="line"></span><br><span class="line">8.1.2 const的安全性</span><br><span class="line"></span><br><span class="line">8.1.3 聚合</span><br><span class="line"></span><br><span class="line">8.1.4 与c语言的区别</span><br><span class="line"></span><br><span class="line">8.2 指针</span><br><span class="line"></span><br><span class="line">8.2.1 指向const的指针</span><br><span class="line"></span><br><span class="line">8.2.2 const指针</span><br><span class="line"></span><br><span class="line">8.2.3 赋值和类型检查</span><br><span class="line"></span><br><span class="line">8.3 函数参数和返回值</span><br><span class="line"></span><br><span class="line">8.3.1 传递const值</span><br><span class="line"></span><br><span class="line">8.3.2 返回const值</span><br><span class="line"></span><br><span class="line">8.3.3 传递和返回地址</span><br><span class="line"></span><br><span class="line">8.4 类</span><br><span class="line"></span><br><span class="line">8.4.1 类里的const</span><br><span class="line"></span><br><span class="line">8.4.2 编译期间类里的常量</span><br><span class="line"></span><br><span class="line">8.4.3 const对象和成员函数</span><br><span class="line"></span><br><span class="line">8.5 volatile</span><br><span class="line"></span><br><span class="line">8.6 小结</span><br><span class="line"></span><br><span class="line">8.7 练习</span><br><span class="line"></span><br><span class="line">第9章 内联函数</span><br><span class="line"></span><br><span class="line">9.1 预处理器的缺陷</span><br><span class="line"></span><br><span class="line">9.1.1 宏和访问</span><br><span class="line"></span><br><span class="line">9.2 内联函数</span><br><span class="line"></span><br><span class="line">9.2.1 类内部的内联函数</span><br><span class="line"></span><br><span class="line">9.2.2 访问函数</span><br><span class="line"></span><br><span class="line">9.3 带内联函数的stash和stack</span><br><span class="line"></span><br><span class="line">9.4 内联函数和编译器</span><br><span class="line"></span><br><span class="line">9.4.1 限制</span><br><span class="line"></span><br><span class="line">9.4.2 向前引用</span><br><span class="line"></span><br><span class="line">9.4.3 在构造函数和析构函数里隐藏行为</span><br><span class="line"></span><br><span class="line">9.5 减少混乱</span><br><span class="line"></span><br><span class="line">9.6 预处理器的更多特征</span><br><span class="line"></span><br><span class="line">9.6.1 标志粘贴</span><br><span class="line"></span><br><span class="line">9.7 改进的错误检查</span><br><span class="line"></span><br><span class="line">9.8 小结</span><br><span class="line"></span><br><span class="line">9.9 练习</span><br><span class="line"></span><br><span class="line">第10章 名字控制</span><br><span class="line"></span><br><span class="line">10.1 来自c语言中的静态元素</span><br><span class="line"></span><br><span class="line">10.1.1 函数内部的静态变量</span><br><span class="line"></span><br><span class="line">10.1.2 控制连接</span><br><span class="line"></span><br><span class="line">10.1.3 其他存储类型说明符</span><br><span class="line"></span><br><span class="line">10.2 名字空间</span><br><span class="line"></span><br><span class="line">10.2.1 创建一个名字空间</span><br><span class="line"></span><br><span class="line">10.2.2 使用名字空间</span><br><span class="line"></span><br><span class="line">10.2.3 名字空间的使用</span><br><span class="line"></span><br><span class="line">10.3 c++中的静态成员</span><br><span class="line"></span><br><span class="line">10.3.1 定义静态数据成员的存储</span><br><span class="line"></span><br><span class="line">10.3.2 嵌套类和局部类</span><br><span class="line"></span><br><span class="line">10.3.3 静态成员函数</span><br><span class="line"></span><br><span class="line">10.4 静态初始化的相依性</span><br><span class="line"></span><br><span class="line">10.4.1 怎么办</span><br><span class="line"></span><br><span class="line">10.5 替代连接说明</span><br><span class="line"></span><br><span class="line">10.6 小结</span><br><span class="line"></span><br><span class="line">10.7 练习</span><br><span class="line"></span><br><span class="line">第11章 引用和拷贝构造函数</span><br><span class="line"></span><br><span class="line">11.1 c++中的指针</span><br><span class="line"></span><br><span class="line">11.2 c++中的引用</span><br><span class="line"></span><br><span class="line">11.2.1 函数中的引用</span><br><span class="line"></span><br><span class="line">11.2.2 参数传递准则</span><br><span class="line"></span><br><span class="line">11.3 拷贝构造函数</span><br><span class="line"></span><br><span class="line">11.3.1 按值传递和返回</span><br><span class="line"></span><br><span class="line">11.3.2 拷贝构造函数</span><br><span class="line"></span><br><span class="line">11.3.3 默认拷贝构造函数</span><br><span class="line"></span><br><span class="line">11.3.4 替代拷贝构造函数的方法</span><br><span class="line"></span><br><span class="line">11.4 指向成员的指针</span><br><span class="line"></span><br><span class="line">11.4.1 函数</span><br><span class="line"></span><br><span class="line">11.5 小结</span><br><span class="line"></span><br><span class="line">11.6 练习</span><br><span class="line"></span><br><span class="line">第12章 运算符重载</span><br><span class="line"></span><br><span class="line">12.1 两个极端</span><br><span class="line"></span><br><span class="line">12.2 语法</span><br><span class="line"></span><br><span class="line">12.3 可重载的运算符</span><br><span class="line"></span><br><span class="line">12.3.1 一元运算符</span><br><span class="line"></span><br><span class="line">12.3.2 二元运算符</span><br><span class="line"></span><br><span class="line">12.3.3 参数和返回值</span><br><span class="line"></span><br><span class="line">12.3.4 不常用的运算符</span><br><span class="line"></span><br><span class="line">12.3.5 不能重载的运算符</span><br><span class="line"></span><br><span class="line">12.4 非成员运算符</span><br><span class="line"></span><br><span class="line">12.4.1 基本方针</span><br><span class="line"></span><br><span class="line">12.5 重载赋值符</span><br><span class="line"></span><br><span class="line">12.5.1 operator&#x3D;的行为</span><br><span class="line"></span><br><span class="line">12.6 自动类型转换</span><br><span class="line"></span><br><span class="line">12.6.1 构造函数转换</span><br><span class="line"></span><br><span class="line">12.6.2 运算符转换</span><br><span class="line"></span><br><span class="line">12.6.3 类型转换例子</span><br><span class="line"></span><br><span class="line">12.6.4 自动类型转换的缺陷</span><br><span class="line"></span><br><span class="line">12.7 小结</span><br><span class="line"></span><br><span class="line">12.8 练习</span><br><span class="line"></span><br><span class="line">第13章 动态对象创建</span><br><span class="line"></span><br><span class="line">13.1 对象创建</span><br><span class="line"></span><br><span class="line">13.1.1 c从堆中获取存储单元的方法</span><br><span class="line"></span><br><span class="line">13.1.2 operator new</span><br><span class="line"></span><br><span class="line">13.1.3 operator delete</span><br><span class="line"></span><br><span class="line">13.1.4 一个简单的例子</span><br><span class="line"></span><br><span class="line">13.1.5 内存管理的开销</span><br><span class="line"></span><br><span class="line">13.2 重新设计前面的例子</span><br><span class="line"></span><br><span class="line">13.2.1 使用delete void*可能会出错</span><br><span class="line"></span><br><span class="line">13.2.2 对指针的清除责任</span><br><span class="line"></span><br><span class="line">13.2.3 指针的stash</span><br><span class="line"></span><br><span class="line">13.3 用于数组的new和delete</span><br><span class="line"></span><br><span class="line">13.3.1 使指针更像数组</span><br><span class="line"></span><br><span class="line">13.4 耗尽内存</span><br><span class="line"></span><br><span class="line">13.5 重载new和delete</span><br><span class="line"></span><br><span class="line">13.5.1 重载全局new和delete</span><br><span class="line"></span><br><span class="line">13.5.2 对于一个类重载new和delete</span><br><span class="line"></span><br><span class="line">13.5.3 为数组重载new和delete</span><br><span class="line"></span><br><span class="line">13.5.4 构造函数调用</span><br><span class="line"></span><br><span class="line">13.5.5 定位new和delete</span><br><span class="line"></span><br><span class="line">13.6 小结</span><br><span class="line"></span><br><span class="line">13.7 练习</span><br><span class="line"></span><br><span class="line">第14章 继承和组合</span><br><span class="line"></span><br><span class="line">14.1 组合语法</span><br><span class="line"></span><br><span class="line">14.2 继承语法</span><br><span class="line"></span><br><span class="line">14.3 构造函数的初始化表达式表</span><br><span class="line"></span><br><span class="line">14.3.1 成员对象初始化</span><br><span class="line"></span><br><span class="line">14.3.2 在初始化表达式表中的内建类型</span><br><span class="line"></span><br><span class="line">14.4 组合和继承的联合</span><br><span class="line"></span><br><span class="line">14.4.1 构造函数和析构函数调用的次序</span><br><span class="line"></span><br><span class="line">14.5 名字隐藏</span><br><span class="line"></span><br><span class="line">14.6 非自动继承的函数</span><br><span class="line"></span><br><span class="line">14.6.1 继承和静态成员函数</span><br><span class="line"></span><br><span class="line">14.7 组合与继承的选择</span><br><span class="line"></span><br><span class="line">14.7.1 子类型设置</span><br><span class="line"></span><br><span class="line">14.7.2 私有继承</span><br><span class="line"></span><br><span class="line">14.8 protected</span><br><span class="line"></span><br><span class="line">14.8.1 protected继承</span><br><span class="line"></span><br><span class="line">14.9 运算符的重载与继承</span><br><span class="line"></span><br><span class="line">14.10 多重继承</span><br><span class="line"></span><br><span class="line">14.11 渐增式开发</span><br><span class="line"></span><br><span class="line">14.12 向上类型转换</span><br><span class="line"></span><br><span class="line">14.12.1 为什么要“向上类型转换”</span><br><span class="line"></span><br><span class="line">14.12.2 向上类型转换和拷贝构造函数</span><br><span class="line"></span><br><span class="line">14.12.3 组合与继承（再论）</span><br><span class="line"></span><br><span class="line">14.12.4 指针和引用的向上类型转换</span><br><span class="line"></span><br><span class="line">14.12.5 危机</span><br><span class="line"></span><br><span class="line">14.13 小结</span><br><span class="line"></span><br><span class="line">14.14 练习</span><br><span class="line"></span><br><span class="line">第15章 多态性和虚函数</span><br><span class="line"></span><br><span class="line">15.1 c++程序员的演变</span><br><span class="line"></span><br><span class="line">15.2 向上类型转换</span><br><span class="line"></span><br><span class="line">15.3 问题</span><br><span class="line"></span><br><span class="line">15.3.1 函数调用捆绑</span><br><span class="line"></span><br><span class="line">15.4 虚函数</span><br><span class="line"></span><br><span class="line">15.4.1 扩展性</span><br><span class="line"></span><br><span class="line">15.5 c++如何实现晚捆绑</span><br><span class="line"></span><br><span class="line">15.5.1 存放类型信息</span><br><span class="line"></span><br><span class="line">15.5.2 虚函数功能图示</span><br><span class="line"></span><br><span class="line">15.5.3 撩开面纱</span><br><span class="line"></span><br><span class="line">15.5.4 安装vpointer</span><br><span class="line"></span><br><span class="line">15.5.5 对象是不同的</span><br><span class="line"></span><br><span class="line">15.6 为什么需要虚函数</span><br><span class="line"></span><br><span class="line">15.7 抽象基类和纯虚函数</span><br><span class="line"></span><br><span class="line">15.7.1 纯虚定义</span><br><span class="line"></span><br><span class="line">15.8 继承和vtable</span><br><span class="line"></span><br><span class="line">15.8.1 对象切片</span><br><span class="line"></span><br><span class="line">15.9 重载和重新定义</span><br><span class="line"></span><br><span class="line">15.9.1 变量返回类型</span><br><span class="line"></span><br><span class="line">15.10 虚函数和构造函数</span><br><span class="line"></span><br><span class="line">15.10.1 构造函数调用次序</span><br><span class="line"></span><br><span class="line">15.10.2 虚函数在构造函数中的行为</span><br><span class="line"></span><br><span class="line">15.11 析构函数和虚拟析构函数</span><br><span class="line"></span><br><span class="line">15.11.1 纯虚析构函数</span><br><span class="line"></span><br><span class="line">15.11.2 析构函数中的虚机制</span><br><span class="line"></span><br><span class="line">15.11.3 创建基于对象的继承</span><br><span class="line"></span><br><span class="line">15.12 运算符重载</span><br><span class="line"></span><br><span class="line">15.13 向下类型转换</span><br><span class="line"></span><br><span class="line">15.14 小结</span><br><span class="line"></span><br><span class="line">15.15 练习</span><br><span class="line"></span><br><span class="line">第16章 模板介绍</span><br><span class="line"></span><br><span class="line">16.1 容器</span><br><span class="line"></span><br><span class="line">16.1.1 容器的需求</span><br><span class="line"></span><br><span class="line">16.2 模板综述</span><br><span class="line"></span><br><span class="line">16.2.1 模板方法</span><br><span class="line"></span><br><span class="line">16.3 模板语法</span><br><span class="line"></span><br><span class="line">16.3.1 非内联函数定义</span><br><span class="line"></span><br><span class="line">16.3.2 作为模板的intstack</span><br><span class="line"></span><br><span class="line">16.3.3 模板中的常量</span><br><span class="line"></span><br><span class="line">16.4 作为模板的stash和stack</span><br><span class="line"></span><br><span class="line">16.4.1 模板化的指针stash</span><br><span class="line"></span><br><span class="line">16.5 打开和关闭所有权</span><br><span class="line"></span><br><span class="line">16.6 以值存放对象</span><br><span class="line"></span><br><span class="line">16.7 迭代器简介</span><br><span class="line"></span><br><span class="line">16.7.1 带有迭代器的栈</span><br><span class="line"></span><br><span class="line">16.7.2 带有迭代器的pstash</span><br><span class="line"></span><br><span class="line">16.8 为什么使用迭代器</span><br><span class="line"></span><br><span class="line">16.8.1 函数模板</span><br><span class="line"></span><br><span class="line">16.9 小结</span><br><span class="line"></span><br><span class="line">16.10 练习</span><br><span class="line"></span><br><span class="line">附录a 编码风格</span><br><span class="line"></span><br><span class="line">附录b 编程准则</span><br><span class="line"></span><br><span class="line">附录c 推荐读物</span><br><span class="line"></span><br><span class="line">第2卷 实用编程技术</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第一部分 建立稳定的系统</span><br><span class="line"></span><br><span class="line">第1章 异常处理</span><br><span class="line"></span><br><span class="line">1.1 传统的错误处理</span><br><span class="line"></span><br><span class="line">1.2 抛出异常</span><br><span class="line"></span><br><span class="line">1.3 捕获异常</span><br><span class="line"></span><br><span class="line">1.3.1 try块</span><br><span class="line"></span><br><span class="line">1.3.2 异常处理器</span><br><span class="line"></span><br><span class="line">1.3.3 终止和恢复</span><br><span class="line"></span><br><span class="line">1.4 异常匹配</span><br><span class="line"></span><br><span class="line">1.4.1 捕获所有异常</span><br><span class="line"></span><br><span class="line">1.4.2 重新抛出异常</span><br><span class="line"></span><br><span class="line">1.4.3 不捕获异常</span><br><span class="line"></span><br><span class="line">1.5 清理</span><br><span class="line"></span><br><span class="line">1.5.1 资源管理</span><br><span class="line"></span><br><span class="line">1.5.2 使所有事物都成为对象</span><br><span class="line"></span><br><span class="line">1.5.3 auto_ptr</span><br><span class="line"></span><br><span class="line">1.5.4 函数级的try块</span><br><span class="line"></span><br><span class="line">1.6 标准异常</span><br><span class="line"></span><br><span class="line">1.7 异常规格说明</span><br><span class="line"></span><br><span class="line">1.7.1 更好的异常规格说明</span><br><span class="line"></span><br><span class="line">1.7.2 异常规格说明和继承</span><br><span class="line"></span><br><span class="line">1.7.3 什么时候不使用异常规格说明</span><br><span class="line"></span><br><span class="line">1.8 异常安全</span><br><span class="line"></span><br><span class="line">1.9 在编程中使用异常</span><br><span class="line"></span><br><span class="line">1.9.1 什么时候避免异常</span><br><span class="line"></span><br><span class="line">1.9.2 异常的典型应用</span><br><span class="line"></span><br><span class="line">1.10 使用异常造成的开销</span><br><span class="line"></span><br><span class="line">1.11 小结</span><br><span class="line"></span><br><span class="line">1.12 练习</span><br><span class="line"></span><br><span class="line">第2章 防御性编程</span><br><span class="line"></span><br><span class="line">2.1 断言</span><br><span class="line"></span><br><span class="line">2.2 一个简单的单元测试框架</span><br><span class="line"></span><br><span class="line">2.2.1 自动测试</span><br><span class="line"></span><br><span class="line">2.2.2 testsuite框架</span><br><span class="line"></span><br><span class="line">2.2.3 测试套件</span><br><span class="line"></span><br><span class="line">2.2.4 测试框架的源代码</span><br><span class="line"></span><br><span class="line">2.3 调试技术</span><br><span class="line"></span><br><span class="line">2.3.1 用于代码跟踪的宏</span><br><span class="line"></span><br><span class="line">2.3.2 跟踪文件</span><br><span class="line"></span><br><span class="line">2.3.3 发现内存泄漏</span><br><span class="line"></span><br><span class="line">2.4 小结</span><br><span class="line"></span><br><span class="line">2.5 练习</span><br><span class="line"></span><br><span class="line">第二部分 标准c++库</span><br><span class="line"></span><br><span class="line">第3章 深入理解字符串</span><br><span class="line"></span><br><span class="line">3.1 字符串的内部是什么</span><br><span class="line"></span><br><span class="line">3.2 创建并初始化c++字符串</span><br><span class="line"></span><br><span class="line">3.3 对字符串进行操作</span><br><span class="line"></span><br><span class="line">3.3.1 追加、插入和连接字符串</span><br><span class="line"></span><br><span class="line">3.3.2 替换字符串中的字符</span><br><span class="line"></span><br><span class="line">3.3.3 使用非成员重载运算符连接</span><br><span class="line"></span><br><span class="line">3.4 字符串的查找</span><br><span class="line"></span><br><span class="line">3.4.1 反向查找</span><br><span class="line"></span><br><span class="line">3.4.2 查找一组字符第1次或最后一次出现的位置</span><br><span class="line"></span><br><span class="line">3.4.3 从字符串中删除字符</span><br><span class="line"></span><br><span class="line">3.4.4 字符串的比较</span><br><span class="line"></span><br><span class="line">3.4.5 字符串和字符的特性</span><br><span class="line"></span><br><span class="line">3.5 字符串的应用</span><br><span class="line"></span><br><span class="line">3.6 小结</span><br><span class="line"></span><br><span class="line">3.7 练习</span><br><span class="line"></span><br><span class="line">第4章 输入输出流</span><br><span class="line"></span><br><span class="line">4.1 为什么引入输入输出流</span><br><span class="line"></span><br><span class="line">4.2 救助输入输出流</span><br><span class="line"></span><br><span class="line">4.2.1 插入符和提取符</span><br><span class="line"></span><br><span class="line">4.2.2 通常用法</span><br><span class="line"></span><br><span class="line">4.2.3 按行输入</span><br><span class="line"></span><br><span class="line">4.3 处理流错误</span><br><span class="line"></span><br><span class="line">4.4 文件输入输出流</span><br><span class="line"></span><br><span class="line">4.4.1 一个文件处理的例子</span><br><span class="line"></span><br><span class="line">4.4.2 打开模式</span><br><span class="line"></span><br><span class="line">4.5 输入输出流缓冲</span><br><span class="line"></span><br><span class="line">4.6 在输入输出流中定位</span><br><span class="line"></span><br><span class="line">4.7 字符串输入输出流</span><br><span class="line"></span><br><span class="line">4.7.1 输入字符串流</span><br><span class="line"></span><br><span class="line">4.7.2 输出字符串流</span><br><span class="line"></span><br><span class="line">4.8 输出流的格式化</span><br><span class="line"></span><br><span class="line">4.8.1 格式化标志</span><br><span class="line"></span><br><span class="line">4.8.2 格式化域</span><br><span class="line"></span><br><span class="line">4.8.3 宽度、填充和精度设置</span><br><span class="line"></span><br><span class="line">4.8.4 一个完整的例子</span><br><span class="line"></span><br><span class="line">4.9 操纵算子</span><br><span class="line"></span><br><span class="line">4.9.1 带参数的操纵算子</span><br><span class="line"></span><br><span class="line">4.9.2 创建操纵算子</span><br><span class="line"></span><br><span class="line">4.9.3 效用算子</span><br><span class="line"></span><br><span class="line">4.10 输入输出流程序举例</span><br><span class="line"></span><br><span class="line">4.10.1 维护类库的源代码</span><br><span class="line"></span><br><span class="line">4.10.2 检测编译器错误</span><br><span class="line"></span><br><span class="line">4.10.3 一个简单的数据记录器</span><br><span class="line"></span><br><span class="line">4.11 国际化</span><br><span class="line"></span><br><span class="line">4.11.1 宽字符流</span><br><span class="line"></span><br><span class="line">4.11.2 区域性字符流</span><br><span class="line"></span><br><span class="line">4.12 小结</span><br><span class="line"></span><br><span class="line">4.13 练习</span><br><span class="line"></span><br><span class="line">第5章 深入理解模板</span><br><span class="line"></span><br><span class="line">5.1 模板参数</span><br><span class="line"></span><br><span class="line">5.1.1 无类型模板参数</span><br><span class="line"></span><br><span class="line">5.1.2 默认模板参数</span><br><span class="line"></span><br><span class="line">5.1.3 模板类型的模板参数</span><br><span class="line"></span><br><span class="line">5.1.4 typename关键字</span><br><span class="line"></span><br><span class="line">5.1.5 以template关键字作为提示</span><br><span class="line"></span><br><span class="line">5.1.6 成员模板</span><br><span class="line"></span><br><span class="line">5.2 有关函数模板的几个问题</span><br><span class="line"></span><br><span class="line">5.2.1 函数模板参数的类型推断</span><br><span class="line"></span><br><span class="line">5.2.2 函数模板重载</span><br><span class="line"></span><br><span class="line">5.2.3 以一个已生成的函数模板地址作为参数</span><br><span class="line"></span><br><span class="line">5.2.4 将函数应用到stl序列容器中</span><br><span class="line"></span><br><span class="line">5.2.5 函数模板的半有序</span><br><span class="line"></span><br><span class="line">5.3 模板特化</span><br><span class="line"></span><br><span class="line">5.3.1 显式特化</span><br><span class="line"></span><br><span class="line">5.3.2 半特化</span><br><span class="line"></span><br><span class="line">5.3.3 一个实例</span><br><span class="line"></span><br><span class="line">5.3.4 防止模板代码膨胀</span><br><span class="line"></span><br><span class="line">5.4 名称查找问题</span><br><span class="line"></span><br><span class="line">5.4.1 模板中的名称</span><br><span class="line"></span><br><span class="line">5.4.2 模板和友元</span><br><span class="line"></span><br><span class="line">5.5 模板编程中的习语</span><br><span class="line"></span><br><span class="line">5.5.1 特征</span><br><span class="line"></span><br><span class="line">5.5.2 策略</span><br><span class="line"></span><br><span class="line">5.5.3 奇特的递归模板模式</span><br><span class="line"></span><br><span class="line">5.6 模板元编程</span><br><span class="line"></span><br><span class="line">5.6.1 编译时编程</span><br><span class="line"></span><br><span class="line">5.6.2 表达式模板</span><br><span class="line"></span><br><span class="line">5.7 模板编译模型</span><br><span class="line"></span><br><span class="line">5.7.1 包含模型</span><br><span class="line"></span><br><span class="line">5.7.2 显式实例化</span><br><span class="line"></span><br><span class="line">5.7.3 分离模型</span><br><span class="line"></span><br><span class="line">5.8 小结</span><br><span class="line"></span><br><span class="line">5.9 练习</span><br><span class="line"></span><br><span class="line">第6章 通用算法</span><br><span class="line"></span><br><span class="line">6.1 概述</span><br><span class="line"></span><br><span class="line">6.1.1 判定函数</span><br><span class="line"></span><br><span class="line">6.1.2 流迭代器</span><br><span class="line"></span><br><span class="line">6.1.3 算法复杂性</span><br><span class="line"></span><br><span class="line">6.2 函数对象</span><br><span class="line"></span><br><span class="line">6.2.1 函数对象的分类</span><br><span class="line"></span><br><span class="line">6.2.2 自动创建函数对象</span><br><span class="line"></span><br><span class="line">6.2.3 可调整的函数对象</span><br><span class="line"></span><br><span class="line">6.2.4 更多的函数对象例子</span><br><span class="line"></span><br><span class="line">6.2.5 函数指针适配器</span><br><span class="line"></span><br><span class="line">6.2.6 编写自己的函数对象适配器</span><br><span class="line"></span><br><span class="line">6.3 stl算法目录</span><br><span class="line"></span><br><span class="line">6.3.1 实例创建的支持工具</span><br><span class="line"></span><br><span class="line">6.3.2 填充和生成</span><br><span class="line"></span><br><span class="line">6.3.3 计数</span><br><span class="line"></span><br><span class="line">6.3.4 操作序列</span><br><span class="line"></span><br><span class="line">6.3.5 查找和替换</span><br><span class="line"></span><br><span class="line">6.3.6 比较范围</span><br><span class="line"></span><br><span class="line">6.3.7 删除元素</span><br><span class="line"></span><br><span class="line">6.3.8 对已排序的序列进行排序和运算</span><br><span class="line"></span><br><span class="line">6.3.9 堆运算</span><br><span class="line"></span><br><span class="line">6.3.10 对某一范围内的所有元素进行运算</span><br><span class="line"></span><br><span class="line">6.3.11 数值算法</span><br><span class="line"></span><br><span class="line">6.3.12 通用实用程序</span><br><span class="line"></span><br><span class="line">6.4 创建自己的stl风格算法</span><br><span class="line"></span><br><span class="line">6.5 小结</span><br><span class="line"></span><br><span class="line">6.6 练习</span><br><span class="line"></span><br><span class="line">第7章 通用容器</span><br><span class="line"></span><br><span class="line">7.1 容器和迭代器</span><br><span class="line"></span><br><span class="line">7.2 概述</span><br><span class="line"></span><br><span class="line">7.2.1 字符串容器</span><br><span class="line"></span><br><span class="line">7.2.2 从stl容器继承</span><br><span class="line"></span><br><span class="line">7.3 更多迭代器</span><br><span class="line"></span><br><span class="line">7.3.1 可逆容器中的迭代器</span><br><span class="line"></span><br><span class="line">7.3.2 迭代器的种类</span><br><span class="line"></span><br><span class="line">7.3.3 预定义迭代器</span><br><span class="line"></span><br><span class="line">7.4 基本序列容器：vector、list和deque</span><br><span class="line"></span><br><span class="line">7.4.1 基本序列容器的操作</span><br><span class="line"></span><br><span class="line">7.4.2 向量</span><br><span class="line"></span><br><span class="line">7.4.3 双端队列</span><br><span class="line"></span><br><span class="line">7.4.4 序列容器间的转换</span><br><span class="line"></span><br><span class="line">7.4.5 被检查的随机访问</span><br><span class="line"></span><br><span class="line">7.4.6 链表</span><br><span class="line"></span><br><span class="line">7.4.7 交换序列</span><br><span class="line"></span><br><span class="line">7.5 集合</span><br><span class="line"></span><br><span class="line">7.6 堆栈</span><br><span class="line"></span><br><span class="line">7.7 队列</span><br><span class="line"></span><br><span class="line">7.8 优先队列</span><br><span class="line"></span><br><span class="line">7.9 持有二进制位</span><br><span class="line"></span><br><span class="line">7.9.1 bitset[n]</span><br><span class="line"></span><br><span class="line">7.9.2 vector[bool]</span><br><span class="line"></span><br><span class="line">7.10 关联式容器</span><br><span class="line"></span><br><span class="line">7.10.1 用于关联式容器的发生器和填充器</span><br><span class="line"></span><br><span class="line">7.10.2 不可思议的映像</span><br><span class="line"></span><br><span class="line">7.10.3 多重映像和重复的关键字</span><br><span class="line"></span><br><span class="line">7.10.4 多重集合</span><br><span class="line"></span><br><span class="line">7.11 将stl容器联合使用</span><br><span class="line"></span><br><span class="line">7.12 清除容器的指针</span><br><span class="line"></span><br><span class="line">7.13 创建自己的容器</span><br><span class="line"></span><br><span class="line">7.14 对stl的扩充</span><br><span class="line"></span><br><span class="line">7.15 非stl容器</span><br><span class="line"></span><br><span class="line">7.16 小结</span><br><span class="line"></span><br><span class="line">7.17 练习</span><br><span class="line"></span><br><span class="line">第三部分 专 题</span><br><span class="line"></span><br><span class="line">第8章 运行时类型识别</span><br><span class="line"></span><br><span class="line">8.1 运行时类型转换</span><br><span class="line"></span><br><span class="line">8.2 typeid 操作符</span><br><span class="line"></span><br><span class="line">8.2.1 类型转换到中间层次类型</span><br><span class="line"></span><br><span class="line">8.2.2 void型指针</span><br><span class="line"></span><br><span class="line">8.2.3 运用带模板的rtti</span><br><span class="line"></span><br><span class="line">8.3 多重继承</span><br><span class="line"></span><br><span class="line">8.4 合理使用rtti</span><br><span class="line"></span><br><span class="line">8.5 rtti的机制和开销</span><br><span class="line"></span><br><span class="line">8.6 小结</span><br><span class="line"></span><br><span class="line">8.7 练习</span><br><span class="line"></span><br><span class="line">第9章 多重继承</span><br><span class="line"></span><br><span class="line">9.1 概论</span><br><span class="line"></span><br><span class="line">9.2 接口继承</span><br><span class="line"></span><br><span class="line">9.3 实现继承</span><br><span class="line"></span><br><span class="line">9.4 重复子对象</span><br><span class="line"></span><br><span class="line">9.5 虚基类</span><br><span class="line"></span><br><span class="line">9.6 名字查找问题</span><br><span class="line"></span><br><span class="line">9.7 避免使用多重继承</span><br><span class="line"></span><br><span class="line">9.8 扩充一个接口</span><br><span class="line"></span><br><span class="line">9.9 小结</span><br><span class="line"></span><br><span class="line">9.10 练习</span><br><span class="line"></span><br><span class="line">第10章 设计模式</span><br><span class="line"></span><br><span class="line">10.1 模式的概念</span><br><span class="line"></span><br><span class="line">10.2 模式分类</span><br><span class="line"></span><br><span class="line">10.3 简化习语</span><br><span class="line"></span><br><span class="line">10.3.1 信使</span><br><span class="line"></span><br><span class="line">10.3.2 收集参数</span><br><span class="line"></span><br><span class="line">10.4 单件</span><br><span class="line"></span><br><span class="line">10.5 命令：选择操作</span><br><span class="line"></span><br><span class="line">10.6 消除对象耦合</span><br><span class="line"></span><br><span class="line">10.6.1 代理模式：作为其他对象的前端</span><br><span class="line"></span><br><span class="line">10.6.2 状态模式：改变对象的行为</span><br><span class="line"></span><br><span class="line">10.7 适配器模式</span><br><span class="line"></span><br><span class="line">10.8 模板方法模式</span><br><span class="line"></span><br><span class="line">10.9 策略模式：运行时选择算法</span><br><span class="line"></span><br><span class="line">10.10 职责链模式：尝试采用一系列</span><br><span class="line"></span><br><span class="line">策略模式</span><br><span class="line"></span><br><span class="line">10.11 工厂模式：封装对象的创建</span><br><span class="line"></span><br><span class="line">10.11.1 多态工厂</span><br><span class="line"></span><br><span class="line">10.11.2 抽象工厂</span><br><span class="line"></span><br><span class="line">10.11.3 虚构造函数</span><br><span class="line"></span><br><span class="line">10.12 构建器模式：创建复杂对象</span><br><span class="line"></span><br><span class="line">10.13 观察者模式</span><br><span class="line"></span><br><span class="line">10.13.1 “内部类”方法</span><br><span class="line"></span><br><span class="line">10.13.2 观察者模式举例</span><br><span class="line"></span><br><span class="line">10.14 多重派遣</span><br><span class="line"></span><br><span class="line">10.15 小结</span><br><span class="line"></span><br><span class="line">10.16 练习</span><br><span class="line"></span><br><span class="line">第11章 并发</span><br><span class="line"></span><br><span class="line">11.1 动机</span><br><span class="line"></span><br><span class="line">11.2 c++中的并发</span><br><span class="line"></span><br><span class="line">11.3 定义任务</span><br><span class="line"></span><br><span class="line">11.4 使用线程</span><br><span class="line"></span><br><span class="line">11.4.1 创建有响应的用户界面</span><br><span class="line"></span><br><span class="line">11.4.2 使用执行器简化工作</span><br><span class="line"></span><br><span class="line">11.4.3 让步</span><br><span class="line"></span><br><span class="line">11.4.4 休眠</span><br><span class="line"></span><br><span class="line">11.4.5 优先权</span><br><span class="line"></span><br><span class="line">11.5 共享有限资源</span><br><span class="line"></span><br><span class="line">11.5.1 保证对象的存在</span><br><span class="line"></span><br><span class="line">11.5.2 不恰当地访问资源</span><br><span class="line"></span><br><span class="line">11.5.3 访问控制</span><br><span class="line"></span><br><span class="line">11.5.4 使用保护简化编码</span><br><span class="line"></span><br><span class="line">11.5.5 线程本地存储</span><br><span class="line"></span><br><span class="line">11.6 终止任务</span><br><span class="line"></span><br><span class="line">11.6.1 防止输入&#x2F;输出流冲突</span><br><span class="line"></span><br><span class="line">11.6.2 举例观赏植物园</span><br><span class="line"></span><br><span class="line">11.6.3 阻塞时终止</span><br><span class="line"></span><br><span class="line">11.6.4 中断</span><br><span class="line"></span><br><span class="line">11.7 线程间协作</span><br><span class="line"></span><br><span class="line">11.7.1 等待和信号</span><br><span class="line"></span><br><span class="line">11.7.2 生产者-消费者关系</span><br><span class="line"></span><br><span class="line">11.7.3 用队列解决线程处理的问题</span><br><span class="line"></span><br><span class="line">11.7.4 广播</span><br><span class="line"></span><br><span class="line">11.8 死锁</span><br><span class="line"></span><br><span class="line">11.9 小结</span><br><span class="line"></span><br><span class="line">11.10 练习</span><br><span class="line"></span><br><span class="line">附录</span><br><span class="line"></span><br><span class="line">附录a 推荐读物</span><br><span class="line"></span><br><span class="line">附录b 其他</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++沉思录中文第2版 PDF</title>
    <url>/posts/1a3b15ff/</url>
    <content><![CDATA[<h4 id="《C-沉思录中文第2版》"><a href="#《C-沉思录中文第2版》" class="headerlink" title="《C++沉思录中文第2版》"></a>《C++沉思录中文第2版》</h4><h6 id="链接-https-pan-baidu-com-s-11XS8oFhwwlpYDCiXrXhvFA-提取码-4rk1"><a href="#链接-https-pan-baidu-com-s-11XS8oFhwwlpYDCiXrXhvFA-提取码-4rk1" class="headerlink" title="链接: https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA 提取码: 4rk1"></a>链接: <a href="https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA">https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA</a> 提取码: 4rk1</h6><p>涵盖了广泛的C++思想和技术——从详细的代码示例到设计原则和哲学，不一而足；<br><a id="more"></a></p>
<p>介绍了如何看待C++中的编程，而不仅仅是遵循C++的规则进行编程；</p>
<p>解释了示例背后的动机；有时甚至使用两种不同的方法来解决同一个问题；</p>
<p>囊括了面向对象编程和通用编程；</p>
<p>解释了标准模板库背后的思想，这是C++中的重要创新。</p>
<p><img src="/images/1f9d3e79a901d84ba59b309fb234acae1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第0章 序幕 1</span><br><span class="line"></span><br><span class="line">0．1　第 一次尝试　1</span><br><span class="line"></span><br><span class="line">0．2　不用类来实现　4</span><br><span class="line"></span><br><span class="line">0．3　为什么用C++更简单　5</span><br><span class="line"></span><br><span class="line">0．4　一个更大的例子　5</span><br><span class="line"></span><br><span class="line">0．5　小结　6</span><br><span class="line"></span><br><span class="line">第　一篇 动 机</span><br><span class="line"></span><br><span class="line">第　1章 为什么我用C++　9</span><br><span class="line"></span><br><span class="line">1．1　问题　9</span><br><span class="line"></span><br><span class="line">1．2　历史背景　10</span><br><span class="line"></span><br><span class="line">1．3　自动软件发布　10</span><br><span class="line"></span><br><span class="line">1．4　进入C++　13</span><br><span class="line"></span><br><span class="line">1．5　重复利用的软件　17</span><br><span class="line"></span><br><span class="line">1．6　后记　18</span><br><span class="line"></span><br><span class="line">第　2章 为什么用C++工作　19</span><br><span class="line"></span><br><span class="line">2．1　小项目的成功　19</span><br><span class="line"></span><br><span class="line">2．2　抽象　21</span><br><span class="line"></span><br><span class="line">2．3　机器应该为人服务　23</span><br><span class="line"></span><br><span class="line">第3章　生活在现实世界中　25</span><br><span class="line"></span><br><span class="line">第二篇　类和继承</span><br><span class="line"></span><br><span class="line">第4章　类设计者的核查表　31</span><br><span class="line"></span><br><span class="line">第5章　代理类　39</span><br><span class="line"></span><br><span class="line">5．1　问题　39</span><br><span class="line"></span><br><span class="line">5．2　经典解决方案　40</span><br><span class="line"></span><br><span class="line">5．3　虚复制函数　41</span><br><span class="line"></span><br><span class="line">5．4　定义代理类　42</span><br><span class="line"></span><br><span class="line">5．5　小结　44</span><br><span class="line"></span><br><span class="line">第6章　句柄：第 一部分　45</span><br><span class="line"></span><br><span class="line">6．1　问题　45</span><br><span class="line"></span><br><span class="line">6．2　一个简单的类　46</span><br><span class="line"></span><br><span class="line">6．3　绑定到句柄　47</span><br><span class="line"></span><br><span class="line">6．4　获取对象　48</span><br><span class="line"></span><br><span class="line">6．5　简单的实现　48</span><br><span class="line"></span><br><span class="line">6．6　引用计数型句柄　49</span><br><span class="line"></span><br><span class="line">6．7　写时复制　51</span><br><span class="line"></span><br><span class="line">6．8　讨论　52</span><br><span class="line"></span><br><span class="line">第7章　句柄：第二部分　55</span><br><span class="line"></span><br><span class="line">7．1　回顾　56</span><br><span class="line"></span><br><span class="line">7．2　分离引用计数　57</span><br><span class="line"></span><br><span class="line">7．3　对引用计数的抽象　58</span><br><span class="line"></span><br><span class="line">7．4　存取函数和写时复制　61</span><br><span class="line"></span><br><span class="line">7．5　讨论　61</span><br><span class="line"></span><br><span class="line">第8章　一个面向对象程序范例　63</span><br><span class="line"></span><br><span class="line">8．1　问题描述　63</span><br><span class="line"></span><br><span class="line">8．2　面向对象的解决方案　64</span><br><span class="line"></span><br><span class="line">8．3　句柄类　67</span><br><span class="line"></span><br><span class="line">8．4　扩展1：新操作　69</span><br><span class="line"></span><br><span class="line">8．5　扩展2：增加新的节点类型　72</span><br><span class="line"></span><br><span class="line">8．6　反思　73</span><br><span class="line"></span><br><span class="line">第9章　一个课堂练习的分析（上）　75</span><br><span class="line"></span><br><span class="line">9．1　问题描述　75</span><br><span class="line"></span><br><span class="line">9．2　接口设计　77</span><br><span class="line"></span><br><span class="line">9．3　补遗　79</span><br><span class="line"></span><br><span class="line">9．4　测试接口　80</span><br><span class="line"></span><br><span class="line">9．5　策略　81</span><br><span class="line"></span><br><span class="line">9．6　方案　81</span><br><span class="line"></span><br><span class="line">9．7　图像的组合　85</span><br><span class="line"></span><br><span class="line">9．8　小结　87</span><br><span class="line"></span><br><span class="line">第　10章 一个课堂练习的分析（下）　89</span><br><span class="line"></span><br><span class="line">10．1　策略　89</span><br><span class="line"></span><br><span class="line">10．2　体验设计的灵活性　102</span><br><span class="line"></span><br><span class="line">10．3　小结　105</span><br><span class="line"></span><br><span class="line">第　11章 什么时候不应当使用虚函数　107</span><br><span class="line"></span><br><span class="line">11．1　适用的情况　107</span><br><span class="line"></span><br><span class="line">11．2　不适用的情况　108</span><br><span class="line"></span><br><span class="line">11．3　析构函数很特殊　113</span><br><span class="line"></span><br><span class="line">11．4　小结　114</span><br><span class="line"></span><br><span class="line">第三篇　模 板</span><br><span class="line"></span><br><span class="line">第　12章 设计容器类　117</span><br><span class="line"></span><br><span class="line">12．1　包含什么　117</span><br><span class="line"></span><br><span class="line">12．2　复制容器意味着什么　118</span><br><span class="line"></span><br><span class="line">12．3　怎样获取容器的元素　121</span><br><span class="line"></span><br><span class="line">12．4　怎样区分读和写　121</span><br><span class="line"></span><br><span class="line">12．5　怎样处理容器的增长　123</span><br><span class="line"></span><br><span class="line">12．6　容器支持哪些操作　124</span><br><span class="line"></span><br><span class="line">12．7　怎样设想容器元素的类型　124</span><br><span class="line"></span><br><span class="line">12．8　容器和继承　125</span><br><span class="line"></span><br><span class="line">12．9　设计一个类似数组的类　126</span><br><span class="line"></span><br><span class="line">第　13章 访问容器中的元素　131</span><br><span class="line"></span><br><span class="line">13．1　模拟指针　131</span><br><span class="line"></span><br><span class="line">13．2　获取数据　132</span><br><span class="line"></span><br><span class="line">13．3　遗留问题　135</span><br><span class="line"></span><br><span class="line">13．4　指向const Array的Pointer　139</span><br><span class="line"></span><br><span class="line">13．5　有用的增强操作　140</span><br><span class="line"></span><br><span class="line">第　14章 迭代器　145</span><br><span class="line"></span><br><span class="line">14．1　完成Pointer类　145</span><br><span class="line"></span><br><span class="line">14．2　什么是迭代器　148</span><br><span class="line"></span><br><span class="line">14．3　删除元素　149</span><br><span class="line"></span><br><span class="line">14．4　删除容器　150</span><br><span class="line"></span><br><span class="line">14．5　其他设计考虑　151</span><br><span class="line"></span><br><span class="line">14．6　讨论　151</span><br><span class="line"></span><br><span class="line">第　15章 序列　153</span><br><span class="line"></span><br><span class="line">15．1　技术状况　153</span><br><span class="line"></span><br><span class="line">15．2　基本的传统观点　154</span><br><span class="line"></span><br><span class="line">15．3　增加一些额外操作　159</span><br><span class="line"></span><br><span class="line">15．4　使用范例　162</span><br><span class="line"></span><br><span class="line">15．5　再增加一些　166</span><br><span class="line"></span><br><span class="line">15．6　请你思考　167</span><br><span class="line"></span><br><span class="line">第　16章 作为接口的模板　169</span><br><span class="line"></span><br><span class="line">16．1　问题　169</span><br><span class="line"></span><br><span class="line">16．2　第 一个例子　170</span><br><span class="line"></span><br><span class="line">16．3　分离迭代方式　170</span><br><span class="line"></span><br><span class="line">16．4　遍历任意类型　172</span><br><span class="line"></span><br><span class="line">16．5　增加其他类型　173</span><br><span class="line"></span><br><span class="line">16．6　将存储技术抽象化　174</span><br><span class="line"></span><br><span class="line">16．7　实证　177</span><br><span class="line"></span><br><span class="line">16．8　小结　178</span><br><span class="line"></span><br><span class="line">第　17章 模板和泛型算法　179</span><br><span class="line"></span><br><span class="line">17．1　一个特例　180</span><br><span class="line"></span><br><span class="line">17．2　泛型化元素类型　180</span><br><span class="line"></span><br><span class="line">17．3　推迟计数　181</span><br><span class="line"></span><br><span class="line">17．4　地址独立性　183</span><br><span class="line"></span><br><span class="line">17．5　查找非数组　184</span><br><span class="line"></span><br><span class="line">17．6　讨论　185</span><br><span class="line"></span><br><span class="line">第　18章 泛型迭代器　187</span><br><span class="line"></span><br><span class="line">18．1　一个不同的算法　187</span><br><span class="line"></span><br><span class="line">18．2　需求的分类　189</span><br><span class="line"></span><br><span class="line">18．3　输入迭代器　190</span><br><span class="line"></span><br><span class="line">18．4　输出迭代器　190</span><br><span class="line"></span><br><span class="line">18．5　前向迭代器　191</span><br><span class="line"></span><br><span class="line">18．6　双向迭代器　191</span><br><span class="line"></span><br><span class="line">18．7　随机存取迭代器　192</span><br><span class="line"></span><br><span class="line">18．8　是继承吗　193</span><br><span class="line"></span><br><span class="line">18．9　性能　193</span><br><span class="line"></span><br><span class="line">18．10　小结　194</span><br><span class="line"></span><br><span class="line">第　19章 使用泛型迭代器　195</span><br><span class="line"></span><br><span class="line">19．1　迭代器类型　196</span><br><span class="line"></span><br><span class="line">19．2　虚拟序列　196</span><br><span class="line"></span><br><span class="line">19．3　输出流迭代器　199</span><br><span class="line"></span><br><span class="line">19．4　输入流迭代器　200</span><br><span class="line"></span><br><span class="line">19．5　讨论　204</span><br><span class="line"></span><br><span class="line">第　20章 迭代器配接器　205</span><br><span class="line"></span><br><span class="line">20．1　一个例子　205</span><br><span class="line"></span><br><span class="line">20．2　方向不对称性　207</span><br><span class="line"></span><br><span class="line">20．3　一致性和不对称性　208</span><br><span class="line"></span><br><span class="line">20．4　自动反向　209</span><br><span class="line"></span><br><span class="line">20．5　讨论　211</span><br><span class="line"></span><br><span class="line">第　21章 函数对象　213</span><br><span class="line"></span><br><span class="line">21．1　一个例子　213</span><br><span class="line"></span><br><span class="line">21．2　函数指针　216</span><br><span class="line"></span><br><span class="line">21．3　函数对象　218</span><br><span class="line"></span><br><span class="line">21．4　函数对象模板　219</span><br><span class="line"></span><br><span class="line">21．5　隐藏中间类型　220</span><br><span class="line"></span><br><span class="line">21．6　一种类型包罗万象　221</span><br><span class="line"></span><br><span class="line">21．7　实现　222</span><br><span class="line"></span><br><span class="line">21．8　讨论　224</span><br><span class="line"></span><br><span class="line">第　22章 函数配接器　225</span><br><span class="line"></span><br><span class="line">22．1　为什么是函数对象　225</span><br><span class="line"></span><br><span class="line">22．2　用于内建操作符的函数对象　226</span><br><span class="line"></span><br><span class="line">22．3　绑定者（Binders）　227</span><br><span class="line"></span><br><span class="line">22．4　更深入地探讨　228</span><br><span class="line"></span><br><span class="line">22．5　接口继承　229</span><br><span class="line"></span><br><span class="line">22．6　使用这些类　230</span><br><span class="line"></span><br><span class="line">22．7　讨论　231</span><br><span class="line"></span><br><span class="line">第四篇　库</span><br><span class="line"></span><br><span class="line">第　23章 日常使用的库　235</span><br><span class="line"></span><br><span class="line">23．1　问题　235</span><br><span class="line"></span><br><span class="line">23．2　理解问题：第 1部分　237</span><br><span class="line"></span><br><span class="line">23．3　实现：第 1部分　237</span><br><span class="line"></span><br><span class="line">23．4　理解问题：第 2部分　239</span><br><span class="line"></span><br><span class="line">23．5　实现：第 2部分　240</span><br><span class="line"></span><br><span class="line">23．6　讨论　242</span><br><span class="line"></span><br><span class="line">第　24章 一个库接口设计实例　243</span><br><span class="line"></span><br><span class="line">24．1　复杂问题　244</span><br><span class="line"></span><br><span class="line">24．2　优化接口　245</span><br><span class="line"></span><br><span class="line">24．3　温故知新　246</span><br><span class="line"></span><br><span class="line">24．4　编写代码　247</span><br><span class="line"></span><br><span class="line">24．5　小结　249</span><br><span class="line"></span><br><span class="line">第　25章 库设计就是语言设计　251</span><br><span class="line"></span><br><span class="line">25．1　字符串　251</span><br><span class="line"></span><br><span class="line">25．2　内存耗尽　252</span><br><span class="line"></span><br><span class="line">25．3　复制　255</span><br><span class="line"></span><br><span class="line">25．4　隐藏实现　257</span><br><span class="line"></span><br><span class="line">25．5　缺省构造函数　259</span><br><span class="line"></span><br><span class="line">25．6　其他操作　260</span><br><span class="line"></span><br><span class="line">25．7　子字符串　262</span><br><span class="line"></span><br><span class="line">25．8　小结　263</span><br><span class="line"></span><br><span class="line">第　26章 语言设计就是库设计　265</span><br><span class="line"></span><br><span class="line">26．1　抽象数据类型　265</span><br><span class="line"></span><br><span class="line">26．2　库和抽象数据类型　266</span><br><span class="line"></span><br><span class="line">26．3　内存分配　269</span><br><span class="line"></span><br><span class="line">26．4　按成员赋值（memberwise assignment）和初始化　270</span><br><span class="line"></span><br><span class="line">26．5　异常处理　272</span><br><span class="line"></span><br><span class="line">26．6　小结　272</span><br><span class="line"></span><br><span class="line">第五篇　技 术</span><br><span class="line"></span><br><span class="line">第　27章 自己跟踪自己的类　275</span><br><span class="line"></span><br><span class="line">27．1　设计一个跟踪类　275</span><br><span class="line"></span><br><span class="line">27．2　创建死代码　278</span><br><span class="line"></span><br><span class="line">27．3　生成对象的审计跟踪　279</span><br><span class="line"></span><br><span class="line">27．4　验证容器行为　281</span><br><span class="line"></span><br><span class="line">27．5　小结　286</span><br><span class="line"></span><br><span class="line">第　28章 在簇中分配对象　287</span><br><span class="line"></span><br><span class="line">28．1　问题　287</span><br><span class="line"></span><br><span class="line">28．2　设计方案　287</span><br><span class="line"></span><br><span class="line">28．3　实现　290</span><br><span class="line"></span><br><span class="line">28．4　加入继承　292</span><br><span class="line"></span><br><span class="line">28．5　小结　293</span><br><span class="line"></span><br><span class="line">第　29章 应用器、操纵器和函数对象　295</span><br><span class="line"></span><br><span class="line">29．1　问题　295</span><br><span class="line"></span><br><span class="line">29．2　一种解决方案　297</span><br><span class="line"></span><br><span class="line">29．3　另一种不同的解决方案　298</span><br><span class="line"></span><br><span class="line">29．4　多个参数　299</span><br><span class="line"></span><br><span class="line">29．5　一个例子　301</span><br><span class="line"></span><br><span class="line">29．6　简化　302</span><br><span class="line"></span><br><span class="line">29．7　思考　303</span><br><span class="line"></span><br><span class="line">29．8　历史记录、参考资料和致谢　304</span><br><span class="line"></span><br><span class="line">第30章　将应用程序库从输入输出中分离出来　305</span><br><span class="line"></span><br><span class="line">30．1　问题　305</span><br><span class="line"></span><br><span class="line">30．2　解决方案1：技巧加蛮力　306</span><br><span class="line"></span><br><span class="line">30．3　解决方案2：抽象输出　307</span><br><span class="line"></span><br><span class="line">30．4　解决方案3：技巧而无蛮力　309</span><br><span class="line"></span><br><span class="line">30．5　评论　311</span><br><span class="line"></span><br><span class="line">第六篇　总 结</span><br><span class="line"></span><br><span class="line">第31章　通过复杂性获取简单性　315</span><br><span class="line"></span><br><span class="line">31．1　世界是复杂的　315</span><br><span class="line"></span><br><span class="line">31．2　复杂性变得隐蔽　316</span><br><span class="line"></span><br><span class="line">31．3　计算机也是一样　316</span><br><span class="line"></span><br><span class="line">31．4　计算机解决实际问题　317</span><br><span class="line"></span><br><span class="line">31．5　类库和语言语义　318</span><br><span class="line"></span><br><span class="line">31．6　很难使事情变得容易　319</span><br><span class="line"></span><br><span class="line">31．7　抽象和接口　320</span><br><span class="line"></span><br><span class="line">31．8　复杂度的守恒　321</span><br><span class="line"></span><br><span class="line">第32章　说了Hello world后再做什么　323</span><br><span class="line"></span><br><span class="line">32．1　找当地的专家　323</span><br><span class="line"></span><br><span class="line">32．2　选一种工具包并适应它　324</span><br><span class="line"></span><br><span class="line">32．3　C的某些部分是必需的　324</span><br><span class="line"></span><br><span class="line">32．4　C的其他部分不是必需的　325</span><br><span class="line"></span><br><span class="line">32．5　给自己设一些问题　327</span><br><span class="line"></span><br><span class="line">32．6　小结　329</span><br><span class="line"></span><br><span class="line">附录　Koenig和Moo夫妇访谈　331</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++大学教程 PDF</title>
    <url>/posts/6d3c2569/</url>
    <content><![CDATA[<h4 id="《C-大学教程》"><a href="#《C-大学教程》" class="headerlink" title="《C++大学教程》"></a>《C++大学教程》</h4><h6 id="链接-https-pan-baidu-com-s-1d6aCaGpyXxLmJxLJl5US9g-提取码-1ine"><a href="#链接-https-pan-baidu-com-s-1d6aCaGpyXxLmJxLJl5US9g-提取码-1ine" class="headerlink" title="链接: https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g 提取码: 1ine"></a>链接: <a href="https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g">https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g</a> 提取码: 1ine</h6><p>张引，浙江大学计算机科学与技术学院副教授，1999年于浙江大学计算机系取得计算机应用博士学位并留校工作至今。主要研究领域为图形图像、模式识别、数据分析与挖掘、知识表达与发现。 Paul Deitel和Harvey Deitel是全球畅销的编程语言教材和专业图书作家，“How to Program”系列是其*负盛名的一套计算机编程教材，已经销售近40年，并被翻译成中文在内的十几种语言。他们成立的Deitel &amp; Associates公司是一家国际知名的企业培训和写作公司，专门进行计算机编程语言、对象技术、移动应用开发及Internet和Web软件技术方面的培训和写作，出版了一流的编程专业的大学教材、 专业图书以及LiveLessons视频课程。<br><a id="more"></a></p>
<p><img src="/images/bd94eb13b5962cf426a58c7134ad80791.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 计算机和C++简介</span><br><span class="line"></span><br><span class="line">1．1简介</span><br><span class="line"></span><br><span class="line">1．2计算机和互联网在工业和研究领域中的应用</span><br><span class="line"></span><br><span class="line">1．3硬件和软件</span><br><span class="line"></span><br><span class="line">1．4数据的层次结构</span><br><span class="line"></span><br><span class="line">1．5机器语言、 汇编语言和高级语言</span><br><span class="line"></span><br><span class="line">1．6 C++</span><br><span class="line"></span><br><span class="line">1．7程序设计语言</span><br><span class="line"></span><br><span class="line">1．8对象技术介绍</span><br><span class="line"></span><br><span class="line">1．9典型的C++程序开发环境</span><br><span class="line"></span><br><span class="line">1．10试运行一个C++应用程序</span><br><span class="line"></span><br><span class="line">1．11操作系统</span><br><span class="line"></span><br><span class="line">1．12互联网和万维网</span><br><span class="line"></span><br><span class="line">1．13软件开发的一些关键术语</span><br><span class="line"></span><br><span class="line">1．14 C++11和开源的Boost库</span><br><span class="line"></span><br><span class="line">1．15与信息技术与时俱进</span><br><span class="line"></span><br><span class="line">1．16 Web资源</span><br><span class="line"></span><br><span class="line">第2章 C++编程入门、 输入&#x2F;输出和运算符</span><br><span class="line"></span><br><span class="line">2．1简介</span><br><span class="line"></span><br><span class="line">2．2第一个C++程序： 输出一行文本</span><br><span class="line"></span><br><span class="line">2．3修改第一个C++程序</span><br><span class="line"></span><br><span class="line">2．4另一个C++程序： 整数相加</span><br><span class="line"></span><br><span class="line">2．5内存的概念</span><br><span class="line"></span><br><span class="line">2．6算术运算</span><br><span class="line"></span><br><span class="line">2．7判断： 相等运算符和关系运算符</span><br><span class="line"></span><br><span class="line">2．8本章小结</span><br><span class="line"></span><br><span class="line">第3章 类、 对象和字符串的介绍</span><br><span class="line"></span><br><span class="line">3．1简介</span><br><span class="line"></span><br><span class="line">3．2定义具有成员函数的类</span><br><span class="line"></span><br><span class="line">3．3定义具有形参的成员函数</span><br><span class="line"></span><br><span class="line">3．4数据成员、 set成员函数和get成员函数</span><br><span class="line"></span><br><span class="line">3．5使用构造函数初始化对象</span><br><span class="line"></span><br><span class="line">3．6一个类对应一个独立文件的可复用性</span><br><span class="line"></span><br><span class="line">3．7接口与实现的分离</span><br><span class="line"></span><br><span class="line">3．8用set函数确认数据的有效性</span><br><span class="line"></span><br><span class="line">3．9本章小结</span><br><span class="line"></span><br><span class="line">第4章 控制语句（第I部分）、 赋值、 自增和自减运算符</span><br><span class="line"></span><br><span class="line">4．1简介</span><br><span class="line"></span><br><span class="line">4．2算法</span><br><span class="line"></span><br><span class="line">4．3伪代码</span><br><span class="line"></span><br><span class="line">4．4控制结构</span><br><span class="line"></span><br><span class="line">4．5 if选择语句</span><br><span class="line"></span><br><span class="line">4．6 if．．．else双路选择语句</span><br><span class="line"></span><br><span class="line">4．7 while循环语句</span><br><span class="line"></span><br><span class="line">4．8算法详述： 计数器控制的循环</span><br><span class="line"></span><br><span class="line">4．9算法详述： 标记控制的循环</span><br><span class="line"></span><br><span class="line">4．10算法详述： 嵌套的控制语句</span><br><span class="line"></span><br><span class="line">4．11赋值运算符</span><br><span class="line"></span><br><span class="line">4．12自增和自减运算符</span><br><span class="line"></span><br><span class="line">4．13本章小结</span><br><span class="line"></span><br><span class="line">第5章 控制语句（第II部分）和逻辑运算符</span><br><span class="line"></span><br><span class="line">5．1简介</span><br><span class="line"></span><br><span class="line">5．2计数器控制的循环的要素</span><br><span class="line"></span><br><span class="line">5．3 for循环语句</span><br><span class="line"></span><br><span class="line">5．4使用for语句的例子</span><br><span class="line"></span><br><span class="line">5．5 do．．．while循环语句</span><br><span class="line"></span><br><span class="line">5．6 switch多路选择语句</span><br><span class="line"></span><br><span class="line">5．7 break和continue语句</span><br><span class="line"></span><br><span class="line">5．8逻辑运算符</span><br><span class="line"></span><br><span class="line">5．9 &#x3D;&#x3D;运算符与&#x3D;运算符的混淆问题</span><br><span class="line"></span><br><span class="line">5．10结构化编程小结</span><br><span class="line"></span><br><span class="line">5．11本章小结</span><br><span class="line"></span><br><span class="line">第6章 函数和递归入门</span><br><span class="line"></span><br><span class="line">6．1简介</span><br><span class="line"></span><br><span class="line">6．2 C++的程序组件</span><br><span class="line"></span><br><span class="line">6．3数学库函数</span><br><span class="line"></span><br><span class="line">6．4具有多个形参的函数定义</span><br><span class="line"></span><br><span class="line">6．5函数原型和实参类型的强制转换</span><br><span class="line"></span><br><span class="line">6．6C++标准库头文件</span><br><span class="line"></span><br><span class="line">6．7实例研究： 随机数生成</span><br><span class="line"></span><br><span class="line">6．8实例研究： 博彩游戏和枚举类型简介</span><br><span class="line"></span><br><span class="line">6．9C++11的随机数</span><br><span class="line"></span><br><span class="line">6．10存储类别和存储期</span><br><span class="line"></span><br><span class="line">6．11作用域规则</span><br><span class="line"></span><br><span class="line">6．12函数调用堆栈和活动记录</span><br><span class="line"></span><br><span class="line">6．13无形参的函数</span><br><span class="line"></span><br><span class="line">6．14内联函数</span><br><span class="line"></span><br><span class="line">6．15引用和引用形参</span><br><span class="line"></span><br><span class="line">6．16默认实参</span><br><span class="line"></span><br><span class="line">6．17一元的作用域分辨运算符</span><br><span class="line"></span><br><span class="line">6．18函数重载</span><br><span class="line"></span><br><span class="line">6．19函数模板</span><br><span class="line"></span><br><span class="line">6．20递归</span><br><span class="line"></span><br><span class="line">6．21递归应用示例： Fibonacci数列</span><br><span class="line"></span><br><span class="line">6．22递归与迭代</span><br><span class="line"></span><br><span class="line">6．23本章小结</span><br><span class="line"></span><br><span class="line">第7章 类模板array和vector、 异常捕获</span><br><span class="line"></span><br><span class="line">7．1简介</span><br><span class="line"></span><br><span class="line">7．2 array对象</span><br><span class="line"></span><br><span class="line">7．3 array对象的声明</span><br><span class="line"></span><br><span class="line">7．4使用array对象的例子</span><br><span class="line"></span><br><span class="line">7．5基于范围的for语句</span><br><span class="line"></span><br><span class="line">7．6实例研究： 利用array对象存放成绩的GradeBook类</span><br><span class="line"></span><br><span class="line">7．7 array对象的排序与查找</span><br><span class="line"></span><br><span class="line">7．8多维array对象</span><br><span class="line"></span><br><span class="line">7．9实例研究： 利用二维array对象的GradeBook类</span><br><span class="line"></span><br><span class="line">7．10 C++标准库类模板vector的介绍</span><br><span class="line"></span><br><span class="line">7．11本章小结</span><br><span class="line"></span><br><span class="line">第8章 指针</span><br><span class="line"></span><br><span class="line">8．1简介</span><br><span class="line"></span><br><span class="line">8．2指针变量的声明和初始化</span><br><span class="line"></span><br><span class="line">8．3指针运算符</span><br><span class="line"></span><br><span class="line">8．4使用指针的按引用传递方式</span><br><span class="line"></span><br><span class="line">8．5内置数组</span><br><span class="line"></span><br><span class="line">8．6使用const修饰指针</span><br><span class="line"></span><br><span class="line">8．7 sizeof运算符</span><br><span class="line"></span><br><span class="line">8．8指针表达式和指针算术运算</span><br><span class="line"></span><br><span class="line">8．9指针和内置数组之间的关系</span><br><span class="line"></span><br><span class="line">8．10基于指针的字符串</span><br><span class="line"></span><br><span class="line">8．11本章小结</span><br><span class="line"></span><br><span class="line">第9章 类的深入剖析： 抛出异常</span><br><span class="line"></span><br><span class="line">9．1简介</span><br><span class="line"></span><br><span class="line">9．2 Time类实例研究</span><br><span class="line"></span><br><span class="line">9．3类的作用域和类成员的访问</span><br><span class="line"></span><br><span class="line">9．4访问函数和工具函数</span><br><span class="line"></span><br><span class="line">9．5 Time类实例研究： 具有默认实参的构造函数</span><br><span class="line"></span><br><span class="line">9．6析构函数</span><br><span class="line"></span><br><span class="line">9．7何时调用构造函数和析构函数</span><br><span class="line"></span><br><span class="line">9．8 Time类实例研究： 微妙的陷阱――返回private数据成员的引用或指针</span><br><span class="line"></span><br><span class="line">9．9默认的逐个成员赋值</span><br><span class="line"></span><br><span class="line">9．10 const对象和const成员函数</span><br><span class="line"></span><br><span class="line">9．11组成： 对象作为类的成员</span><br><span class="line"></span><br><span class="line">9．12 friend函数和friend类</span><br><span class="line"></span><br><span class="line">9．13使用this指针</span><br><span class="line"></span><br><span class="line">9．14 static类成员</span><br><span class="line"></span><br><span class="line">9．15本章小结</span><br><span class="line"></span><br><span class="line">第10章 运算符重载： string类</span><br><span class="line"></span><br><span class="line">10．1简介</span><br><span class="line"></span><br><span class="line">10．2使用标准库中string类的重载运算符</span><br><span class="line"></span><br><span class="line">10．3运算符重载的基础知识</span><br><span class="line"></span><br><span class="line">10．4重载二元运算符</span><br><span class="line"></span><br><span class="line">10．5重载二元流插入运算符和流提取运算符</span><br><span class="line"></span><br><span class="line">10．6重载一元运算符</span><br><span class="line"></span><br><span class="line">10．7重载一元前置与后置运算符： ++和--</span><br><span class="line"></span><br><span class="line">10．8实例研究： Date类</span><br><span class="line"></span><br><span class="line">10．9动态内存管理</span><br><span class="line"></span><br><span class="line">10．10实例研究： Array类</span><br><span class="line"></span><br><span class="line">10．11运算符作为成员函数和非成员函数的比较</span><br><span class="line"></span><br><span class="line">10．12类型转换</span><br><span class="line"></span><br><span class="line">10．13 explicit构造函数与转换运算符</span><br><span class="line"></span><br><span class="line">10．14重载函数调用运算符（）</span><br><span class="line"></span><br><span class="line">10．15本章小结</span><br><span class="line"></span><br><span class="line">第11章 面向对象编程： 继承</span><br><span class="line"></span><br><span class="line">11．1简介</span><br><span class="line"></span><br><span class="line">11．2基类和派生类</span><br><span class="line"></span><br><span class="line">11．3基类和派生类之间的关系</span><br><span class="line"></span><br><span class="line">11．4派生类中的构造函数和析构函数</span><br><span class="line"></span><br><span class="line">11．5 public、 protected和private继承</span><br><span class="line"></span><br><span class="line">11．6继承与软件工程</span><br><span class="line"></span><br><span class="line">11．7本章小结</span><br><span class="line"></span><br><span class="line">第12章 面向对象编程： 多态性</span><br><span class="line"></span><br><span class="line">12．1简介</span><br><span class="line"></span><br><span class="line">12．2多态性介绍： 多态视频游戏</span><br><span class="line"></span><br><span class="line">12．3类继承层次中对象之间的关系</span><br><span class="line"></span><br><span class="line">12．4类型域和switch语句</span><br><span class="line"></span><br><span class="line">12．5抽象类和纯virtual函数</span><br><span class="line"></span><br><span class="line">12．6实例研究： 应用多态性的工资发放系统</span><br><span class="line"></span><br><span class="line">12．7（选读）多态性、 virtual函数和动态绑定的底层实现机制</span><br><span class="line"></span><br><span class="line">12．8实例研究： 应用向下强制类型转换、 dynamic_cast、 typeid和type_info并使用</span><br><span class="line"></span><br><span class="line">多态性和运行时类型信息的工资发放系统</span><br><span class="line"></span><br><span class="line">12．9本章小结</span><br><span class="line"></span><br><span class="line">第13章 输入&#x2F;输出流的深入剖析</span><br><span class="line"></span><br><span class="line">13．1简介</span><br><span class="line"></span><br><span class="line">13．2流</span><br><span class="line"></span><br><span class="line">13．3输出流</span><br><span class="line"></span><br><span class="line">13．4输入流</span><br><span class="line"></span><br><span class="line">13．5使用read、 write和gcount的非格式化的I&#x2F;O</span><br><span class="line"></span><br><span class="line">13．6流操作符简介</span><br><span class="line"></span><br><span class="line">13．7流的格式状态和流操作符</span><br><span class="line"></span><br><span class="line">13．8流的错误状态</span><br><span class="line"></span><br><span class="line">13．9将输出流连接到输入流</span><br><span class="line"></span><br><span class="line">13．10本章小结</span><br><span class="line"></span><br><span class="line">第14章 文件处理</span><br><span class="line"></span><br><span class="line">14．1简介</span><br><span class="line"></span><br><span class="line">14．2文件和流</span><br><span class="line"></span><br><span class="line">14．3创建顺序文件</span><br><span class="line"></span><br><span class="line">14．4从顺序文件读取数据</span><br><span class="line"></span><br><span class="line">14．5更新顺序文件</span><br><span class="line"></span><br><span class="line">14．6随机存取文件</span><br><span class="line"></span><br><span class="line">14．7创建随机存取文件</span><br><span class="line"></span><br><span class="line">14．8向随机存取文件随机写入数据</span><br><span class="line"></span><br><span class="line">14．9从随机存取文件顺序读取数据</span><br><span class="line"></span><br><span class="line">14．10实例研究： 事务处理程序</span><br><span class="line"></span><br><span class="line">14．11对象序列化</span><br><span class="line"></span><br><span class="line">14．12本章小结第15章标准库的容器和迭代器</span><br><span class="line"></span><br><span class="line">15．1标准模板库（STL）简介</span><br><span class="line"></span><br><span class="line">15．2容器简介</span><br><span class="line"></span><br><span class="line">15．3迭代器简介</span><br><span class="line"></span><br><span class="line">15．4算法简介</span><br><span class="line"></span><br><span class="line">15．5序列容器</span><br><span class="line"></span><br><span class="line">15．6关联容器</span><br><span class="line"></span><br><span class="line">15．7容器适配器</span><br><span class="line"></span><br><span class="line">15．8 bitset类</span><br><span class="line"></span><br><span class="line">15．9本章小结</span><br><span class="line"></span><br><span class="line">第16章 标准库算法</span><br><span class="line"></span><br><span class="line">16．1简介</span><br><span class="line"></span><br><span class="line">16．2对迭代器的最低要求</span><br><span class="line"></span><br><span class="line">16．3算法</span><br><span class="line"></span><br><span class="line">16．4函数对象</span><br><span class="line"></span><br><span class="line">16．5 lambda表达式</span><br><span class="line"></span><br><span class="line">16．6标准库算法总结</span><br><span class="line"></span><br><span class="line">16．7本章小结</span><br><span class="line"></span><br><span class="line">第17章 异常处理深入剖析</span><br><span class="line"></span><br><span class="line">17．1简介</span><br><span class="line"></span><br><span class="line">17．2实例： 处理除数为0的异常处理</span><br><span class="line"></span><br><span class="line">17．3重新抛出异常</span><br><span class="line"></span><br><span class="line">17．4堆栈展开</span><br><span class="line"></span><br><span class="line">17．5什么时候使用异常处理</span><br><span class="line"></span><br><span class="line">17．6构造函数、 析构函数和异常处理</span><br><span class="line"></span><br><span class="line">17．7异常与继承</span><br><span class="line"></span><br><span class="line">17．8处理new失败</span><br><span class="line"></span><br><span class="line">17．9类uique_ptr和动态内存分配</span><br><span class="line"></span><br><span class="line">17．10标准库的异常类层次结构</span><br><span class="line"></span><br><span class="line">17．11本章小结</span><br><span class="line"></span><br><span class="line">第18章 自定义模板的介绍</span><br><span class="line"></span><br><span class="line">18．1简介</span><br><span class="line"></span><br><span class="line">18．2类模板</span><br><span class="line"></span><br><span class="line">18．3使用函数模板来操作类模板特化的对象</span><br><span class="line"></span><br><span class="line">18．4非类型形参</span><br><span class="line"></span><br><span class="line">18．5模板类型形参的默认实参</span><br><span class="line"></span><br><span class="line">18．6重载函数模板</span><br><span class="line"></span><br><span class="line">18．7本章小结</span><br><span class="line"></span><br><span class="line">第19章 自定义的模板化数据结构</span><br><span class="line"></span><br><span class="line">19．1简介</span><br><span class="line"></span><br><span class="line">19．2自引用类</span><br><span class="line"></span><br><span class="line">19．3链表</span><br><span class="line"></span><br><span class="line">19．4堆栈</span><br><span class="line"></span><br><span class="line">19．5队列</span><br><span class="line"></span><br><span class="line">19．6树</span><br><span class="line"></span><br><span class="line">19．7本章小结</span><br><span class="line"></span><br><span class="line">第20章 查找与排序</span><br><span class="line"></span><br><span class="line">20．1简介</span><br><span class="line"></span><br><span class="line">20．2查找算法</span><br><span class="line"></span><br><span class="line">20．3排序算法</span><br><span class="line"></span><br><span class="line">20．4本章小结</span><br><span class="line"></span><br><span class="line">第21章 string类和字符串流处理的深入剖析</span><br><span class="line"></span><br><span class="line">21．1简介</span><br><span class="line"></span><br><span class="line">21．2字符串的赋值和连接</span><br><span class="line"></span><br><span class="line">21．3字符串的比较</span><br><span class="line"></span><br><span class="line">21．4子串</span><br><span class="line"></span><br><span class="line">21．5交换字符串</span><br><span class="line"></span><br><span class="line">21．6 string类的特征</span><br><span class="line"></span><br><span class="line">21．7查找字符串中的子串和字符</span><br><span class="line"></span><br><span class="line">21．8在字符串中替换字符</span><br><span class="line"></span><br><span class="line">21．9在字符串中插入字符</span><br><span class="line"></span><br><span class="line">21．10转换成C风格的基于指针的char字符串</span><br><span class="line"></span><br><span class="line">21．11迭代器</span><br><span class="line"></span><br><span class="line">21．12字符串流处理</span><br><span class="line"></span><br><span class="line">21．13 C++11数值转换函数</span><br><span class="line"></span><br><span class="line">21．14本章小结</span><br><span class="line"></span><br><span class="line">第22章 位、 字符、 C字符串和结构体</span><br><span class="line"></span><br><span class="line">22．1简介</span><br><span class="line"></span><br><span class="line">22．2结构体的定义</span><br><span class="line"></span><br><span class="line">22．3 typedef</span><br><span class="line"></span><br><span class="line">22．4示例： 洗牌和发牌模拟</span><br><span class="line"></span><br><span class="line">22．5位运算符</span><br><span class="line"></span><br><span class="line">22．6位域</span><br><span class="line"></span><br><span class="line">22．7字符处理库</span><br><span class="line"></span><br><span class="line">22．8 C字符串操作函数</span><br><span class="line"></span><br><span class="line">22．9 C字符串转换函数</span><br><span class="line"></span><br><span class="line">22．10 C字符串操作库中的搜索函数</span><br><span class="line"></span><br><span class="line">22．11 C字符串操作库中的内存函数</span><br><span class="line"></span><br><span class="line">22．12本章小结</span><br><span class="line"></span><br><span class="line">第23章 其他主题</span><br><span class="line"></span><br><span class="line">23．1简介</span><br><span class="line"></span><br><span class="line">23．2 const_cast运算符</span><br><span class="line"></span><br><span class="line">23．3 mutable类成员</span><br><span class="line"></span><br><span class="line">23．4命名空间</span><br><span class="line"></span><br><span class="line">23．5运算符关键字</span><br><span class="line"></span><br><span class="line">23．6指向类成员的指针（．和-＞）</span><br><span class="line"></span><br><span class="line">23．7多重继承</span><br><span class="line"></span><br><span class="line">23．8多重继承和virtual基类</span><br><span class="line"></span><br><span class="line">23．9本章小结</span><br><span class="line"></span><br><span class="line">附录A运算符的优先级与结合律</span><br><span class="line"></span><br><span class="line">附录B ASCII字符集</span><br><span class="line"></span><br><span class="line">附录C基本数据类型</span><br><span class="line"></span><br><span class="line">附录D计数系统</span><br><span class="line"></span><br><span class="line">附录E预处理器索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入探索C++对象模型 PDF</title>
    <url>/posts/fd8338f8/</url>
    <content><![CDATA[<h4 id="《深入探索C-对象模型》"><a href="#《深入探索C-对象模型》" class="headerlink" title="《深入探索C++对象模型》"></a>《深入探索C++对象模型》</h4><h6 id="链接-https-pan-baidu-com-s-1wgdmx-bfiJGCYnmuEimYdw-提取码-s4ht"><a href="#链接-https-pan-baidu-com-s-1wgdmx-bfiJGCYnmuEimYdw-提取码-s4ht" class="headerlink" title="链接: https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw 提取码: s4ht"></a>链接: <a href="https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw">https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw</a> 提取码: s4ht</h6><p>　本书重点介绍了C++面向对象程序设计的底层机制，包括结构式语意、暂时性对象的生成、封装、继承和虚拟——虚拟函数和虚拟继承。书中向你表明：理解底层实现模型，可以极大地提高你的编码效率。Lippman澄清了那些关于C++系统开销与复杂性的各种错误信息和猜测，指出了其中某些成本和利益交换确实存在。他在书中详述了各种实现模型，指出了它们的发展方向以及促使其发展的根本原因。本书涵盖了C++对象模型的语意暗示，并指出了这个模型是如何对程序造成影响的。<br><a id="more"></a><br><!-- more --></p>
<p>　　</p>
<p><img src="/images/2d8e59e7e0b8c33a6113a25de7643de81.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">1 Object Lessons</span><br><span class="line"></span><br><span class="line">2 The Semantics of Constructors</span><br><span class="line"></span><br><span class="line">3 The Semantics of Data</span><br><span class="line"></span><br><span class="line">4 The Semantics of Function</span><br><span class="line"></span><br><span class="line">5 Semantics of Construction,Destruction,and Copy</span><br><span class="line"></span><br><span class="line">6 Runtime Semantics</span><br><span class="line"></span><br><span class="line">7 On the Cusp of the Object Model</span><br><span class="line"></span><br><span class="line">Index</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++设计新思维-泛型编程与设计之应用 PDF</title>
    <url>/posts/8a84086e/</url>
    <content><![CDATA[<h4 id="《C-设计新思维-泛型编程与设计之应用》"><a href="#《C-设计新思维-泛型编程与设计之应用》" class="headerlink" title="《C++设计新思维-泛型编程与设计之应用》"></a>《C++设计新思维-泛型编程与设计之应用》</h4><h6 id="链接-https-pan-baidu-com-s-1-filEqOMM0laa8HykZ7rqw-提取码-a73e"><a href="#链接-https-pan-baidu-com-s-1-filEqOMM0laa8HykZ7rqw-提取码-a73e" class="headerlink" title="链接: https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw 提取码: a73e"></a>链接: <a href="https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw">https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw</a> 提取码: a73e</h6><p><img src="/images/721291edffa41a2d0899e9915bdc07901.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++primer5th PDF</title>
    <url>/posts/138d59d4/</url>
    <content><![CDATA[<h4 id="《C-primer5th》"><a href="#《C-primer5th》" class="headerlink" title="《C++primer5th》"></a>《C++primer5th》</h4><h5 id="链接-https-pan-baidu-com-s-18XEECPX5Zfi4aCOxSdQR7g-提取码-f66t"><a href="#链接-https-pan-baidu-com-s-18XEECPX5Zfi4aCOxSdQR7g-提取码-f66t" class="headerlink" title="链接: https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g 提取码: f66t"></a>链接: <a href="https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g">https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g</a> 提取码: f66t</h5><p>Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他最早接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和C Primer Plus。<br><a id="more"></a></p>
<p><img src="/images/575720d3c11e5d80cea3a386a372d65d1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第 1章 预备知识 1</span><br><span class="line"></span><br><span class="line">1．1　C++简介　1</span><br><span class="line"></span><br><span class="line">1．2　C++简史　2</span><br><span class="line"></span><br><span class="line">1．2．1　C语言　2</span><br><span class="line"></span><br><span class="line">1．2．2　C语言编程原理　2</span><br><span class="line"></span><br><span class="line">1．2．3　面向对象编程　3</span><br><span class="line"></span><br><span class="line">1．2．4　C++和泛型编程　3</span><br><span class="line"></span><br><span class="line">1．2．5　C++的起源　4</span><br><span class="line"></span><br><span class="line">1．3　可移植性和标准　5</span><br><span class="line"></span><br><span class="line">1．3．1　C++的发展　5</span><br><span class="line"></span><br><span class="line">1．3．2　本书遵循的C++标准　6</span><br><span class="line"></span><br><span class="line">1．4　程序创建的技巧　6</span><br><span class="line"></span><br><span class="line">1．4．1　创建源代码文件　6</span><br><span class="line"></span><br><span class="line">1．4．2　编译和链接　7</span><br><span class="line"></span><br><span class="line">1．5　总结　10</span><br><span class="line"></span><br><span class="line">第　2章 开始学习C++　11</span><br><span class="line"></span><br><span class="line">2．1　进入C++　11</span><br><span class="line"></span><br><span class="line">2．1．1　main( )函数　12</span><br><span class="line"></span><br><span class="line">2．1．2　C++注释　14</span><br><span class="line"></span><br><span class="line">2．1．3　C++预处理器和iostream文件　14</span><br><span class="line"></span><br><span class="line">2．1．4　头文件名　15</span><br><span class="line"></span><br><span class="line">2．1．5　名称空间　15</span><br><span class="line"></span><br><span class="line">2．1．6　使用cout进行C++输出　16</span><br><span class="line"></span><br><span class="line">2．1．7　C++源代码的格式化　17</span><br><span class="line"></span><br><span class="line">2．2　C++语句　18</span><br><span class="line"></span><br><span class="line">2．2．1　声明语句和变量　19</span><br><span class="line"></span><br><span class="line">2．2．2　赋值语句　20</span><br><span class="line"></span><br><span class="line">2．2．3　cout的新花样　20</span><br><span class="line"></span><br><span class="line">2．3　其他C++语句　21</span><br><span class="line"></span><br><span class="line">2．3．1　使用cin　21</span><br><span class="line"></span><br><span class="line">2．3．2　使用cout进行拼接　21</span><br><span class="line"></span><br><span class="line">2．3．3　类简介　22</span><br><span class="line"></span><br><span class="line">2．4　函数　23</span><br><span class="line"></span><br><span class="line">2．4．1　使用有返回值的函数　23</span><br><span class="line"></span><br><span class="line">2．4．2　函数变体　25</span><br><span class="line"></span><br><span class="line">2．4．3　用户定义的函数　26</span><br><span class="line"></span><br><span class="line">2．4．4　用户定义的有返回值的函数　28</span><br><span class="line"></span><br><span class="line">2．4．5　在多函数程序中使用using编译指令　29</span><br><span class="line"></span><br><span class="line">2．5　总结　30</span><br><span class="line"></span><br><span class="line">2．6　复习题　30</span><br><span class="line"></span><br><span class="line">2．7　编程练习　30</span><br><span class="line"></span><br><span class="line">第3章　处理数据　32</span><br><span class="line"></span><br><span class="line">3．1　简单变量　32</span><br><span class="line"></span><br><span class="line">3．1．1　变量名　33</span><br><span class="line"></span><br><span class="line">3．1．2　整型　34</span><br><span class="line"></span><br><span class="line">3．1．3　整型short、int、long和long long　34</span><br><span class="line"></span><br><span class="line">3．1．4　无符号类型　37</span><br><span class="line"></span><br><span class="line">3．1．5　选择整型类型　38</span><br><span class="line"></span><br><span class="line">3．1．6　整型字面值　39</span><br><span class="line"></span><br><span class="line">3．1．7　C++如何确定常量的类型　40</span><br><span class="line"></span><br><span class="line">3．1．8　char类型：字符和小整数　41</span><br><span class="line"></span><br><span class="line">3．1．9　bool类型　46</span><br><span class="line"></span><br><span class="line">3．2　const限定符　46</span><br><span class="line"></span><br><span class="line">3．3　浮点数　47</span><br><span class="line"></span><br><span class="line">3．3．1　书写浮点数　47</span><br><span class="line"></span><br><span class="line">3．3．2　浮点类型　48</span><br><span class="line"></span><br><span class="line">3．3．3　浮点常量　49</span><br><span class="line"></span><br><span class="line">3．3．4　浮点数的优缺点　49</span><br><span class="line"></span><br><span class="line">3．4　C++算术运算符　50</span><br><span class="line"></span><br><span class="line">3．4．1　运算符优先级和结合性　51</span><br><span class="line"></span><br><span class="line">3．4．2　除法分支　51</span><br><span class="line"></span><br><span class="line">3．4．3　求模运算符　52</span><br><span class="line"></span><br><span class="line">3．4．4　类型转换　53</span><br><span class="line"></span><br><span class="line">3．4．5　C++11中的auto声明　56</span><br><span class="line"></span><br><span class="line">3．5　总结　57</span><br><span class="line"></span><br><span class="line">3．6　复习题　57</span><br><span class="line"></span><br><span class="line">3．7　编程练习　58</span><br><span class="line"></span><br><span class="line">第4章　复合类型　59</span><br><span class="line"></span><br><span class="line">4．1　数组　59</span><br><span class="line"></span><br><span class="line">4．1．1　程序说明　61</span><br><span class="line"></span><br><span class="line">4．1．2　数组的初始化规则　61</span><br><span class="line"></span><br><span class="line">4．1．3　C++11数组初始化方法　62</span><br><span class="line"></span><br><span class="line">4．2　字符串　62</span><br><span class="line"></span><br><span class="line">4．2．1　拼接字符串常量　63</span><br><span class="line"></span><br><span class="line">4．2．2　在数组中使用字符串　63</span><br><span class="line"></span><br><span class="line">4．2．3　字符串输入　64</span><br><span class="line"></span><br><span class="line">4．2．4　每次读取一行字符串输入　65</span><br><span class="line"></span><br><span class="line">4．2．5　混合输入字符串和数字　67</span><br><span class="line"></span><br><span class="line">4．3　string类简介　68</span><br><span class="line"></span><br><span class="line">4．3．1　C++11字符串初始化　69</span><br><span class="line"></span><br><span class="line">4．3．2　赋值、拼接和附加　69</span><br><span class="line"></span><br><span class="line">4．3．3　string类的其他操作　70</span><br><span class="line"></span><br><span class="line">4．3．4　string类I&#x2F;O　71</span><br><span class="line"></span><br><span class="line">4．3．5　其他形式的字符串字面值　72</span><br><span class="line"></span><br><span class="line">4．4　结构简介　73</span><br><span class="line"></span><br><span class="line">4．4．1　在程序中使用结构　74</span><br><span class="line"></span><br><span class="line">4．4．2　C++11结构初始化　75</span><br><span class="line"></span><br><span class="line">4．4．3　结构可以将string类作为成员吗　75</span><br><span class="line"></span><br><span class="line">4．4．4　其他结构属性　76</span><br><span class="line"></span><br><span class="line">4．4．5　结构数组　77</span><br><span class="line"></span><br><span class="line">4．4．6　结构中的位字段　78</span><br><span class="line"></span><br><span class="line">4．5　共用体　78</span><br><span class="line"></span><br><span class="line">4．6　枚举　79</span><br><span class="line"></span><br><span class="line">4．6．1　设置枚举量的值　80</span><br><span class="line"></span><br><span class="line">4．6．2　枚举的取值范围　80</span><br><span class="line"></span><br><span class="line">4．7　指针和自由存储空间　80</span><br><span class="line"></span><br><span class="line">4．7．1　声明和初始化指针　82</span><br><span class="line"></span><br><span class="line">4．7．2　指针的危险　84</span><br><span class="line"></span><br><span class="line">4．7．3　指针和数字　84</span><br><span class="line"></span><br><span class="line">4．7．4　使用new来分配内存　84</span><br><span class="line"></span><br><span class="line">4．7．5　使用delete释放内存　86</span><br><span class="line"></span><br><span class="line">4．7．6　使用new来创建动态数组　86</span><br><span class="line"></span><br><span class="line">4．8　指针、数组和指针算术　88</span><br><span class="line"></span><br><span class="line">4．8．1　程序说明　89</span><br><span class="line"></span><br><span class="line">4．8．2　指针小结　90</span><br><span class="line"></span><br><span class="line">4．8．3　指针和字符串　92</span><br><span class="line"></span><br><span class="line">4．8．4　使用new创建动态结构　94</span><br><span class="line"></span><br><span class="line">4．8．5　自动存储、静态存储和动态存储　96</span><br><span class="line"></span><br><span class="line">4．9　类型组合　97</span><br><span class="line"></span><br><span class="line">4．10　数组的替代品　99</span><br><span class="line"></span><br><span class="line">4．10．1　模板类vector　99</span><br><span class="line"></span><br><span class="line">4．10．2　模板类array（C++11）　99</span><br><span class="line"></span><br><span class="line">4．10．3　比较数组、vector对象和array对象　99</span><br><span class="line"></span><br><span class="line">4．11　总结　101</span><br><span class="line"></span><br><span class="line">4．12　复习题　101</span><br><span class="line"></span><br><span class="line">4．13　编程练习　102</span><br><span class="line"></span><br><span class="line">第5章　循环和关系表达式　104</span><br><span class="line"></span><br><span class="line">5．1　for循环　104</span><br><span class="line"></span><br><span class="line">5．1．1　for循环的组成部分　105</span><br><span class="line"></span><br><span class="line">5．1．2　回到for循环　109</span><br><span class="line"></span><br><span class="line">5．1．3　修改步长　110</span><br><span class="line"></span><br><span class="line">5．1．4　使用for循环访问字符串　110</span><br><span class="line"></span><br><span class="line">5．1．5　递增运算符（++）和递减运算符（ ）　111</span><br><span class="line"></span><br><span class="line">5．1．6　副作用和顺序点　112</span><br><span class="line"></span><br><span class="line">5．1．7　前缀格式和后缀格式　112</span><br><span class="line"></span><br><span class="line">5．1．8　递增&#x2F;递减运算符和指针　112</span><br><span class="line"></span><br><span class="line">5．1．9　组合赋值运算符　113</span><br><span class="line"></span><br><span class="line">5．1．10　复合语句（语句块）　113</span><br><span class="line"></span><br><span class="line">5．1．11　其他语法技巧——逗号运算符　115</span><br><span class="line"></span><br><span class="line">5．1．12　关系表达式　116</span><br><span class="line"></span><br><span class="line">5．1．13　赋值、比较和可能犯的错误　117</span><br><span class="line"></span><br><span class="line">5．1．14　C-风格字符串的比较　118</span><br><span class="line"></span><br><span class="line">5．1．15　比较string类字符串　120</span><br><span class="line"></span><br><span class="line">5．2　while循环　120</span><br><span class="line"></span><br><span class="line">5．2．1　for与while　121</span><br><span class="line"></span><br><span class="line">5．2．2　等待一段时间：编写延时循环　123</span><br><span class="line"></span><br><span class="line">5．3　do while循环　124</span><br><span class="line"></span><br><span class="line">5．4　基于范围的for循环（C++11）　125</span><br><span class="line"></span><br><span class="line">5．5　循环和文本输入　125</span><br><span class="line"></span><br><span class="line">5．5．1　使用原始的cin进行输入　126</span><br><span class="line"></span><br><span class="line">5．5．2　使用cin．get(char)进行补救　126</span><br><span class="line"></span><br><span class="line">5．5．3　使用哪一个cin．get( )　127</span><br><span class="line"></span><br><span class="line">5．5．4　文件尾条件　128</span><br><span class="line"></span><br><span class="line">5．5．5　另一个cin．get( )版本　129</span><br><span class="line"></span><br><span class="line">5．6　嵌套循环和二维数组　131</span><br><span class="line"></span><br><span class="line">5．6．1　初始化二维数组　132</span><br><span class="line"></span><br><span class="line">5．6．2　使用二维数组　133</span><br><span class="line"></span><br><span class="line">5．7　总结　134</span><br><span class="line"></span><br><span class="line">5．8　复习题　134</span><br><span class="line"></span><br><span class="line">5．9　编程练习　135</span><br><span class="line"></span><br><span class="line">第6章　分支语句和逻辑运算符　137</span><br><span class="line"></span><br><span class="line">6．1　if语句　137</span><br><span class="line"></span><br><span class="line">6．1．1　if else语句　138</span><br><span class="line"></span><br><span class="line">6．1．2　格式化if else语句　139</span><br><span class="line"></span><br><span class="line">6．1．3　if else if else结构　140</span><br><span class="line"></span><br><span class="line">6．2　逻辑表达式　141</span><br><span class="line"></span><br><span class="line">6．2．1　逻辑OR运算符：||　141</span><br><span class="line"></span><br><span class="line">6．2．2　逻辑AND运算符：&amp;&amp;　142</span><br><span class="line"></span><br><span class="line">6．2．3　用&amp;&amp;来设置取值范围　144</span><br><span class="line"></span><br><span class="line">6．2．4　逻辑NOT运算符：!　145</span><br><span class="line"></span><br><span class="line">6．2．5　逻辑运算符细节　146</span><br><span class="line"></span><br><span class="line">6．2．6　其他表示方式　146</span><br><span class="line"></span><br><span class="line">6．3　字符函数库cctype　147</span><br><span class="line"></span><br><span class="line">6．4　：运算符　148</span><br><span class="line"></span><br><span class="line">6．5　switch语句　149</span><br><span class="line"></span><br><span class="line">6．5．1　将枚举量用作标签　151</span><br><span class="line"></span><br><span class="line">6．5．2　switch和if else　152</span><br><span class="line"></span><br><span class="line">6．6　break和continue语句　153</span><br><span class="line"></span><br><span class="line">6．7　读取数字的循环　154</span><br><span class="line"></span><br><span class="line">6．8　简单文件输入&#x2F;输出　157</span><br><span class="line"></span><br><span class="line">6．8．1　文本I&#x2F;O和文本文件　157</span><br><span class="line"></span><br><span class="line">6．8．2　写入到文本文件中　158</span><br><span class="line"></span><br><span class="line">6．8．3　读取文本文件　160</span><br><span class="line"></span><br><span class="line">6．9　总结　163</span><br><span class="line"></span><br><span class="line">6．10　复习题　163</span><br><span class="line"></span><br><span class="line">6．11　编程练习　165</span><br><span class="line"></span><br><span class="line">第7章　函数——C++的编程模块　167</span><br><span class="line"></span><br><span class="line">7．1　复习函数的基本知识　167</span><br><span class="line"></span><br><span class="line">7．1．1　定义函数　168</span><br><span class="line"></span><br><span class="line">7．1．2　函数原型和函数调用　169</span><br><span class="line"></span><br><span class="line">7．2　函数参数和按值传递　171</span><br><span class="line"></span><br><span class="line">7．2．1　多个参数　172</span><br><span class="line"></span><br><span class="line">7．2．2　另一个接受两个参数的函数　174</span><br><span class="line"></span><br><span class="line">7．3　函数和数组　175</span><br><span class="line"></span><br><span class="line">7．3．1　函数如何使用指针来处理数组　176</span><br><span class="line"></span><br><span class="line">7．3．2　将数组作为参数意味着什么　176</span><br><span class="line"></span><br><span class="line">7．3．3　更多数组函数示例　178</span><br><span class="line"></span><br><span class="line">7．3．4　使用数组区间的函数　181</span><br><span class="line"></span><br><span class="line">7．3．5　指针和const　182</span><br><span class="line"></span><br><span class="line">7．4　函数和二维数组　185</span><br><span class="line"></span><br><span class="line">7．5　函数和C-风格字符串　186</span><br><span class="line"></span><br><span class="line">7．5．1　将C-风格字符串作为参数的函数　186</span><br><span class="line"></span><br><span class="line">7．5．2　返回C-风格字符串的函数　187</span><br><span class="line"></span><br><span class="line">7．6　函数和结构　188</span><br><span class="line"></span><br><span class="line">7．6．1　传递和返回结构　188</span><br><span class="line"></span><br><span class="line">7．6．2　另一个处理结构的函数示例　189</span><br><span class="line"></span><br><span class="line">7．6．3　传递结构的地址　192</span><br><span class="line"></span><br><span class="line">7．7　函数和string对象　194</span><br><span class="line"></span><br><span class="line">7．8　函数与array对象　195</span><br><span class="line"></span><br><span class="line">7．9　递归　196</span><br><span class="line"></span><br><span class="line">7．9．1　包含一个递归调用的递归　196</span><br><span class="line"></span><br><span class="line">7．9．2　包含多个递归调用的递归　197</span><br><span class="line"></span><br><span class="line">7．10　函数指针　198</span><br><span class="line"></span><br><span class="line">7．10．1　函数指针的基础知识　199</span><br><span class="line"></span><br><span class="line">7．10．2　函数指针示例　200</span><br><span class="line"></span><br><span class="line">7．10．3　深入探讨函数指针　201</span><br><span class="line"></span><br><span class="line">7．10．4　使用typedef进行简化　204</span><br><span class="line"></span><br><span class="line">7．11　总结　204</span><br><span class="line"></span><br><span class="line">7．12　复习题　205</span><br><span class="line"></span><br><span class="line">7．13　编程练习　206</span><br><span class="line"></span><br><span class="line">第8章　函数探幽　208</span><br><span class="line"></span><br><span class="line">8．1　C++内联函数　208</span><br><span class="line"></span><br><span class="line">8．2　引用变量　210</span><br><span class="line"></span><br><span class="line">8．2．1　创建引用变量　210</span><br><span class="line"></span><br><span class="line">8．2．2　将引用用作函数参数　212</span><br><span class="line"></span><br><span class="line">8．2．3　引用的属性和特别之处　214</span><br><span class="line"></span><br><span class="line">8．2．4　将引用用于结构　216</span><br><span class="line"></span><br><span class="line">8．2．5　将引用用于类对象　220</span><br><span class="line"></span><br><span class="line">8．2．6　对象、继承和引用　222</span><br><span class="line"></span><br><span class="line">8．2．7　何时使用引用参数　224</span><br><span class="line"></span><br><span class="line">8．3　默认参数　225</span><br><span class="line"></span><br><span class="line">8．4　函数重载　227</span><br><span class="line"></span><br><span class="line">8．4．1　重载示例　228</span><br><span class="line"></span><br><span class="line">8．4．2　何时使用函数重载　230</span><br><span class="line"></span><br><span class="line">8．5　函数模板　230</span><br><span class="line"></span><br><span class="line">8．5．1　重载的模板　232</span><br><span class="line"></span><br><span class="line">8．5．2　模板的局限性　233</span><br><span class="line"></span><br><span class="line">8．5．3　显式具体化　234</span><br><span class="line"></span><br><span class="line">8．5．4　实例化和具体化　236</span><br><span class="line"></span><br><span class="line">8．5．5　编译器选择使用哪个函数版本　237</span><br><span class="line"></span><br><span class="line">8．5．6　模板函数的发展　241</span><br><span class="line"></span><br><span class="line">8．6　总结　243</span><br><span class="line"></span><br><span class="line">8．7　复习题　243</span><br><span class="line"></span><br><span class="line">8．8　编程练习　244</span><br><span class="line"></span><br><span class="line">第9章　内存模型和名称空间　246</span><br><span class="line"></span><br><span class="line">9．1　单独编译　246</span><br><span class="line"></span><br><span class="line">9．2　存储持续性、作用域和链接性　250</span><br><span class="line"></span><br><span class="line">9．2．1　作用域和链接　250</span><br><span class="line"></span><br><span class="line">9．2．2　自动存储持续性　250</span><br><span class="line"></span><br><span class="line">9．2．3　静态持续变量　253</span><br><span class="line"></span><br><span class="line">9．2．4　静态持续性、外部链接性　254</span><br><span class="line"></span><br><span class="line">9．2．5　静态持续性、内部链接性　257</span><br><span class="line"></span><br><span class="line">9．2．6　静态存储持续性、无链接性　258</span><br><span class="line"></span><br><span class="line">9．2．7　说明符和限定符　260</span><br><span class="line"></span><br><span class="line">9．2．8　函数和链接性　261</span><br><span class="line"></span><br><span class="line">9．2．9　语言链接性　262</span><br><span class="line"></span><br><span class="line">9．2．10　存储方案和动态分配　262</span><br><span class="line"></span><br><span class="line">9．3　名称空间　266</span><br><span class="line"></span><br><span class="line">9．3．1　传统的C++名称空间　266</span><br><span class="line"></span><br><span class="line">9．3．2　新的名称空间特性　267</span><br><span class="line"></span><br><span class="line">9．3．3　名称空间示例　271</span><br><span class="line"></span><br><span class="line">9．3．4　名称空间及其前途　274</span><br><span class="line"></span><br><span class="line">9．4　总结　274</span><br><span class="line"></span><br><span class="line">9．5　复习题　275</span><br><span class="line"></span><br><span class="line">9．6　编程练习　276</span><br><span class="line"></span><br><span class="line">第　10章 对象和类　278</span><br><span class="line"></span><br><span class="line">10．1　过程性编程和面向对象编程　278</span><br><span class="line"></span><br><span class="line">10．2　抽象和类　279</span><br><span class="line"></span><br><span class="line">10．2．1　类型是什么　279</span><br><span class="line"></span><br><span class="line">10．2．2　C++中的类　280</span><br><span class="line"></span><br><span class="line">10．2．3　实现类成员函数　283</span><br><span class="line"></span><br><span class="line">10．2．4　使用类　285</span><br><span class="line"></span><br><span class="line">10．2．5　修改实现　286</span><br><span class="line"></span><br><span class="line">10．2．6　小结　287</span><br><span class="line"></span><br><span class="line">10．3　类的构造函数和析构函数　288</span><br><span class="line"></span><br><span class="line">10．3．1　声明和定义构造函数　288</span><br><span class="line"></span><br><span class="line">10．3．2　使用构造函数　289</span><br><span class="line"></span><br><span class="line">10．3．3　默认构造函数　290</span><br><span class="line"></span><br><span class="line">10．3．4　析构函数　290</span><br><span class="line"></span><br><span class="line">10．3．5　改进Stock类　291</span><br><span class="line"></span><br><span class="line">10．3．6　构造函数和析构函数小结　296</span><br><span class="line"></span><br><span class="line">10．4　this指针　296</span><br><span class="line"></span><br><span class="line">10．5　对象数组　300</span><br><span class="line"></span><br><span class="line">10．6　类作用域　302</span><br><span class="line"></span><br><span class="line">10．6．1　作用域为类的常量　302</span><br><span class="line"></span><br><span class="line">10．6．2　作用域内枚举（C++11）　303</span><br><span class="line"></span><br><span class="line">10．7　抽象数据类型　304</span><br><span class="line"></span><br><span class="line">10．8　总结　307</span><br><span class="line"></span><br><span class="line">10．9　复习题　307</span><br><span class="line"></span><br><span class="line">10．10　编程练习　308</span><br><span class="line"></span><br><span class="line">第　11章 使用类　310</span><br><span class="line"></span><br><span class="line">11．1　运算符重载　310</span><br><span class="line"></span><br><span class="line">11．2　计算时间：一个运算符重载示例　311</span><br><span class="line"></span><br><span class="line">11．2．1　添加加法运算符　313</span><br><span class="line"></span><br><span class="line">11．2．2　重载限制　315</span><br><span class="line"></span><br><span class="line">11．2．3　其他重载运算符　316</span><br><span class="line"></span><br><span class="line">11．3　友元　318</span><br><span class="line"></span><br><span class="line">11．3．1　创建友元　319</span><br><span class="line"></span><br><span class="line">11．3．2　常用的友元：重载&lt;&lt;运算符　320</span><br><span class="line"></span><br><span class="line">11．4　重载运算符：作为成员函数还是非成员函数　324</span><br><span class="line"></span><br><span class="line">11．5　再谈重载：一个矢量类　324</span><br><span class="line"></span><br><span class="line">11．5．1　使用状态成员　329</span><br><span class="line"></span><br><span class="line">11．5．2　为Vector类重载算术运算符　331</span><br><span class="line"></span><br><span class="line">11．5．3　对实现的说明　332</span><br><span class="line"></span><br><span class="line">11．5．4　使用Vector类来模拟随机漫步　332</span><br><span class="line"></span><br><span class="line">11．6　类的自动转换和强制类型转换　334</span><br><span class="line"></span><br><span class="line">11．6．1　转换函数　338</span><br><span class="line"></span><br><span class="line">11．6．2　转换函数和友元函数　341</span><br><span class="line"></span><br><span class="line">11．7　总结　343</span><br><span class="line"></span><br><span class="line">11．8　复习题　344</span><br><span class="line"></span><br><span class="line">11．9　编程练习　344</span><br><span class="line"></span><br><span class="line">第　12章 类和动态内存分配　346</span><br><span class="line"></span><br><span class="line">12．1　动态内存和类　346</span><br><span class="line"></span><br><span class="line">12．1．1　复习示例和静态类成员　346</span><br><span class="line"></span><br><span class="line">12．1．2　特殊成员函数　352</span><br><span class="line"></span><br><span class="line">12．1．3　回到Stringbad：复制构造函数的哪里出了问题　354</span><br><span class="line"></span><br><span class="line">12．1．4　Stringbad的其他问题：赋值运算符　356</span><br><span class="line"></span><br><span class="line">12．2　改进后的新String类　357</span><br><span class="line"></span><br><span class="line">12．2．1　修订后的默认构造函数　357</span><br><span class="line"></span><br><span class="line">12．2．2　比较成员函数　358</span><br><span class="line"></span><br><span class="line">12．2．3　使用中括号表示法访问字符　359</span><br><span class="line"></span><br><span class="line">12．2．4　静态类成员函数　360</span><br><span class="line"></span><br><span class="line">12．2．5　进一步重载赋值运算符　360</span><br><span class="line"></span><br><span class="line">12．3　在构造函数中使用new时应注意的事项　364</span><br><span class="line"></span><br><span class="line">12．3．1　应该和不应该　365</span><br><span class="line"></span><br><span class="line">12．3．2　包含类成员的类的逐成员复制　365</span><br><span class="line"></span><br><span class="line">12．4　有关返回对象的说明　366</span><br><span class="line"></span><br><span class="line">12．4．1　返回指向const对象的引用　366</span><br><span class="line"></span><br><span class="line">12．4．2　返回指向非const对象的引用　366</span><br><span class="line"></span><br><span class="line">12．4．3　返回对象　367</span><br><span class="line"></span><br><span class="line">12．4．4　返回const对象　367</span><br><span class="line"></span><br><span class="line">12．5　使用指向对象的指针　368</span><br><span class="line"></span><br><span class="line">12．5．1　再谈new和delete　369</span><br><span class="line"></span><br><span class="line">12．5．2　指针和对象小结　370</span><br><span class="line"></span><br><span class="line">12．5．3　再谈定位new运算符　371</span><br><span class="line"></span><br><span class="line">12．6　复习各种技术　374</span><br><span class="line"></span><br><span class="line">12．6．1　重载&lt;&lt;运算符　374</span><br><span class="line"></span><br><span class="line">12．6．2　转换函数　375</span><br><span class="line"></span><br><span class="line">12．6．3　其构造函数使用new的类　375</span><br><span class="line"></span><br><span class="line">12．7　队列模拟　375</span><br><span class="line"></span><br><span class="line">12．7．1　队列类　376</span><br><span class="line"></span><br><span class="line">12．7．2　Customer类　382</span><br><span class="line"></span><br><span class="line">12．7．3　ATM模拟　384</span><br><span class="line"></span><br><span class="line">12．8　总结　387</span><br><span class="line"></span><br><span class="line">12．9　复习题　388</span><br><span class="line"></span><br><span class="line">12．10　编程练习　389</span><br><span class="line"></span><br><span class="line">第　13章 类继承　392</span><br><span class="line"></span><br><span class="line">13．1　一个简单的基类　393</span><br><span class="line"></span><br><span class="line">13．1．1　派生一个类　394</span><br><span class="line"></span><br><span class="line">13．1．2　构造函数：访问权限的考虑　395</span><br><span class="line"></span><br><span class="line">13．1．3　使用派生类　397</span><br><span class="line"></span><br><span class="line">13．1．4　派生类和基类之间的特殊关系　398</span><br><span class="line"></span><br><span class="line">13．2　继承：is-a关系　400</span><br><span class="line"></span><br><span class="line">13．3　多态公有继承　400</span><br><span class="line"></span><br><span class="line">13．4　静态联编和动态联编　409</span><br><span class="line"></span><br><span class="line">13．4．1　指针和引用类型的兼容性　409</span><br><span class="line"></span><br><span class="line">13．4．2　虚成员函数和动态联编　411</span><br><span class="line"></span><br><span class="line">13．4．3　有关虚函数注意事项　412</span><br><span class="line"></span><br><span class="line">13．5　访问控制：protected　414</span><br><span class="line"></span><br><span class="line">13．6　抽象基类　415</span><br><span class="line"></span><br><span class="line">13．6．1　应用ABC概念　416</span><br><span class="line"></span><br><span class="line">13．6．2　ABC理念　421</span><br><span class="line"></span><br><span class="line">13．7　继承和动态内存分配　421</span><br><span class="line"></span><br><span class="line">13．7．1　第 一种情况：派生类不使用new　421</span><br><span class="line"></span><br><span class="line">13．7．2　第二种情况：派生类使用new　422</span><br><span class="line"></span><br><span class="line">13．7．3　使用动态内存分配和友元的继承示例　423</span><br><span class="line"></span><br><span class="line">13．8　类设计回顾　427</span><br><span class="line"></span><br><span class="line">13．8．1　编译器生成的成员函数　427</span><br><span class="line"></span><br><span class="line">13．8．2　其他的类方法　428</span><br><span class="line"></span><br><span class="line">13．8．3　公有继承的考虑因素　429</span><br><span class="line"></span><br><span class="line">13．8．4　类函数小结　432</span><br><span class="line"></span><br><span class="line">13．9　总结　433</span><br><span class="line"></span><br><span class="line">13．10　复习题　433</span><br><span class="line"></span><br><span class="line">13．11　编程练习　434</span><br><span class="line"></span><br><span class="line">第　14章 C++中的代码重用　436</span><br><span class="line"></span><br><span class="line">14．1　包含对象成员的类　436</span><br><span class="line"></span><br><span class="line">14．1．1　valarray类简介　437</span><br><span class="line"></span><br><span class="line">14．1．2　Student类的设计　437</span><br><span class="line"></span><br><span class="line">14．1．3　Student类示例　438</span><br><span class="line"></span><br><span class="line">14．2　私有继承　443</span><br><span class="line"></span><br><span class="line">14．2．1　Student类示例（新版本）　443</span><br><span class="line"></span><br><span class="line">14．2．2　使用包含还是私有继承　447</span><br><span class="line"></span><br><span class="line">14．2．3　保护继承　448</span><br><span class="line"></span><br><span class="line">14．2．4　使用using重新定义访问权限　448</span><br><span class="line"></span><br><span class="line">14．3　多重继承　449</span><br><span class="line"></span><br><span class="line">14．3．1　有多少Worker　452</span><br><span class="line"></span><br><span class="line">14．3．2　哪个方法　455</span><br><span class="line"></span><br><span class="line">14．3．3　MI小结　461</span><br><span class="line"></span><br><span class="line">14．4　类模板　462</span><br><span class="line"></span><br><span class="line">14．4．1　定义类模板　462</span><br><span class="line"></span><br><span class="line">14．4．2　使用模板类　464</span><br><span class="line"></span><br><span class="line">14．4．3　深入探讨模板类　465</span><br><span class="line"></span><br><span class="line">14．4．4　数组模板示例和非类型参数　469</span><br><span class="line"></span><br><span class="line">14．4．5　模板多功能性　470</span><br><span class="line"></span><br><span class="line">14．4．6　模板的具体化　473</span><br><span class="line"></span><br><span class="line">14．4．7　成员模板　474</span><br><span class="line"></span><br><span class="line">14．4．8　将模板用作参数　476</span><br><span class="line"></span><br><span class="line">14．4．9　模板类和友元　477</span><br><span class="line"></span><br><span class="line">14．4．10　模板别名（C++11）　482</span><br><span class="line"></span><br><span class="line">14．5　总结　482</span><br><span class="line"></span><br><span class="line">14．6　复习题　483</span><br><span class="line"></span><br><span class="line">14．7　编程练习　484</span><br><span class="line"></span><br><span class="line">第　15章 友元、异常和其他　488</span><br><span class="line"></span><br><span class="line">15．1　友元　488</span><br><span class="line"></span><br><span class="line">15．1．1　友元类　488</span><br><span class="line"></span><br><span class="line">15．1．2　友元成员函数　492</span><br><span class="line"></span><br><span class="line">15．1．3　其他友元关系　494</span><br><span class="line"></span><br><span class="line">15．1．4　共同的友元　495</span><br><span class="line"></span><br><span class="line">15．2　嵌套类　495</span><br><span class="line"></span><br><span class="line">15．2．1　嵌套类和访问权限　496</span><br><span class="line"></span><br><span class="line">15．2．2　模板中的嵌套　497</span><br><span class="line"></span><br><span class="line">15．3　异常　499</span><br><span class="line"></span><br><span class="line">15．3．1　调用abort()　500</span><br><span class="line"></span><br><span class="line">15．3．2　返回错误码　500</span><br><span class="line"></span><br><span class="line">15．3．3　异常机制　501</span><br><span class="line"></span><br><span class="line">15．3．4　将对象用作异常类型　504</span><br><span class="line"></span><br><span class="line">15．3．5　异常规范和C++11　506</span><br><span class="line"></span><br><span class="line">15．3．6　栈解退　506</span><br><span class="line"></span><br><span class="line">15．3．7　其他异常特性　510</span><br><span class="line"></span><br><span class="line">15．3．8　exception类　511</span><br><span class="line"></span><br><span class="line">15．3．9　异常、类和继承　514</span><br><span class="line"></span><br><span class="line">15．3．10　异常何时会迷失方向　517</span><br><span class="line"></span><br><span class="line">15．3．11　有关异常的注意事项　519</span><br><span class="line"></span><br><span class="line">15．4　RTTI　520</span><br><span class="line"></span><br><span class="line">15．4．1　RTTI的用途　520</span><br><span class="line"></span><br><span class="line">15．4．2　RTTI的工作原理　521</span><br><span class="line"></span><br><span class="line">15．5　类型转换运算符　526</span><br><span class="line"></span><br><span class="line">15．6　总结　528</span><br><span class="line"></span><br><span class="line">15．7　复习题　528</span><br><span class="line"></span><br><span class="line">15．8　编程练习　529</span><br><span class="line"></span><br><span class="line">第　16章 string类和标准模板库　530</span><br><span class="line"></span><br><span class="line">16．1　string类　530</span><br><span class="line"></span><br><span class="line">16．1．1　构造字符串　530</span><br><span class="line"></span><br><span class="line">16．1．2　string类输入　533</span><br><span class="line"></span><br><span class="line">16．1．3　使用字符串　535</span><br><span class="line"></span><br><span class="line">16．1．4　string还提供了哪些功能　538</span><br><span class="line"></span><br><span class="line">16．1．5　字符串种类　539</span><br><span class="line"></span><br><span class="line">16．2　智能指针模板类　539</span><br><span class="line"></span><br><span class="line">16．2．1　使用智能指针　540</span><br><span class="line"></span><br><span class="line">16．2．2　有关智能指针的注意事项　542</span><br><span class="line"></span><br><span class="line">16．2．3　unique_ptr为何优于auto_ptr　543</span><br><span class="line"></span><br><span class="line">16．2．4　选择智能指针　545</span><br><span class="line"></span><br><span class="line">16．3　标准模板库　545</span><br><span class="line"></span><br><span class="line">16．3．1　模板类vector　546</span><br><span class="line"></span><br><span class="line">16．3．2　可对矢量执行的操作　547</span><br><span class="line"></span><br><span class="line">16．3．3　对矢量可执行的其他操作　550</span><br><span class="line"></span><br><span class="line">16．3．4　基于范围的for循环（C++11）　553</span><br><span class="line"></span><br><span class="line">16．4　泛型编程　553</span><br><span class="line"></span><br><span class="line">16．4．1　为何使用迭代器　553</span><br><span class="line"></span><br><span class="line">16．4．2　迭代器类型　556</span><br><span class="line"></span><br><span class="line">16．4．3　迭代器层次结构　557</span><br><span class="line"></span><br><span class="line">16．4．4　概念、改进和模型　558</span><br><span class="line"></span><br><span class="line">16．4．5　容器种类　562</span><br><span class="line"></span><br><span class="line">16．4．6　关联容器　568</span><br><span class="line"></span><br><span class="line">16．4．7　无序关联容器（C++11）　572</span><br><span class="line"></span><br><span class="line">16．5　函数对象　572</span><br><span class="line"></span><br><span class="line">16．5．1　函数符概念　573</span><br><span class="line"></span><br><span class="line">16．5．2　预定义的函数符　575</span><br><span class="line"></span><br><span class="line">16．5．3　自适应函数符和函数适配器　576</span><br><span class="line"></span><br><span class="line">16．6　算法　577</span><br><span class="line"></span><br><span class="line">16．6．1　算法组　578</span><br><span class="line"></span><br><span class="line">16．6．2　算法的通用特征　578</span><br><span class="line"></span><br><span class="line">16．6．3　STL和string类　579</span><br><span class="line"></span><br><span class="line">16．6．4　函数和容器方法　579</span><br><span class="line"></span><br><span class="line">16．6．5　使用STL　581</span><br><span class="line"></span><br><span class="line">16．7　其他库　583</span><br><span class="line"></span><br><span class="line">16．7．1　vector、valarray和array　583</span><br><span class="line"></span><br><span class="line">16．7．2　模板initializer_list（C++11）　586</span><br><span class="line"></span><br><span class="line">16．7．3　使用initializer_list　587</span><br><span class="line"></span><br><span class="line">16．8　总结　588</span><br><span class="line"></span><br><span class="line">16．9　复习题　589</span><br><span class="line"></span><br><span class="line">16．10　编程练习　590</span><br><span class="line"></span><br><span class="line">第　17章 输入、输出和文件　592</span><br><span class="line"></span><br><span class="line">17．1　C++输入和输出概述　592</span><br><span class="line"></span><br><span class="line">17．1．1　流和缓冲区　593</span><br><span class="line"></span><br><span class="line">17．1．2　流、缓冲区和iostream文件　594</span><br><span class="line"></span><br><span class="line">17．1．3　重定向　596</span><br><span class="line"></span><br><span class="line">17．2　使用cout进行输出　597</span><br><span class="line"></span><br><span class="line">17．2．1　重载的&lt;&lt;运算符　597</span><br><span class="line"></span><br><span class="line">17．2．2　其他ostream方法　598</span><br><span class="line"></span><br><span class="line">17．2．3　刷新输出缓冲区　600</span><br><span class="line"></span><br><span class="line">17．2．4　用cout进行格式化　601</span><br><span class="line"></span><br><span class="line">17．3　使用cin进行输入　611</span><br><span class="line"></span><br><span class="line">17．3．1　cin&gt;&gt;如何检查输入　612</span><br><span class="line"></span><br><span class="line">17．3．2　流状态　613</span><br><span class="line"></span><br><span class="line">17．3．3　其他istream类方法　616</span><br><span class="line"></span><br><span class="line">17．3．4　其他istream方法　620</span><br><span class="line"></span><br><span class="line">17．4　文件输入和输出　622</span><br><span class="line"></span><br><span class="line">17．4．1　简单的文件I&#x2F;O　623</span><br><span class="line"></span><br><span class="line">17．4．2　流状态检查和is_open()　625</span><br><span class="line"></span><br><span class="line">17．4．3　打开多个文件　625</span><br><span class="line"></span><br><span class="line">17．4．4　命令行处理技术　626</span><br><span class="line"></span><br><span class="line">17．4．5　文件模式　627</span><br><span class="line"></span><br><span class="line">17．4．6　随机存取　633</span><br><span class="line"></span><br><span class="line">17．5　内核格式化　638</span><br><span class="line"></span><br><span class="line">17．6　总结　640</span><br><span class="line"></span><br><span class="line">17．7　复习题　641</span><br><span class="line"></span><br><span class="line">17．8　编程练习　642</span><br><span class="line"></span><br><span class="line">第　18章 探讨C++新标准　644</span><br><span class="line"></span><br><span class="line">18．1　复习前面介绍过的C++11功能　644</span><br><span class="line"></span><br><span class="line">18．1．1　新类型　644</span><br><span class="line"></span><br><span class="line">18．1．2　统一的初始化　644</span><br><span class="line"></span><br><span class="line">18．1．3　声明　645</span><br><span class="line"></span><br><span class="line">18．1．4　智能指针　646</span><br><span class="line"></span><br><span class="line">18．1．5　异常规范方面的修改　647</span><br><span class="line"></span><br><span class="line">18．1．6　作用域内枚举　647</span><br><span class="line"></span><br><span class="line">18．1．7　对类的修改　647</span><br><span class="line"></span><br><span class="line">18．1．8　模板和STL方面的修改　648</span><br><span class="line"></span><br><span class="line">18．1．9　右值引用　649</span><br><span class="line"></span><br><span class="line">18．2　移动语义和右值引用　650</span><br><span class="line"></span><br><span class="line">18．2．1　为何需要移动语义　650</span><br><span class="line"></span><br><span class="line">18．2．2　一个移动示例　651</span><br><span class="line"></span><br><span class="line">18．2．3　移动构造函数解析　654</span><br><span class="line"></span><br><span class="line">18．2．4　赋值　655</span><br><span class="line"></span><br><span class="line">18．2．5　强制移动　655</span><br><span class="line"></span><br><span class="line">18．3　新的类功能　658</span><br><span class="line"></span><br><span class="line">18．3．1　特殊的成员函数　658</span><br><span class="line"></span><br><span class="line">18．3．2　默认的方法和禁用的方法　659</span><br><span class="line"></span><br><span class="line">18．3．3　委托构造函数　660</span><br><span class="line"></span><br><span class="line">18．3．4　继承构造函数　660</span><br><span class="line"></span><br><span class="line">18．3．5　管理虚方法：override和final　661</span><br><span class="line"></span><br><span class="line">18．4　Lambda函数　662</span><br><span class="line"></span><br><span class="line">18．4．1　比较函数指针、函数符和Lambda函数　662</span><br><span class="line"></span><br><span class="line">18．4．2　为何使用lambda　664</span><br><span class="line"></span><br><span class="line">18．5　包装器　666</span><br><span class="line"></span><br><span class="line">18．5．1　包装器function及模板的低效性　666</span><br><span class="line"></span><br><span class="line">18．5．2　修复问题　667</span><br><span class="line"></span><br><span class="line">18．5．3　其他方式　669</span><br><span class="line"></span><br><span class="line">18．6　可变参数模板　669</span><br><span class="line"></span><br><span class="line">18．6．1　模板和函数参数包　669</span><br><span class="line"></span><br><span class="line">18．6．2　展开参数包　670</span><br><span class="line"></span><br><span class="line">18．6．3　在可变参数模板函数中使用递归　670</span><br><span class="line"></span><br><span class="line">18．7　C++11新增的其他功能　672</span><br><span class="line"></span><br><span class="line">18．7．1　并行编程　672</span><br><span class="line"></span><br><span class="line">18．7．2　新增的库　672</span><br><span class="line"></span><br><span class="line">18．7．3　低级编程　673</span><br><span class="line"></span><br><span class="line">18．7．4　杂项　673</span><br><span class="line"></span><br><span class="line">18．8　语言变化　674</span><br><span class="line"></span><br><span class="line">18．8．1　Boost项目　674</span><br><span class="line"></span><br><span class="line">18．8．2　TR1　674</span><br><span class="line"></span><br><span class="line">18．8．3　使用Boost　674</span><br><span class="line"></span><br><span class="line">18．9　接下来的任务　675</span><br><span class="line"></span><br><span class="line">18．10　总结　675</span><br><span class="line"></span><br><span class="line">18．11　复习题　676</span><br><span class="line"></span><br><span class="line">18．12　编程练习　678</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C++Templates PDF</title>
    <url>/posts/648a6942/</url>
    <content><![CDATA[<h4 id="《C-Templates》"><a href="#《C-Templates》" class="headerlink" title="《C++Templates》"></a>《C++Templates》</h4><h4 id="链接-https-pan-baidu-com-s-1qOCGMBeqsCv3wk3mwNs4fQ-提取码-bhmc"><a href="#链接-https-pan-baidu-com-s-1qOCGMBeqsCv3wk3mwNs4fQ-提取码-bhmc" class="headerlink" title="链接: https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ 提取码: bhmc"></a>链接: <a href="https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ">https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ</a> 提取码: bhmc</h4><p>David Vandevoorde 有20多年的C 工作经验，C 标准委员会成员。曾因为审校The C Programming Language一书的草稿，获得B<em>arne Stroustrup的推荐，编写了C Solutions。Nico</em> M. Josuttis The C Standard Library - A Tutorial andReference（中文版名为《C 标准库》）的作者，这本书出版以后成为实际 的标准读本。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1章 关 本章</span><br><span class="line"></span><br><span class="line">1.1 阅读本书所需具备的知识</span><br><span class="line"></span><br><span class="line">1.2 本书的整体结构</span><br><span class="line"></span><br><span class="line">1.3 如何阅读本书</span><br><span class="line"></span><br><span class="line">1.4 关 编程风格的一些 明</span><br><span class="line"></span><br><span class="line">1.5 标准 现实</span><br><span class="line"></span><br><span class="line">1.6 码例子 更多信息</span><br><span class="line"></span><br><span class="line">1.7 馈</span><br><span class="line"></span><br><span class="line">1部分 基础</span><br><span class="line"></span><br><span class="line">2章 函数模板</span><br><span class="line"></span><br><span class="line">2.1 初探函数模板</span><br><span class="line"></span><br><span class="line">2.1.1 定义模板</span><br><span class="line"></span><br><span class="line">2.1.2 使用模板</span><br><span class="line"></span><br><span class="line">2.2 实参的演绎(dedu*ion)</span><br><span class="line"></span><br><span class="line">2.3 模板参数</span><br><span class="line"></span><br><span class="line">2.4 重载函数模板</span><br><span class="line"></span><br><span class="line">2.5 小结</span><br><span class="line"></span><br><span class="line">3章 类模板</span><br><span class="line"></span><br><span class="line">3.1 类模板Stack的实现</span><br><span class="line"></span><br><span class="line">3.1.1 类模板的 明</span><br><span class="line"></span><br><span class="line">3.1.2 成员函数的实现</span><br><span class="line"></span><br><span class="line">3.2 类模板Stack的使用</span><br><span class="line"></span><br><span class="line">3.3 类模板的 化</span><br><span class="line"></span><br><span class="line">3.4 局部 化</span><br><span class="line"></span><br><span class="line">3.5 缺省模板实参</span><br><span class="line"></span><br><span class="line">3.6 小结</span><br><span class="line"></span><br><span class="line">4章 非类型模板参数</span><br><span class="line"></span><br><span class="line">4.1 非类型的类模板参数</span><br><span class="line"></span><br><span class="line">4.2 非类型的函数模板参数</span><br><span class="line"></span><br><span class="line">4.3 非类型模板参数的限</span><br><span class="line"></span><br><span class="line">4.4 小结</span><br><span class="line"></span><br><span class="line">5章 技巧性基础知识</span><br><span class="line"></span><br><span class="line">5.1 关键字typename</span><br><span class="line"></span><br><span class="line">5.2 使用this-&gt;</span><br><span class="line"></span><br><span class="line">5.3 成员模板</span><br><span class="line"></span><br><span class="line">5.4 模板的模板参数</span><br><span class="line"></span><br><span class="line">5.5 零初始化</span><br><span class="line"></span><br><span class="line">5.6 使用字符串作为函数模板的实参</span><br><span class="line"></span><br><span class="line">5.7 小结</span><br><span class="line"></span><br><span class="line">6章 模板实</span><br><span class="line"></span><br><span class="line">6.1 包模型</span><br><span class="line"></span><br><span class="line">6.1.1 链接 错误</span><br><span class="line"></span><br><span class="line">6.1.2 头文件中的模板</span><br><span class="line"></span><br><span class="line">6.2 显式实例化</span><br><span class="line"></span><br><span class="line">6.2.1 显式实例化的例子</span><br><span class="line"></span><br><span class="line">6.2.2 整合包模型 显式实例化</span><br><span class="line"></span><br><span class="line">6.3 分离模型</span><br><span class="line"></span><br><span class="line">6.3.1 关键字export</span><br><span class="line"></span><br><span class="line">6.3.2 分离模型的限</span><br><span class="line"></span><br><span class="line">6.3.3 为分离模型 好准备</span><br><span class="line"></span><br><span class="line">6.4 模板 内联</span><br><span class="line"></span><br><span class="line">6.5 预编译头文件</span><br><span class="line"></span><br><span class="line">6.6 调试模板</span><br><span class="line"></span><br><span class="line">6.6.1 理 长段的错误信息</span><br><span class="line"></span><br><span class="line">6.6.2 浅式实例化</span><br><span class="line"></span><br><span class="line">6.6.3 长符号串</span><br><span class="line"></span><br><span class="line">6.6.4 跟踪程序</span><br><span class="line"></span><br><span class="line">6.6.5 oracles</span><br><span class="line"></span><br><span class="line">6.6.6 archetypes</span><br><span class="line"></span><br><span class="line">6.7 本章后</span><br><span class="line"></span><br><span class="line">6.8 小结</span><br><span class="line"></span><br><span class="line">7章 模板*语</span><br><span class="line"></span><br><span class="line">7.1 &#39;类模板&#39;还是&#39;模板类&#39;</span><br><span class="line"></span><br><span class="line">7.2 实例化 化</span><br><span class="line"></span><br><span class="line">7.3 明 定义</span><br><span class="line"></span><br><span class="line">7.4 一处定义原则</span><br><span class="line"></span><br><span class="line">7.5 模板实参 模板参数</span><br><span class="line"></span><br><span class="line">2部分 深入模板</span><br><span class="line"></span><br><span class="line">8章 深入模板基础</span><br><span class="line"></span><br><span class="line">8.1 参数化 明</span><br><span class="line"></span><br><span class="line">8.1.1 虚成员函数</span><br><span class="line"></span><br><span class="line">8.1.2 模板的链接</span><br><span class="line"></span><br><span class="line">8.1.3 基本模板</span><br><span class="line"></span><br><span class="line">8.2 模板参数</span><br><span class="line"></span><br><span class="line">8.2.1 类型参数</span><br><span class="line"></span><br><span class="line">8.2.2 非类型参数</span><br><span class="line"></span><br><span class="line">8.2.3 模板的模板参数</span><br><span class="line"></span><br><span class="line">8.2.4 缺省模板实参</span><br><span class="line"></span><br><span class="line">8.3 模板实参</span><br><span class="line"></span><br><span class="line">8.3.1 函数模板实参</span><br><span class="line"></span><br><span class="line">8.3.2 类型实参</span><br><span class="line"></span><br><span class="line">8.3.3 非类型实参</span><br><span class="line"></span><br><span class="line">8.3.4 模板的模板实参</span><br><span class="line"></span><br><span class="line">8.3.5 实参的等价性</span><br><span class="line"></span><br><span class="line">8.4 友元</span><br><span class="line"></span><br><span class="line">8.4.1 友元函数</span><br><span class="line"></span><br><span class="line">8.4.2 友元模板</span><br><span class="line"></span><br><span class="line">8.5 本章后</span><br><span class="line"></span><br><span class="line">9章 模板中的名称</span><br><span class="line"></span><br><span class="line">9.1 名称的分类</span><br><span class="line"></span><br><span class="line">9.2 名称查找</span><br><span class="line"></span><br><span class="line">9.2.1 Argument-Dependent Lookup(ADL)</span><br><span class="line"></span><br><span class="line">9.2.2 友元名称*入</span><br><span class="line"></span><br><span class="line">9.2.3 *入式类名称</span><br><span class="line"></span><br><span class="line">9.3 析模板</span><br><span class="line"></span><br><span class="line">9.3.1 非模板中的 下文相关性</span><br><span class="line"></span><br><span class="line">9.3.2 依赖型类型名称</span><br><span class="line"></span><br><span class="line">9.3.3 依赖型模板名称</span><br><span class="line"></span><br><span class="line">9.3.4 using-declar*ion中的依赖型名称</span><br><span class="line"></span><br><span class="line">9.3.5 ADL 显式模板实参</span><br><span class="line"></span><br><span class="line">9.4 生 类模板</span><br><span class="line"></span><br><span class="line">9.4.1 非依赖型基类</span><br><span class="line"></span><br><span class="line">9.4.2 依赖型基类</span><br><span class="line"></span><br><span class="line">9.5 本章后</span><br><span class="line"></span><br><span class="line">10章 实例化</span><br><span class="line"></span><br><span class="line">10.1 On-De*nd实例化</span><br><span class="line"></span><br><span class="line">10.2 迟实例化</span><br><span class="line"></span><br><span class="line">10.3 C 的实例化模型</span><br><span class="line"></span><br><span class="line">10.3.1 阶段查找</span><br><span class="line"></span><br><span class="line">10.3.2 POI</span><br><span class="line"></span><br><span class="line">10.3.3 包模型与分离模型</span><br><span class="line"></span><br><span class="line">10.3.4 跨翻译单元查找</span><br><span class="line"></span><br><span class="line">10.3.5 例子</span><br><span class="line"></span><br><span class="line">10.4 几 实现方案</span><br><span class="line"></span><br><span class="line">10.4.1 贪婪实例化</span><br><span class="line"></span><br><span class="line">10.4.2 询问实例化</span><br><span class="line"></span><br><span class="line">10.4.3 迭 实例化</span><br><span class="line"></span><br><span class="line">10.5 显式实例化</span><br><span class="line"></span><br><span class="line">10.6 本章后</span><br><span class="line"></span><br><span class="line">11章 模板实参演译</span><br><span class="line"></span><br><span class="line">11.1 演绎的过程</span><br><span class="line"></span><br><span class="line">11.2 演绎的 下文</span><br><span class="line"></span><br><span class="line">11.3 殊的演绎 况</span><br><span class="line"></span><br><span class="line">11.4 可接受的实参转型</span><br><span class="line"></span><br><span class="line">11.5 类模板参数</span><br><span class="line"></span><br><span class="line">11.6 缺省调用实参</span><br><span class="line"></span><br><span class="line">11.7 Barton-Nack*n方法</span><br><span class="line"></span><br><span class="line">11.8 本章后</span><br><span class="line"></span><br><span class="line">12章 化与重载</span><br><span class="line"></span><br><span class="line">12.1 当泛型 码不再适用的时候</span><br><span class="line"></span><br><span class="line">12.1.1 透明自定义</span><br><span class="line"></span><br><span class="line">12.1.2 语义的透明性</span><br><span class="line"></span><br><span class="line">12.2 重载函数模板</span><br><span class="line"></span><br><span class="line">12.2.1 名</span><br><span class="line"></span><br><span class="line">12.2.2 重载的函数模板的局部排序</span><br><span class="line"></span><br><span class="line">12.2.3 正式的排序原则</span><br><span class="line"></span><br><span class="line">12.2.4 模板 非模板</span><br><span class="line"></span><br><span class="line">12.3 显式 化</span><br><span class="line"></span><br><span class="line">12.3.1 全局的类模板 化</span><br><span class="line"></span><br><span class="line">12.3.2 全局的函数模板 化</span><br><span class="line"></span><br><span class="line">12.3.3 全局成员 化</span><br><span class="line"></span><br><span class="line">12.4 局部的类模板 化</span><br><span class="line"></span><br><span class="line">12.5 本章后</span><br><span class="line"></span><br><span class="line">13章 未来的方向</span><br><span class="line"></span><br><span class="line">13.1 尖括号Hack</span><br><span class="line"></span><br><span class="line">13.2 放松typename的原则</span><br><span class="line"></span><br><span class="line">13.3 缺省函数模板实参</span><br><span class="line"></span><br><span class="line">13.4 字符串文字 浮点型模板实参</span><br><span class="line"></span><br><span class="line">13.5 放松模板的模板参数的匹</span><br><span class="line"></span><br><span class="line">13.6 typedef模板</span><br><span class="line"></span><br><span class="line">13.7 函数模板的局部 化</span><br><span class="line"></span><br><span class="line">13.8 typeof运算符</span><br><span class="line"></span><br><span class="line">13.9 命名模板实参</span><br><span class="line"></span><br><span class="line">13.10 静态属性</span><br><span class="line"></span><br><span class="line">13.11 户端的实例化诊断信息</span><br><span class="line"></span><br><span class="line">13.12 重载类模板</span><br><span class="line"></span><br><span class="line">13.13 List参数</span><br><span class="line"></span><br><span class="line">13.14 布局控</span><br><span class="line"></span><br><span class="line">13.15 初始化 的演绎</span><br><span class="line"></span><br><span class="line">13.16 函数表 式</span><br><span class="line"></span><br><span class="line">13.17 本章后</span><br><span class="line"></span><br><span class="line">3部分 模板与设计</span><br><span class="line"></span><br><span class="line">14章 模板的多态威力</span><br><span class="line"></span><br><span class="line">14.1 动多态</span><br><span class="line"></span><br><span class="line">14.2 静多态</span><br><span class="line"></span><br><span class="line">14.3 动多态 静多态</span><br><span class="line"></span><br><span class="line">14.3.1 *语</span><br><span class="line"></span><br><span class="line">14.3.2 优点 缺点</span><br><span class="line"></span><br><span class="line">14.3.3 组合这 多态</span><br><span class="line"></span><br><span class="line">14.4 新形式的设计模板</span><br><span class="line"></span><br><span class="line">14.5 泛型程序设计</span><br><span class="line"></span><br><span class="line">14.6 本章后</span><br><span class="line"></span><br><span class="line">15章 trait与policy类</span><br><span class="line"></span><br><span class="line">15.1 一个实例：累加一个序列</span><br><span class="line"></span><br><span class="line">15.1.1 fixed traits</span><br><span class="line"></span><br><span class="line">15.1.2 value trait</span><br><span class="line"></span><br><span class="line">15.1.3 参数化trait</span><br><span class="line"></span><br><span class="line">15.1.4 policy policy类</span><br><span class="line"></span><br><span class="line">15.1.5 trait policy：区别在何处</span><br><span class="line"></span><br><span class="line">15.1.6 成员模板 模板的模板参数</span><br><span class="line"></span><br><span class="line">15.1.7 组合多个policie &#x2F;或trait</span><br><span class="line"></span><br><span class="line">15.1.8 运用普通的迭 行累积</span><br><span class="line"></span><br><span class="line">15.2 类型函数</span><br><span class="line"></span><br><span class="line">15.2.1 确定元素的类型</span><br><span class="line"></span><br><span class="line">15.2.2 确定class类型</span><br><span class="line"></span><br><span class="line">15.2.3 引用 限定符</span><br><span class="line"></span><br><span class="line">15.2.4 promotion trait</span><br><span class="line"></span><br><span class="line">15.3 policy trait</span><br><span class="line"></span><br><span class="line">15.3.1 只读的参数类型</span><br><span class="line"></span><br><span class="line">15.3.2 拷贝、交换 移动</span><br><span class="line"></span><br><span class="line">15.4 本章后</span><br><span class="line"></span><br><span class="line">16章 模板与继承</span><br><span class="line"></span><br><span class="line">16.1 命名模板参数</span><br><span class="line"></span><br><span class="line">16.2 空基类优化</span><br><span class="line"></span><br><span class="line">16.2.1 布局原则</span><br><span class="line"></span><br><span class="line">16.2.2 成员作基类</span><br><span class="line"></span><br><span class="line">16.3 奇 的递归模板模式</span><br><span class="line"></span><br><span class="line">16.4 参数化虚拟性</span><br><span class="line"></span><br><span class="line">16.5 本章后</span><br><span class="line"></span><br><span class="line">17章 metaprogram</span><br><span class="line"></span><br><span class="line">17.1 metaprogram的个实例</span><br><span class="line"></span><br><span class="line">17.2 枚举值 静态常量</span><br><span class="line"></span><br><span class="line">17.3 2个例子：计算 方根</span><br><span class="line"></span><br><span class="line">17.4 使用归纳变量</span><br><span class="line"></span><br><span class="line">17.5 计算 整性</span><br><span class="line"></span><br><span class="line">17.6 递归实例化 递归模板实参</span><br><span class="line"></span><br><span class="line">17.7 使用metaprogram来展开循环</span><br><span class="line"></span><br><span class="line">17.8 本章后</span><br><span class="line"></span><br><span class="line">18章 表 式模板</span><br><span class="line"></span><br><span class="line">18.1 临时变量 分割循环</span><br><span class="line"></span><br><span class="line">18.2 在模板实参中编码表 式</span><br><span class="line"></span><br><span class="line">18.2.1 表 式模板的 作数</span><br><span class="line"></span><br><span class="line">18.2.2 Array类型</span><br><span class="line"></span><br><span class="line">18.2.3 运算符</span><br><span class="line"></span><br><span class="line">18.2.4 回顾</span><br><span class="line"></span><br><span class="line">18.2.5 表 式模板赋值</span><br><span class="line"></span><br><span class="line">18.3 表 式模板的性能与 束</span><br><span class="line"></span><br><span class="line">18.4 本章后</span><br><span class="line"></span><br><span class="line">4部分 高级应用程序</span><br><span class="line"></span><br><span class="line">19章 类型区分</span><br><span class="line"></span><br><span class="line">19.1 辨别基本类型</span><br><span class="line"></span><br><span class="line">19.2 辨别组合类型</span><br><span class="line"></span><br><span class="line">19.3 辨别函数类型</span><br><span class="line"></span><br><span class="line">19.4 运用重载 析辨别枚举类型</span><br><span class="line"></span><br><span class="line">19.5 辨别class类型</span><br><span class="line"></span><br><span class="line">19.6 辨别所有类型的函数模板</span><br><span class="line"></span><br><span class="line">19.7 本章后</span><br><span class="line"></span><br><span class="line">20章 智能指针</span><br><span class="line"></span><br><span class="line">20.1 holder trule</span><br><span class="line"></span><br><span class="line">20.1.1 全处理异常</span><br><span class="line"></span><br><span class="line">20.1.2 holder</span><br><span class="line"></span><br><span class="line">20.1.3 作为成员的holder</span><br><span class="line"></span><br><span class="line">20.1.4 源获取 初始化</span><br><span class="line"></span><br><span class="line">20.1.5 holder的局限</span><br><span class="line"></span><br><span class="line">20.1.6 复 holder</span><br><span class="line"></span><br><span class="line">20.1.7 跨函数调用来复 holder</span><br><span class="line"></span><br><span class="line">20.1.8 trule</span><br><span class="line"></span><br><span class="line">20.2 引用 数</span><br><span class="line"></span><br><span class="line">20.2.1 计数 在什么 方</span><br><span class="line"></span><br><span class="line">20.2.2 并发访问计数</span><br><span class="line"></span><br><span class="line">20.2.3 析构 释放</span><br><span class="line"></span><br><span class="line">20.2.4 CountingPtr模板</span><br><span class="line"></span><br><span class="line">20.2.5 一个简单的非侵入式计数</span><br><span class="line"></span><br><span class="line">20.2.6 一个简单的侵入式计数 模板</span><br><span class="line"></span><br><span class="line">20.2.7 常数性</span><br><span class="line"></span><br><span class="line">20.2.8 隐式转型</span><br><span class="line"></span><br><span class="line">20.2.9 较</span><br><span class="line"></span><br><span class="line">20.3 本章后</span><br><span class="line"></span><br><span class="line">21章 tuple</span><br><span class="line"></span><br><span class="line">21.1 duo</span><br><span class="line"></span><br><span class="line">21.2 可递归duo</span><br><span class="line"></span><br><span class="line">21.2.1 域的个数</span><br><span class="line"></span><br><span class="line">21.2.2 域的类型</span><br><span class="line"></span><br><span class="line">21.2.3 域的值</span><br><span class="line"></span><br><span class="line">21.3 tuple构造</span><br><span class="line"></span><br><span class="line">21.4 本章后</span><br><span class="line"></span><br><span class="line">22章 函数对象 回调</span><br><span class="line"></span><br><span class="line">22.1 直接调用、间接调用与内联调用</span><br><span class="line"></span><br><span class="line">22.2 函数指针与函数引用</span><br><span class="line"></span><br><span class="line">22.3 成员函数指针</span><br><span class="line"></span><br><span class="line">22.4 class类型的仿函数</span><br><span class="line"></span><br><span class="line">22.4.1 class类型仿函数的 1个实例</span><br><span class="line"></span><br><span class="line">22.4.2 class类型仿函数的类型</span><br><span class="line"></span><br><span class="line">22.5 指定仿函数</span><br><span class="line"></span><br><span class="line">22.5.1 作为模板类型实参的仿函数</span><br><span class="line"></span><br><span class="line">22.5.2 作为函数调用实参的仿函数</span><br><span class="line"></span><br><span class="line">22.5.3 结合函数调用参数 模板类型参数</span><br><span class="line"></span><br><span class="line">22.5.4 作为非类型模板实参的仿函数</span><br><span class="line"></span><br><span class="line">22.5.5 函数指针的封装</span><br><span class="line"></span><br><span class="line">22.6 内省</span><br><span class="line"></span><br><span class="line">22.6.1 分析一个仿函数的类型</span><br><span class="line"></span><br><span class="line">22.6.2 访问参数的类型</span><br><span class="line"></span><br><span class="line">22.6.3 封装函数指针</span><br><span class="line"></span><br><span class="line">22.7 函数对象组合</span><br><span class="line"></span><br><span class="line">22.7.1 简单的组合</span><br><span class="line"></span><br><span class="line">22.7.2 混合类型的组合</span><br><span class="line"></span><br><span class="line">22.7.3 减少参数的个数</span><br><span class="line"></span><br><span class="line">22.8 值绑定</span><br><span class="line"></span><br><span class="line">22.8.1 选择绑定的目标</span><br><span class="line"></span><br><span class="line">22.8.2 绑定 名</span><br><span class="line"></span><br><span class="line">22.8.3 实参选择</span><br><span class="line"></span><br><span class="line">22.8.4 辅助函数</span><br><span class="line"></span><br><span class="line">22.9 仿函数 作：一个 整的实现</span><br><span class="line"></span><br><span class="line">22.10 本章后</span><br><span class="line"></span><br><span class="line">附录A 一处定义原则</span><br><span class="line"></span><br><span class="line">A.1 翻译单元</span><br><span class="line"></span><br><span class="line">A.2 明 定义</span><br><span class="line"></span><br><span class="line">A.3 一处定义原则的细节</span><br><span class="line"></span><br><span class="line">A.3.1 程序的一处定义 束</span><br><span class="line"></span><br><span class="line">A.3.2 翻译单元的一处定义 束</span><br><span class="line"></span><br><span class="line">A.3.3 跨翻译单元的等价性 束</span><br><span class="line"></span><br><span class="line">附录B 重载 析</span><br><span class="line"></span><br><span class="line">B.1 何时应用重载 析</span><br><span class="line"></span><br><span class="line">B.2 简化过的重载 析</span><br><span class="line"></span><br><span class="line">B.2.1 成员函数的隐实参</span><br><span class="line"></span><br><span class="line">B.2.2 细化匹</span><br><span class="line"></span><br><span class="line">B.3 重载的细节</span><br><span class="line"></span><br><span class="line">B.3.1 非模板优先</span><br><span class="line"></span><br><span class="line">B.3.2 转型序列</span><br><span class="line"></span><br><span class="line">B.3.3 指针的转型</span><br><span class="line"></span><br><span class="line">B.3.4 仿函数 理函数</span><br><span class="line"></span><br><span class="line">B.3.5 其 的重载 况</span><br><span class="line"></span><br><span class="line">参考 料</span><br><span class="line"></span><br><span class="line">*语表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C语言编程精粹 PDF</title>
    <url>/posts/faeefce1/</url>
    <content><![CDATA[<h4 id="《C语言编程精粹》"><a href="#《C语言编程精粹》" class="headerlink" title="《C语言编程精粹》"></a>《C语言编程精粹》</h4><h6 id="链接-https-pan-baidu-com-s-10UmQgH1QaXLrx6IfL1QUxw-提取码-xvas"><a href="#链接-https-pan-baidu-com-s-10UmQgH1QaXLrx6IfL1QUxw-提取码-xvas" class="headerlink" title="链接: https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw 提取码: xvas"></a>链接: <a href="https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw">https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw</a> 提取码: xvas</h6><p>软件日趋复杂，编码错误随之而来。要在测试前发现程序的错误，开发出无错误的程序，关键是弄清楚错误为何产生，又是如何产生。《编程精粹编写高质量C语言代码》给出了多条编程方面的指导，这些指导看似简单，却是作者多年思考及实践的结果，是对其编程经验的总结。书中解决问题的思考过程对于程序开发人员尤显珍贵。<br><a id="more"></a></p>
<p><img src="/images/ca9119466f647bc8db3fe209fa360c131.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">1 A HYPOTHETICAL PILER</span><br><span class="line"></span><br><span class="line">2 ASSERT YOURSELF</span><br><span class="line"></span><br><span class="line">3 FORTIFY YOUR SUBSYSTEMS</span><br><span class="line"></span><br><span class="line">4 STEP THROUGH YOUR CODE</span><br><span class="line"></span><br><span class="line">5 CANDY-MACHINE INTERFACES</span><br><span class="line"></span><br><span class="line">6 RISKY BUSINESS</span><br><span class="line"></span><br><span class="line">7 TREACHERIES OF THE TRADE</span><br><span class="line"></span><br><span class="line">8 THE REST IS ATTITUDE</span><br><span class="line"></span><br><span class="line">EPILOGUE WHERE DO YOU GO FROM HERE?</span><br><span class="line"></span><br><span class="line">APPENDIX A CODING CHECKLISTS</span><br><span class="line"></span><br><span class="line">APPENDIX B MEMORY LOGGING ROUTINES</span><br><span class="line"></span><br><span class="line">APPENDIX C ANSWERS</span><br><span class="line"></span><br><span class="line">REFERENCES</span><br><span class="line"></span><br><span class="line">INDEX</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C语言参考手册第五版 PDF</title>
    <url>/posts/8de9cc77/</url>
    <content><![CDATA[<h4 id="《C语言参考手册第五版》"><a href="#《C语言参考手册第五版》" class="headerlink" title="《C语言参考手册第五版》"></a>《C语言参考手册第五版》</h4><h6 id="链接-https-pan-baidu-com-s-1uBQRP1LZmQnlZVNpSat1tg-提取码-x3ns"><a href="#链接-https-pan-baidu-com-s-1uBQRP1LZmQnlZVNpSat1tg-提取码-x3ns" class="headerlink" title="链接: https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg 提取码: x3ns"></a>链接: <a href="https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg">https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg</a> 提取码: x3ns</h6><p>《C语言参考手册(原书第5版)》是C语言的详尽参考手册，分为两部分：第一部分讨论了C语言的所有语言特征，包括词法、预处理机制、声明、类型、表达式、语句以及函数等基本语言特征；第二部分讨论了C语言的标准库，针对它们不同的功能分别进行详细介绍。为了帮助读者理解相关概念，《C语言参考手册(原书第5版)》在讨论C语言及其标准库的细节时，提供了许多实例和解释。第一部分的各章还提供了练习题和主要练习的解答，这些练习可帮助读者加深理解C语言的基本功能和特性。<br><a id="more"></a></p>
<p><img src="/images/d0ffd6df7d8a1387063c30c3c6ce1d251.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">《C语言参考手册(原书第5版)》</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前 言</span><br><span class="line"></span><br><span class="line">第一部分 C语言</span><br><span class="line"></span><br><span class="line">第1章 概述 2</span><br><span class="line"></span><br><span class="line">1.1 C语言的演变 2</span><br><span class="line"></span><br><span class="line">1.1.1 传统C 2</span><br><span class="line"></span><br><span class="line">1.1.2 标准C（1989） 2</span><br><span class="line"></span><br><span class="line">1.1.3 标准C（1995） 3</span><br><span class="line"></span><br><span class="line">1.1.4 标准C（1999） 3</span><br><span class="line"></span><br><span class="line">1.1.5 标准C++ 4</span><br><span class="line"></span><br><span class="line">1.1.6 《C语言参考手册(原书第5版)》内容 4</span><br><span class="line"></span><br><span class="line">1.2 应该使用哪种C语言 4</span><br><span class="line"></span><br><span class="line">1.3 C编程概述 5</span><br><span class="line"></span><br><span class="line">1.4 一致性 6</span><br><span class="line"></span><br><span class="line">1.5 语法约定 7</span><br><span class="line"></span><br><span class="line">第2章 词法元素 8</span><br><span class="line"></span><br><span class="line">2.1 字符集 8</span><br><span class="line"></span><br><span class="line">2.1.1 执行字符集 9</span><br><span class="line"></span><br><span class="line">2.1.2 空白字符和行终止符 9</span><br><span class="line"></span><br><span class="line">2.1.3 字符编码 10</span><br><span class="line"></span><br><span class="line">2.1.4 三字符组 10</span><br><span class="line"></span><br><span class="line">2.1.5 多字节字符和宽字符 11</span><br><span class="line"></span><br><span class="line">2.2 注释 13</span><br><span class="line"></span><br><span class="line">2.3 标记 14</span><br><span class="line"></span><br><span class="line">2.4 操作符和分隔符 15</span><br><span class="line"></span><br><span class="line">2.5 标识符 15</span><br><span class="line"></span><br><span class="line">2.6 关键字 17</span><br><span class="line"></span><br><span class="line">2.7 常量 18</span><br><span class="line"></span><br><span class="line">2.7.1 整数常量 18</span><br><span class="line"></span><br><span class="line">2.7.2 浮点数常量 22</span><br><span class="line"></span><br><span class="line">2.7.3 字符常量 23</span><br><span class="line"></span><br><span class="line">2.7.4 字符串常量 25</span><br><span class="line"></span><br><span class="line">2.7.5 转义字符 27</span><br><span class="line"></span><br><span class="line">2.7.6 字符转义码 28</span><br><span class="line"></span><br><span class="line">2.7.7 数值转义码 29</span><br><span class="line"></span><br><span class="line">2.8 C++兼容性 29</span><br><span class="line"></span><br><span class="line">2.8.1 字符集 30</span><br><span class="line"></span><br><span class="line">2.8.2 注释 30</span><br><span class="line"></span><br><span class="line">2.8.3 操作符 30</span><br><span class="line"></span><br><span class="line">2.8.4 标识符和关键字 30</span><br><span class="line"></span><br><span class="line">2.8.5 字符常量 30</span><br><span class="line"></span><br><span class="line">2.9 关于字符集、指令集和编码 30</span><br><span class="line"></span><br><span class="line">2.10 练习 32</span><br><span class="line"></span><br><span class="line">第3章 C预处理器 34</span><br><span class="line"></span><br><span class="line">3.1 预处理器命令 34</span><br><span class="line"></span><br><span class="line">3.2 预处理器词法约定 35</span><br><span class="line"></span><br><span class="line">3.3 定义和替换 36</span><br><span class="line"></span><br><span class="line">3.3.1 类似对象的宏定义 36</span><br><span class="line"></span><br><span class="line">3.3.2 定义带参数的宏 37</span><br><span class="line"></span><br><span class="line">3.3.3 宏表达式的重新扫描 39</span><br><span class="line"></span><br><span class="line">3.3.4 预定义的宏 40</span><br><span class="line"></span><br><span class="line">3.3.5 取消宏定义和重新定义宏 42</span><br><span class="line"></span><br><span class="line">3.3.6 宏展开的优先级错误 42</span><br><span class="line"></span><br><span class="line">3.3.7 宏参数的副作用 43</span><br><span class="line"></span><br><span class="line">3.3.8 把标记转换为字符串 43</span><br><span class="line"></span><br><span class="line">3.3.9 宏展开中的标记合并 44</span><br><span class="line"></span><br><span class="line">3.3.10 宏的可变参数列表 45</span><br><span class="line"></span><br><span class="line">3.3.11 其他问题 46</span><br><span class="line"></span><br><span class="line">3.4 文件包含 46</span><br><span class="line"></span><br><span class="line">3.5 条件编译 48</span><br><span class="line"></span><br><span class="line">3.5.1 #if、#else和#endif命令 48</span><br><span class="line"></span><br><span class="line">3.5.2 #elif命令 49</span><br><span class="line"></span><br><span class="line">3.5.3 #ifdef和#ifndef命令 50</span><br><span class="line"></span><br><span class="line">3.5.4 条件命令中的常量表达式 51</span><br><span class="line"></span><br><span class="line">3.5.5 defined操作符 52</span><br><span class="line"></span><br><span class="line">3.6 显式的行号 52</span><br><span class="line"></span><br><span class="line">3.7 pragma指令 53</span><br><span class="line"></span><br><span class="line">3.7.1 标准pragma命令 53</span><br><span class="line"></span><br><span class="line">3.7.2 标准pragma指令的位置 54</span><br><span class="line"></span><br><span class="line">3.7.3 _Pragma操作符 54</span><br><span class="line"></span><br><span class="line">3.8 错误指令 54</span><br><span class="line"></span><br><span class="line">3.9 C++兼容性 55</span><br><span class="line"></span><br><span class="line">3.10 练习 55</span><br><span class="line"></span><br><span class="line">第4章 声明 57</span><br><span class="line"></span><br><span class="line">4.1 声明的组织形式 57</span><br><span class="line"></span><br><span class="line">4.2 术语 58</span><br><span class="line"></span><br><span class="line">4.2.1 作用域 58</span><br><span class="line"></span><br><span class="line">4.2.2 可见性 59</span><br><span class="line"></span><br><span class="line">4.2.3 前向引用 59</span><br><span class="line"></span><br><span class="line">4.2.4 名称的重载 60</span><br><span class="line"></span><br><span class="line">4.2.5 重复声明 61</span><br><span class="line"></span><br><span class="line">4.2.6 重复可见性 62</span><br><span class="line"></span><br><span class="line">4.2.7 范围 62</span><br><span class="line"></span><br><span class="line">4.2.8 初始值 63</span><br><span class="line"></span><br><span class="line">4.2.9 外部名称 64</span><br><span class="line"></span><br><span class="line">4.2.10 编译时名称 65</span><br><span class="line"></span><br><span class="line">4.3 存储类别和函数指定符 65</span><br><span class="line"></span><br><span class="line">4.3.1 默认存储类别指定符 66</span><br><span class="line"></span><br><span class="line">4.3.2 存储类别指定符的例子 66</span><br><span class="line"></span><br><span class="line">4.3.3 函数指定符 67</span><br><span class="line"></span><br><span class="line">4.4 类型指定符和限定符 67</span><br><span class="line"></span><br><span class="line">4.4.1 默认类型指定符 68</span><br><span class="line"></span><br><span class="line">4.4.2 缺失的声明器 69</span><br><span class="line"></span><br><span class="line">4.4.3 类型限定符 70</span><br><span class="line"></span><br><span class="line">4.4.4 const 70</span><br><span class="line"></span><br><span class="line">4.4.5 volatile和序列点 72</span><br><span class="line"></span><br><span class="line">4.4.6 restrict 74</span><br><span class="line"></span><br><span class="line">4.5 声明器 75</span><br><span class="line"></span><br><span class="line">4.5.1 简单声明器 75</span><br><span class="line"></span><br><span class="line">4.5.2 指针声明器 76</span><br><span class="line"></span><br><span class="line">4.5.3 数组声明器 77</span><br><span class="line"></span><br><span class="line">4.5.4 函数声明器 78</span><br><span class="line"></span><br><span class="line">4.5.5 声明器的组合 80</span><br><span class="line"></span><br><span class="line">4.6 初始化值 81</span><br><span class="line"></span><br><span class="line">4.6.1 整数 82</span><br><span class="line"></span><br><span class="line">4.6.2 浮点数 83</span><br><span class="line"></span><br><span class="line">4.6.3 指针 83</span><br><span class="line"></span><br><span class="line">4.6.4 数组 84</span><br><span class="line"></span><br><span class="line">4.6.5 枚举 86</span><br><span class="line"></span><br><span class="line">4.6.6 结构 86</span><br><span class="line"></span><br><span class="line">4.6.7 联合 87</span><br><span class="line"></span><br><span class="line">4.6.8 省略花括号 88</span><br><span class="line"></span><br><span class="line">4.6.9 指定成员的初始化值 88</span><br><span class="line"></span><br><span class="line">4.7 隐式声明 89</span><br><span class="line"></span><br><span class="line">4.8 外部名称 90</span><br><span class="line"></span><br><span class="line">4.8.1 初始化值模型 90</span><br><span class="line"></span><br><span class="line">4.8.2 省略的存储类别模型 90</span><br><span class="line"></span><br><span class="line">4.8.3 公共模型 90</span><br><span class="line"></span><br><span class="line">4.8.4 混合公共模型 91</span><br><span class="line"></span><br><span class="line">4.8.5 总结和建议 91</span><br><span class="line"></span><br><span class="line">4.8.6 未引用的外部声明 92</span><br><span class="line"></span><br><span class="line">4.9 C++兼容性 92</span><br><span class="line"></span><br><span class="line">4.9.1 作用域 92</span><br><span class="line"></span><br><span class="line">4.9.2 标签和typedef名称 92</span><br><span class="line"></span><br><span class="line">4.9.3 用于类型的存储类别指定符 93</span><br><span class="line"></span><br><span class="line">4.9.4 const类型限定符 93</span><br><span class="line"></span><br><span class="line">4.9.5 初始化值 93</span><br><span class="line"></span><br><span class="line">4.9.6 隐式声明 93</span><br><span class="line"></span><br><span class="line">4.9.7 定义和引用声明 94</span><br><span class="line"></span><br><span class="line">4.9.8 函数链接 94</span><br><span class="line"></span><br><span class="line">4.9.9 无参函数 94</span><br><span class="line"></span><br><span class="line">4.10 练习 94</span><br><span class="line"></span><br><span class="line">第5章 类型 97</span><br><span class="line"></span><br><span class="line">5.1 整数类型 98</span><br><span class="line"></span><br><span class="line">5.1.1 有符号整数类型 98</span><br><span class="line"></span><br><span class="line">5.1.2 无符号整数类型 101</span><br><span class="line"></span><br><span class="line">5.1.3 字符类型 102</span><br><span class="line"></span><br><span class="line">5.1.4 扩展整数类型 104</span><br><span class="line"></span><br><span class="line">5.1.5 布尔类型 104</span><br><span class="line"></span><br><span class="line">5.2 浮点类型 104</span><br><span class="line"></span><br><span class="line">5.3 指针类型 108</span><br><span class="line"></span><br><span class="line">5.3.1 通用指针 109</span><br><span class="line"></span><br><span class="line">5.3.2 null指针和非法指针 109</span><br><span class="line"></span><br><span class="line">5.3.3 使用指针的一些警告 110</span><br><span class="line"></span><br><span class="line">5.4 数组类型 111</span><br><span class="line"></span><br><span class="line">5.4.1 数组和指针 111</span><br><span class="line"></span><br><span class="line">5.4.2 多维数组 112</span><br><span class="line"></span><br><span class="line">5.4.3 数组边界 112</span><br><span class="line"></span><br><span class="line">5.4.4 操作 113</span><br><span class="line"></span><br><span class="line">5.4.5 可变长度的数组 113</span><br><span class="line"></span><br><span class="line">5.5 枚举类型 115</span><br><span class="line"></span><br><span class="line">5.6 结构类型 117</span><br><span class="line"></span><br><span class="line">5.6.1 结构类型引用 119</span><br><span class="line"></span><br><span class="line">5.6.2 结构上的操作 120</span><br><span class="line"></span><br><span class="line">5.6.3 成员 120</span><br><span class="line"></span><br><span class="line">5.6.4 结构成员的布局 122</span><br><span class="line"></span><br><span class="line">5.6.5 位段 122</span><br><span class="line"></span><br><span class="line">5.6.6 移植性问题 124</span><br><span class="line"></span><br><span class="line">5.6.7 结构的大小 125</span><br><span class="line"></span><br><span class="line">5.6.8 灵活数组成员 126</span><br><span class="line"></span><br><span class="line">5.7 联合类型 127</span><br><span class="line"></span><br><span class="line">5.7.1 联合成员的布局 127</span><br><span class="line"></span><br><span class="line">5.7.2 联合的大小 128</span><br><span class="line"></span><br><span class="line">5.7.3 使用联合类型 129</span><br><span class="line"></span><br><span class="line">5.7.4 （其他）使用联合类型 130</span><br><span class="line"></span><br><span class="line">5.8 函数类型 131</span><br><span class="line"></span><br><span class="line">5.9 void类型 133</span><br><span class="line"></span><br><span class="line">5.10 typedef名称 133</span><br><span class="line"></span><br><span class="line">5.10.1 用于函数类型的typedef名称 135</span><br><span class="line"></span><br><span class="line">5.10.2 重定义typedef名称 135</span><br><span class="line"></span><br><span class="line">5.10.3 编译器的说明 136</span><br><span class="line"></span><br><span class="line">5.11 类型兼容性 136</span><br><span class="line"></span><br><span class="line">5.11.1 等价的类型 136</span><br><span class="line"></span><br><span class="line">5.11.2 枚举兼容性 137</span><br><span class="line"></span><br><span class="line">5.11.3 数组兼容性 138</span><br><span class="line"></span><br><span class="line">5.11.4 函数兼容性 138</span><br><span class="line"></span><br><span class="line">5.11.5 结构和联合兼容性 139</span><br><span class="line"></span><br><span class="line">5.11.6 指针兼容性 139</span><br><span class="line"></span><br><span class="line">5.11.7 源文件之间的兼容性 139</span><br><span class="line"></span><br><span class="line">5.12 类型名称和抽象声明器 139</span><br><span class="line"></span><br><span class="line">5.13 C++兼容性 141</span><br><span class="line"></span><br><span class="line">5.13.1 枚举类型 141</span><br><span class="line"></span><br><span class="line">5.13.2 typedef名称 141</span><br><span class="line"></span><br><span class="line">5.13.3 类型兼容性 141</span><br><span class="line"></span><br><span class="line">5.14 练习 141</span><br><span class="line"></span><br><span class="line">第6章 转换和表示形式 144</span><br><span class="line"></span><br><span class="line">6.1 表示形式 144</span><br><span class="line"></span><br><span class="line">6.1.1 存储单位和数据长度 144</span><br><span class="line"></span><br><span class="line">6.1.2 字节顺序 145</span><br><span class="line"></span><br><span class="line">6.1.3 对齐限制 146</span><br><span class="line"></span><br><span class="line">6.1.4 指针的长度 147</span><br><span class="line"></span><br><span class="line">6.1.5 地址模型的效果 147</span><br><span class="line"></span><br><span class="line">6.1.6 类型表示形式 149</span><br><span class="line"></span><br><span class="line">6.2 转换 150</span><br><span class="line"></span><br><span class="line">6.2.1 表示形式的变化 150</span><br><span class="line"></span><br><span class="line">6.2.2 细微的转换 150</span><br><span class="line"></span><br><span class="line">6.2.3 转换为整数类型 150</span><br><span class="line"></span><br><span class="line">6.2.4 转换为浮点类型 152</span><br><span class="line"></span><br><span class="line">6.2.5 转换为结构和联合类型 152</span><br><span class="line"></span><br><span class="line">6.2.6 转换为枚举类型 152</span><br><span class="line"></span><br><span class="line">6.2.7 转换为指针类型 152</span><br><span class="line"></span><br><span class="line">6.2.8 转换为数组和函数类型 153</span><br><span class="line"></span><br><span class="line">6.2.9 转换为void类型 153</span><br><span class="line"></span><br><span class="line">6.3 寻常转换 154</span><br><span class="line"></span><br><span class="line">6.3.1 类型转换 154</span><br><span class="line"></span><br><span class="line">6.3.2 赋值转换 154</span><br><span class="line"></span><br><span class="line">6.3.3 寻常单目转换 155</span><br><span class="line"></span><br><span class="line">6.3.4 寻常双目转换 157</span><br><span class="line"></span><br><span class="line">6.3.5 默认的函数实参转换 158</span><br><span class="line"></span><br><span class="line">6.3.6 其他函数转换 159</span><br><span class="line"></span><br><span class="line">6.4 C++兼容性 159</span><br><span class="line"></span><br><span class="line">6.5 练习 159</span><br><span class="line"></span><br><span class="line">第7章 表达式 161</span><br><span class="line"></span><br><span class="line">7.1 对象、左值和指示符 161</span><br><span class="line"></span><br><span class="line">7.2 表达式和优先级 162</span><br><span class="line"></span><br><span class="line">7.2.1 操作符的优先级和结合性 162</span><br><span class="line"></span><br><span class="line">7.2.2 溢出和其他算术异常 163</span><br><span class="line"></span><br><span class="line">7.3 基本表达式 164</span><br><span class="line"></span><br><span class="line">7.3.1 名称 164</span><br><span class="line"></span><br><span class="line">7.3.2 字面值 165</span><br><span class="line"></span><br><span class="line">7.3.3 带括号的表达式 165</span><br><span class="line"></span><br><span class="line">7.4 后缀表达式 166</span><br><span class="line"></span><br><span class="line">7.4.1 下标表达式 166</span><br><span class="line"></span><br><span class="line">7.4.2 成员选择 168</span><br><span class="line"></span><br><span class="line">7.4.3 函数调用 169</span><br><span class="line"></span><br><span class="line">7.4.4 后缀增值和减值操作符 171</span><br><span class="line"></span><br><span class="line">7.4.5 复合字面值 172</span><br><span class="line"></span><br><span class="line">7.5 单目表达式 173</span><br><span class="line"></span><br><span class="line">7.5.1 类型转换 174</span><br><span class="line"></span><br><span class="line">7.5.2 sizeof操作符 174</span><br><span class="line"></span><br><span class="line">7.5.3 单目负号和正号 176</span><br><span class="line"></span><br><span class="line">7.5.4 逻辑反 176</span><br><span class="line"></span><br><span class="line">7.5.5 位反 177</span><br><span class="line"></span><br><span class="line">7.5.6 取地址操作符 177</span><br><span class="line"></span><br><span class="line">7.5.7 间接访问 178</span><br><span class="line"></span><br><span class="line">7.5.8 前缀增值和减值操作符 179</span><br><span class="line"></span><br><span class="line">7.6 双目操作符表达式 180</span><br><span class="line"></span><br><span class="line">7.6.1 乘除操作符 180</span><br><span class="line"></span><br><span class="line">7.6.2 加减操作符 182</span><br><span class="line"></span><br><span class="line">7.6.3 移位操作符 183</span><br><span class="line"></span><br><span class="line">7.6.4 关系操作符 185</span><br><span class="line"></span><br><span class="line">7.6.5 相等操作符 186</span><br><span class="line"></span><br><span class="line">7.6.6 位操作符 188</span><br><span class="line"></span><br><span class="line">7.6.7 整数集合的例子 189</span><br><span class="line"></span><br><span class="line">7.7 逻辑操作符表达式 192</span><br><span class="line"></span><br><span class="line">7.8 条件表达式 194</span><br><span class="line"></span><br><span class="line">7.9 赋值表达式 195</span><br><span class="line"></span><br><span class="line">7.9.1 简单赋值 196</span><br><span class="line"></span><br><span class="line">7.9.2 复合赋值 197</span><br><span class="line"></span><br><span class="line">7.10 线性表达式 197</span><br><span class="line"></span><br><span class="line">7.11 常量表达式 198</span><br><span class="line"></span><br><span class="line">7.11.1 预处理器常量表达式 199</span><br><span class="line"></span><br><span class="line">7.11.2 整型常量表达式 200</span><br><span class="line"></span><br><span class="line">7.11.3 初始化值常量表达式 200</span><br><span class="line"></span><br><span class="line">7.12 求值的顺序 201</span><br><span class="line"></span><br><span class="line">7.13 被丢弃的值 202</span><br><span class="line"></span><br><span class="line">7.14 内存访问的优化 203</span><br><span class="line"></span><br><span class="line">7.15 C++兼容性 204</span><br><span class="line"></span><br><span class="line">7.16 练习 204</span><br><span class="line"></span><br><span class="line">第8章 语句 206</span><br><span class="line"></span><br><span class="line">8.1 语句的基本语法规则 206</span><br><span class="line"></span><br><span class="line">8.2 表达式语句 207</span><br><span class="line"></span><br><span class="line">8.3 标签语句 207</span><br><span class="line"></span><br><span class="line">8.4 复合语句 208</span><br><span class="line"></span><br><span class="line">8.5 条件语句 210</span><br><span class="line"></span><br><span class="line">8.5.1 多路条件语句 210</span><br><span class="line"></span><br><span class="line">8.5.2 悬疑的else问题 211</span><br><span class="line"></span><br><span class="line">8.6 迭代式语句 212</span><br><span class="line"></span><br><span class="line">8.6.1 while语句 212</span><br><span class="line"></span><br><span class="line">8.6.2 do语句 213</span><br><span class="line"></span><br><span class="line">8.6.3 for语句 214</span><br><span class="line"></span><br><span class="line">8.6.4 使用for语句 215</span><br><span class="line"></span><br><span class="line">8.6.5 多个控制变量 217</span><br><span class="line"></span><br><span class="line">8.7 switch语句 218</span><br><span class="line"></span><br><span class="line">8.8 break和continue语句 220</span><br><span class="line"></span><br><span class="line">8.9 return语句 222</span><br><span class="line"></span><br><span class="line">8.10 goto语句 223</span><br><span class="line"></span><br><span class="line">8.11 空语句 224</span><br><span class="line"></span><br><span class="line">8.12 C++兼容性 224</span><br><span class="line"></span><br><span class="line">8.12.1 复合语句 224</span><br><span class="line"></span><br><span class="line">8.12.2 循环中的声明 224</span><br><span class="line"></span><br><span class="line">8.13 练习 225</span><br><span class="line"></span><br><span class="line">第9章 函数 226</span><br><span class="line"></span><br><span class="line">9.1 函数定义 226</span><br><span class="line"></span><br><span class="line">9.2 函数原型 228</span><br><span class="line"></span><br><span class="line">9.2.1 原型出现在什么时候 230</span><br><span class="line"></span><br><span class="line">9.2.2 混合使用原型和非原型声明 230</span><br><span class="line"></span><br><span class="line">9.2.3 合理地使用原型 231</span><br><span class="line"></span><br><span class="line">9.2.4 原型和调用约定 231</span><br><span class="line"></span><br><span class="line">9.2.5 标准C和传统C的兼容性 233</span><br><span class="line"></span><br><span class="line">9.3 形式参数声明 233</span><br><span class="line"></span><br><span class="line">9.4 形参类型的调整 235</span><br><span class="line"></span><br><span class="line">9.5 参数传递约定 236</span><br><span class="line"></span><br><span class="line">9.6 形参的一致 237</span><br><span class="line"></span><br><span class="line">9.7 函数的返回类型 238</span><br><span class="line"></span><br><span class="line">9.8 返回类型的一致 239</span><br><span class="line"></span><br><span class="line">9.9 main函数 239</span><br><span class="line"></span><br><span class="line">9.10 内联函数 240</span><br><span class="line"></span><br><span class="line">9.11 C++兼容性 242</span><br><span class="line"></span><br><span class="line">9.11.1 原型 242</span><br><span class="line"></span><br><span class="line">9.11.2 形参和返回类型中的类型声明 242</span><br><span class="line"></span><br><span class="line">9.11.3 返回类型的一致 242</span><br><span class="line"></span><br><span class="line">9.11.4 main 242</span><br><span class="line"></span><br><span class="line">9.11.5 内联 243</span><br><span class="line"></span><br><span class="line">9.12 练习 243</span><br><span class="line"></span><br><span class="line">第二部分 C函数库</span><br><span class="line"></span><br><span class="line">第10章 函数库简介 246</span><br><span class="line"></span><br><span class="line">10.1 标准C工具 246</span><br><span class="line"></span><br><span class="line">10.2 C++兼容性 247</span><br><span class="line"></span><br><span class="line">10.3 库头文件和名称 249</span><br><span class="line"></span><br><span class="line">10.3.1 assert.h 249</span><br><span class="line"></span><br><span class="line">10.3.2 complex.h 249</span><br><span class="line"></span><br><span class="line">10.3.3 ctype.h 249</span><br><span class="line"></span><br><span class="line">10.3.4 errno.h 249</span><br><span class="line"></span><br><span class="line">10.3.5 fenv.h 249</span><br><span class="line"></span><br><span class="line">10.3.6 float.h 250</span><br><span class="line"></span><br><span class="line">10.3.7 inttypes.h 250</span><br><span class="line"></span><br><span class="line">10.3.8 iso64.h 250</span><br><span class="line"></span><br><span class="line">10.3.9 limits.h 250</span><br><span class="line"></span><br><span class="line">10.3.10 locale.h 250</span><br><span class="line"></span><br><span class="line">10.3.11 math.h 251</span><br><span class="line"></span><br><span class="line">10.3.12 setjmp.h 252</span><br><span class="line"></span><br><span class="line">10.3.13 signal.h 252</span><br><span class="line"></span><br><span class="line">10.3.14 stdarg.h 252</span><br><span class="line"></span><br><span class="line">10.3.15 stdbool.h 252</span><br><span class="line"></span><br><span class="line">10.3.16 stddef.h 252</span><br><span class="line"></span><br><span class="line">10.3.17 stdint.h 252</span><br><span class="line"></span><br><span class="line">10.3.18 stdio.h 252</span><br><span class="line"></span><br><span class="line">10.3.19 stdlib.h 253</span><br><span class="line"></span><br><span class="line">10.3.20 string.h 253</span><br><span class="line"></span><br><span class="line">10.3.21 tgmath.h 253</span><br><span class="line"></span><br><span class="line">10.3.22 time.h 254</span><br><span class="line"></span><br><span class="line">10.3.23 wchar.h 254</span><br><span class="line"></span><br><span class="line">10.3.24 wctype.h 254</span><br><span class="line"></span><br><span class="line">第11章 标准语言附加 255</span><br><span class="line"></span><br><span class="line">11.1 NULL、ptrdiff_t、size_t、offsetof 255</span><br><span class="line"></span><br><span class="line">11.2 EDOM、ERANGE、EILSEQ、errno、</span><br><span class="line"></span><br><span class="line">strerror、perror 256</span><br><span class="line"></span><br><span class="line">11.3 bool、false、true 257</span><br><span class="line"></span><br><span class="line">11.4 va_list、va_start、va_arg、va_end 258</span><br><span class="line"></span><br><span class="line">11.5 标准C的操作符宏 261</span><br><span class="line"></span><br><span class="line">第12章 字符处理 262</span><br><span class="line"></span><br><span class="line">12.1 isalnum、isalpha、iscntrl、iswalnum、iswalpha、iswcntrl 262</span><br><span class="line"></span><br><span class="line">12.2 iscsym、iscsymf 264</span><br><span class="line"></span><br><span class="line">12.3 isdigit、isodigit、isxdigit、iswdigit、iswxdigit 264</span><br><span class="line"></span><br><span class="line">12.4 isgraph、isprint、ispunct、iswgraph、iswprint、iswpunct 265</span><br><span class="line"></span><br><span class="line">12.5 islower、isupper、iswlower、iswupper 266</span><br><span class="line"></span><br><span class="line">12.6 isblank、isspace、iswhite、iswspace 266</span><br><span class="line"></span><br><span class="line">12.7 toascii 267</span><br><span class="line"></span><br><span class="line">12.8 toint 267</span><br><span class="line"></span><br><span class="line">12.9 tolower、toupper、towlower、</span><br><span class="line"></span><br><span class="line">towupper 267</span><br><span class="line"></span><br><span class="line">12.10 wctype_t、wctype、iswctype 268</span><br><span class="line"></span><br><span class="line">12.11 wctrans_t、wctrans 269</span><br><span class="line"></span><br><span class="line">第13章 字符串处理 270</span><br><span class="line"></span><br><span class="line">13.1 strcat、strncat、wcscat、wcsncat 270</span><br><span class="line"></span><br><span class="line">13.2 strcmp、strncmp、wcscmp、wcsncmp 271</span><br><span class="line"></span><br><span class="line">13.3 strcpy、strncpy、wcscpy、cscncpy 272</span><br><span class="line"></span><br><span class="line">13.4 strlen、wcslen 273</span><br><span class="line"></span><br><span class="line">13.5 strchr、strrchr、wcschr、wcsrchr 273</span><br><span class="line"></span><br><span class="line">13.6 strspn、strcspn、strpbrk、strrpbrk、</span><br><span class="line"></span><br><span class="line">wcsspn、wcscspn、wcspbrk 274</span><br><span class="line"></span><br><span class="line">13.7 strstr、strtok、wcsstr、wcstok 275</span><br><span class="line"></span><br><span class="line">13.8 strtod、strtof、strtold、strtol、strtoll、strtoul、strtoull 276</span><br><span class="line"></span><br><span class="line">13.9 atof、atoi、atol、atoll 277</span><br><span class="line"></span><br><span class="line">13.10 strcoll、strxfrm、wcscoll、wcsxfrm 277</span><br><span class="line"></span><br><span class="line">第14章 内存函数 279</span><br><span class="line"></span><br><span class="line">14.1 memchr、wmemchr 279</span><br><span class="line"></span><br><span class="line">14.2 memcmp、wmemcmp 279</span><br><span class="line"></span><br><span class="line">14.3 memcpy、memccpy、memmove、wmemcpy、wmemmove 280</span><br><span class="line"></span><br><span class="line">14.4 memset、wmemset 281</span><br><span class="line"></span><br><span class="line">第15章 输入&#x2F;输出工具 282</span><br><span class="line"></span><br><span class="line">15.1 FILE、EOF、wchar_t、WEOF 283</span><br><span class="line"></span><br><span class="line">15.2 fopen、fclose、fflush、freopen、</span><br><span class="line"></span><br><span class="line">fwide 284</span><br><span class="line"></span><br><span class="line">15.2.1 文件模式 285</span><br><span class="line"></span><br><span class="line">15.2.2 文件的定向 286</span><br><span class="line"></span><br><span class="line">15.3 setbuf、setvbuf 287</span><br><span class="line"></span><br><span class="line">15.4 stdin、stdout、stderr 287</span><br><span class="line"></span><br><span class="line">15.5 fseek、ftell、rewind、fgetpos、</span><br><span class="line"></span><br><span class="line">fsetpos 288</span><br><span class="line"></span><br><span class="line">15.5.1 fseek和ftell 287</span><br><span class="line"></span><br><span class="line">15.5.2 fgetpos和fsetpos 290</span><br><span class="line"></span><br><span class="line">15.6 fgetc、fgetwc、getc、getwc、getchar、getwchar、ungetc、ungetwc 290</span><br><span class="line"></span><br><span class="line">15.7 fgets、fgetws、gets 291</span><br><span class="line"></span><br><span class="line">15.8 fscanf、fwscanf、scanf、wscanf、</span><br><span class="line"></span><br><span class="line">sscanf、swscanf 292</span><br><span class="line"></span><br><span class="line">15.8.1 控制字符串 293</span><br><span class="line"></span><br><span class="line">15.8.2 转换规范 293</span><br><span class="line"></span><br><span class="line">15.9 fputc、fputwc、putc、putwc、putchar、putwchar 298</span><br><span class="line"></span><br><span class="line">15.10 fputs、fputws、puts 299</span><br><span class="line"></span><br><span class="line">15.11 fprintf、printf、sprintf、snprintf、fwprintf、wprintf、swprintf 299</span><br><span class="line"></span><br><span class="line">15.11.1 输出格式 300</span><br><span class="line"></span><br><span class="line">15.11.2 转换规范 301</span><br><span class="line"></span><br><span class="line">15.11.3 转换标志 301</span><br><span class="line"></span><br><span class="line">15.11.4 最小字段宽度 302</span><br><span class="line"></span><br><span class="line">15.11.5 精度 303</span><br><span class="line"></span><br><span class="line">15.11.6 长度规范 303</span><br><span class="line"></span><br><span class="line">15.11.7 转换操作 304</span><br><span class="line"></span><br><span class="line">15.12 v[x]printf、v[x]scanf 311</span><br><span class="line"></span><br><span class="line">15.13 fread、fwrite 312</span><br><span class="line"></span><br><span class="line">15.14 feof、ferror、clearerr 313</span><br><span class="line"></span><br><span class="line">15.15 remove、rename 314</span><br><span class="line"></span><br><span class="line">15.16 tmpfile、tmpnam、mktemp 314</span><br><span class="line"></span><br><span class="line">第16章 基本工具 316</span><br><span class="line"></span><br><span class="line">16.1 malloc、calloc、mlalloc、clalloc、free、cfree 316</span><br><span class="line"></span><br><span class="line">16.2 rand、srand、RAND_MAX 318</span><br><span class="line"></span><br><span class="line">16.3 atof、atoi、atol、atoll 319</span><br><span class="line"></span><br><span class="line">16.4 strtod、strtof、strtold、strtol、strtoll、strtoul、strtoull 319</span><br><span class="line"></span><br><span class="line">16.5 abort、atexit、exit、_Exit、EXIT_FAILURE、EXIT_SUCCESS 321</span><br><span class="line"></span><br><span class="line">16.6 getenv 322</span><br><span class="line"></span><br><span class="line">16.7 system 323</span><br><span class="line"></span><br><span class="line">16.8 bsearch、qsort 323</span><br><span class="line"></span><br><span class="line">16.9 abs、labs、llabs、div、ldiv、lldiv 325</span><br><span class="line"></span><br><span class="line">16.10 mblen、mbtowc、wctomb 326</span><br><span class="line"></span><br><span class="line">16.10.1 编码和转换状态 327</span><br><span class="line"></span><br><span class="line">16.10.2 长度函数 327</span><br><span class="line"></span><br><span class="line">16.10.3 转换为宽字符 327</span><br><span class="line"></span><br><span class="line">16.10.4 宽字符转换为多字节字符 328</span><br><span class="line"></span><br><span class="line">16.11 mbstowcs、wcstombs 328</span><br><span class="line"></span><br><span class="line">16.11.1 转换为宽字符串 328</span><br><span class="line"></span><br><span class="line">16.11.2 从宽字符串转换为多字节字符 329</span><br><span class="line"></span><br><span class="line">第17章 数学函数 331</span><br><span class="line"></span><br><span class="line">17.1 abs、lbas、llabs、div、ldiv、lldiv 331</span><br><span class="line"></span><br><span class="line">17.2 fabs 332</span><br><span class="line"></span><br><span class="line">17.3 ceil、floor、lrint、llrint、lround、llround、nearbyint、round、rint、trunc 332</span><br><span class="line"></span><br><span class="line">17.4 fmod、remainder、remquo 333</span><br><span class="line"></span><br><span class="line">17.5 frexp、ldexp、modf、scalbn 334</span><br><span class="line"></span><br><span class="line">17.6 exp、exp2、expm1、ilogb、log、log10、log1p、log2、logb 334</span><br><span class="line"></span><br><span class="line">17.7 cbrt、fma、hypot、pow、sqrt 335</span><br><span class="line"></span><br><span class="line">17.8 rand、srand、RAND_MAX 336</span><br><span class="line"></span><br><span class="line">17.9 cos、sin、tan、cosh、sinh、tanh 336</span><br><span class="line"></span><br><span class="line">17.10 acos、asin、atan、atan2、acosh、</span><br><span class="line"></span><br><span class="line">asinh、atanh 337</span><br><span class="line"></span><br><span class="line">17.11 fdim、fmax、fmin 338</span><br><span class="line"></span><br><span class="line">17.12 类型通用的宏 338</span><br><span class="line"></span><br><span class="line">17.13 erf、erfc、lgamma、tgamma 341</span><br><span class="line"></span><br><span class="line">17.14 fpclassify、isfinite、isinf、isnan、isnormal、signbit 342</span><br><span class="line"></span><br><span class="line">17.15 copysign、nan、nextafter、</span><br><span class="line"></span><br><span class="line">nexttoward 343</span><br><span class="line"></span><br><span class="line">17.16 isgreater、isgreaterequal、isless、</span><br><span class="line"></span><br><span class="line">islessequal、islessgreater、isunordered 343</span><br><span class="line"></span><br><span class="line">第18章 时间和日期函数 345</span><br><span class="line"></span><br><span class="line">18.1 clock、clock_t、CLOCKS_PER_SEC、times 345</span><br><span class="line"></span><br><span class="line">18.2 time、time_t 346</span><br><span class="line"></span><br><span class="line">18.3 asctime、ctime 346</span><br><span class="line"></span><br><span class="line">18.4 gmtime、localtime、mktime 347</span><br><span class="line"></span><br><span class="line">18.5 difftime 348</span><br><span class="line"></span><br><span class="line">18.6 strtime、wcsftime 349</span><br><span class="line"></span><br><span class="line">第19章 控制函数 352</span><br><span class="line"></span><br><span class="line">19.1 assert、NDEBUG 352</span><br><span class="line"></span><br><span class="line">19.2 system、exec 352</span><br><span class="line"></span><br><span class="line">19.3 exit、abort 353</span><br><span class="line"></span><br><span class="line">19.4 setjmp、longjmp、jmp_buf 353</span><br><span class="line"></span><br><span class="line">19.5 atexit 354</span><br><span class="line"></span><br><span class="line">19.6 signal、raise、gsignal、ssignal、</span><br><span class="line"></span><br><span class="line">psignal 354</span><br><span class="line"></span><br><span class="line">19.7 sleep、alarm 356</span><br><span class="line"></span><br><span class="line">第20章 区域 357</span><br><span class="line"></span><br><span class="line">20.1 setlocale 357</span><br><span class="line"></span><br><span class="line">20.2 localeconv 358</span><br><span class="line"></span><br><span class="line">第21章 扩展整数类型 361</span><br><span class="line"></span><br><span class="line">21.1 基本规则 361</span><br><span class="line"></span><br><span class="line">21.1.1 类型的种类 361</span><br><span class="line"></span><br><span class="line">21.1.2 要么都定义，要么都不定义 361</span><br><span class="line"></span><br><span class="line">21.1.3 MIN和MAX限制 361</span><br><span class="line"></span><br><span class="line">21.1.4 PRI...和SCN...格式字符串宏 362</span><br><span class="line"></span><br><span class="line">21.2 固定长度的整数类型 363</span><br><span class="line"></span><br><span class="line">21.3 具有最小宽度的最小长度类型 364</span><br><span class="line"></span><br><span class="line">21.4 具有最小宽度的快速类型 364</span><br><span class="line"></span><br><span class="line">21.5 指针长度和zuida长度整数类型 365</span><br><span class="line"></span><br><span class="line">21.6 ptrdiff_t、size_t、wchar_t、wint_t和sig_atomic_t的范围 366</span><br><span class="line"></span><br><span class="line">21.7 imaxabs、imaxdiv、imaxdiv_t 366</span><br><span class="line"></span><br><span class="line">21.8 strtoimax、strtouimax 367</span><br><span class="line"></span><br><span class="line">21.9 wcstoimax、wcstoumax 367</span><br><span class="line"></span><br><span class="line">第22章 浮点环境 368</span><br><span class="line"></span><br><span class="line">22.1 介绍 368</span><br><span class="line"></span><br><span class="line">22.2 浮点环境 369</span><br><span class="line"></span><br><span class="line">22.3 浮点异常 369</span><br><span class="line"></span><br><span class="line">22.4 浮点四舍五入模式 370</span><br><span class="line"></span><br><span class="line">22.5 浮点表达式收缩 371</span><br><span class="line"></span><br><span class="line">第23章 复数运算 372</span><br><span class="line"></span><br><span class="line">23.1 复数函数库约定 372</span><br><span class="line"></span><br><span class="line">23.2 complex、_Complex_I、imaginary、_Imaginary_I、I 372</span><br><span class="line"></span><br><span class="line">23.3 CX_LIMITED_RANGE 372</span><br><span class="line"></span><br><span class="line">23.4 cacos、casin、catan、ccos、csin、</span><br><span class="line"></span><br><span class="line">ctan 373</span><br><span class="line"></span><br><span class="line">23.5 cacosh、casinh、catanh、ccosh、csinh、ctanh 374</span><br><span class="line"></span><br><span class="line">23.6 cexp、clog、cabs、cpow、csqrt 374</span><br><span class="line"></span><br><span class="line">23.7 carg、cimag、creal、conj、cproj 375</span><br><span class="line"></span><br><span class="line">第24章 宽字符和多字节字符工具 377</span><br><span class="line"></span><br><span class="line">24.1 基本类型和宏 377</span><br><span class="line"></span><br><span class="line">24.2 宽字符和多字节字符之间的转换 377</span><br><span class="line"></span><br><span class="line">24.3 宽字符串和多字节字符串之间的转换 379</span><br><span class="line"></span><br><span class="line">24.4 转换为算术类型 380</span><br><span class="line"></span><br><span class="line">24.5 输入和输出函数 380</span><br><span class="line"></span><br><span class="line">24.6 字符串函数 381</span><br><span class="line"></span><br><span class="line">24.7 日期和时间转换 382</span><br><span class="line"></span><br><span class="line">24.8 宽字符分类和映射函数 382</span><br><span class="line"></span><br><span class="line">附录A ASCII字符集 383</span><br><span class="line"></span><br><span class="line">附录B 语法 384</span><br><span class="line"></span><br><span class="line">附录C 练习答案 396</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop技术内幕_深入解析HadoopCommon和HDFS架构设计与实现原理 PDF</title>
    <url>/posts/14e09dcd/</url>
    <content><![CDATA[<h4 id="《Hadoop技术内幕-深入解析HadoopCommon和HDFS架构设计与实现原理》"><a href="#《Hadoop技术内幕-深入解析HadoopCommon和HDFS架构设计与实现原理》" class="headerlink" title="《Hadoop技术内幕_深入解析HadoopCommon和HDFS架构设计与实现原理》"></a>《Hadoop技术内幕_深入解析HadoopCommon和HDFS架构设计与实现原理》</h4><h6 id="链接-https-pan-baidu-com-s-1jOadD77nyb77JjvxQomioQ-提取码-c3gx"><a href="#链接-https-pan-baidu-com-s-1jOadD77nyb77JjvxQomioQ-提取码-c3gx" class="headerlink" title="链接: https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ 提取码: c3gx"></a>链接: <a href="https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ">https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ</a> 提取码: c3gx</h6><p>Hadoop技术内幕”共两册，分别从源代码的角度对“Common HDFS”和MapReduce的架构设计和实现原理进行了极为详细的分析。《Hadoop技术内幕：深入解析HadoopCommon和HDFS架构设计与实现原理》由腾讯数据平台的资深Hadoop专家、X-RIME的作者亲自执笔，对Common和HDFS的源代码进行了分析，旨在为Hadoop的优化、定制和扩展提供原理性的指导。除此之外，本书还从源代码实现中对分布式技术的精髓、分布式系统设计的思想和方法，以及Java语言的编码技巧、编程规范和对设计模式的精妙运用进行了总结和分析，对提高读者的分布式技术能力和Java编程能力都非常有帮助。本书适合Hadoop的二次开发人员、应用开发工程师、运维工程师阅读。<br><a id="more"></a></p>
<p>　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前　言</span><br><span class="line"></span><br><span class="line">部分　环境准备</span><br><span class="line"></span><br><span class="line">章　源代码环境准备</span><br><span class="line"></span><br><span class="line">1.1　什么是Hadoop</span><br><span class="line"></span><br><span class="line">1.1.1　Hadoop简史</span><br><span class="line"></span><br><span class="line">1.1.2　Hadoop的优势</span><br><span class="line"></span><br><span class="line">1.1.3　Hadoop生态系统</span><br><span class="line"></span><br><span class="line">1.2　准备源代码阅读环境</span><br><span class="line"></span><br><span class="line">1.2.1　安装与配置K</span><br><span class="line"></span><br><span class="line">1.2.2　安装Eclipse</span><br><span class="line"></span><br><span class="line">1.2.3　安装辅助工具Ant</span><br><span class="line"></span><br><span class="line">1.2.4　安装类UNIX Shell环境Cygwin</span><br><span class="line"></span><br><span class="line">1.3　准备Hadoop源代码</span><br><span class="line"></span><br><span class="line">1.3.1　下载Hadoop</span><br><span class="line"></span><br><span class="line">1.3.2　创建Eclipse项目</span><br><span class="line"></span><br><span class="line">1.3.3　Hadoop源代码组织</span><br><span class="line"></span><br><span class="line">1.4　小结</span><br><span class="line"></span><br><span class="line">第二部分　Common的实现</span><br><span class="line"></span><br><span class="line">第2章　Hadoop配置信息处理</span><br><span class="line"></span><br><span class="line">2.1　配置文件简介</span><br><span class="line"></span><br><span class="line">2.1.1　Windows操作系统的配置文件</span><br><span class="line"></span><br><span class="line">2.1.2　Java配置文件</span><br><span class="line"></span><br><span class="line">2.2　Hadoop Configuration详解</span><br><span class="line"></span><br><span class="line">2.2.1　Hadoop配置文件的格式</span><br><span class="line"></span><br><span class="line">2.2.2　Configuration的成员变量</span><br><span class="line"></span><br><span class="line">2.2.3　资源加载</span><br><span class="line"></span><br><span class="line">2.2.4　使用get和set访问设置配置项</span><br><span class="line"></span><br><span class="line">2.3　Configurable接口</span><br><span class="line"></span><br><span class="line">2.4　小结</span><br><span class="line"></span><br><span class="line">第3章　序列化与压缩</span><br><span class="line"></span><br><span class="line">3.1　序列化</span><br><span class="line"></span><br><span class="line">3.1.1　Java内建序列化机制</span><br><span class="line"></span><br><span class="line">3.1.2　Hadoop序列化机制</span><br><span class="line"></span><br><span class="line">3.1.3　Hadoop序列化机制的特征</span><br><span class="line"></span><br><span class="line">3.1.4　Hadoop Writable机制</span><br><span class="line"></span><br><span class="line">3.1.5　典型的Writable类详解</span><br><span class="line"></span><br><span class="line">3.1.6　Hadoop序列化框架</span><br><span class="line"></span><br><span class="line">3.2　压缩</span><br><span class="line"></span><br><span class="line">3.2.1　Hadoop压缩简介</span><br><span class="line"></span><br><span class="line">3.2.2　Hadoop压缩API应用实例</span><br><span class="line"></span><br><span class="line">3.2.3　Hadoop压缩框架</span><br><span class="line"></span><br><span class="line">3.2.4　Java本地方法</span><br><span class="line"></span><br><span class="line">3.2.5　支持Snappy压缩</span><br><span class="line"></span><br><span class="line">3.3　小结</span><br><span class="line"></span><br><span class="line">第4章　Hadoop远程过程调用</span><br><span class="line"></span><br><span class="line">4.1　远程过程调用基础知识</span><br><span class="line"></span><br><span class="line">4.1.1　RPC原理</span><br><span class="line"></span><br><span class="line">4.1.2　RPC机制的实现</span><br><span class="line"></span><br><span class="line">4.1.3　Java远程方法调用</span><br><span class="line"></span><br><span class="line">4.2　Java动态代理</span><br><span class="line"></span><br><span class="line">4.2.1　创建代理接口</span><br><span class="line"></span><br><span class="line">4.2.2　调用转发</span><br><span class="line"></span><br><span class="line">4.2.3　动态代理实例</span><br><span class="line"></span><br><span class="line">4.3　Java NIO</span><br><span class="line"></span><br><span class="line">4.3.1　Java基本套接字</span><br><span class="line"></span><br><span class="line">4.3.2　Java NIO基础</span><br><span class="line"></span><br><span class="line">4.3.3　Java NIO实例：回显服务器</span><br><span class="line"></span><br><span class="line">4.4　Hadoop中的远程过程调用</span><br><span class="line"></span><br><span class="line">4.4.1　利用Hadoop IPC构建简单的分布式系统</span><br><span class="line"></span><br><span class="line">4.4.2　Hadoop IPC的代码结构</span><br><span class="line"></span><br><span class="line">4.5　Hadoop IPC连接相关过程</span><br><span class="line"></span><br><span class="line">4.5.1　IPC连接成员变量</span><br><span class="line"></span><br><span class="line">4.5.2　建立IPC连接</span><br><span class="line"></span><br><span class="line">4.5.3　数据分帧和读写</span><br><span class="line"></span><br><span class="line">4.5.4　维护IPC连接</span><br><span class="line"></span><br><span class="line">4.5.5　关闭IPC连接</span><br><span class="line"></span><br><span class="line">4.6　Hadoop IPC方法调用相关过程</span><br><span class="line"></span><br><span class="line">4.6.1　Java接口与接口体</span><br><span class="line"></span><br><span class="line">4.6.2　IPC方法调用成员变量</span><br><span class="line"></span><br><span class="line">4.6.3　客户端方法调用过程</span><br><span class="line"></span><br><span class="line">4.6.4　服务器端方法调用过程</span><br><span class="line"></span><br><span class="line">4.7　Hadoop IPC上的其他辅助过程</span><br><span class="line"></span><br><span class="line">4.7.1　RPC.getProxy和RPC.stopProxy</span><br><span class="line"></span><br><span class="line">4.7.2　RPC.getServer和Server的启停</span><br><span class="line"></span><br><span class="line">4.8　小结</span><br><span class="line"></span><br><span class="line">第5章　Hadoop文件系统</span><br><span class="line"></span><br><span class="line">5.1　文件系统</span><br><span class="line"></span><br><span class="line">5.1.1　文件系统的用户界面</span><br><span class="line"></span><br><span class="line">5.1.2　文件系统的实现</span><br><span class="line"></span><br><span class="line">5.1.3　文件系统的保护控制</span><br><span class="line"></span><br><span class="line">5.2　Linux文件系统</span><br><span class="line"></span><br><span class="line">5.2.1　Linux本地文件系统</span><br><span class="line"></span><br><span class="line">5.2.2　虚拟文件系统</span><br><span class="line"></span><br><span class="line">5.2.3　Linux文件保护机制</span><br><span class="line"></span><br><span class="line">5.2.4　Linux文件系统API</span><br><span class="line"></span><br><span class="line">5.3　分布式文件系统</span><br><span class="line"></span><br><span class="line">5.3.1　分布式文件系统的特性</span><br><span class="line"></span><br><span class="line">5.3.2　基本NFS体系结构</span><br><span class="line"></span><br><span class="line">5.3.3　NFS支持的文件操作</span><br><span class="line"></span><br><span class="line">5.4　Java文件系统</span><br><span class="line"></span><br><span class="line">5.4.1　Java文件系统API</span><br><span class="line"></span><br><span class="line">5.4.2　URI和URL</span><br><span class="line"></span><br><span class="line">5.4.3　Java输入输出流</span><br><span class="line"></span><br><span class="line">5.4.4　存取文件</span><br><span class="line"></span><br><span class="line">5.5　Hadoop抽象文件系统</span><br><span class="line"></span><br><span class="line">5.5.1　Hadoop文件系统API</span><br><span class="line"></span><br><span class="line">5.5.2　Hadoop输入输出流</span><br><span class="line"></span><br><span class="line">5.5.3　Hadoop文件系统中的权限</span><br><span class="line"></span><br><span class="line">5.5.4　抽象文件系统中的静态方法</span><br><span class="line"></span><br><span class="line">5.5.5　Hadoop文件系统中的协议处理器</span><br><span class="line"></span><br><span class="line">5.6　Hadoop具体文件系统</span><br><span class="line"></span><br><span class="line">5.6.1　FileSystem层次结构</span><br><span class="line"></span><br><span class="line">5.6.2　RawLocalFileSystem的实现</span><br><span class="line"></span><br><span class="line">5.6.3　ChecksumFileSystem的实现</span><br><span class="line"></span><br><span class="line">5.6.4　RawInMemoryFileSystem的实现</span><br><span class="line"></span><br><span class="line">5.7　小结</span><br><span class="line"></span><br><span class="line">第三部分　Hadoop分布式文件系统</span><br><span class="line"></span><br><span class="line">第6章　HDFS概述</span><br><span class="line"></span><br><span class="line">6.1　初识HDFS</span><br><span class="line"></span><br><span class="line">6.1.1　HDFS主要特性</span><br><span class="line"></span><br><span class="line">6.1.2　HDFS体系结构</span><br><span class="line"></span><br><span class="line">6.1.3　HDFS源代码结构</span><br><span class="line"></span><br><span class="line">6.2　基于远程过程调用的接口</span><br><span class="line"></span><br><span class="line">6.2.1　与客户端相关的接口</span><br><span class="line"></span><br><span class="line">6.2.2　HDFS各服务器间的接口</span><br><span class="line"></span><br><span class="line">6.3　非远程过程调用接口</span><br><span class="line"></span><br><span class="line">6.3.1　数据节点上的非IPC接口</span><br><span class="line"></span><br><span class="line">6.3.2　名字节点和第二名字节点上的非IPC接口</span><br><span class="line"></span><br><span class="line">6.4　HDFS主要流程</span><br><span class="line"></span><br><span class="line">6.4.1　客户端到名字节点的文件与目录操作</span><br><span class="line"></span><br><span class="line">6.4.2　客户端读文件</span><br><span class="line"></span><br><span class="line">6.4.3　客户端写文件</span><br><span class="line"></span><br><span class="line">6.4.4　数据节点的启动和心跳</span><br><span class="line"></span><br><span class="line">6.4.5　第二名字节点合并元数据</span><br><span class="line"></span><br><span class="line">6.5　小结</span><br><span class="line"></span><br><span class="line">第7章　数据节点实现</span><br><span class="line"></span><br><span class="line">7.1　数据块存储</span><br><span class="line"></span><br><span class="line">7.1.1　数据节点的磁盘目录文件结构</span><br><span class="line"></span><br><span class="line">7.1.2　数据节点存储的实现</span><br><span class="line"></span><br><span class="line">7.1.3　数据节点升级</span><br><span class="line"></span><br><span class="line">7.1.4　文件系统数据集的工作机制</span><br><span class="line"></span><br><span class="line">7.2　流式接口的实现</span><br><span class="line"></span><br><span class="line">7.2.1　DataXceiverServer和DataXceiver</span><br><span class="line"></span><br><span class="line">7.2.2　读数据</span><br><span class="line"></span><br><span class="line">7.2.3　写数据</span><br><span class="line"></span><br><span class="line">7.2.4　数据块替换、数据块拷贝和读数据块检验信息</span><br><span class="line"></span><br><span class="line">7.3　作为整体的数据节点</span><br><span class="line"></span><br><span class="line">7.3.1　数据节点和名字节点的交互</span><br><span class="line"></span><br><span class="line">7.3.2　数据块扫描器</span><br><span class="line"></span><br><span class="line">7.3.3　数据节点的启停</span><br><span class="line"></span><br><span class="line">7.4　小结</span><br><span class="line"></span><br><span class="line">第8章　名字节点实现</span><br><span class="line"></span><br><span class="line">8.1　文件系统的目录树</span><br><span class="line"></span><br><span class="line">8.1.1　从i-node到INode</span><br><span class="line"></span><br><span class="line">8.1.2　命名空间镜像和编辑日志</span><br><span class="line"></span><br><span class="line">8.1.3　第二名字节点</span><br><span class="line"></span><br><span class="line">8.1.4　FSDirectory的实现</span><br><span class="line"></span><br><span class="line">8.2　数据块和数据节点管理</span><br><span class="line"></span><br><span class="line">8.2.1　数据结构</span><br><span class="line"></span><br><span class="line">8.2.2　数据节点管理</span><br><span class="line"></span><br><span class="line">8.2.3　数据块管理</span><br><span class="line"></span><br><span class="line">8.3　远程接口ClientProtocol的实现</span><br><span class="line"></span><br><span class="line">8.3.1　文件和目录相关事务</span><br><span class="line"></span><br><span class="line">8.3.2　读数据使用的方法</span><br><span class="line"></span><br><span class="line">8.3.3　写数据使用的方法</span><br><span class="line"></span><br><span class="line">8.3.4　工具dfsadmin依赖的方法</span><br><span class="line"></span><br><span class="line">8.4　名字节点的启动和停止</span><br><span class="line"></span><br><span class="line">8.4.1　安全模式</span><br><span class="line"></span><br><span class="line">8.4.2　名字节点的启动</span><br><span class="line"></span><br><span class="line">8.4.3　名字节点的停止</span><br><span class="line"></span><br><span class="line">8.5　小结</span><br><span class="line"></span><br><span class="line">第9章　HDFS客户端</span><br><span class="line"></span><br><span class="line">9.1　认识DFSClient</span><br><span class="line"></span><br><span class="line">9.1.1　DFSClient的构造和关闭</span><br><span class="line"></span><br><span class="line">9.1.2　文件和目录、系统管理相关事务</span><br><span class="line"></span><br><span class="line">9.1.3　删除HDFS文件目录的流程</span><br><span class="line"></span><br><span class="line">9.2　输入流</span><br><span class="line"></span><br><span class="line">9.2.1　读数据前的准备：打开文件</span><br><span class="line"></span><br><span class="line">9.2.2　读数据</span><br><span class="line"></span><br><span class="line">9.2.3　关闭输入流</span><br><span class="line"></span><br><span class="line">9.2.4　读取HDFS文件数据的流程</span><br><span class="line"></span><br><span class="line">9.3　输出流</span><br><span class="line"></span><br><span class="line">9.3.1　写数据前的准备：创建文件</span><br><span class="line"></span><br><span class="line">9.3.2　写数据：数据流管道的建立</span><br><span class="line"></span><br><span class="line">9.3.3　写数据：数据包的发送</span><br><span class="line"></span><br><span class="line">9.3.4　写数据：数据流管道出错处理</span><br><span class="line"></span><br><span class="line">9.3.5　写数据：租约更新</span><br><span class="line"></span><br><span class="line">9.3.6　写数据：DFSOutputStream.sync的作用</span><br><span class="line"></span><br><span class="line">9.3.7　关闭输出流</span><br><span class="line"></span><br><span class="line">9.3.8　向HDFS文件写入数据的流程</span><br><span class="line"></span><br><span class="line">9.4　DistributedFileSystem的实现</span><br><span class="line"></span><br><span class="line">9.5　HDFS常用工具</span><br><span class="line"></span><br><span class="line">9.5.1　FsShell</span><br><span class="line"></span><br><span class="line">9.5.2　DFSAdmin</span><br><span class="line"></span><br><span class="line">9.6　小结</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop技术内幕深入解析YARN架构设计与实现原理 PDF</title>
    <url>/posts/63e7ad5b/</url>
    <content><![CDATA[<h4 id="《Hadoop技术内幕深入解析YARN架构设计与实现原理》"><a href="#《Hadoop技术内幕深入解析YARN架构设计与实现原理》" class="headerlink" title="《Hadoop技术内幕深入解析YARN架构设计与实现原理》"></a>《Hadoop技术内幕深入解析YARN架构设计与实现原理》</h4><h6 id="链接-https-pan-baidu-com-s-1vhJ4ETMwDztkR10tx90-Vg-提取码-bdje"><a href="#链接-https-pan-baidu-com-s-1vhJ4ETMwDztkR10tx90-Vg-提取码-bdje" class="headerlink" title="链接: https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg 提取码: bdje"></a>链接: <a href="https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg">https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg</a> 提取码: bdje</h6><p>《Hadoop技术内幕：深入解析YARN架构设计与实现原理》是“Hadoop技术内幕”系列的第3本书，前面两本分别对Common、HDFS和MapReduce进行了深入分析和讲解，赢得了极好的口碑，Hadoop领域几乎人手一册，本书则对YARN展开了深入的探讨，是首部关于YARN的专著。仍然由资深Hadoop技术专家董西成执笔，根据的Hadoop 2.0版本撰写，权威社区ChinaHadoop鼎力推荐。<br><a id="more"></a></p>
<p><img src="/images/2b92211653fadaf898a0caaf5259502b1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《Hadoop技术内幕：深入解析YARN架构设计与实现原理》</span><br><span class="line"></span><br><span class="line">前 言</span><br><span class="line"></span><br><span class="line">第一部分 准备篇</span><br><span class="line"></span><br><span class="line">第1章 环境准备 2</span><br><span class="line"></span><br><span class="line">1.1 准备学习环境 2</span><br><span class="line"></span><br><span class="line">1.1.1 基础软件下载 2</span><br><span class="line"></span><br><span class="line">1.1.2 如何准备Linux环境 3</span><br><span class="line"></span><br><span class="line">1.2 获取Hadoop源代码 5</span><br><span class="line"></span><br><span class="line">1.3 搭建Hadoop源代码阅读环境 5</span><br><span class="line"></span><br><span class="line">1.3.1 创建Hadoop工程 5</span><br><span class="line"></span><br><span class="line">1.3.2 Hadoop源代码阅读技巧 8</span><br><span class="line"></span><br><span class="line">1.4 Hadoop源代码组织结构 10</span><br><span class="line"></span><br><span class="line">1.5 Hadoop初体验 12</span><br><span class="line"></span><br><span class="line">1.5.1 搭建Hadoop环境 12</span><br><span class="line"></span><br><span class="line">1.5.2 Hadoop Shell介绍 15</span><br><span class="line"></span><br><span class="line">1.6 编译及调试Hadoop源代码 16</span><br><span class="line"></span><br><span class="line">1.6.1 编译Hadoop源代码 17</span><br><span class="line"></span><br><span class="line">1.6.2 调试Hadoop源代码 18</span><br><span class="line"></span><br><span class="line">1.7 小结 20</span><br><span class="line"></span><br><span class="line">第2章 YARN设计理念与基本架构 21</span><br><span class="line"></span><br><span class="line">2.1 YARN产生背景 21</span><br><span class="line"></span><br><span class="line">2.1.1 MRv1的局限性 21</span><br><span class="line"></span><br><span class="line">2.1.2 轻量级弹性计算平台 22</span><br><span class="line"></span><br><span class="line">2.2 Hadoop基础知识 23</span><br><span class="line"></span><br><span class="line">2.2.1 术语解释 23</span><br><span class="line"></span><br><span class="line">2.2.2 Hadoop版本变迁 25</span><br><span class="line"></span><br><span class="line">2.3 YARN基本设计思想 29</span><br><span class="line"></span><br><span class="line">2.3.1 基本框架对比 29</span><br><span class="line"></span><br><span class="line">2.3.2 编程模型对比 30</span><br><span class="line"></span><br><span class="line">2.4 YARN 基本架构 31</span><br><span class="line"></span><br><span class="line">2.4.1 YARN基本组成结构 32</span><br><span class="line"></span><br><span class="line">2.4.2 YARN通信协议 34</span><br><span class="line"></span><br><span class="line">2.5 YARN工作流程 35</span><br><span class="line"></span><br><span class="line">2.6 多角度理解YARN 36</span><br><span class="line"></span><br><span class="line">2.6.1 并行编程 36</span><br><span class="line"></span><br><span class="line">2.6.2 资源管理系统 36</span><br><span class="line"></span><br><span class="line">2.6.3 云计算 37</span><br><span class="line"></span><br><span class="line">2.7 本书涉及内容 38</span><br><span class="line"></span><br><span class="line">2.8 小结 38</span><br><span class="line"></span><br><span class="line">第二部分 YARN核心设计篇</span><br><span class="line"></span><br><span class="line">第3章 YARN基础库 40</span><br><span class="line"></span><br><span class="line">3.1 概述 40</span><br><span class="line"></span><br><span class="line">3.2 第三方开源库 41</span><br><span class="line"></span><br><span class="line">3.2.1 Protocol Buffers 41</span><br><span class="line"></span><br><span class="line">3.2.2 Apache Avro 43</span><br><span class="line"></span><br><span class="line">3.3 底层通信库 46</span><br><span class="line"></span><br><span class="line">3.3.1 RPC通信模型 46</span><br><span class="line"></span><br><span class="line">3.3.2 Hadoop RPC的特点概述 48</span><br><span class="line"></span><br><span class="line">3.3.3 RPC总体架构 48</span><br><span class="line"></span><br><span class="line">3.3.4 Hadoop RPC使用方法 49</span><br><span class="line"></span><br><span class="line">3.3.5 Hadoop RPC类详解 51</span><br><span class="line"></span><br><span class="line">3.3.6 Hadoop RPC参数调优 57</span><br><span class="line"></span><br><span class="line">3.3.7 YARN RPC实现 57</span><br><span class="line"></span><br><span class="line">3.3.8 YARN RPC应用实例 61</span><br><span class="line"></span><br><span class="line">3.4 服务库与事件库 65</span><br><span class="line"></span><br><span class="line">3.4.1 服务库 66</span><br><span class="line"></span><br><span class="line">3.4.2 事件库 66</span><br><span class="line"></span><br><span class="line">3.4.3 YARN服务库和事件库的使用方法 68</span><br><span class="line"></span><br><span class="line">3.4.4 事件驱动带来的变化 70</span><br><span class="line"></span><br><span class="line">3.5 状态机库 72</span><br><span class="line"></span><br><span class="line">3.5.1 YARN状态转换方式 72</span><br><span class="line"></span><br><span class="line">3.5.2 状态机类 73</span><br><span class="line"></span><br><span class="line">3.5.3 状态机的使用方法 73</span><br><span class="line"></span><br><span class="line">3.5.4 状态机可视化 76</span><br><span class="line"></span><br><span class="line">3.6 源代码阅读引导 76</span><br><span class="line"></span><br><span class="line">3.7 小结 77</span><br><span class="line"></span><br><span class="line">3.8 问题讨论 77</span><br><span class="line"></span><br><span class="line">第4章 YARN应用程序设计方法 78</span><br><span class="line"></span><br><span class="line">4.1 概述 78</span><br><span class="line"></span><br><span class="line">4.2 客户端设计 79</span><br><span class="line"></span><br><span class="line">4.2.1 客户端编写流程 80</span><br><span class="line"></span><br><span class="line">4.2.2 客户端编程库 84</span><br><span class="line"></span><br><span class="line">4.3 ApplicationMaster设计 84</span><br><span class="line"></span><br><span class="line">4.3.1 ApplicationMaster编写流程 84</span><br><span class="line"></span><br><span class="line">4.3.2 ApplicationMaster编程库 92</span><br><span class="line"></span><br><span class="line">4.4 YARN 应用程序实例 95</span><br><span class="line"></span><br><span class="line">4.4.1 DistributedShell 95</span><br><span class="line"></span><br><span class="line">4.4.2 Unmanaged AM 99</span><br><span class="line"></span><br><span class="line">4.5 源代码阅读引导 100</span><br><span class="line"></span><br><span class="line">4.6 小结 100</span><br><span class="line"></span><br><span class="line">4.7 问题讨论 100</span><br><span class="line"></span><br><span class="line">第5章 ResourceManager剖析 102</span><br><span class="line"></span><br><span class="line">5.1 概述 102</span><br><span class="line"></span><br><span class="line">5.1.1 ResourceManager基本职能 102</span><br><span class="line"></span><br><span class="line">5.1.2 ResourceManager内部架构 103</span><br><span class="line"></span><br><span class="line">5.1.3 ResourceManager事件与事件处理器 106</span><br><span class="line"></span><br><span class="line">5.2 用户交互模块 108</span><br><span class="line"></span><br><span class="line">5.2.1 ClientRMService 108</span><br><span class="line"></span><br><span class="line">5.2.2 AdminService 109</span><br><span class="line"></span><br><span class="line">5.3 ApplicationMaster管理 109</span><br><span class="line"></span><br><span class="line">5.4 NodeManager管理 112</span><br><span class="line"></span><br><span class="line">5.5 Application管理 113</span><br><span class="line"></span><br><span class="line">5.6 状态机管理 114</span><br><span class="line"></span><br><span class="line">5.6.1 RMApp状态机 115</span><br><span class="line"></span><br><span class="line">5.6.2 RMAppAttempt状态机 119</span><br><span class="line"></span><br><span class="line">5.6.3 RMContainer状态机 123</span><br><span class="line"></span><br><span class="line">5.6.4 RMNode状态机 127</span><br><span class="line"></span><br><span class="line">5.7 几个常见行为分析 129</span><br><span class="line"></span><br><span class="line">5.7.1 启动ApplicationMaster 129</span><br><span class="line"></span><br><span class="line">5.7.2 申请与分配Container 132</span><br><span class="line"></span><br><span class="line">5.7.3 杀死Application 134</span><br><span class="line"></span><br><span class="line">5.7.4 Container超时 135</span><br><span class="line"></span><br><span class="line">5.7.5 ApplicationMaster超时 138</span><br><span class="line"></span><br><span class="line">5.7.6 NodeManager超时 138</span><br><span class="line"></span><br><span class="line">5.8 安全管理 139</span><br><span class="line"></span><br><span class="line">5.8.1 术语介绍 139</span><br><span class="line"></span><br><span class="line">5.8.2 Hadoop认证机制 139</span><br><span class="line"></span><br><span class="line">5.8.3 Hadoop授权机制 142</span><br><span class="line"></span><br><span class="line">5.9 容错机制 144</span><br><span class="line"></span><br><span class="line">5.9.1 Hadoop HA基本框架 145</span><br><span class="line"></span><br><span class="line">5.9.2 YARN HA实现 148</span><br><span class="line"></span><br><span class="line">5.10 源代码阅读引导 149</span><br><span class="line"></span><br><span class="line">5.11 小结 151</span><br><span class="line"></span><br><span class="line">5.12 问题讨论 152</span><br><span class="line"></span><br><span class="line">第6章 资源调度器 153</span><br><span class="line"></span><br><span class="line">6.1 资源调度器背景 153</span><br><span class="line"></span><br><span class="line">6.2 HOD调度器 154</span><br><span class="line"></span><br><span class="line">6.2.1 Torque资源管理器 154</span><br><span class="line"></span><br><span class="line">6.2.2 HOD作业调度 155</span><br><span class="line"></span><br><span class="line">6.3 YARN资源调度器的基本架构 157</span><br><span class="line"></span><br><span class="line">6.3.1 基本架构 157</span><br><span class="line"></span><br><span class="line">6.3.2 资源表示模型 160</span><br><span class="line"></span><br><span class="line">6.3.3 资源调度模型 161</span><br><span class="line"></span><br><span class="line">6.3.4 资源抢占模型 164</span><br><span class="line"></span><br><span class="line">6.4 YARN层级队列管理机制 169</span><br><span class="line"></span><br><span class="line">6.4.1 层级队列管理机制 169</span><br><span class="line"></span><br><span class="line">6.4.2 队列命名规则 171</span><br><span class="line"></span><br><span class="line">6.5 Capacity Scheduler 172</span><br><span class="line"></span><br><span class="line">6.5.1 Capacity Scheduler的功能 172</span><br><span class="line"></span><br><span class="line">6.5.2 Capacity Scheduler实现 176</span><br><span class="line"></span><br><span class="line">6.6 Fair Scheduler 179</span><br><span class="line"></span><br><span class="line">6.6.1 Fair Scheduler功能介绍 180</span><br><span class="line"></span><br><span class="line">6.6.2 Fair Scheduler实现 182</span><br><span class="line"></span><br><span class="line">6.6.3 Fair Scheduler与Capacity Scheduler对比 183</span><br><span class="line"></span><br><span class="line">6.7 其他资源调度器介绍 184</span><br><span class="line"></span><br><span class="line">6.8 源代码阅读引导 185</span><br><span class="line"></span><br><span class="line">6.9 小结 186</span><br><span class="line"></span><br><span class="line">6.10 问题讨论 187</span><br><span class="line"></span><br><span class="line">第7章 NodeManager剖析 188</span><br><span class="line"></span><br><span class="line">7.1 概述 188</span><br><span class="line"></span><br><span class="line">7.1.1 NodeManager基本职能 188</span><br><span class="line"></span><br><span class="line">7.1.2 NodeManager内部架构 190</span><br><span class="line"></span><br><span class="line">7.1.3 NodeManager事件与事件处理器 193</span><br><span class="line"></span><br><span class="line">7.2 节点健康状况检测 194</span><br><span class="line"></span><br><span class="line">7.2.1 自定义Shell脚本 194</span><br><span class="line"></span><br><span class="line">7.2.2 检测磁盘损坏数目 196</span><br><span class="line"></span><br><span class="line">7.3 分布式缓存机制 196</span><br><span class="line"></span><br><span class="line">7.3.1 资源可见性与分类 198</span><br><span class="line"></span><br><span class="line">7.3.2 分布式缓存实现 200</span><br><span class="line"></span><br><span class="line">7.4 目录结构管理 203</span><br><span class="line"></span><br><span class="line">7.4.1 数据目录管理 203</span><br><span class="line"></span><br><span class="line">7.4.2 日志目录管理 203</span><br><span class="line"></span><br><span class="line">7.5 状态机管理 206</span><br><span class="line"></span><br><span class="line">7.5.1 Application状态机 207</span><br><span class="line"></span><br><span class="line">7.5.2 Container状态机 210</span><br><span class="line"></span><br><span class="line">7.5.3 LocalizedResource状态机 213</span><br><span class="line"></span><br><span class="line">7.6 Container生命周期剖析 214</span><br><span class="line"></span><br><span class="line">7.6.1 Container资源本地化 214</span><br><span class="line"></span><br><span class="line">7.6.2 Container运行 218</span><br><span class="line"></span><br><span class="line">7.6.3 Container资源清理 222</span><br><span class="line"></span><br><span class="line">7.7 资源隔离 224</span><br><span class="line"></span><br><span class="line">7.7.1 Cgroups介绍 224</span><br><span class="line"></span><br><span class="line">7.7.2 内存资源隔离 228</span><br><span class="line"></span><br><span class="line">7.7.3 CPU资源隔离 230</span><br><span class="line"></span><br><span class="line">7.8 源代码阅读引导 234</span><br><span class="line"></span><br><span class="line">7.9 小结 235</span><br><span class="line"></span><br><span class="line">7.10 问题讨论 236</span><br><span class="line"></span><br><span class="line">第三部分 计算框架篇</span><br><span class="line"></span><br><span class="line">第8章 离线计算框架MapReduce 238</span><br><span class="line"></span><br><span class="line">8.1 概述 238</span><br><span class="line"></span><br><span class="line">8.1.1 基本构成 238</span><br><span class="line"></span><br><span class="line">8.1.2 事件与事件处理器 240</span><br><span class="line"></span><br><span class="line">8.2 MapReduce客户端 241</span><br><span class="line"></span><br><span class="line">8.2.1 ApplicationClientProtocol协议 242</span><br><span class="line"></span><br><span class="line">8.2.2 MRClientProtocol协议 243</span><br><span class="line"></span><br><span class="line">8.3 MRAppMaster工作流程 243</span><br><span class="line"></span><br><span class="line">8.4 MR作业生命周期及相关状态机 246</span><br><span class="line"></span><br><span class="line">8.4.1 MR作业生命周期 246</span><br><span class="line"></span><br><span class="line">8.4.2 Job状态机 249</span><br><span class="line"></span><br><span class="line">8.4.3 Task状态机 253</span><br><span class="line"></span><br><span class="line">8.4.4 TaskAttempt状态机 255</span><br><span class="line"></span><br><span class="line">8.5 资源申请与再分配 259</span><br><span class="line"></span><br><span class="line">8.5.1 资源申请 259</span><br><span class="line"></span><br><span class="line">8.5.2 资源再分配 262</span><br><span class="line"></span><br><span class="line">8.6 Container启动与释放 263</span><br><span class="line"></span><br><span class="line">8.7 推测执行机制 264</span><br><span class="line"></span><br><span class="line">8.7.1 算法介绍 265</span><br><span class="line"></span><br><span class="line">8.7.2 推测执行相关类 266</span><br><span class="line"></span><br><span class="line">8.8 作业恢复 267</span><br><span class="line"></span><br><span class="line">8.9 数据处理引擎 269</span><br><span class="line"></span><br><span class="line">8.10 历史作业管理器 271</span><br><span class="line"></span><br><span class="line">8.11 MRv1与MRv2对比 273</span><br><span class="line"></span><br><span class="line">8.11.1 MRv1 On YARN 273</span><br><span class="line"></span><br><span class="line">8.11.2 MRv1与MRv2架构比较 274</span><br><span class="line"></span><br><span class="line">8.11.3 MRv1与MRv2编程接口兼容性 274</span><br><span class="line"></span><br><span class="line">8.12 源代码阅读引导 275</span><br><span class="line"></span><br><span class="line">8.13 小结 277</span><br><span class="line"></span><br><span class="line">8.14 问题讨论 277</span><br><span class="line"></span><br><span class="line">第9章 DAG计算框架Tez 278</span><br><span class="line"></span><br><span class="line">9.1 背景 278</span><br><span class="line"></span><br><span class="line">9.2 Tez数据处理引擎 281</span><br><span class="line"></span><br><span class="line">9.2.1 Tez编程模型 281</span><br><span class="line"></span><br><span class="line">9.2.2 Tez数据处理引擎 282</span><br><span class="line"></span><br><span class="line">9.3 DAG Master实现 284</span><br><span class="line"></span><br><span class="line">9.3.1 DAG编程模型 284</span><br><span class="line"></span><br><span class="line">9.3.2 MR到DAG转换 286</span><br><span class="line"></span><br><span class="line">9.3.3 DAGAppMaster 288</span><br><span class="line"></span><br><span class="line">9.4 优化机制 291</span><br><span class="line"></span><br><span class="line">9.4.1 当前YARN框架存在的问题 291</span><br><span class="line"></span><br><span class="line">9.4.2 Tez引入的优化技术 292</span><br><span class="line"></span><br><span class="line">9.5 Tez应用场景 292</span><br><span class="line"></span><br><span class="line">9.6 与其他系统比较 294</span><br><span class="line"></span><br><span class="line">9.7 小结 295</span><br><span class="line"></span><br><span class="line">第10章 实时&#x2F;内存计算框架Storm&#x2F;Spark 296</span><br><span class="line"></span><br><span class="line">10.1 Hadoop M...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Hadoop技术内幕深入理解MapReduce架构设计与实现原理 PDF</title>
    <url>/posts/557a8338/</url>
    <content><![CDATA[<h4 id="《Hadoop技术内幕深入理解MapReduce架构设计与实现原理》"><a href="#《Hadoop技术内幕深入理解MapReduce架构设计与实现原理》" class="headerlink" title="《Hadoop技术内幕深入理解MapReduce架构设计与实现原理》"></a>《Hadoop技术内幕深入理解MapReduce架构设计与实现原理》</h4><h6 id="链接-https-pan-baidu-com-s-16DxrvNwDO6FIQnU1GApa4w-提取码-wfks"><a href="#链接-https-pan-baidu-com-s-16DxrvNwDO6FIQnU1GApa4w-提取码-wfks" class="headerlink" title="链接: https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w 提取码: wfks"></a>链接: <a href="https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w">https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w</a> 提取码: wfks</h6><p>由Hadoop领域资深的实践者亲自执笔，首先介绍了MapReduce的设计理念和编程模型，然后从源代码的角度深入分析了RPC框架、客户端、JobTracker、TaskTracker和Task等MapReduce运行时环境的架构设计与实现原理，最后从实际应用的角度深入讲解了Hadoop的性能优化、安全机制、多用户作业调度器和下一代MapReduce框架等高级主题和内容。本书适合Hadoop的二次开发人员、应用开发工程师、运维工程师阅读。<br><a id="more"></a></p>
<p><img src="/images/bd789db9f22cd19fd8b3f4e0cf92aa051.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前 言</span><br><span class="line"></span><br><span class="line">第一部分 基础篇</span><br><span class="line"></span><br><span class="line">第1章 阅读源代码前的准备&#x2F; 2</span><br><span class="line"></span><br><span class="line">1.1 准备源代码学习环境&#x2F; 2</span><br><span class="line"></span><br><span class="line">1.1.1 基础软件下载&#x2F; 2</span><br><span class="line"></span><br><span class="line">1.1.2 如何准备Windows环境&#x2F; 3</span><br><span class="line"></span><br><span class="line">1.1.3 如何准备Linux环境&#x2F; 6</span><br><span class="line"></span><br><span class="line">1.2 获取Hadoop源代码&#x2F; 7</span><br><span class="line"></span><br><span class="line">1.3 搭建Hadoop源代码阅读环境&#x2F; 8</span><br><span class="line"></span><br><span class="line">1.3.1 创建Hadoop工程&#x2F; 8</span><br><span class="line"></span><br><span class="line">1.3.2 Hadoop源代码阅读技巧&#x2F; 9</span><br><span class="line"></span><br><span class="line">1.4 Hadoop源代码组织结构&#x2F; 10</span><br><span class="line"></span><br><span class="line">1.5 Hadoop初体验&#x2F; 13</span><br><span class="line"></span><br><span class="line">1.5.1 启动Hadoop&#x2F; 13</span><br><span class="line"></span><br><span class="line">1.5.2 Hadoop Shell介绍&#x2F; 15</span><br><span class="line"></span><br><span class="line">1.5.3 Hadoop Eclipse插件介绍&#x2F; 15</span><br><span class="line"></span><br><span class="line">1.6 编译及调试Hadoop源代码&#x2F; 19</span><br><span class="line"></span><br><span class="line">1.6.1 编译Hadoop源代码&#x2F; 19</span><br><span class="line"></span><br><span class="line">1.6.2 调试Hadoop源代码&#x2F; 20</span><br><span class="line"></span><br><span class="line">1.7 小结&#x2F; 23</span><br><span class="line"></span><br><span class="line">第2章 MapReduce设计理念与基本架构&#x2F; 24</span><br><span class="line"></span><br><span class="line">2.1 Hadoop发展史&#x2F; 24</span><br><span class="line"></span><br><span class="line">2.1.1 Hadoop产生背景&#x2F; 24</span><br><span class="line"></span><br><span class="line">2.1.2 Apache Hadoop新版本的特性&#x2F; 25</span><br><span class="line"></span><br><span class="line">2.1.3 Hadoop版本变迁&#x2F; 26</span><br><span class="line"></span><br><span class="line">2.2 Hadoop MapReduce设计目标&#x2F; 28</span><br><span class="line"></span><br><span class="line">2.3 MapReduce编程模型概述&#x2F; 29</span><br><span class="line"></span><br><span class="line">2.3.1 MapReduce编程模型简介&#x2F; 29</span><br><span class="line"></span><br><span class="line">2.3.2 MapReduce编程实例&#x2F; 31</span><br><span class="line"></span><br><span class="line">2.4 Hadoop基本架构&#x2F; 32</span><br><span class="line"></span><br><span class="line">2.4.1 HDFS架构&#x2F; 33</span><br><span class="line"></span><br><span class="line">2.4.2 Hadoop MapReduce架构&#x2F; 34</span><br><span class="line"></span><br><span class="line">2.5 Hadoop MapReduce作业的生命周期&#x2F; 36</span><br><span class="line"></span><br><span class="line">2.6 小结&#x2F; 38</span><br><span class="line"></span><br><span class="line">第二部分 MapReduce编程模型篇</span><br><span class="line"></span><br><span class="line">第3章 MapReduce编程模型&#x2F; 40</span><br><span class="line"></span><br><span class="line">3.1 MapReduce编程模型概述&#x2F; 40</span><br><span class="line"></span><br><span class="line">3.1.1 MapReduce编程接口体系结构&#x2F; 40</span><br><span class="line"></span><br><span class="line">3.1.2 新旧MapReduce API比较&#x2F; 41</span><br><span class="line"></span><br><span class="line">3.2 MapReduce API基本概念&#x2F; 42</span><br><span class="line"></span><br><span class="line">3.2.1 序列化&#x2F; 42</span><br><span class="line"></span><br><span class="line">3.2.2 Reporter参数&#x2F; 43</span><br><span class="line"></span><br><span class="line">3.2.3 回调机制&#x2F; 43</span><br><span class="line"></span><br><span class="line">3.3 Java API解析&#x2F; 44</span><br><span class="line"></span><br><span class="line">3.3.1 作业配置与提交&#x2F; 44</span><br><span class="line"></span><br><span class="line">3.3.2 InputFormat接口的设计与实现&#x2F; 48</span><br><span class="line"></span><br><span class="line">3.3.3 OutputFormat接口的设计与实现&#x2F; 53</span><br><span class="line"></span><br><span class="line">3.3.4 Mapper与Reducer解析&#x2F; 55</span><br><span class="line"></span><br><span class="line">3.3.5 Partitioner接口的设计与实现&#x2F; 59</span><br><span class="line"></span><br><span class="line">3.4 非Java API解析&#x2F; 61</span><br><span class="line"></span><br><span class="line">3.4.1 Hadoop Streaming的实现原理&#x2F; 61</span><br><span class="line"></span><br><span class="line">3.4.2 Hadoop Pipes的实现原理&#x2F; 64</span><br><span class="line"></span><br><span class="line">3.5 Hadoop工作流&#x2F; 67</span><br><span class="line"></span><br><span class="line">3.5.1 JobControl的实现原理&#x2F; 67</span><br><span class="line"></span><br><span class="line">3.5.2 ChainMapper&#x2F;ChainReducer的实现原理&#x2F; 69</span><br><span class="line"></span><br><span class="line">3.5.3 Hadoop工作流引擎&#x2F; 71</span><br><span class="line"></span><br><span class="line">3.6 小结&#x2F; 73</span><br><span class="line"></span><br><span class="line">第三部分 MapReduce核心设计篇</span><br><span class="line"></span><br><span class="line">第4章 Hadoop RPC框架解析&#x2F; 76</span><br><span class="line"></span><br><span class="line">4.1 Hadoop RPC框架概述&#x2F; 76</span><br><span class="line"></span><br><span class="line">4.2 Java基础知识&#x2F; 77</span><br><span class="line"></span><br><span class="line">4.2.1 Java反射机制与动态代理&#x2F; 78</span><br><span class="line"></span><br><span class="line">4.2.2 Java网络编程&#x2F; 80</span><br><span class="line"></span><br><span class="line">4.2.3 Java NIO&#x2F; 82</span><br><span class="line"></span><br><span class="line">4.3 Hadoop RPC基本框架分析&#x2F; 89</span><br><span class="line"></span><br><span class="line">4.3.1 RPC基本概念&#x2F; 89</span><br><span class="line"></span><br><span class="line">4.3.2 Hadoop RPC基本框架&#x2F; 91</span><br><span class="line"></span><br><span class="line">4.3.3 集成其他开源RPC框架&#x2F; 98</span><br><span class="line"></span><br><span class="line">4.4 MapReduce通信协议分析&#x2F; 100</span><br><span class="line"></span><br><span class="line">4.4.1 MapReduce 通信协议概述&#x2F; 100</span><br><span class="line"></span><br><span class="line">4.4.2 JobSubmissionProtocol通信协议&#x2F; 102</span><br><span class="line"></span><br><span class="line">4.4.3 InterTrackerProtocol通信协议&#x2F; 102</span><br><span class="line"></span><br><span class="line">4.4.4 TaskUmbilicalProtocol通信协议&#x2F; 103</span><br><span class="line"></span><br><span class="line">4.4.5 其他通信协议&#x2F; 104</span><br><span class="line"></span><br><span class="line">4.5 小结&#x2F; 106</span><br><span class="line"></span><br><span class="line">第5章 作业提交与初始化过程分析&#x2F; 107</span><br><span class="line"></span><br><span class="line">5.1 作业提交与初始化概述&#x2F; 107</span><br><span class="line"></span><br><span class="line">5.2 作业提交过程详解&#x2F; 108</span><br><span class="line"></span><br><span class="line">5.2.1 执行Shell命令&#x2F; 108</span><br><span class="line"></span><br><span class="line">5.2.2 作业文件上传&#x2F; 109</span><br><span class="line"></span><br><span class="line">5.2.3 产生InputSplit文件&#x2F; 111</span><br><span class="line"></span><br><span class="line">5.2.4 作业提交到JobTracker&#x2F; 113</span><br><span class="line"></span><br><span class="line">5.3 作业初始化过程详解&#x2F; 115</span><br><span class="line"></span><br><span class="line">5.4 Hadoop DistributedCache原理分析&#x2F; 117</span><br><span class="line"></span><br><span class="line">5.4.1 使用方法介绍&#x2F; 118</span><br><span class="line"></span><br><span class="line">5.4.2 工作原理分析&#x2F; 120</span><br><span class="line"></span><br><span class="line">5.5 小结&#x2F; 122</span><br><span class="line"></span><br><span class="line">第6章 JobTracker内部实现剖析&#x2F; 123</span><br><span class="line"></span><br><span class="line">6.1 JobTracker概述&#x2F; 123</span><br><span class="line"></span><br><span class="line">6.2 JobTracker启动过程分析&#x2F; 125</span><br><span class="line"></span><br><span class="line">6.2.1 JobTracker启动过程概述&#x2F; 125</span><br><span class="line"></span><br><span class="line">6.2.2 重要对象初始化&#x2F; 125</span><br><span class="line"></span><br><span class="line">6.2.3 各种线程功能&#x2F; 128</span><br><span class="line"></span><br><span class="line">6.2.4 作业恢复&#x2F; 129</span><br><span class="line"></span><br><span class="line">6.3 心跳接收与应答&#x2F; 129</span><br><span class="line"></span><br><span class="line">6.3.1 更新状态&#x2F; 131</span><br><span class="line"></span><br><span class="line">6.3.2 下达命令&#x2F; 131</span><br><span class="line"></span><br><span class="line">6.4 Job和Task运行时信息维护&#x2F; 134</span><br><span class="line"></span><br><span class="line">6.4.1 作业描述模型&#x2F; 134</span><br><span class="line"></span><br><span class="line">6.4.2 JobInProgress&#x2F; 136</span><br><span class="line"></span><br><span class="line">6.4.3 TaskInProgress&#x2F; 137</span><br><span class="line"></span><br><span class="line">6.4.4 作业和任务状态转换图&#x2F; 139</span><br><span class="line"></span><br><span class="line">6.5 容错机制&#x2F; 141</span><br><span class="line"></span><br><span class="line">6.5.1 JobTracker容错&#x2F; 141</span><br><span class="line"></span><br><span class="line">6.5.2 TaskTracker容错&#x2F; 142</span><br><span class="line"></span><br><span class="line">6.5.3 Job&#x2F;Task容错&#x2F; 145</span><br><span class="line"></span><br><span class="line">6.5.4 Record容错&#x2F; 147</span><br><span class="line"></span><br><span class="line">6.5.5 磁盘容错&#x2F; 151</span><br><span class="line"></span><br><span class="line">6.6 任务推测执行原理&#x2F; 152</span><br><span class="line"></span><br><span class="line">6.6.1 计算模型假设&#x2F; 153</span><br><span class="line"></span><br><span class="line">6.6.2 1.0.0版本的算法&#x2F; 153</span><br><span class="line"></span><br><span class="line">6.6.3 0.21.0版本的算法&#x2F; 154</span><br><span class="line"></span><br><span class="line">6.6.4 2.0版本的算法&#x2F; 156</span><br><span class="line"></span><br><span class="line">6.7 Hadoop资源管理&#x2F; 157</span><br><span class="line"></span><br><span class="line">6.7.1 任务调度框架分析&#x2F; 159</span><br><span class="line"></span><br><span class="line">6.7.2 任务选择策略分析&#x2F; 162</span><br><span class="line"></span><br><span class="line">6.7.3 FIFO调度器分析&#x2F; 164</span><br><span class="line"></span><br><span class="line">6.7.4 Hadoop资源管理优化&#x2F; 165</span><br><span class="line"></span><br><span class="line">6.8 小结&#x2F; 168</span><br><span class="line"></span><br><span class="line">第7章 TaskTracker内部实现剖析&#x2F; 169</span><br><span class="line"></span><br><span class="line">7.1 TaskTracker概述&#x2F; 169</span><br><span class="line"></span><br><span class="line">7.2 TaskTracker启动过程分析&#x2F; 170</span><br><span class="line"></span><br><span class="line">7.2.1 重要变量初始化&#x2F; 171</span><br><span class="line"></span><br><span class="line">7.2.2 重要对象初始化&#x2F; 171</span><br><span class="line"></span><br><span class="line">7.2.3 连接JobTracker&#x2F; 172</span><br><span class="line"></span><br><span class="line">7.3 心跳机制&#x2F; 172</span><br><span class="line"></span><br><span class="line">7.3.1 单次心跳发送&#x2F; 172</span><br><span class="line"></span><br><span class="line">7.3.2 状态发送&#x2F; 175</span><br><span class="line"></span><br><span class="line">7.3.3 命令执行&#x2F; 178</span><br><span class="line"></span><br><span class="line">7.4 TaskTracker行为分析&#x2F; 179</span><br><span class="line"></span><br><span class="line">7.4.1 启动新任务&#x2F; 179</span><br><span class="line"></span><br><span class="line">7.4.2 提交任务&#x2F; 179</span><br><span class="line"></span><br><span class="line">7.4.3 杀死任务&#x2F; 181</span><br><span class="line"></span><br><span class="line">7.4.4 杀死作业&#x2F; 182</span><br><span class="line"></span><br><span class="line">7.4.5 重新初始化&#x2F; 184</span><br><span class="line"></span><br><span class="line">7.5 作业目录管理&#x2F; 184</span><br><span class="line"></span><br><span class="line">7.6 启动新任务&#x2F; 186</span><br><span class="line"></span><br><span class="line">7.6.1 任务启动过程分析&#x2F; 186</span><br><span class="line"></span><br><span class="line">7.6.2 资源隔离机制&#x2F; 193</span><br><span class="line"></span><br><span class="line">7.7 小结&#x2F; 195</span><br><span class="line"></span><br><span class="line">第8章 Task运行过程分析&#x2F; 196</span><br><span class="line"></span><br><span class="line">8.1 Task运行过程概述&#x2F; 196</span><br><span class="line"></span><br><span class="line">8.2 基本数据结构和算法&#x2F; 197</span><br><span class="line"></span><br><span class="line">8.2.1 IFile存储格式&#x2F; 197</span><br><span class="line"></span><br><span class="line">8.2.2 排序&#x2F; 198</span><br><span class="line"></span><br><span class="line">8.2.3 Reporter&#x2F; 201</span><br><span class="line"></span><br><span class="line">8.3 Map Task内部实现&#x2F; 204</span><br><span class="line"></span><br><span class="line">8.3.1 Map Task整体流程&#x2F; 204</span><br><span class="line"></span><br><span class="line">8.3.2 Collect过程分析&#x2F; 205</span><br><span class="line"></span><br><span class="line">8.3.3 Spill过程分析&#x2F; 213</span><br><span class="line"></span><br><span class="line">8.3.4 Combine过程分析&#x2F; 214</span><br><span class="line"></span><br><span class="line">8.4 Reduce Task内部实现&#x2F; 214</span><br><span class="line"></span><br><span class="line">8.4.1 Reduce Task整体流程&#x2F; 215</span><br><span class="line"></span><br><span class="line">8.4.2 Shuffle和Merge阶段分析&#x2F; 215</span><br><span class="line"></span><br><span class="line">8.4.3 Sort和Reduce阶段分析&#x2F; 218</span><br><span class="line"></span><br><span class="line">8.5 Map&#x2F;Reduce Task优化&#x2F; 219</span><br><span class="line"></span><br><span class="line">8.5.1 参数调优&#x2F; 219</span><br><span class="line"></span><br><span class="line">8.5.2 系统优化&#x2F; 220</span><br><span class="line"></span><br><span class="line">8.6 小结&#x2F; 224</span><br><span class="line"></span><br><span class="line">第四部分 MapReduce高级篇</span><br><span class="line"></span><br><span class="line">第9章 Hadoop性能调优&#x2F; 228</span><br><span class="line"></span><br><span class="line">9.1 概述&#x2F; 228</span><br><span class="line"></span><br><span class="line">9.2 从管理员角度进行调优&#x2F; 229</span><br><span class="line"></span><br><span class="line">9.2.1 硬件选择&#x2F; 229</span><br><span class="line"></span><br><span class="line">9.2.2 操...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C语言函数大全 PDF</title>
    <url>/posts/227db3ae/</url>
    <content><![CDATA[<h4 id="《C语言函数大全》"><a href="#《C语言函数大全》" class="headerlink" title="《C语言函数大全》"></a>《C语言函数大全》</h4><h6 id="链接-https-pan-baidu-com-s-1aRyWBmJxbPpycsGn9DNavw-提取码-yd4r"><a href="#链接-https-pan-baidu-com-s-1aRyWBmJxbPpycsGn9DNavw-提取码-yd4r" class="headerlink" title="链接: https://pan.baidu.com/s/1aRyWBmJxbPpycsGn9DNavw 提取码: yd4r"></a>链接: <a href="https://pan.baidu.com/s/1aRyWBmJxbPpycsGn9DNavw">https://pan.baidu.com/s/1aRyWBmJxbPpycsGn9DNavw</a> 提取码: yd4r</h6><p><img src="/images/573a344646435cda4c4847667a6ba5a81.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 Unix C函数</span><br><span class="line"></span><br><span class="line">1 错误报告</span><br><span class="line"></span><br><span class="line">2 内存分配</span><br><span class="line"></span><br><span class="line">3 字符处理</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第2章 Turbo C函数</span><br><span class="line"></span><br><span class="line">1 ALLOC.H</span><br><span class="line"></span><br><span class="line">2 ASSERT.H</span><br><span class="line"></span><br><span class="line">3 BIOS.H</span><br><span class="line"></span><br><span class="line">4 CONIO.H</span><br><span class="line"></span><br><span class="line">5 CTYPE.H</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第3章 Microsoft C函数</span><br><span class="line"></span><br><span class="line">1 以字为单位的内存处理函数</span><br><span class="line"></span><br><span class="line">2 单个字符处理函数</span><br><span class="line"></span><br><span class="line">3 数字与字符串转换函数</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C语言解析教程 PDF</title>
    <url>/posts/b2c2ae3f/</url>
    <content><![CDATA[<h4 id="《C语言解析教程》"><a href="#《C语言解析教程》" class="headerlink" title="《C语言解析教程》"></a>《C语言解析教程》</h4><h6 id="链接-https-pan-baidu-com-s-1-4ATuTRkfCZ7cV-SuTGyyg-提取码-hn2i"><a href="#链接-https-pan-baidu-com-s-1-4ATuTRkfCZ7cV-SuTGyyg-提取码-hn2i" class="headerlink" title="链接: https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg 提取码: hn2i"></a>链接: <a href="https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg">https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg</a> 提取码: hn2i</h6><p><img src="/images/07f2cbedc40c3a0791a386c026f1a51a1.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C语言深度解剖 PDF</title>
    <url>/posts/c5c59ea9/</url>
    <content><![CDATA[<h4 id="《C语言深度解剖》"><a href="#《C语言深度解剖》" class="headerlink" title="《C语言深度解剖》"></a>《C语言深度解剖》</h4><h6 id="链接-https-pan-baidu-com-s-1x4-ZXgZnX3ifkc9cpOVjww-提取码-ggfh"><a href="#链接-https-pan-baidu-com-s-1x4-ZXgZnX3ifkc9cpOVjww-提取码-ggfh" class="headerlink" title="链接: https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww 提取码: ggfh"></a>链接: <a href="https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww">https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww</a> 提取码: ggfh</h6><p>《C语言深度解剖（第3版）》由作者结合自身多年嵌入式C语言开发经验和平时讲解C语言的心得体会整理而成，其中有很多作者独特的见解或看法。由于并不是从头到尾讲解C语言的基础知识，所以该书并不适用于C语言零基础的读者，其内容要比一般的C语言图书深得多、细致得多，其中有很多问题是各大公司的面试或笔试题。第3版中新增加了部分C语言知识点的内容。<br><a id="more"></a></p>
<p><img src="/images/603cf16b0a6c5e0d70b246b4b3db9c0f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 关键字</span><br><span class="line"></span><br><span class="line">1．1 最宽宏大量的关键字-auto</span><br><span class="line"></span><br><span class="line">1．2 最快的关键字——register</span><br><span class="line"></span><br><span class="line">1．2．1 皇帝身边的小太监——寄存器</span><br><span class="line"></span><br><span class="line">1．2．2 使用register修饰符的注意点</span><br><span class="line"></span><br><span class="line">1．3 最名不符实的关键字- static</span><br><span class="line"></span><br><span class="line">1．3．1 修饰变量</span><br><span class="line"></span><br><span class="line">1．3．2 修饰函数</span><br><span class="line"></span><br><span class="line">1．4 基本数据类型——short、int、long、char、float、double</span><br><span class="line"></span><br><span class="line">1．4．1 数据类型与“模子</span><br><span class="line"></span><br><span class="line">1．4．2 变量的命名规则</span><br><span class="line"></span><br><span class="line">1．5 最冤枉的关键字——sizeof</span><br><span class="line"></span><br><span class="line">1．5．1 常年被人误认为函数</span><br><span class="line"></span><br><span class="line">1．5．2 sizeof（int）*p表示什么意思</span><br><span class="line"></span><br><span class="line">1．6 signed、unsigned关键字</span><br><span class="line"></span><br><span class="line">1．7 if、else组合</span><br><span class="line"></span><br><span class="line">1．7．1 bool变量与”零值“进行比较</span><br><span class="line"></span><br><span class="line">1．7．2 float变量与”零值“进行比较</span><br><span class="line"></span><br><span class="line">1．7．3 指针变量与”零值“进行比较</span><br><span class="line"></span><br><span class="line">1．7．4 else到底与哪个if配对呢</span><br><span class="line"></span><br><span class="line">1．7．5 if语句后面的分号</span><br><span class="line"></span><br><span class="line">1．7．6 使用if语句的其他注意事项</span><br><span class="line"></span><br><span class="line">1．8 switch、case组合</span><br><span class="line"></span><br><span class="line">1．8．1 不要拿青龙偃月刀去削苹果</span><br><span class="line"></span><br><span class="line">1．8．2 case关键字后面的值有什么要求吗</span><br><span class="line"></span><br><span class="line">1．8．3 case语句的排列顺序</span><br><span class="line"></span><br><span class="line">1．8．4 使用case语句的其他注意事项</span><br><span class="line"></span><br><span class="line">1．9 do、while、for关键字</span><br><span class="line"></span><br><span class="line">1．9．1 break与continue的区别</span><br><span class="line"></span><br><span class="line">1．9．2 循环语句的注意点</span><br><span class="line"></span><br><span class="line">1．1 0 goto关键字</span><br><span class="line"></span><br><span class="line">1．11 void关键字</span><br><span class="line"></span><br><span class="line">1．11．1 void a</span><br><span class="line"></span><br><span class="line">1．11．2 void修饰函数返回值和参数</span><br><span class="line"></span><br><span class="line">1．11．3 void指针</span><br><span class="line"></span><br><span class="line">1．11．4 void不能代表一个真实的变量</span><br><span class="line"></span><br><span class="line">1．12 return关键字</span><br><span class="line"></span><br><span class="line">1．13 const关键字也许该被替换为readonly</span><br><span class="line"></span><br><span class="line">1．13．1 const修饰的只读变量</span><br><span class="line"></span><br><span class="line">1．13．2 节省空间 避免不必要的内存分配，同时提高效率</span><br><span class="line"></span><br><span class="line">1．13．3 修饰一般变量</span><br><span class="line"></span><br><span class="line">1．13．4 修饰数组</span><br><span class="line"></span><br><span class="line">1．13．5 修饰指针</span><br><span class="line"></span><br><span class="line">1．13．6 修饰函数的参数</span><br><span class="line"></span><br><span class="line">1．13．7 修饰函数的返回值</span><br><span class="line"></span><br><span class="line">1．14 最易变的关键字——volatile</span><br><span class="line"></span><br><span class="line">1．15 最会带帽子的关键字——extern</span><br><span class="line"></span><br><span class="line">1．16 struct关键字</span><br><span class="line"></span><br><span class="line">1．16．1 空结构体多大</span><br><span class="line"></span><br><span class="line">1．16．2 柔性数组</span><br><span class="line"></span><br><span class="line">1．16．3 struct与class的区别</span><br><span class="line"></span><br><span class="line">1．17 union关键字</span><br><span class="line"></span><br><span class="line">1．17．1 大小端模式对union类型数据的影响</span><br><span class="line"></span><br><span class="line">1．17．2 如何用程序确认当前系统的存储模式</span><br><span class="line"></span><br><span class="line">1．18 enum关键字</span><br><span class="line"></span><br><span class="line">1．18．1 枚举类型的使用方法</span><br><span class="line"></span><br><span class="line">1．18．2 枚举与#define宏的区别</span><br><span class="line"></span><br><span class="line">1．19 伟大的缝纫师——typedef关键字</span><br><span class="line"></span><br><span class="line">1．19．1 关于马甲的笑话</span><br><span class="line"></span><br><span class="line">1．19．2 历史的误会——也许应该是typerename</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第2章 符号</span><br><span class="line"></span><br><span class="line">第3章 预处理</span><br><span class="line"></span><br><span class="line">第4章 指针和数组</span><br><span class="line"></span><br><span class="line">第5章 内存管理</span><br><span class="line"></span><br><span class="line">第6章 函 数</span><br><span class="line"></span><br><span class="line">第7章 文件结构</span><br><span class="line"></span><br><span class="line">第8章 关于面试的秘密</span><br><span class="line"></span><br><span class="line">附录1 C语言基础测试题</span><br><span class="line"></span><br><span class="line">附录2 C语言基础测试题答案</span><br><span class="line"></span><br><span class="line">后记</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>C专家编程 PDF</title>
    <url>/posts/5ccccf13/</url>
    <content><![CDATA[<h4 id="《C专家编程》"><a href="#《C专家编程》" class="headerlink" title="《C专家编程》"></a>《C专家编程》</h4><h6 id="链接-https-pan-baidu-com-s-15Zdcb5fYb6gZ0MzjPspyLw-提取码-c8fu"><a href="#链接-https-pan-baidu-com-s-15Zdcb5fYb6gZ0MzjPspyLw-提取码-c8fu" class="headerlink" title="链接: https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw 提取码: c8fu"></a>链接: <a href="https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw">https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw</a> 提取码: c8fu</h6><p>《C专家编程》展示了优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。<br><a id="more"></a></p>
<p>《C专家编程》对C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。本书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。</p>
<p>《C专家编程》可以帮助有一定经验的C程序员成为C编程方面的专家；对于C语言功底深厚的程序员，本书可以帮助他们站在C的高度了解和学习C++。</p>
<p><img src="/images/4de7b8e9a4a4d602c65dceab1919548f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第 1章 C：穿越时空的迷雾 1</span><br><span class="line"></span><br><span class="line">1．1　C语言的史前阶段　1</span><br><span class="line"></span><br><span class="line">1．2　C语言的早期体验　4</span><br><span class="line"></span><br><span class="line">1．3　标准I&#x2F;O库和C预处理器　5</span><br><span class="line"></span><br><span class="line">1．4　K&amp;R C　8</span><br><span class="line"></span><br><span class="line">1．5　今日之ANSI C　10</span><br><span class="line"></span><br><span class="line">1．6　它很棒，但它符合标准吗　12</span><br><span class="line"></span><br><span class="line">1．7　编译限制　14</span><br><span class="line"></span><br><span class="line">1．8　ANSI C标准的结构　15</span><br><span class="line"></span><br><span class="line">1．9　阅读ANSI C标准，寻找乐趣和裨益　18</span><br><span class="line"></span><br><span class="line">1．10　“安静的改变”究竟有多少安静　22</span><br><span class="line"></span><br><span class="line">1．11　轻松一下——由编译器定义的Pragmas效果　25</span><br><span class="line"></span><br><span class="line">第　2章 这不是Bug，而是语言特性　27</span><br><span class="line"></span><br><span class="line">2．1　这关语言特性何事，在Fortran里这就是Bug呀　27</span><br><span class="line"></span><br><span class="line">2．2　多做之过　29</span><br><span class="line"></span><br><span class="line">2．3　误做之过　36</span><br><span class="line"></span><br><span class="line">2．4　少做之过　43</span><br><span class="line"></span><br><span class="line">2．5　轻松一下——有些特性确实就是Bug　51</span><br><span class="line"></span><br><span class="line">第3章　分析C语言的声明　53</span><br><span class="line"></span><br><span class="line">3．1　只有编译器才会喜欢的语法　54</span><br><span class="line"></span><br><span class="line">3．2　声明是如何形成的　56</span><br><span class="line"></span><br><span class="line">3．3　优先级规则　61</span><br><span class="line"></span><br><span class="line">3．4　通过图表分析C语言的声明　63</span><br><span class="line"></span><br><span class="line">3．5　typedef可以成为你的朋友　65</span><br><span class="line"></span><br><span class="line">3．6　typedef int x[10]和#define x int[10]的区别　66</span><br><span class="line"></span><br><span class="line">3．7　typedef struct foo&#123; ．．． foo; &#125;的含义　67</span><br><span class="line"></span><br><span class="line">3．8　理解所有分析过程的代码段　69</span><br><span class="line"></span><br><span class="line">3．9　轻松一下——驱动物理实体的软件　71</span><br><span class="line"></span><br><span class="line">第4章　令人震惊的事实：数组和指针并不相同　79</span><br><span class="line"></span><br><span class="line">4．1　数组并非指针　79</span><br><span class="line"></span><br><span class="line">4．2　我的代码为什么无法运行　79</span><br><span class="line"></span><br><span class="line">4．3　什么是声明，什么是定义　80</span><br><span class="line"></span><br><span class="line">4．4　使声明与定义相匹配　84</span><br><span class="line"></span><br><span class="line">4．5　数组和指针的其他区别　84</span><br><span class="line"></span><br><span class="line">4．6　轻松一下——回文的乐趣　85</span><br><span class="line"></span><br><span class="line">第5章　对链接的思考　89</span><br><span class="line"></span><br><span class="line">5．1　函数库、链接和载入　89</span><br><span class="line"></span><br><span class="line">5．2　动态链接的优点　92</span><br><span class="line"></span><br><span class="line">5．3　函数库链接的5个特殊秘密　95</span><br><span class="line"></span><br><span class="line">5．4　警惕Interpositioning　99</span><br><span class="line"></span><br><span class="line">5．5　产生链接器报告文件　104</span><br><span class="line"></span><br><span class="line">5．6　轻松一下——看看谁在说话：挑战Turing测验　105</span><br><span class="line"></span><br><span class="line">第6章　运动的诗章：运行时数据结构　111</span><br><span class="line"></span><br><span class="line">6．1　a．out及其传说　112</span><br><span class="line"></span><br><span class="line">6．2　段　113</span><br><span class="line"></span><br><span class="line">6．3　操作系统在a．out文件里干了些什么　115</span><br><span class="line"></span><br><span class="line">6．4　C语言运行时系统在a．out里干了些什么　117</span><br><span class="line"></span><br><span class="line">6．5　当函数被调用时发生了什么：过程活动记录　119</span><br><span class="line"></span><br><span class="line">6．6　auto和static关键字　123</span><br><span class="line"></span><br><span class="line">6．7　控制线程　124</span><br><span class="line"></span><br><span class="line">6．8　setjmp和longjmp　124</span><br><span class="line"></span><br><span class="line">6．9　UNIX中的堆栈段　126</span><br><span class="line"></span><br><span class="line">6．10　MS-DOS中的堆栈段　126</span><br><span class="line"></span><br><span class="line">6．11　有用的C语言工具　127</span><br><span class="line"></span><br><span class="line">6．12　轻松一下——卡耐基·梅隆大学的编程难题　130</span><br><span class="line"></span><br><span class="line">6．13　只适用于高级学员阅读的材料　132</span><br><span class="line"></span><br><span class="line">第7章　对内存的思考　133</span><br><span class="line"></span><br><span class="line">7．1　Intel 80x86系列　133</span><br><span class="line"></span><br><span class="line">7．2　Intel 80x86内存模型以及它的工作原理　137</span><br><span class="line"></span><br><span class="line">7．3　虚拟内存　141</span><br><span class="line"></span><br><span class="line">7．4　cache存储器　144</span><br><span class="line"></span><br><span class="line">7．5　数据段和堆　148</span><br><span class="line"></span><br><span class="line">7．6　内存泄漏　149</span><br><span class="line"></span><br><span class="line">7．7　总线错误　153</span><br><span class="line"></span><br><span class="line">7．8　轻松一下——“Thing King”和“页面游戏”　159</span><br><span class="line"></span><br><span class="line">第8章　为什么程序员无法分清万圣节和圣诞节　163</span><br><span class="line"></span><br><span class="line">8．1　Portzebie度量衡系统　163</span><br><span class="line"></span><br><span class="line">8．2　根据位模式构筑图形　164</span><br><span class="line"></span><br><span class="line">8．3　在等待时类型发生了变化　166</span><br><span class="line"></span><br><span class="line">8．4　原型之痛　168</span><br><span class="line"></span><br><span class="line">8．5　原型在什么地方会失败　170</span><br><span class="line"></span><br><span class="line">8．6　不需要按回车键就能得到一个字符　173</span><br><span class="line"></span><br><span class="line">8．7　用C语言实现有限状态机　177</span><br><span class="line"></span><br><span class="line">8．8　软件比硬件更困难　178</span><br><span class="line"></span><br><span class="line">8．9　如何进行强制类型转换，为何要进行类型强制转换　181</span><br><span class="line"></span><br><span class="line">8．10　轻松一下——国际C语言混乱代码大赛　183</span><br><span class="line"></span><br><span class="line">第9章　再论数组　193</span><br><span class="line"></span><br><span class="line">9．1　什么时候数组与指针相同　193</span><br><span class="line"></span><br><span class="line">9．2　为什么会发生混淆　194</span><br><span class="line"></span><br><span class="line">9．3　为什么C语言把数组形参当作指针　199</span><br><span class="line"></span><br><span class="line">9．4　数组片段的下标　202</span><br><span class="line"></span><br><span class="line">9．5　数组和指针可交换性的总结　203</span><br><span class="line"></span><br><span class="line">9．6　C语言的多维数组　203</span><br><span class="line"></span><br><span class="line">9．7　轻松一下——软件&#x2F;硬件平衡　209</span><br><span class="line"></span><br><span class="line">第　10章 再论指针　213</span><br><span class="line"></span><br><span class="line">10．1　多维数组的内存布局　213</span><br><span class="line"></span><br><span class="line">10．2　指针数组就是Iliffe向量　214</span><br><span class="line"></span><br><span class="line">10．3　在锯齿状数组上使用指针　217</span><br><span class="line"></span><br><span class="line">10．4　向函数传递一个一维数组　220</span><br><span class="line"></span><br><span class="line">10．5　使用指针向函数传递一个多维数组　221</span><br><span class="line"></span><br><span class="line">10．6　使用指针从函数返回一个数组　224</span><br><span class="line"></span><br><span class="line">10．7　使用指针创建和使用动态数组　226</span><br><span class="line"></span><br><span class="line">10．8　轻松一下——程序检验的限制　231</span><br><span class="line"></span><br><span class="line">第　11章 你懂得C，所以C++不在话下　235</span><br><span class="line"></span><br><span class="line">11．1　初识OOP　235</span><br><span class="line"></span><br><span class="line">11．2　抽象——取事物的本质特性　237</span><br><span class="line"></span><br><span class="line">11．3　封装——把相关的类型、数据和函数组合在一起　238</span><br><span class="line"></span><br><span class="line">11．4　展示一些类——用户定义类型享有和预定义类型一样的权限　239</span><br><span class="line"></span><br><span class="line">11．5　访问控制　240</span><br><span class="line"></span><br><span class="line">11．6　声明　241</span><br><span class="line"></span><br><span class="line">11．7　如何调用成员函数　243</span><br><span class="line"></span><br><span class="line">11．8　继承——复用已经定义的操作　245</span><br><span class="line"></span><br><span class="line">11．9　多重继承——从两个或更多的基类派生　249</span><br><span class="line"></span><br><span class="line">11．10　重载——作用于不同类型的同一操作具有相同的名字　250</span><br><span class="line"></span><br><span class="line">11．11　C++如何进行操作符重载　250</span><br><span class="line"></span><br><span class="line">11．12　C++的输入&#x2F;输出（I&#x2F;O）　251</span><br><span class="line"></span><br><span class="line">11．13　多态——运行时绑定　252</span><br><span class="line"></span><br><span class="line">11．14　解释　253</span><br><span class="line"></span><br><span class="line">11．15　C++如何表现多态　254</span><br><span class="line"></span><br><span class="line">11．16　新奇玩意儿——多态　255</span><br><span class="line"></span><br><span class="line">11．17　C++的其他要点　256</span><br><span class="line"></span><br><span class="line">11．18　如果我的目标是那里，我不会从这里起步　257</span><br><span class="line"></span><br><span class="line">11．19　它或许过于复杂，但却是唯一可行的方案　259</span><br><span class="line"></span><br><span class="line">11．20　轻松一下——死亡计算机协会　263</span><br><span class="line"></span><br><span class="line">11．21　更多阅读材料　264</span><br><span class="line"></span><br><span class="line">附录A　程序员工作面试的秘密　265</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java8实战 PDF</title>
    <url>/posts/2bcbff85/</url>
    <content><![CDATA[<h4 id="《Java8实战》"><a href="#《Java8实战》" class="headerlink" title="《Java8实战》"></a>《Java8实战》</h4><h6 id="链接-https-pan-baidu-com-s-15aXVvIX4lvGldhCU7fggdQ-提取码-hh1e"><a href="#链接-https-pan-baidu-com-s-15aXVvIX4lvGldhCU7fggdQ-提取码-hh1e" class="headerlink" title="链接: https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ 提取码: hh1e"></a>链接: <a href="https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ">https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ</a> 提取码: hh1e</h6><p>现代Java应用充分利用了微服务、反应式架构以及流式数据等创新设计。现代Java特性，譬如Lambda、流以及大家期待已久的Java模块系统让这些设计的实现极其便利。是时候更新技能工具箱了，只有这样，你才能从容应对迎面而来的种种挑战！<br><a id="more"></a></p>
<p>本书通过透彻的示例和通俗的语言讲解了Java语言这些激动人心的特性，作者注重细节，努力降低了学习难度，节省你宝贵的时间。依照本书边学边练，你可以很快掌握流应用程序接口、Java模块系统等现代Java新特性，再进一步去探寻实现并发的新方法，了解函数式编程如何帮你编写可读性好又容易维护的代码。潜心修炼，你的编程实力必能提高到新的层次。</p>
<p><img src="/images/6bf4c66de8d417c48a2c28a04bedf34f1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一部分 基础知识 </span><br><span class="line"></span><br><span class="line">第　1 章 Java 8、9、10以及11的变化　2 </span><br><span class="line"></span><br><span class="line">1．1　为什么要关心Java的变化　2 </span><br><span class="line"></span><br><span class="line">1．2　Java怎么还在变　4 </span><br><span class="line"></span><br><span class="line">1．2．1　Java在编程语言生态系统中的位置　5 </span><br><span class="line"></span><br><span class="line">1．2．2　流处理　6 </span><br><span class="line"></span><br><span class="line">1．2．3　用行为参数化把代码传递给方法　7 </span><br><span class="line"></span><br><span class="line">1．2．4　并行与共享的可变数据　8 </span><br><span class="line"></span><br><span class="line">1．2．5　Java需要演变　9 </span><br><span class="line"></span><br><span class="line">1．3　Java中的函数　9 </span><br><span class="line"></span><br><span class="line">1．3．1　方法和Lambda作为一等值　10 </span><br><span class="line"></span><br><span class="line">1．3．2　传递代码：一个例子　11 </span><br><span class="line"></span><br><span class="line">1．3．3　从传递方法到Lambda　13 </span><br><span class="line"></span><br><span class="line">1．4　流　14 </span><br><span class="line"></span><br><span class="line">1．5　默认方法及Java模块　17 </span><br><span class="line"></span><br><span class="line">1．6　来自函数式编程的其他好思想　19 </span><br><span class="line"></span><br><span class="line">1．7　小结　20 </span><br><span class="line"></span><br><span class="line">第　2 章 通过行为参数化传递代码　22 </span><br><span class="line"></span><br><span class="line">2．1　应对不断变化的需求　23 </span><br><span class="line"></span><br><span class="line">2．1．1　初试牛刀：筛选绿苹果　23 </span><br><span class="line"></span><br><span class="line">2．1．2　再展身手：把颜色作为参数　23 </span><br><span class="line"></span><br><span class="line">2．1．3　第三次尝试：对你能想到的每个属性做筛选　24 </span><br><span class="line"></span><br><span class="line">2．2　行为参数化　25 </span><br><span class="line"></span><br><span class="line">2．3　对付啰唆　30 </span><br><span class="line"></span><br><span class="line">2．3．1　匿名类　30 </span><br><span class="line"></span><br><span class="line">2．3．2　第五次尝试：使用匿名类　31 </span><br><span class="line"></span><br><span class="line">2．3．3　第六次尝试：使用Lambda表达式　32 </span><br><span class="line"></span><br><span class="line">2．3．4　第七次尝试：将List类型抽象化　33 </span><br><span class="line"></span><br><span class="line">2．4　真实的例子　33 </span><br><span class="line"></span><br><span class="line">2．4．1　用Comparator来排序　33 </span><br><span class="line"></span><br><span class="line">2．4．2　用Runnable执行代码块　34 </span><br><span class="line"></span><br><span class="line">2．4．3　通过Callable返回结果　35 </span><br><span class="line"></span><br><span class="line">2．4．4　GUI事件处理　35 </span><br><span class="line"></span><br><span class="line">2．5　小结　36 </span><br><span class="line"></span><br><span class="line">第　3 章 Lambda表达式　37 </span><br><span class="line"></span><br><span class="line">3．1　Lambda管中窥豹　37 </span><br><span class="line"></span><br><span class="line">3．2　在哪里以及如何使用Lambda　40 </span><br><span class="line"></span><br><span class="line">3．2．1　函数式接口　40 </span><br><span class="line"></span><br><span class="line">3．2．2　函数描述符　42 </span><br><span class="line"></span><br><span class="line">3．3　把Lambda付诸实践：环绕执行模式　44 </span><br><span class="line"></span><br><span class="line">3．3．1　第 1 步：记得行为参数化　44 </span><br><span class="line"></span><br><span class="line">3．3．2　第 2 步：使用函数式接口来传递行为　45 </span><br><span class="line"></span><br><span class="line">3．3．3　第 3 步：执行一个行为　45 </span><br><span class="line"></span><br><span class="line">3．3．4　第 4 步：传递Lambda　46 </span><br><span class="line"></span><br><span class="line">3．4　使用函数式接口　47 </span><br><span class="line"></span><br><span class="line">3．4．1　Predicate　47 </span><br><span class="line"></span><br><span class="line">3．4．2　Consumer　47 </span><br><span class="line"></span><br><span class="line">3．4．3　Function　48 </span><br><span class="line"></span><br><span class="line">3．5　类型检查、类型推断以及限制　52 </span><br><span class="line"></span><br><span class="line">3．5．1　类型检查　52 </span><br><span class="line"></span><br><span class="line">3．5．2　同样的Lambda，不同的函数式接口　53 </span><br><span class="line"></span><br><span class="line">3．5．3　类型推断　55 </span><br><span class="line"></span><br><span class="line">3．5．4　使用局部变量　56 </span><br><span class="line"></span><br><span class="line">3．6　方法引用　57 </span><br><span class="line"></span><br><span class="line">3．6．1　管中窥豹　57 </span><br><span class="line"></span><br><span class="line">3．6．2　构造函数引用　60 </span><br><span class="line"></span><br><span class="line">3．7　Lambda和方法引用实战　62 </span><br><span class="line"></span><br><span class="line">3．7．1　第 1 步：传递代码　62 </span><br><span class="line"></span><br><span class="line">3．7．2　第 2 步：使用匿名类　62 </span><br><span class="line"></span><br><span class="line">3．7．3　第 3 步：使用Lambda表达式　62 </span><br><span class="line"></span><br><span class="line">3．7．4　第 4 步：使用方法引用　63 </span><br><span class="line"></span><br><span class="line">3．8　复合Lambda表达式的有用方法　63 </span><br><span class="line"></span><br><span class="line">3．8．1　比较器复合　64 </span><br><span class="line"></span><br><span class="line">3．8．2　谓词复合　64 </span><br><span class="line"></span><br><span class="line">3．8．3　函数复合　65 </span><br><span class="line"></span><br><span class="line">3．9　数学中的类似思想　66 </span><br><span class="line"></span><br><span class="line">3．9．1　积分　66 </span><br><span class="line"></span><br><span class="line">3．9．2　与Java 8的Lambda联系起来　68 </span><br><span class="line"></span><br><span class="line">3．10　小结　68 </span><br><span class="line"></span><br><span class="line">第二部分　使用流进行函数式数据处理 </span><br><span class="line"></span><br><span class="line">第　4 章 引入流　72 </span><br><span class="line"></span><br><span class="line">4．1　流是什么　72 </span><br><span class="line"></span><br><span class="line">4．2　流简介　76 </span><br><span class="line"></span><br><span class="line">4．3　流与集合　78 </span><br><span class="line"></span><br><span class="line">4．3．1　只能遍历一次　79 </span><br><span class="line"></span><br><span class="line">4．3．2　外部迭代与内部迭代　80 </span><br><span class="line"></span><br><span class="line">4．4　流操作　82 </span><br><span class="line"></span><br><span class="line">4．4．1　中间操作　83 </span><br><span class="line"></span><br><span class="line">4．4．2　终端操作　84 </span><br><span class="line"></span><br><span class="line">4．4．3　使用流　84 </span><br><span class="line"></span><br><span class="line">4．5　路线图　85 </span><br><span class="line"></span><br><span class="line">4．6　小结　85 </span><br><span class="line"></span><br><span class="line">第　5 章 使用流　86 </span><br><span class="line"></span><br><span class="line">5．1　筛选　87 </span><br><span class="line"></span><br><span class="line">5．1．1　用谓词筛选　87 </span><br><span class="line"></span><br><span class="line">5．1．2　筛选各异的元素　87 </span><br><span class="line"></span><br><span class="line">5．2　流的切片　88 </span><br><span class="line"></span><br><span class="line">5．2．1　使用谓词对流进行切片　88 </span><br><span class="line"></span><br><span class="line">5．2．2　截短流　90 </span><br><span class="line"></span><br><span class="line">5．2．3　跳过元素　90 </span><br><span class="line"></span><br><span class="line">5．3　映射　91 </span><br><span class="line"></span><br><span class="line">5．3．1　对流中每一个元素应用函数　91 </span><br><span class="line"></span><br><span class="line">5．3．2　流的扁平化　92 </span><br><span class="line"></span><br><span class="line">5．4　查找和匹配　95 </span><br><span class="line"></span><br><span class="line">5．4．1　检查谓词是否至少匹配一个元素　95 </span><br><span class="line"></span><br><span class="line">5．4．2　检查谓词是否匹配所有元素　96 </span><br><span class="line"></span><br><span class="line">5．4．3　查找元素　96 </span><br><span class="line"></span><br><span class="line">5．4．4　查找第 一个元素　97 </span><br><span class="line"></span><br><span class="line">5．5　归约　98 </span><br><span class="line"></span><br><span class="line">5．5．1　元素求和　98 </span><br><span class="line"></span><br><span class="line">5．5．2　大值和小值　100 </span><br><span class="line"></span><br><span class="line">5．6　付诸实践　103 </span><br><span class="line"></span><br><span class="line">5．6．1　领域：交易员和交易　103 </span><br><span class="line"></span><br><span class="line">5．6．2　解答　104 </span><br><span class="line"></span><br><span class="line">5．7　数值流　106 </span><br><span class="line"></span><br><span class="line">5．7．1　原始类型流特化　107 </span><br><span class="line"></span><br><span class="line">5．7．2　数值范围　108 </span><br><span class="line"></span><br><span class="line">5．7．3　数值流应用：勾股数　108 </span><br><span class="line"></span><br><span class="line">5．8　构建流　111 </span><br><span class="line"></span><br><span class="line">5．8．1　由值创建流　111 </span><br><span class="line"></span><br><span class="line">5．8．2　由可空对象创建流　111 </span><br><span class="line"></span><br><span class="line">5．8．3　由数组创建流　112 </span><br><span class="line"></span><br><span class="line">5．8．4　由文件生成流　112 </span><br><span class="line"></span><br><span class="line">5．8．5　由函数生成流：创建无限流　113 </span><br><span class="line"></span><br><span class="line">5．9　概述　116 </span><br><span class="line"></span><br><span class="line">5．10　小结　116 </span><br><span class="line"></span><br><span class="line">第　6 章 用流收集数据　118 </span><br><span class="line"></span><br><span class="line">6．1　收集器简介　119 </span><br><span class="line"></span><br><span class="line">6．1．1　收集器用作高级归约　119 </span><br><span class="line"></span><br><span class="line">6．1．2　预定义收集器　120 </span><br><span class="line"></span><br><span class="line">6．2　归约和汇总　121 </span><br><span class="line"></span><br><span class="line">6．2．1　查找流中的大值和小值　121 </span><br><span class="line"></span><br><span class="line">6．2．2　汇总　122 </span><br><span class="line"></span><br><span class="line">6．2．3　连接字符串　123 </span><br><span class="line"></span><br><span class="line">6．2．4　广义的归约汇总　124 </span><br><span class="line"></span><br><span class="line">6．3　分组　127 </span><br><span class="line"></span><br><span class="line">6．3．1　操作分组的元素　128 </span><br><span class="line"></span><br><span class="line">6．3．2　多级分组　130 </span><br><span class="line"></span><br><span class="line">6．3．3　按子组收集数据　131 </span><br><span class="line"></span><br><span class="line">6．4　分区　134 </span><br><span class="line"></span><br><span class="line">6．4．1　分区的优势　135 </span><br><span class="line"></span><br><span class="line">6．4．2　将数字按质数和非质数分区　136 </span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA并发编程实践 PDF</title>
    <url>/posts/b5af6a26/</url>
    <content><![CDATA[<h4 id="《JAVA并发编程实践》"><a href="#《JAVA并发编程实践》" class="headerlink" title="《JAVA并发编程实践》"></a>《JAVA并发编程实践》</h4><h6 id="链接-https-pan-baidu-com-s-1QxgwO4qZQEaChi-l7r3YTw-提取码-tcvd"><a href="#链接-https-pan-baidu-com-s-1QxgwO4qZQEaChi-l7r3YTw-提取码-tcvd" class="headerlink" title="链接: https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw 提取码: tcvd"></a>链接: <a href="https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw">https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw</a> 提取码: tcvd</h6><p>随着多核处理器的普及，使用并发成为构建高性能应用程序的关键。Java 5以及6在开发并发程序取得了显著的进步，提高了Java虚拟机的性能，提高了并发类的可伸缩性，并加入了丰富的新并发构建块。在本书中，这些便利工具的创造者不仅解释了它们究竟如何工作、如何使用，同时，还阐释了创造它们的原因，及其背后的设计模式。 本书既能够成为读者的理论支持，又可以作为构建可靠的，可伸缩的，可维护的并发程序的技术支持。本书并不仅仅提供并发API的清单及其机制，本书还提供了设计原则，模式和思想模型，使我们能够更好地构建正确的，性能良好的并发程序。<br><a id="more"></a></p>
<p><img src="/images/223d8e668ac4079bc3508fd7f543bfab1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">代码清单</span><br><span class="line"></span><br><span class="line">序</span><br><span class="line"></span><br><span class="line">章 介绍</span><br><span class="line"></span><br><span class="line">1.1 并发的（非常）简短历史</span><br><span class="line"></span><br><span class="line">1.2 线程的优点</span><br><span class="line"></span><br><span class="line">1.3 线程的风险</span><br><span class="line"></span><br><span class="line">1.4 线程无处不在</span><br><span class="line"></span><br><span class="line">部分 基础</span><br><span class="line"></span><br><span class="line">第2章 线程安全</span><br><span class="line"></span><br><span class="line">2.1 什么是线程安全性</span><br><span class="line"></span><br><span class="line">2.2 原子性</span><br><span class="line"></span><br><span class="line">2.3 锁</span><br><span class="line"></span><br><span class="line">2.4 用锁来保护状态</span><br><span class="line"></span><br><span class="line">2.5 活跃度与性能</span><br><span class="line"></span><br><span class="line">第3章 共享对象</span><br><span class="line"></span><br><span class="line">3.1 可见性</span><br><span class="line"></span><br><span class="line">3.2 发布和逸出</span><br><span class="line"></span><br><span class="line">3.3 线程封闭</span><br><span class="line"></span><br><span class="line">3.4 不可变性</span><br><span class="line"></span><br><span class="line">3.5 安全发布</span><br><span class="line"></span><br><span class="line">第4章 组合对象</span><br><span class="line"></span><br><span class="line">4.1 设计线程安全的类</span><br><span class="line"></span><br><span class="line">4.2 实例限制</span><br><span class="line"></span><br><span class="line">4.3 委托线程安全</span><br><span class="line"></span><br><span class="line">4.4 向已有的线程安全类添加功能</span><br><span class="line"></span><br><span class="line">4.5 同步策略的文档化</span><br><span class="line"></span><br><span class="line">第5章 构建块</span><br><span class="line"></span><br><span class="line">5.1 同步容器</span><br><span class="line"></span><br><span class="line">5.2 发容器</span><br><span class="line"></span><br><span class="line">5.3 阻塞队列和生产者一消费者模式</span><br><span class="line"></span><br><span class="line">5.4 阻塞和可中断的方法</span><br><span class="line"></span><br><span class="line">5.5 Synchronizer</span><br><span class="line"></span><br><span class="line">5.6 为计算结果建立高效、可伸缩的高速缓存</span><br><span class="line"></span><br><span class="line">第2部分 构建并发应用程序</span><br><span class="line"></span><br><span class="line">第6章 任务执行</span><br><span class="line"></span><br><span class="line">6.1 在线程中执行任务</span><br><span class="line"></span><br><span class="line">6.2 Executor 框架</span><br><span class="line"></span><br><span class="line">6.3 寻找可强化的并行性</span><br><span class="line"></span><br><span class="line">第7章 取消和关闭</span><br><span class="line"></span><br><span class="line">7.1 任务取消</span><br><span class="line"></span><br><span class="line">7.2 停止基于线程的服务</span><br><span class="line"></span><br><span class="line">7.3 处理反常的线程终止</span><br><span class="line"></span><br><span class="line">7.4 JVM关闭</span><br><span class="line"></span><br><span class="line">第8章 应用线程池</span><br><span class="line"></span><br><span class="line">8.1 任务与执行策略问的隐性耦合</span><br><span class="line"></span><br><span class="line">8.2 定制线程池的大小</span><br><span class="line"></span><br><span class="line">8.3 配置ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">8.4 扩展ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">8.5 并行递归算法</span><br><span class="line"></span><br><span class="line">第9章 GUI应用程序</span><br><span class="line"></span><br><span class="line">9.1 为什么GUI是单线程化的</span><br><span class="line"></span><br><span class="line">9.2 短期的GUI任务</span><br><span class="line"></span><br><span class="line">9.3 耗时GUI任务</span><br><span class="line"></span><br><span class="line">9.4 共享数据模型</span><br><span class="line"></span><br><span class="line">9.5 其他形式的单线程子系统</span><br><span class="line"></span><br><span class="line">第3部分 活跃度，性能和测试</span><br><span class="line"></span><br><span class="line">0章 避免活跃度危险</span><br><span class="line"></span><br><span class="line">1章 性能和可伸缩性</span><br><span class="line"></span><br><span class="line">2章 测试并发程序</span><br><span class="line"></span><br><span class="line">第4部分 高级主题</span><br><span class="line"></span><br><span class="line">3章 显示锁</span><br><span class="line"></span><br><span class="line">4章 构建自定义的同步工具</span><br><span class="line"></span><br><span class="line">5章 原子变量与非阻塞同步机制</span><br><span class="line"></span><br><span class="line">6章 Java存储模型</span><br><span class="line"></span><br><span class="line">附录A 同步Annotation</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>EffectiveJava中文第二版 PDF</title>
    <url>/posts/c2a85ab0/</url>
    <content><![CDATA[<h4 id="《EffectiveJava中文第二版》"><a href="#《EffectiveJava中文第二版》" class="headerlink" title="《EffectiveJava中文第二版》"></a>《EffectiveJava中文第二版》</h4><h6 id="链接-https-pan-baidu-com-s-1TZUpz5TwlE1HxMqFagQFIA-提取码-ankv"><a href="#链接-https-pan-baidu-com-s-1TZUpz5TwlE1HxMqFagQFIA-提取码-ankv" class="headerlink" title="链接: https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA 提取码: ankv"></a>链接: <a href="https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA">https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA</a> 提取码: ankv</h6><p><img src="/images/9528555b018c733c5960a2c680fa7f221.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 引言</span><br><span class="line"></span><br><span class="line">第2章 创建和销毁对象</span><br><span class="line"></span><br><span class="line">　第1条：考虑用静态工厂方法代替构造器</span><br><span class="line"></span><br><span class="line">　第2条：遇到多个构造器参数时要考虑用构建器</span><br><span class="line"></span><br><span class="line">　第3条：用私有构造器或者枚举类型强化Singleton属性</span><br><span class="line"></span><br><span class="line">　第4条：通过私有构造器强化不可实例化的能力</span><br><span class="line"></span><br><span class="line">　第5条：避免创建不必要的对象</span><br><span class="line"></span><br><span class="line">　第6条：消除过期的对象引用</span><br><span class="line"></span><br><span class="line">　第7条：避免使用终结函数</span><br><span class="line"></span><br><span class="line">第3章 对于所有对象都通用的方法</span><br><span class="line"></span><br><span class="line">　第8条：改写equals时请遵守通用约定</span><br><span class="line"></span><br><span class="line">　第9条：改写equals时总要改写hashCode</span><br><span class="line"></span><br><span class="line">　第10条：始终要改写toString</span><br><span class="line"></span><br><span class="line">　第11条：谨慎地改写clone</span><br><span class="line"></span><br><span class="line">　第12条：考虑实现Comparable接口</span><br><span class="line"></span><br><span class="line">第4章 类和接口</span><br><span class="line"></span><br><span class="line">　第13条：使类和成员的可访问性小化</span><br><span class="line"></span><br><span class="line">　第14条：在公有类中使用访问方法而非公有域</span><br><span class="line"></span><br><span class="line">　第15条：使非可变性小化</span><br><span class="line"></span><br><span class="line">　第16条：复合优先于继承</span><br><span class="line"></span><br><span class="line">　第17条：要么为继承而设计，并提供文档说明，要么就禁止继承</span><br><span class="line"></span><br><span class="line">　第18条：接口优于抽象类</span><br><span class="line"></span><br><span class="line">　第19条：接口只用于定义类型</span><br><span class="line"></span><br><span class="line">　第20条：类层次优于标签类</span><br><span class="line"></span><br><span class="line">　第21条：用函数对象表示策略</span><br><span class="line"></span><br><span class="line">　第22条：优先考虑静态成员类</span><br><span class="line"></span><br><span class="line">第5章 泛型</span><br><span class="line"></span><br><span class="line">　第23条：请不要在新代码中使用原生态类型</span><br><span class="line"></span><br><span class="line">　第24条：消除非受检警告</span><br><span class="line"></span><br><span class="line">　第25条：列表优先于数组</span><br><span class="line"></span><br><span class="line">　第26条：优先考虑泛型</span><br><span class="line"></span><br><span class="line">　第27条：优先考虑泛型方法</span><br><span class="line"></span><br><span class="line">　第28条：利用有限制通配符来提升API的灵活性</span><br><span class="line"></span><br><span class="line">　第29条：优先考虑类型安全的异构容器</span><br><span class="line"></span><br><span class="line">第6章 枚举和注解</span><br><span class="line"></span><br><span class="line">　第30条：用enum代替int常量</span><br><span class="line"></span><br><span class="line">　第31条：用实例域代替序数</span><br><span class="line"></span><br><span class="line">　第32条：用EnumSet代替位域</span><br><span class="line"></span><br><span class="line">　第33条：用EnumMap代替序数索引</span><br><span class="line"></span><br><span class="line">　第34条：用接口模拟可伸缩的枚举</span><br><span class="line"></span><br><span class="line">　第35条：注解优先于命名模式</span><br><span class="line"></span><br><span class="line">　第36条：坚持使用Override注解</span><br><span class="line"></span><br><span class="line">　第37条：用标记接口定义类型</span><br><span class="line"></span><br><span class="line">第7章 方法</span><br><span class="line"></span><br><span class="line">　第38条：检查参数的有效性</span><br><span class="line"></span><br><span class="line">　第39条：必要时进行保护性拷贝</span><br><span class="line"></span><br><span class="line">　第40条：谨慎设计方法签名</span><br><span class="line"></span><br><span class="line">　第41条：慎用重载</span><br><span class="line"></span><br><span class="line">　第42条：慎用可变参数（varargs）</span><br><span class="line"></span><br><span class="line">　第43条：返回零长度的数组或者集合，而不是null</span><br><span class="line"></span><br><span class="line">　第44条：为所有导出的API元素编写文档注释</span><br><span class="line"></span><br><span class="line">第8章 通用程序设计</span><br><span class="line"></span><br><span class="line">　第45条：将局部变量的作用域小化</span><br><span class="line"></span><br><span class="line">　第46条：for-each循环优先于传统的for循环</span><br><span class="line"></span><br><span class="line">　第47条：了解和使用类库</span><br><span class="line"></span><br><span class="line">　第48条：如果需要的答案，请避免使用float和double</span><br><span class="line"></span><br><span class="line">　第49条：原语类型优先于装箱的原语类型</span><br><span class="line"></span><br><span class="line">　第50条：如果其他类型更适合，则尽量避免使用字符串</span><br><span class="line"></span><br><span class="line">　第51条：了解字符串连接的性能</span><br><span class="line"></span><br><span class="line">　第52条：通过接口引用对象</span><br><span class="line"></span><br><span class="line">　第53条：接口优先于反射机制</span><br><span class="line"></span><br><span class="line">　第54条：谨慎地使用本地方法</span><br><span class="line"></span><br><span class="line">　第55条：谨慎地进行优化</span><br><span class="line"></span><br><span class="line">　第56条：遵守普遍接受的命名惯例</span><br><span class="line"></span><br><span class="line">第9章 异常</span><br><span class="line"></span><br><span class="line">　第57条：只针对异常的条件才使用异常</span><br><span class="line"></span><br><span class="line">　第58条：对可恢复的条件使用受检异常，对编程错误使用运行时异常</span><br><span class="line"></span><br><span class="line">　第59条：避免不必要地使用受检的异常</span><br><span class="line"></span><br><span class="line">　第60条：尽量使用标准的异常</span><br><span class="line"></span><br><span class="line">　第61条：抛出与抽象相对应的异常</span><br><span class="line"></span><br><span class="line">　第62条：每个方法抛出的所有异常都要有文档</span><br><span class="line"></span><br><span class="line">　第63条：在细节消息中包含失败－捕获信息</span><br><span class="line"></span><br><span class="line">　第64条：努力使失败保持原子性</span><br><span class="line"></span><br><span class="line">　第65条：不要忽略异常</span><br><span class="line"></span><br><span class="line">第10章 并发</span><br><span class="line"></span><br><span class="line">　第66条：同步访问共享的可变数据</span><br><span class="line"></span><br><span class="line">　第67条：避免过多同步</span><br><span class="line"></span><br><span class="line">　第68条：executor和task优先于线程</span><br><span class="line"></span><br><span class="line">　第69条：并发工具优先于wait和notify</span><br><span class="line"></span><br><span class="line">　第70条：线程安全性的文档化</span><br><span class="line"></span><br><span class="line">　第71条：慎用延迟初始化</span><br><span class="line"></span><br><span class="line">　第72条：不要依赖于线程调度器</span><br><span class="line"></span><br><span class="line">　第73条：避免使用线程组</span><br><span class="line"></span><br><span class="line">第11章 序列化</span><br><span class="line"></span><br><span class="line">　第74条：谨慎地实现Serializable</span><br><span class="line"></span><br><span class="line">　第75条：考虑使用自定义的序列化形式</span><br><span class="line"></span><br><span class="line">　第76条：保护性地编写readObject方法</span><br><span class="line"></span><br><span class="line">　第77条：对于实例控制，枚举类型优先于readResolve</span><br><span class="line"></span><br><span class="line">　第78条：考虑用序列化代理代替序列化实例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>EffectiveSTL中文版 PDF</title>
    <url>/posts/5ba10b0a/</url>
    <content><![CDATA[<h4 id="《EffectiveSTL中文版》"><a href="#《EffectiveSTL中文版》" class="headerlink" title="《EffectiveSTL中文版》"></a>《EffectiveSTL中文版》</h4><h6 id="链接-https-pan-baidu-com-s-1fxVIhRfeYNAT7sppBBUyTA-提取码-arzc"><a href="#链接-https-pan-baidu-com-s-1fxVIhRfeYNAT7sppBBUyTA-提取码-arzc" class="headerlink" title="链接: https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA 提取码: arzc"></a>链接: <a href="https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA">https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA</a> 提取码: arzc</h6><p>STL是C++标准库的一部分。本书是针对STL的经验总结，书中列出了50个条款，绝大多数条款都解释了在使用STL时应该注意的某一个方面的问题，并且详尽地分析了问题的来源、解决方案的优劣。<br><a id="more"></a></p>
<p>C++的标准模板库(STL)是革命性的技术，但是要想用好STL却并不容易。在本书中，畅销书作家Scott Meyers(Effective C++和More Effective C++的作者)揭示了专家总结的一些关键规则，包括专家们总是采用的做法，以及专家们总是避免的做法。通过这些规则，程序员可以高效地使用STL。</p>
<p>一般书主要描述了STL中有些什么内容，而本书则重点讲述了如何使用STL。本书共有50条指导原则，在讲述每一条原则的时候，Scott Meyers都提供了透彻的分析和详尽的实例，所以读者不仅可以学到要做什么，而且还能够知道什么时候该这样做，以及为什么要这样做。</p>
<p><img src="/images/c680d150e5ed861e934c10819f0ff9c81.jpg" width="50%" height="50%"></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>HeadFirst设计模式 PDF</title>
    <url>/posts/2ca63b9c/</url>
    <content><![CDATA[<h4 id="《HeadFirst设计模式》"><a href="#《HeadFirst设计模式》" class="headerlink" title="《HeadFirst设计模式》"></a>《HeadFirst设计模式》</h4><h6 id="链接-https-pan-baidu-com-s-10-UvT-8j-jwJLQzIULL2rg-提取码-33ff"><a href="#链接-https-pan-baidu-com-s-10-UvT-8j-jwJLQzIULL2rg-提取码-33ff" class="headerlink" title="链接: https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg 提取码: 33ff"></a>链接: <a href="https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg">https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg</a> 提取码: 33ff</h6><p>本书趋近，因为它在提供专业知识的同时，仍然具有相当高的可读性。 本书共有14章，每章都介绍了几个设计模式，完整地涵盖了四人组版本23个设计模式。 前言介绍了这本书的用法第1章至第11章陆续介绍了设计模式：Strategy、Observer、Decorator、Abstract Factory、Factory Method、Singleton、Command、Adapter、Facade、TemplatMethod、Iterator、Composite、State、Proxy。 第12章介绍了如何将两个以上的设计模式结合起来成为新的设计模式（例如，的MVC模式），作者称其为复合设计模式。 第13章介绍了如何进一步学习设计模式，如何发掘新的设计模式等主题。 附录A介绍了剩下的设计模式：Bridge（桥接）、Builder（生成器）、Chainof Responsibility（责任链）、Flyweight（蝇量）、Interpreter（解释器）、Mediator（中介者）、Memento（备忘录）、Prototype（原型）、Visitor（访问者）。 另外，第1章至第9章还穿插介绍了四个OO基本概念（抽象、封装、继承、多态），以及九个OO原则（Principle）。不要轻视这些OO原则，因为每个设计模式背后都含了几个OO原则的概念。很多时候，在设计出现两难情况时我们须回归到OO原则，以方便判断取舍。<br><a id="more"></a></p>
<p><img src="/images/82f67901bd7ed74ae5bbce88f9a833dd1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">引子</span><br><span class="line"></span><br><span class="line">谁适合读这本书?</span><br><span class="line"></span><br><span class="line">我们知道你的大脑在想什么</span><br><span class="line"></span><br><span class="line">元认知</span><br><span class="line"></span><br><span class="line">让你的大脑就范</span><br><span class="line"></span><br><span class="line">技术审校</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">1 欢迎来到设计模式世界：设计模式入门</span><br><span class="line"></span><br><span class="line">模拟鸭子应用</span><br><span class="line"></span><br><span class="line">Joe想到继承</span><br><span class="line"></span><br><span class="line">利用接口如何？</span><br><span class="line"></span><br><span class="line">软件开发的不变真理</span><br><span class="line"></span><br><span class="line">分开变化和不变部分</span><br><span class="line"></span><br><span class="line">设计鸭子的行为</span><br><span class="line"></span><br><span class="line">测试鸭子的代码</span><br><span class="line"></span><br><span class="line">动态地设置行为</span><br><span class="line"></span><br><span class="line">封装行为的大局观</span><br><span class="line"></span><br><span class="line">“有一个”比“是一个”更好</span><br><span class="line"></span><br><span class="line">策略模式</span><br><span class="line"></span><br><span class="line">共享模式词汇的威力</span><br><span class="line"></span><br><span class="line">我如何使用设计模式？</span><br><span class="line"></span><br><span class="line">设计箱内的工具</span><br><span class="line"></span><br><span class="line">习题解答</span><br><span class="line"></span><br><span class="line">2 让你的对象知悉现况</span><br><span class="line"></span><br><span class="line">气象观测站</span><br><span class="line"></span><br><span class="line">认识观察者模式</span><br><span class="line"></span><br><span class="line">出版者＋订阅者＝观罕者模式</span><br><span class="line"></span><br><span class="line">五分钟短剧：观察主题</span><br><span class="line"></span><br><span class="line">定义观察者模式</span><br><span class="line"></span><br><span class="line">松耦合的威力</span><br><span class="line"></span><br><span class="line">设计气象站</span><br><span class="line"></span><br><span class="line">实现气象站</span><br><span class="line"></span><br><span class="line">使用Java内建的观察者模式</span><br><span class="line"></span><br><span class="line">java.util.Observable的黑暗面</span><br><span class="line"></span><br><span class="line">设计箱内的工具</span><br><span class="line"></span><br><span class="line">习题解答</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">3 装饰者模式：装饰对象</span><br><span class="line"></span><br><span class="line">4 工厂模式：烘烤OO的精华</span><br><span class="line"></span><br><span class="line">5 单件模式： 的对象</span><br><span class="line"></span><br><span class="line">6 命令模式：封装调用</span><br><span class="line"></span><br><span class="line">7 适配器模式与外观模式：随遇而安</span><br><span class="line"></span><br><span class="line">8 模板方法模式：封装算法</span><br><span class="line"></span><br><span class="line">9 送代器与组合模式：管理良好的集合</span><br><span class="line"></span><br><span class="line">10 状态模式：事物的状态</span><br><span class="line"></span><br><span class="line">11 代理模式：控制对象访问</span><br><span class="line"></span><br><span class="line">12 复合模式：模式中的模式</span><br><span class="line"></span><br><span class="line">13 与设计模式相处：真实世界中的模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>HeadFirstJava第二版涵盖java5.0 PDF</title>
    <url>/posts/4c61b279/</url>
    <content><![CDATA[<h4 id="《HeadFirstJava第二版涵盖java5-0》"><a href="#《HeadFirstJava第二版涵盖java5-0》" class="headerlink" title="《HeadFirstJava第二版涵盖java5.0》"></a>《HeadFirstJava第二版涵盖java5.0》</h4><h6 id="链接-https-pan-baidu-com-s-1mlFzvUoucefh8MePSUtGng-提取码-bmkj"><a href="#链接-https-pan-baidu-com-s-1mlFzvUoucefh8MePSUtGng-提取码-bmkj" class="headerlink" title="链接: https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng 提取码: bmkj"></a>链接: <a href="https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng">https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng</a> 提取码: bmkj</h6><p>《HeadFirstJava》是一本完整地面向对象(object-oriented，OO)程序设计和Java的学习指导用书，根据学习理论所设计，你可以从程序语言的基础开始，到线程、网络与分布式程序等项目。重要的是，你可以学会如何像一个面向对象开发者一样去思考，而且不只是读死书。　　在这里，你可以会玩游戏、拼图、解谜题以及以意想不到的方式与Java交互。　　在这些活动中，你还会写出一堆真正的Java程序，如一个船舰炮战游戏和一个网络聊天程序等等。　　“HeadFirst系列”图文并茂学习方式能让你快速地在脑海中掌握住知识，敞开心胸准备好学习这些关键性的主题：　　★Java程序语言　　★面向对象程序开发　　★Swing图形化接口　　★使用JavaAPI函数库　　★编写、测试与布署应用程序　　★处理异常；多线程　　★网络程序设计　　★集合与泛型<br><a id="more"></a></p>
<p><img src="/images/b77e0c3f3688efd685ad38b8ec646a551.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">序1 进入Java的世界Java的工作方式Java的程序结构剖析类main（）方法循环条件分支设计程序术语制造机谈话录习题2 拜访对象村椅子大战继承覆盖什么是类？创建你的个对象使用main（）猜数字习题3 认识变量声明变量Primitive主数据类型Java关键字引用变量对象的声明与赋值可回收堆空间数组习题4 对象的行为操作对象状态的方法方法参数与返回类型值传递Getters与Setters封装数组中的引用习题5 超强力方法创建战舰游戏简单版编写伪码测试编写程序完成版用Math.random（）产生数预先输入好的程序循环类型转换用Integer.parseInt（）转换字符串习题6 使用Java函数库7 对象村的优质生活8 深入多态9 对象的前世今生10 数字很重要11 有风险的行为12 看图说故事13 使用Swing14 保存对象15 网络联机16 数据结构17 发布程序18 分布式计算附录A：程序料理决定版附录B：十大遗珠之憾索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>HeadFirstServletandJSP(高清中文版) PDF</title>
    <url>/posts/3b6682ef/</url>
    <content><![CDATA[<h4 id="《HeadFirstServletandJSP-高清中文版-》"><a href="#《HeadFirstServletandJSP-高清中文版-》" class="headerlink" title="《HeadFirstServletandJSP(高清中文版)》"></a>《HeadFirstServletandJSP(高清中文版)》</h4><h6 id="链接-https-pan-baidu-com-s-16BEMBE1sAYB-JAx4-KPsaA-提取码-vkmk"><a href="#链接-https-pan-baidu-com-s-16BEMBE1sAYB-JAx4-KPsaA-提取码-vkmk" class="headerlink" title="链接: https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA 提取码: vkmk"></a>链接: <a href="https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA">https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA</a> 提取码: vkmk</h6><p>本书主要针对的是学习J2EE 1.5，参加Sun认证的Web组件开发人员。全书并没有给你一大堆需要死记硬背的条条框框，它能将知识直接送入你的大脑。你会通过不寻常的方式同Servlet和JSP打交道，可以学得<em>深入、</em>快捷。你会看到一个全新的模拟测验，让你的大脑记住3个作用域，分别是与表达式语言操作符面对面，理解容器如何处理针对一个Servlet的多个请求，了解HttpSession中的重要里程碑。<br><a id="more"></a></p>
<p><img src="/images/d05e91f8cf73780cfa75984f8356e3f71.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">引子</span><br><span class="line"></span><br><span class="line">1 为什么使用Servlets&amp;JSP：前言与概述</span><br><span class="line"></span><br><span class="line">2 Web应用体系结构：高层概述</span><br><span class="line"></span><br><span class="line">3 MVC迷你教程：MVC实战</span><br><span class="line"></span><br><span class="line">4 作为Servlet：请求和响应</span><br><span class="line"></span><br><span class="line">5 作为Web应用：属性和监听者</span><br><span class="line"></span><br><span class="line">6 会话状态：会话管理</span><br><span class="line"></span><br><span class="line">7 作为JSP：使用JSP</span><br><span class="line"></span><br><span class="line">8 没有脚本的页面：无脚本的JSP</span><br><span class="line"></span><br><span class="line">9 强大的定制标记：使用JSTL</span><br><span class="line"></span><br><span class="line">10 JSTL也有力不能及的时候：定制标记开发</span><br><span class="line"></span><br><span class="line">11 部署Web应用：Web应用部署</span><br><span class="line"></span><br><span class="line">12 要保密，要安全：Web应用安全</span><br><span class="line"></span><br><span class="line">13 过滤器的威力：过滤器和包装器</span><br><span class="line"></span><br><span class="line">14 企业设计模式：模式和struts</span><br><span class="line"></span><br><span class="line">A 附录A：*终模拟测验</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java从小白到大牛精简版 PDF</title>
    <url>/posts/abd99f7e/</url>
    <content><![CDATA[<h4 id="《Java从小白到大牛精简版》"><a href="#《Java从小白到大牛精简版》" class="headerlink" title="《Java从小白到大牛精简版》"></a>《Java从小白到大牛精简版》</h4><h6 id="链接-https-pan-baidu-com-s-1RVLm1dzPhc8yTbs0rdXyOw-提取码-mz9r"><a href="#链接-https-pan-baidu-com-s-1RVLm1dzPhc8yTbs0rdXyOw-提取码-mz9r" class="headerlink" title="链接: https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw 提取码: mz9r"></a>链接: <a href="https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw">https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw</a> 提取码: mz9r</h6><p>中主要内容包括：开篇综述；开发环境搭建；*一个Java程序；Java语法基础；Java编码规范；数据类型；运算符；控制语句；数组；字符串；面向对象基础；对象；继承与多态；抽象类与接口；枚举类；Java常用类；内部类；Java 8函数式编程基础——Lambda表达式；异常处理；对象容器——集合；泛型；文件管理与IO流；多线程编程；网络编程；Swing图形用户界面编程；反射；注解；数据库编程。全书最后还给出了两个实战项目——项目实战1：开发PetStore宠物商店项目；项目实战2：开发Java版QQ2006聊天工具。<br><a id="more"></a></p>
<p><img src="/images/e93b9f5d2ce6e45ee217b6ca250e31bf1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 开篇综述</span><br><span class="line"></span><br><span class="line">1.1 Java语言历史</span><br><span class="line"></span><br><span class="line">1.2 Java语言特点</span><br><span class="line"></span><br><span class="line">1.3 Java平台</span><br><span class="line"></span><br><span class="line">1.4 Java虚拟机</span><br><span class="line"></span><br><span class="line">第2章 开发环境搭建</span><br><span class="line"></span><br><span class="line">2.1 JDK工具包</span><br><span class="line"></span><br><span class="line">JDK下载和安装</span><br><span class="line"></span><br><span class="line">设置环境变量</span><br><span class="line"></span><br><span class="line">2.2 Eclipse开发工具</span><br><span class="line"></span><br><span class="line">Eclipse下载和安装</span><br><span class="line"></span><br><span class="line">安装中文语言包</span><br><span class="line"></span><br><span class="line">Eclipse界面</span><br><span class="line"></span><br><span class="line">Windows系统中常用快捷键</span><br><span class="line"></span><br><span class="line">2.3 其他开发工具</span><br><span class="line"></span><br><span class="line">IntelliJ IDEA</span><br><span class="line"></span><br><span class="line">NetBeans IDE</span><br><span class="line"></span><br><span class="line">文本编辑工具</span><br><span class="line"></span><br><span class="line">第3章 第一个Java程序</span><br><span class="line"></span><br><span class="line">3.1 使用Eclipse实现</span><br><span class="line"></span><br><span class="line">创建项目</span><br><span class="line"></span><br><span class="line">创建类</span><br><span class="line"></span><br><span class="line">运行程序</span><br><span class="line"></span><br><span class="line">3.2 文本编辑工具+JDK实现</span><br><span class="line"></span><br><span class="line">编写源代码文件</span><br><span class="line"></span><br><span class="line">编译程序</span><br><span class="line"></span><br><span class="line">运行程序</span><br><span class="line"></span><br><span class="line">3.3 代码解释</span><br><span class="line"></span><br><span class="line">第4章 Java语法基础</span><br><span class="line"></span><br><span class="line">4.1 标识符、关键字和保留字</span><br><span class="line"></span><br><span class="line">标识符</span><br><span class="line"></span><br><span class="line">关键字</span><br><span class="line"></span><br><span class="line">保留字</span><br><span class="line"></span><br><span class="line">4.2 Java分隔符</span><br><span class="line"></span><br><span class="line">4.3 变量</span><br><span class="line"></span><br><span class="line">4.4 常量</span><br><span class="line"></span><br><span class="line">第5章 Java编码规范</span><br><span class="line"></span><br><span class="line">5.1 命名规范</span><br><span class="line"></span><br><span class="line">5.2 注释规范</span><br><span class="line"></span><br><span class="line">文件注释</span><br><span class="line"></span><br><span class="line">文档注释</span><br><span class="line"></span><br><span class="line">代码注释</span><br><span class="line"></span><br><span class="line">使用地标注释</span><br><span class="line"></span><br><span class="line">5.3 代码排版</span><br><span class="line"></span><br><span class="line">空行</span><br><span class="line"></span><br><span class="line">空格</span><br><span class="line"></span><br><span class="line">缩进</span><br><span class="line"></span><br><span class="line">断行</span><br><span class="line"></span><br><span class="line">5.4 其他规范</span><br><span class="line"></span><br><span class="line">第6章 数据类型</span><br><span class="line"></span><br><span class="line">6.1 基本数据类型</span><br><span class="line"></span><br><span class="line">6.2 整型类型</span><br><span class="line"></span><br><span class="line">6.3 浮点类型</span><br><span class="line"></span><br><span class="line">6.4 数字表示方式</span><br><span class="line"></span><br><span class="line">进制数字表示</span><br><span class="line"></span><br><span class="line">指数表示</span><br><span class="line"></span><br><span class="line">6.5 字符类型</span><br><span class="line"></span><br><span class="line">6.6 布尔类型</span><br><span class="line"></span><br><span class="line">6.7 数值类型相互转换</span><br><span class="line"></span><br><span class="line">自动类型转换</span><br><span class="line"></span><br><span class="line">强制类型转换</span><br><span class="line"></span><br><span class="line">6.8 引用数据类型</span><br><span class="line"></span><br><span class="line">第7章 运算符</span><br><span class="line"></span><br><span class="line">7.1 算术运算符</span><br><span class="line"></span><br><span class="line">7.2 关系运算符</span><br><span class="line"></span><br><span class="line">7.3 逻辑运算符</span><br><span class="line"></span><br><span class="line">7.4 位运算符</span><br><span class="line"></span><br><span class="line">7.5 其他运算符</span><br><span class="line"></span><br><span class="line">7.6 运算符优先级</span><br><span class="line"></span><br><span class="line">第8章 控制语句</span><br><span class="line"></span><br><span class="line">8.1 分支语句</span><br><span class="line"></span><br><span class="line">if语句</span><br><span class="line"></span><br><span class="line">switch语句</span><br><span class="line"></span><br><span class="line">8.2 循环语句</span><br><span class="line"></span><br><span class="line">while语句</span><br><span class="line"></span><br><span class="line">do-while语句</span><br><span class="line"></span><br><span class="line">for语句</span><br><span class="line"></span><br><span class="line">增强for语句</span><br><span class="line"></span><br><span class="line">8.3 跳转语句</span><br><span class="line"></span><br><span class="line">break语句</span><br><span class="line"></span><br><span class="line">continue语句</span><br><span class="line"></span><br><span class="line">第9章 数组</span><br><span class="line"></span><br><span class="line">9.1 一维数组</span><br><span class="line"></span><br><span class="line">数组声明</span><br><span class="line"></span><br><span class="line">数组初始化</span><br><span class="line"></span><br><span class="line">案例：数组合并</span><br><span class="line"></span><br><span class="line">9.2 多维数组</span><br><span class="line"></span><br><span class="line">二维数组声明</span><br><span class="line"></span><br><span class="line">二维数组的初始化</span><br><span class="line"></span><br><span class="line">不规则数组</span><br><span class="line"></span><br><span class="line">第10章 字符串</span><br><span class="line"></span><br><span class="line">10.1 Java中的字符串</span><br><span class="line"></span><br><span class="line">10.2 使用API文档</span><br><span class="line"></span><br><span class="line">10.3 不可变字符串</span><br><span class="line"></span><br><span class="line">String</span><br><span class="line"></span><br><span class="line">字符串池</span><br><span class="line"></span><br><span class="line">字符串拼接</span><br><span class="line"></span><br><span class="line">字符串查找</span><br><span class="line"></span><br><span class="line">字符串比较</span><br><span class="line"></span><br><span class="line">字符串截取</span><br><span class="line"></span><br><span class="line">10.4 可变字符串</span><br><span class="line"></span><br><span class="line">StringBuffer和StringBuilder</span><br><span class="line"></span><br><span class="line">字符串追加</span><br><span class="line"></span><br><span class="line">字符串插入、删除和替换</span><br><span class="line"></span><br><span class="line">第11章 面向对象基础</span><br><span class="line"></span><br><span class="line">11.1 面向对象概述</span><br><span class="line"></span><br><span class="line">11.2 面向对象三个基本特性</span><br><span class="line"></span><br><span class="line">11.3 类</span><br><span class="line"></span><br><span class="line">11.4 包</span><br><span class="line"></span><br><span class="line">11.5 方法重载（Overload）</span><br><span class="line"></span><br><span class="line">11.6 封装性与访问控制</span><br><span class="line"></span><br><span class="line">11.7 静态变量和静态方法</span><br><span class="line"></span><br><span class="line">11.8 静态代码块</span><br><span class="line"></span><br><span class="line">第12章 对象</span><br><span class="line"></span><br><span class="line">12.1 创建对象</span><br><span class="line"></span><br><span class="line">12.2 空对象</span><br><span class="line"></span><br><span class="line">12.3 构造方法</span><br><span class="line"></span><br><span class="line">12.4 this关键字</span><br><span class="line"></span><br><span class="line">12.5 对象销毁</span><br><span class="line"></span><br><span class="line">第13章 继承与多态</span><br><span class="line"></span><br><span class="line">13.1 Java中的继承</span><br><span class="line"></span><br><span class="line">13.2 调用父类构造方法</span><br><span class="line"></span><br><span class="line">13.3 变量隐藏和方法覆盖</span><br><span class="line"></span><br><span class="line">13.4 多态</span><br><span class="line"></span><br><span class="line">13.5 再谈final关键字</span><br><span class="line"></span><br><span class="line">第14章 抽象类与接口</span><br><span class="line"></span><br><span class="line">14.1 抽象类</span><br><span class="line"></span><br><span class="line">14.2 使用接口</span><br><span class="line"></span><br><span class="line">Java 8新特性默认方法和静态方法</span><br><span class="line"></span><br><span class="line">14.3 抽象类与接口区别</span><br><span class="line"></span><br><span class="line">第15章 枚举类</span><br><span class="line"></span><br><span class="line">15.1 枚举概述</span><br><span class="line"></span><br><span class="line">15.2 枚举类声明</span><br><span class="line"></span><br><span class="line">15.3 枚举常用方法</span><br><span class="line"></span><br><span class="line">第16章 Java常用类</span><br><span class="line"></span><br><span class="line">16.1 Java根类——Object</span><br><span class="line"></span><br><span class="line">16.2 包装类</span><br><span class="line"></span><br><span class="line">16.3 Math类</span><br><span class="line"></span><br><span class="line">16.4 大数值</span><br><span class="line"></span><br><span class="line">16.5 日期时间相关类</span><br><span class="line"></span><br><span class="line">16.6 Java 8新日期时间相关类</span><br><span class="line"></span><br><span class="line">第17章 内部类</span><br><span class="line"></span><br><span class="line">17.1 内部类概述</span><br><span class="line"></span><br><span class="line">17.2 成员内部类</span><br><span class="line"></span><br><span class="line">17.3 局部内部类</span><br><span class="line"></span><br><span class="line">17.4 匿名内部类</span><br><span class="line"></span><br><span class="line">第18章 Java 8函数式编程基础——Lambda表达式</span><br><span class="line"></span><br><span class="line">18.1 Lambda表达式概述</span><br><span class="line"></span><br><span class="line">从一个示例开始</span><br><span class="line"></span><br><span class="line">Lambda表达式实现</span><br><span class="line"></span><br><span class="line">函数式接口</span><br><span class="line"></span><br><span class="line">18.2 Lambda表达式简化形式</span><br><span class="line"></span><br><span class="line">省略参数类型</span><br><span class="line"></span><br><span class="line">省略参数小括号</span><br><span class="line"></span><br><span class="line">省略return和大括号</span><br><span class="line"></span><br><span class="line">18.3 作为参数使用Lambda表达式</span><br><span class="line"></span><br><span class="line">18.4 访问变量</span><br><span class="line"></span><br><span class="line">访问成员变量</span><br><span class="line"></span><br><span class="line">捕获局部变量</span><br><span class="line"></span><br><span class="line">18.5 方法引用</span><br><span class="line"></span><br><span class="line">第19章 异常处理</span><br><span class="line"></span><br><span class="line">19.1 从一个问题开始</span><br><span class="line"></span><br><span class="line">19.2 异常类继承层次</span><br><span class="line"></span><br><span class="line">19.3 捕获异常</span><br><span class="line"></span><br><span class="line">19.4 释放资源</span><br><span class="line"></span><br><span class="line">19.5 throws与声明方法抛出异常</span><br><span class="line"></span><br><span class="line">19.6 自定义异常类</span><br><span class="line"></span><br><span class="line">19.7 throw与显式抛出异常</span><br><span class="line"></span><br><span class="line">第20章 对象容器——集合</span><br><span class="line"></span><br><span class="line">20.1 集合概述</span><br><span class="line"></span><br><span class="line">20.2 List集合</span><br><span class="line"></span><br><span class="line">20.3 Set集合</span><br><span class="line"></span><br><span class="line">20.4 Map集合</span><br><span class="line"></span><br><span class="line">第21章 泛型</span><br><span class="line"></span><br><span class="line">21.1 一个问题的思考</span><br><span class="line"></span><br><span class="line">21.2 使用泛型</span><br><span class="line"></span><br><span class="line">21.3 自定义泛型类</span><br><span class="line"></span><br><span class="line">21.4 自定义泛型接口</span><br><span class="line"></span><br><span class="line">21.5 泛型方法</span><br><span class="line"></span><br><span class="line">第22章 文件管理与I&#x2F;O流</span><br><span class="line"></span><br><span class="line">22.1 文件管理</span><br><span class="line"></span><br><span class="line">22.2 I&#x2F;O流概述</span><br><span class="line"></span><br><span class="line">22.3 字节流</span><br><span class="line"></span><br><span class="line">22.4 字符流</span><br><span class="line"></span><br><span class="line">第23章 多线程编程</span><br><span class="line"></span><br><span class="line">23.1 基础知识</span><br><span class="line"></span><br><span class="line">23.2 创建子线程</span><br><span class="line"></span><br><span class="line">23.3 线程的状态</span><br><span class="line"></span><br><span class="line">23.4 线程管理</span><br><span class="line"></span><br><span class="line">23.5 线程安全</span><br><span class="line"></span><br><span class="line">23.6 线程间通信</span><br><span class="line"></span><br><span class="line">第24章 网络编程</span><br><span class="line"></span><br><span class="line">24.1 网络基础</span><br><span class="line"></span><br><span class="line">24.1.4 端口</span><br><span class="line"></span><br><span class="line">24.2 TCP Socket低层次网络编程</span><br><span class="line"></span><br><span class="line">24.3 UDP Socket低层次网络编程</span><br><span class="line"></span><br><span class="line">24.4 数据交换格式</span><br><span class="line"></span><br><span class="line">24.5 访问互联网资源</span><br><span class="line"></span><br><span class="line">第25章 Swing图形用户界面编程</span><br><span class="line"></span><br><span class="line">25.1 Java图形用户界面技术</span><br><span class="line"></span><br><span class="line">25.2 Swing技术基础</span><br><span class="line"></span><br><span class="line">25.3 事件处理模型</span><br><span class="line"></span><br><span class="line">25.4 布局管理</span><br><span class="line"></span><br><span class="line">25.5 Swing组件</span><br><span class="line"></span><br><span class="line">25.6 案例：图书库存</span><br><span class="line"></span><br><span class="line">第26章 反射</span><br><span class="line"></span><br><span class="line">26.1 Java反射机制API</span><br><span class="line"></span><br><span class="line">26.2 创建对象</span><br><span class="line"></span><br><span class="line">26.3 调用方法</span><br><span class="line"></span><br><span class="line">26.4 调用成员变量</span><br><span class="line"></span><br><span class="line">第27章 注解（Annotation）</span><br><span class="line"></span><br><span class="line">27.1 基本注解</span><br><span class="line"></span><br><span class="line">27.2 元注解</span><br><span class="line"></span><br><span class="line">27.3 自定义注解</span><br><span class="line"></span><br><span class="line">第28章 数据库编程</span><br><span class="line"></span><br><span class="line">28.1 数据持久技术概述</span><br><span class="line"></span><br><span class="line">28.2 MySQL数据库管理系统</span><br><span class="line"></span><br><span class="line">28.3 JDBC技术</span><br><span class="line"></span><br><span class="line">28.4 案例：数据CRUD操作</span><br><span class="line"></span><br><span class="line">第29章 项目实战1：开发PetStore宠物商店项目</span><br><span class="line"></span><br><span class="line">29.1 系统分析与设计</span><br><span class="line"></span><br><span class="line">项目概述</span><br><span class="line"></span><br><span class="line">需求分析</span><br><span class="line"></span><br><span class="line">原型设计</span><br><span class="line"></span><br><span class="line">数据库设计</span><br><span class="line"></span><br><span class="line">架构设计</span><br><span class="line"></span><br><span class="line">系统设计</span><br><span class="line"></span><br><span class="line">29.2 任务1：创建数据库</span><br><span class="line"></span><br><span class="line">迭代1.1：安装和配置MySQL数据库</span><br><span class="line"></span><br><span class="line">迭代1.2：编写数据库DDL脚本</span><br><span class="line"></span><br><span class="line">迭代1.3：插入初始数据到数据库</span><br><span class="line"></span><br><span class="line">29.3 任务2：应用并初始化项目</span><br><span class="line"></span><br><span class="line">29.4 任务3：编写数据持久层代码</span><br><span class="line"></span><br><span class="line">29.5 任务4：编写表示层代码</span><br><span class="line"></span><br><span class="line">29.6 任务5：应用程序打包发布</span><br><span class="line"></span><br><span class="line">第30章 项目实战2：开发Java版QQ2006聊天工具</span><br><span class="line"></span><br><span class="line">30.1 系统分析与设计</span><br><span class="line"></span><br><span class="line">项目概述</span><br><span class="line"></span><br><span class="line">需求分析</span><br><span class="line"></span><br><span class="line">原型设计</span><br><span class="line"></span><br><span class="line">数据库设计</span><br><span class="line"></span><br><span class="line">网络拓扑图</span><br><span class="line"></span><br><span class="line">系统设计</span><br><span class="line"></span><br><span class="line">30.2 任务1：创建服务器端数据库</span><br><span class="line"></span><br><span class="line">迭代1.1：安装和配置MySQL数据库</span><br><span class="line"></span><br><span class="line">迭代1.2：编写数据库DDL脚本</span><br><span class="line"></span><br><span class="line">迭代1.3：插入初始数据到数据库</span><br><span class="line"></span><br><span class="line">30.3 任务2：应用并初始化项目</span><br><span class="line"></span><br><span class="line">30.4 任务3：编写服务器端外围代码</span><br><span class="line"></span><br><span class="line">30.5 任务4：客户端UI实现</span><br><span class="line"></span><br><span class="line">30.6 任务5：用户登录过程实现</span><br><span class="line"></span><br><span class="line">30.7 任务6：用户登录刷新好友列表</span><br><span class="line"></span><br><span class="line">30.8 任务7：聊天过程实现</span><br><span class="line"></span><br><span class="line">30.9 任务8：用户下线刷新好友列表过程</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术卷1第8版 PDF</title>
    <url>/posts/dcdeafe8/</url>
    <content><![CDATA[<h4 id="《Java核心技术卷1第8版》"><a href="#《Java核心技术卷1第8版》" class="headerlink" title="《Java核心技术卷1第8版》"></a>《Java核心技术卷1第8版》</h4><h6 id="链接-https-pan-baidu-com-s-1bvbULlJcLOgrjOfbaajuyA-提取码-9i6e"><a href="#链接-https-pan-baidu-com-s-1bvbULlJcLOgrjOfbaajuyA-提取码-9i6e" class="headerlink" title="链接: https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA 提取码: 9i6e"></a>链接: <a href="https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA">https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA</a> 提取码: 9i6e</h6><p>Java领域*有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强。<br><a id="more"></a></p>
<p>本书共14章。第1章概述Java语言与其他程序设计语言不同的性能；第2章讲解如何下载和安装JDK及本书的程序示例；第3章介绍变量、循环和简单的函数；第4章讲解类和封装；第5章介绍继承；第6章解释接口和内部类；第7章讨论异常处理，并给出大量实用的调试技巧；第8章概要介绍泛型程序设计；第9章讨论Java平台的集合框架；第10章介绍GUI程序设计，讨论如何建立窗口、如何在窗口中绘图、如何利用几何图形绘图、如何采用多种字体格式化文本，以及如何显示图像；第11章详细讨论抽象窗口工具包的事件模型；第12章详细讨论Swing GUI工具包；第13章介绍如何将程序部署为应用或applet；第14章讨论并发。本书*后还有一个附录，其中列出了Java语言的保留字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 Java程序设计概述 1</span><br><span class="line"></span><br><span class="line">1.1 Java程序设计平台 1</span><br><span class="line"></span><br><span class="line">1.2 Java“白皮书”的关键术语 2</span><br><span class="line"></span><br><span class="line">1.2.1 简单性 2</span><br><span class="line"></span><br><span class="line">1.2.2 面向对象 2</span><br><span class="line"></span><br><span class="line">1.2.3 分布式 3</span><br><span class="line"></span><br><span class="line">1.2.4 健壮性 3</span><br><span class="line"></span><br><span class="line">1.2.5 安全性 3</span><br><span class="line"></span><br><span class="line">1.2.6 体系结构中立 4</span><br><span class="line"></span><br><span class="line">1.2.7 可移植性 4</span><br><span class="line"></span><br><span class="line">1.2.8 解释型 5</span><br><span class="line"></span><br><span class="line">1.2.9 高性能 5</span><br><span class="line"></span><br><span class="line">1.2.10 多线程 5</span><br><span class="line"></span><br><span class="line">1.2.11 动态性 5</span><br><span class="line"></span><br><span class="line">1.3 Java applet与Internet 6</span><br><span class="line"></span><br><span class="line">1.4 Java发展简史 7</span><br><span class="line"></span><br><span class="line">1.5 关于Java的常见误解 9</span><br><span class="line"></span><br><span class="line">第2章 Java程序设计环境 12</span><br><span class="line"></span><br><span class="line">2.1 安装Java开发工具包 12</span><br><span class="line"></span><br><span class="line">2.1.1 下载JDK 12</span><br><span class="line"></span><br><span class="line">2.1.2 设置JDK 13</span><br><span class="line"></span><br><span class="line">2.1.3 安装库源文件和文档 15</span><br><span class="line"></span><br><span class="line">2.2 使用命令行工具 16</span><br><span class="line"></span><br><span class="line">2.3 使用集成开发环境 18</span><br><span class="line"></span><br><span class="line">2.4 运行图形化应用程序 21</span><br><span class="line"></span><br><span class="line">2.5 构建并运行applet 23</span><br><span class="line"></span><br><span class="line">第3章 Java的基本程序设计结构 28</span><br><span class="line"></span><br><span class="line">3.1 一个简单的Java应用程序 28</span><br><span class="line"></span><br><span class="line">3.2 注释 31</span><br><span class="line"></span><br><span class="line">3.3 数据类型 32</span><br><span class="line"></span><br><span class="line">3.3.1 整型 32</span><br><span class="line"></span><br><span class="line">3.3.2 浮点类型 33</span><br><span class="line"></span><br><span class="line">3.3.3 char类型 34</span><br><span class="line"></span><br><span class="line">3.3.4 Unicode和char类型 35</span><br><span class="line"></span><br><span class="line">3.3.5 boolean类型 35</span><br><span class="line"></span><br><span class="line">3.4 变量 36</span><br><span class="line"></span><br><span class="line">3.4.1 变量初始化 37</span><br><span class="line"></span><br><span class="line">3.4.2 常量 37</span><br><span class="line"></span><br><span class="line">3.5 运算符 38</span><br><span class="line"></span><br><span class="line">3.5.1 数学函数与常量 39</span><br><span class="line"></span><br><span class="line">3.5.2 数值类型之间的转换 40</span><br><span class="line"></span><br><span class="line">3.5.3 强制类型转换 41</span><br><span class="line"></span><br><span class="line">3.5.4 结合赋值和运算符 42</span><br><span class="line"></span><br><span class="line">3.5.5 自增与自减运算符 42</span><br><span class="line"></span><br><span class="line">3.5.6 关系和boolean运算符 42</span><br><span class="line"></span><br><span class="line">3.5.7 位运算符 43</span><br><span class="line"></span><br><span class="line">3.5.8 括号与运算符级别 44</span><br><span class="line"></span><br><span class="line">3.5.9 枚举类型 45</span><br><span class="line"></span><br><span class="line">3.6 字符串 45</span><br><span class="line"></span><br><span class="line">3.6.1 子串 45</span><br><span class="line"></span><br><span class="line">3.6.2 拼接 46</span><br><span class="line"></span><br><span class="line">3.6.3 不可变字符串 46</span><br><span class="line"></span><br><span class="line">3.6.4 检测字符串是否相等 47</span><br><span class="line"></span><br><span class="line">3.6.5 空串与Null串 48</span><br><span class="line"></span><br><span class="line">3.6.6 码点与代码单元 49</span><br><span class="line"></span><br><span class="line">3.6.7 String API 50</span><br><span class="line"></span><br><span class="line">3.6.8 阅读联机API文档 52</span><br><span class="line"></span><br><span class="line">3.6.9 构建字符串 54</span><br><span class="line"></span><br><span class="line">3.7 输入输出 55</span><br><span class="line"></span><br><span class="line">3.7.1 读取输入 55</span><br><span class="line"></span><br><span class="line">3.7.2 格式化输出 58</span><br><span class="line"></span><br><span class="line">3.7.3 文件输入与输出 61</span><br><span class="line"></span><br><span class="line">3.8 控制流程 63</span><br><span class="line"></span><br><span class="line">3.8.1 块作用域 63</span><br><span class="line"></span><br><span class="line">3.8.2 条件语句 63</span><br><span class="line"></span><br><span class="line">3.8.3 循环 66</span><br><span class="line"></span><br><span class="line">3.8.4 确定循环 69</span><br><span class="line"></span><br><span class="line">3.8.5 多重选择：switch语句 72</span><br><span class="line"></span><br><span class="line">3.8.6 中断控制流程语句 74</span><br><span class="line"></span><br><span class="line">3.9 大数值 76</span><br><span class="line"></span><br><span class="line">3.10 数组 78</span><br><span class="line"></span><br><span class="line">3.10.1 for each循环 79</span><br><span class="line"></span><br><span class="line">3.10.2 数组初始化以及匿名数组 80</span><br><span class="line"></span><br><span class="line">3.10.3 数组拷贝 81</span><br><span class="line"></span><br><span class="line">3.10.4 命令行参数 81</span><br><span class="line"></span><br><span class="line">3.10.5 数组排序 82</span><br><span class="line"></span><br><span class="line">3.10.6 多维数组 85</span><br><span class="line"></span><br><span class="line">3.10.7 不规则数组 88</span><br><span class="line"></span><br><span class="line">第4章 对象与类 91</span><br><span class="line"></span><br><span class="line">4.1 面向对象程序设计概述 91</span><br><span class="line"></span><br><span class="line">4.1.1 类 92</span><br><span class="line"></span><br><span class="line">4.1.2 对象 93</span><br><span class="line"></span><br><span class="line">4.1.3 识别类 93</span><br><span class="line"></span><br><span class="line">4.1.4 类之间的关系 94</span><br><span class="line"></span><br><span class="line">4.2 使用预定义类 95</span><br><span class="line"></span><br><span class="line">4.2.1 对象与对象变量 95</span><br><span class="line"></span><br><span class="line">4.2.2 Java类库中的LocalDate类 98</span><br><span class="line"></span><br><span class="line">4.2.3 更改器方法与访问器方法 100</span><br><span class="line"></span><br><span class="line">4.3 用户自定义类 103</span><br><span class="line"></span><br><span class="line">4.3.1 Employee类 103</span><br><span class="line"></span><br><span class="line">4.3.2 多个源文件的使用 105</span><br><span class="line"></span><br><span class="line">4.3.3 剖析Employee类 106</span><br><span class="line"></span><br><span class="line">4.3.4 从构造器开始 106</span><br><span class="line"></span><br><span class="line">4.3.5 隐式参数与显式参数 108</span><br><span class="line"></span><br><span class="line">4.3.6 封装的优点 109</span><br><span class="line"></span><br><span class="line">4.3.7 基于类的访问权限 111</span><br><span class="line"></span><br><span class="line">4.3.8 私有方法 111</span><br><span class="line"></span><br><span class="line">4.3.9 final实例域 112</span><br><span class="line"></span><br><span class="line">4.4 静态域与静态方法 112</span><br><span class="line"></span><br><span class="line">4.4.1 静态域 112</span><br><span class="line"></span><br><span class="line">4.4.2 静态常量 113</span><br><span class="line"></span><br><span class="line">4.4.3 静态方法 114</span><br><span class="line"></span><br><span class="line">4.4.4 工厂方法 115</span><br><span class="line"></span><br><span class="line">4.4.5 main方法 115</span><br><span class="line"></span><br><span class="line">4.5 方法参数 118</span><br><span class="line"></span><br><span class="line">4.6 对象构造 123</span><br><span class="line"></span><br><span class="line">4.6.1 重载 123</span><br><span class="line"></span><br><span class="line">4.6.2 默认域初始化 123</span><br><span class="line"></span><br><span class="line">4.6.3 无参数的构造器 124</span><br><span class="line"></span><br><span class="line">4.6.4 显式域初始化 125</span><br><span class="line"></span><br><span class="line">4.6.5 参数名 125</span><br><span class="line"></span><br><span class="line">4.6.6 调用另一个构造器 126</span><br><span class="line"></span><br><span class="line">4.6.7 初始化块 127</span><br><span class="line"></span><br><span class="line">4.6.8 对象析构与finalize方法 130</span><br><span class="line"></span><br><span class="line">4.7 包 131</span><br><span class="line"></span><br><span class="line">4.7.1 类的导入 131</span><br><span class="line"></span><br><span class="line">4.7.2 静态导入 133</span><br><span class="line"></span><br><span class="line">4.7.3 将类放入包中 133</span><br><span class="line"></span><br><span class="line">4.7.4 包作用域 136</span><br><span class="line"></span><br><span class="line">4.8 类路径 137</span><br><span class="line"></span><br><span class="line">4.8.1 设置类路径 139</span><br><span class="line"></span><br><span class="line">4.9 文档注释 140</span><br><span class="line"></span><br><span class="line">4.9.1 注释的插入 140</span><br><span class="line"></span><br><span class="line">4.9.2 类注释 140</span><br><span class="line"></span><br><span class="line">4.9.3 方法注释 141</span><br><span class="line"></span><br><span class="line">4.9.4 域注释 142</span><br><span class="line"></span><br><span class="line">4.9.5 通用注释 142</span><br><span class="line"></span><br><span class="line">4.9.6 包与概述注释 143</span><br><span class="line"></span><br><span class="line">4.9.7 注释的抽取 143</span><br><span class="line"></span><br><span class="line">4.10 类设计技巧 144</span><br><span class="line"></span><br><span class="line">第5章 继承 147</span><br><span class="line"></span><br><span class="line">5.1 类、超类和子类 147</span><br><span class="line"></span><br><span class="line">5.1.1 定义子类 147</span><br><span class="line"></span><br><span class="line">5.1.2 覆盖方法 149</span><br><span class="line"></span><br><span class="line">5.1.3 子类构造器 150</span><br><span class="line"></span><br><span class="line">5.1.4 继承层次 153</span><br><span class="line"></span><br><span class="line">5.1.5 多态 154</span><br><span class="line"></span><br><span class="line">5.1.6 理解方法调用 155</span><br><span class="line"></span><br><span class="line">5.1.7 阻止继承：final类和方法 157</span><br><span class="line"></span><br><span class="line">5.1.8 强制类型转换 158</span><br><span class="line"></span><br><span class="line">5.1.9 抽象类 160</span><br><span class="line"></span><br><span class="line">5.1.10 受保护访问 165</span><br><span class="line"></span><br><span class="line">5.2 Object：所有类的超类 166</span><br><span class="line"></span><br><span class="line">5.2.1 equals方法 166</span><br><span class="line"></span><br><span class="line">5.2.2 相等测试与继承 167</span><br><span class="line"></span><br><span class="line">5.2.3 hashCode方法 170</span><br><span class="line"></span><br><span class="line">5.2.4 toString方法 172</span><br><span class="line"></span><br><span class="line">5.3 泛型数组列表 178</span><br><span class="line"></span><br><span class="line">5.3.1 访问数组列表元素 180</span><br><span class="line"></span><br><span class="line">5.3.2 类型化与原始数组列表的兼容性 183</span><br><span class="line"></span><br><span class="line">5.4 对象包装器与自动装箱 184</span><br><span class="line"></span><br><span class="line">5.5 参数数量可变的方法 187</span><br><span class="line"></span><br><span class="line">5.6 枚举类 188</span><br><span class="line"></span><br><span class="line">5.7 反射 190</span><br><span class="line"></span><br><span class="line">5.7.1 Class类 190</span><br><span class="line"></span><br><span class="line">5.7.2 捕获异常 192</span><br><span class="line"></span><br><span class="line">5.7.3 利用反射分析类的能力 194</span><br><span class="line"></span><br><span class="line">5.7.4 在运行时使用反射分析对象 198</span><br><span class="line"></span><br><span class="line">5.7.5 使用反射编写泛型数组代码 202</span><br><span class="line"></span><br><span class="line">5.7.6 调用任意方法 205</span><br><span class="line"></span><br><span class="line">5.8 继承的设计技巧 208</span><br><span class="line"></span><br><span class="line">第6章 接口、lambda表达式与内部类 211</span><br><span class="line"></span><br><span class="line">6.1 接口 211</span><br><span class="line"></span><br><span class="line">6.1.1 接口概念 211</span><br><span class="line"></span><br><span class="line">6.1.2 接口的特性 217</span><br><span class="line"></span><br><span class="line">6.1.3 接口与抽象类 218</span><br><span class="line"></span><br><span class="line">6.1.4 静态方法 218</span><br><span class="line"></span><br><span class="line">6.1.5 默认方法 219</span><br><span class="line"></span><br><span class="line">6.1.6 解决默认方法冲突 220</span><br><span class="line"></span><br><span class="line">6.2 接口示例 222</span><br><span class="line"></span><br><span class="line">6.2.1 接口与回调 222</span><br><span class="line"></span><br><span class="line">6.2.2 Comparator接口 224</span><br><span class="line"></span><br><span class="line">6.2.3 对象克隆 225</span><br><span class="line"></span><br><span class="line">6.3 lambda表达式 231</span><br><span class="line"></span><br><span class="line">6.3.1 为什么引入lambda表达式 231</span><br><span class="line"></span><br><span class="line">6.3.2 lambda表达式的语法 232</span><br><span class="line"></span><br><span class="line">6.3.3 函数式接口 234</span><br><span class="line"></span><br><span class="line">6.3.4 方法引用 235</span><br><span class="line"></span><br><span class="line">6.3.5 构造器引用 237</span><br><span class="line"></span><br><span class="line">6.3.6 变量作用域 237</span><br><span class="line"></span><br><span class="line">6.3.7 处理lambda表达式 239</span><br><span class="line"></span><br><span class="line">6.3.8 再谈Comparator 242</span><br><span class="line"></span><br><span class="line">6.4 内部类 242</span><br><span class="line"></span><br><span class="line">6.4.1 使用内部类访问对象状态 244</span><br><span class="line"></span><br><span class="line">6.4.2 内部类的特殊语法规则 247</span><br><span class="line"></span><br><span class="line">6.4.3 内部类是否有用、必要和安全 248</span><br><span class="line"></span><br><span class="line">6.4.4 局部内部类 250</span><br><span class="line"></span><br><span class="line">6.4.5 由外部方法访问变量 250</span><br><span class="line"></span><br><span class="line">6.4.6 匿名内部类 252</span><br><span class="line"></span><br><span class="line">6.4.7 静态内部类 255</span><br><span class="line"></span><br><span class="line">6.5 代理 258</span><br><span class="line"></span><br><span class="line">6.5.1 何时使用代理 259</span><br><span class="line"></span><br><span class="line">6.5.2 创建代理对象 259</span><br><span class="line"></span><br><span class="line">6.5.3 代理类的特性 262</span><br><span class="line"></span><br><span class="line">第7章 异常、断言和日志 264</span><br><span class="line"></span><br><span class="line">7.1 处理错误 264</span><br><span class="line"></span><br><span class="line">7.1.1 异常分类 265</span><br><span class="line"></span><br><span class="line">7.1.2 声明受查异常 267</span><br><span class="line"></span><br><span class="line">7.1.3 如何抛出异常 269</span><br><span class="line"></span><br><span class="line">7.1.4 创建异常类 270</span><br><span class="line"></span><br><span class="line">7.2 捕获异常 271</span><br><span class="line"></span><br><span class="line">7.2.1 捕获异常 271</span><br><span class="line"></span><br><span class="line">7.2.2 捕获多个异常 273</span><br><span class="line"></span><br><span class="line">7.2.3 再次抛出异常与异常链 274</span><br><span class="line"></span><br><span class="line">7.2.4 finally子句 275</span><br><span class="line"></span><br><span class="line">7.2.5 带资源的try语句 278</span><br><span class="line"></span><br><span class="line">7.2.6 分析堆栈轨迹元素 280</span><br><span class="line"></span><br><span class="line">7.3 使用异常机制的技巧 282</span><br><span class="line"></span><br><span class="line">7.4 使用断言 285</span><br><span class="line"></span><br><span class="line">7.4.1 断言的概念 285</span><br><span class="line"></span><br><span class="line">7.4.2 启用和禁用断言 286</span><br><span class="line"></span><br><span class="line">7.4.3 使用断言完成参数检查 287</span><br><span class="line"></span><br><span class="line">7.4.4 为文档假设使用断言 288</span><br><span class="line"></span><br><span class="line">7.5 记录日志 289</span><br><span class="line"></span><br><span class="line">7.5.1 基本日志 289</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术卷2第8版 PDF</title>
    <url>/posts/45d7fe52/</url>
    <content><![CDATA[<h4 id="《Java核心技术卷2第8版》"><a href="#《Java核心技术卷2第8版》" class="headerlink" title="《Java核心技术卷2第8版》"></a>《Java核心技术卷2第8版》</h4><h6 id="链接-https-pan-baidu-com-s-1hwW2u-FhrUaZGxSgLEtGlg-提取码-x58i"><a href="#链接-https-pan-baidu-com-s-1hwW2u-FhrUaZGxSgLEtGlg-提取码-x58i" class="headerlink" title="链接: https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg 提取码: x58i"></a>链接: <a href="https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg">https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg</a> 提取码: x58i</h6><p><img src="/images/245331e9bd0ded1bdc349955247dc2e21.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p>本书是Java[令页]域有影响力和价值的著作之一，由拥有20多年教[0学0]与研究[纟巠]验的Java技术专家撰写（获Jolt[0大0]奖），与《Java编程思想》齐[0名0]，10余年全球[0畅0]销不衰，广受[女子][0评0]。[0第0]10版根据JavaSE8全[mian]更[亲斤]，同时修正了[0第0]9版中的不足，系统全[mian]讲解了Java语言的核心概念、语[0法0]、重要特性和开发方[0法0]，包含[0大0]量案例，实践性强。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">[0第0]1章　Java SE 8的流库 1</span><br><span class="line"></span><br><span class="line">1.1　从迭代到流的操作 1</span><br><span class="line"></span><br><span class="line">1.2　流的创建 3</span><br><span class="line"></span><br><span class="line">1.3　filter、map和flatMap方[0法0] 6</span><br><span class="line"></span><br><span class="line">1.4　抽取子流和连接流 8</span><br><span class="line"></span><br><span class="line">1.5　其他的流转换 8</span><br><span class="line"></span><br><span class="line">1.6　简单约简 9</span><br><span class="line"></span><br><span class="line">1.7　Optional类型 11</span><br><span class="line"></span><br><span class="line">1.7.1　如何使用Optional值 11</span><br><span class="line"></span><br><span class="line">1.7.2　不适合使用Optional值的方式 12</span><br><span class="line"></span><br><span class="line">1.7.3　创建Optional值 13</span><br><span class="line"></span><br><span class="line">1.7.4　用flatMap来构建Optional值的函数 13</span><br><span class="line"></span><br><span class="line">1.8　收集结果 15</span><br><span class="line"></span><br><span class="line">1.9　收集到映[身寸]表中 19</span><br><span class="line"></span><br><span class="line">1.10　群组和分区 23</span><br><span class="line"></span><br><span class="line">1.11　下游收集器 24</span><br><span class="line"></span><br><span class="line">1.12　约简操作 28</span><br><span class="line"></span><br><span class="line">1.13　基本类型流 29</span><br><span class="line"></span><br><span class="line">1.14　并行流 34</span><br><span class="line"></span><br><span class="line">[0第0]2章　输入与输出 39</span><br><span class="line"></span><br><span class="line">2.1　输入&#x2F;输出流 39</span><br><span class="line"></span><br><span class="line">2.1.1　读写字节 39</span><br><span class="line"></span><br><span class="line">2.1.2　完整的流家族 42</span><br><span class="line"></span><br><span class="line">2.1.3　组合输入&#x2F;输出流过滤器 45</span><br><span class="line"></span><br><span class="line">2.2　文本输入与输出 48</span><br><span class="line"></span><br><span class="line">2.2.1　如何写出文本输出 49</span><br><span class="line"></span><br><span class="line">2.2.2　如何读入文本输入 51</span><br><span class="line"></span><br><span class="line">2.2.3　以文本格式存储对象 52</span><br><span class="line"></span><br><span class="line">2.2.4　字符编码方式 55</span><br><span class="line"></span><br><span class="line">2.3　读写二进制数据 57</span><br><span class="line"></span><br><span class="line">2.3.1　DataInput和DataOutput接口 57</span><br><span class="line"></span><br><span class="line">2.3.2　随[1机1]访问文[亻牛] 59</span><br><span class="line"></span><br><span class="line">2.3.3　ZIP文档 63</span><br><span class="line"></span><br><span class="line">2.4　对象输入&#x2F;输出流与序列化 66</span><br><span class="line"></span><br><span class="line">2.4.1　保存和加载序列化对象 66</span><br><span class="line"></span><br><span class="line">2.4.2　理解对象序列化的文[亻牛]格式 70</span><br><span class="line"></span><br><span class="line">2.4.3　修改默认的序列化[1机1]制 75</span><br><span class="line"></span><br><span class="line">2.4.4　序列化单例和类型安全的枚举 77</span><br><span class="line"></span><br><span class="line">2.4.5　版本管理 78</span><br><span class="line"></span><br><span class="line">2.4.6　为克隆使用序列化 80</span><br><span class="line"></span><br><span class="line">2.5　操作文[亻牛] 83</span><br><span class="line"></span><br><span class="line">2.5.1　Path 83</span><br><span class="line"></span><br><span class="line">2.5.2　读写文[亻牛] 85</span><br><span class="line"></span><br><span class="line">2.5.3　创建文[亻牛]和目录 87</span><br><span class="line"></span><br><span class="line">2.5.4　复制、移动和删除文[亻牛] 88</span><br><span class="line"></span><br><span class="line">2.5.5　获取文[亻牛]信息 89</span><br><span class="line"></span><br><span class="line">2.5.6　访问目录中的项 91</span><br><span class="line"></span><br><span class="line">2.5.7　使用目录流 92</span><br><span class="line"></span><br><span class="line">2.5.8　ZIP文[亻牛]系统 95</span><br><span class="line"></span><br><span class="line">2.6　内存映[身寸]文[亻牛] 96</span><br><span class="line"></span><br><span class="line">2.6.1　内存映[身寸]文[亻牛]的性能 96</span><br><span class="line"></span><br><span class="line">2.6.2　缓冲区数据结构 103</span><br><span class="line"></span><br><span class="line">2.6.3　文[亻牛]加锁[1机1]制 105</span><br><span class="line"></span><br><span class="line">2.7　正则表达式 106</span><br><span class="line"></span><br><span class="line">[0第0]3章　XML 117</span><br><span class="line"></span><br><span class="line">3.1　XML概述 117</span><br><span class="line"></span><br><span class="line">3.1.1　XML文档的结构 119</span><br><span class="line"></span><br><span class="line">3.2　解析XML文档 122</span><br><span class="line"></span><br><span class="line">3.3　验证XML文档 132</span><br><span class="line"></span><br><span class="line">3.3.1　文档类型定义 133</span><br><span class="line"></span><br><span class="line">3.3.2　XML Schema 139</span><br><span class="line"></span><br><span class="line">3.3.3　实用示例 142</span><br><span class="line"></span><br><span class="line">3.4　使用XPath来定位信息 154</span><br><span class="line"></span><br><span class="line">3.5　使用命[0名0]空间 159</span><br><span class="line"></span><br><span class="line">3.6　流[1机1]制解析器 162</span><br><span class="line"></span><br><span class="line">3.6.1　使用SAX解析器 162</span><br><span class="line"></span><br><span class="line">3.6.2　使用StAX解析器 166</span><br><span class="line"></span><br><span class="line">3.7　生成XML文档 170</span><br><span class="line"></span><br><span class="line">3.7.1　不带命[0名0]空间的文档 170</span><br><span class="line"></span><br><span class="line">3.7.2　带命[0名0]空间的文档 170</span><br><span class="line"></span><br><span class="line">3.7.3　写出文档 171</span><br><span class="line"></span><br><span class="line">3.7.4　示例：生成SVG文[亻牛] 172</span><br><span class="line"></span><br><span class="line">3.7.5　使用StAX写出XML文档 174</span><br><span class="line"></span><br><span class="line">3.8　XSL转换 181</span><br><span class="line"></span><br><span class="line">[0第0]4章　网络 191</span><br><span class="line"></span><br><span class="line">4.1　连接到服务器 191</span><br><span class="line"></span><br><span class="line">4.1.1　使用telnet 191</span><br><span class="line"></span><br><span class="line">4.1.2　用Java连接到服务器 193</span><br><span class="line"></span><br><span class="line">4.1.3　套接字[0超0]时 195</span><br><span class="line"></span><br><span class="line">4.1.4　因特网地址 196</span><br><span class="line"></span><br><span class="line">4.2　实现服务器 198</span><br><span class="line"></span><br><span class="line">4.2.1　服务器套接字 198</span><br><span class="line"></span><br><span class="line">4.2.2　为多个客户端服务 201</span><br><span class="line"></span><br><span class="line">4.2.3　半关闭 204</span><br><span class="line"></span><br><span class="line">4.3　可中断套接字 205</span><br><span class="line"></span><br><span class="line">4.4　获取Web数 211</span><br><span class="line"></span><br><span class="line">4.4.1　URL和URI 211</span><br><span class="line"></span><br><span class="line">4.4.2　使用URLConnection获取信息 213</span><br><span class="line"></span><br><span class="line">4.4.3　[扌是]交表单数据 220</span><br><span class="line"></span><br><span class="line">4.5　发送E-mail 228</span><br><span class="line"></span><br><span class="line">[0第0]5章　数据库编程 232</span><br><span class="line"></span><br><span class="line">5.1　JDBC的设计 232</span><br><span class="line"></span><br><span class="line">5.1.1　JDBC驱动程序类型 233</span><br><span class="line"></span><br><span class="line">5.1.2　JDBC的典型用[0法0] 234</span><br><span class="line"></span><br><span class="line">5.2　结构化查询语言 234</span><br><span class="line"></span><br><span class="line">5.3　JDBC配置 239</span><br><span class="line"></span><br><span class="line">5.3.1　数据库URL 240</span><br><span class="line"></span><br><span class="line">5.3.2　驱动程序JAR文[亻牛] 240</span><br><span class="line"></span><br><span class="line">5.3.3　启动数据库 240</span><br><span class="line"></span><br><span class="line">5.3.4　注册驱动器类 241</span><br><span class="line"></span><br><span class="line">5.3.5　连接到数据库 242</span><br><span class="line"></span><br><span class="line">5.4　使用JDBC语句 244</span><br><span class="line"></span><br><span class="line">5.4.1　执行SQL语句 244</span><br><span class="line"></span><br><span class="line">5.4.2　管理连接、语句和结果集 247</span><br><span class="line"></span><br><span class="line">5.4.3　分析SQL异常 248</span><br><span class="line"></span><br><span class="line">5.4.4　组装数据库 250</span><br><span class="line"></span><br><span class="line">5.5　执行查询操作 254</span><br><span class="line"></span><br><span class="line">5.5.1　预备语句 254</span><br><span class="line"></span><br><span class="line">5.5.2　读写LOB 259</span><br><span class="line"></span><br><span class="line">5.5.3　SQL转义 261</span><br><span class="line"></span><br><span class="line">5.5.4　多结果集 262</span><br><span class="line"></span><br><span class="line">5.5.5　获取自动生成的键 263</span><br><span class="line"></span><br><span class="line">5.6　可滚动和可更[亲斤]的结果集 263</span><br><span class="line"></span><br><span class="line">5.6.1　可滚动的结果集 264</span><br><span class="line"></span><br><span class="line">5.6.2　可更[亲斤]的结果集 266</span><br><span class="line"></span><br><span class="line">5.7　行集 269</span><br><span class="line"></span><br><span class="line">5.7.1　构建行集 270</span><br><span class="line"></span><br><span class="line">5.7.2　被缓存的行集 270</span><br><span class="line"></span><br><span class="line">5.8　元数据 273</span><br><span class="line"></span><br><span class="line">5.9　事务 282</span><br><span class="line"></span><br><span class="line">5.9.1　用JDBC对事务编程 282</span><br><span class="line"></span><br><span class="line">5.9.2　保存点 283</span><br><span class="line"></span><br><span class="line">5.9.3　批量更[亲斤] 283</span><br><span class="line"></span><br><span class="line">5.10　高级SQL类型 285</span><br><span class="line"></span><br><span class="line">5.11　Web与企业应用中的连接管理 286</span><br><span class="line"></span><br><span class="line">[0第0]6章　日期和时间API 288</span><br><span class="line"></span><br><span class="line">6.1　时间线 288</span><br><span class="line"></span><br><span class="line">6.2　本地时间 291</span><br><span class="line"></span><br><span class="line">6.3　日期调整器 294</span><br><span class="line"></span><br><span class="line">6.4　本地时间 295</span><br><span class="line"></span><br><span class="line">6.5　时区时间 296</span><br><span class="line"></span><br><span class="line">6.6　格式化和解析 299</span><br><span class="line"></span><br><span class="line">6.7　与遗留代码的互操作 302</span><br><span class="line"></span><br><span class="line">[0第0]7章　[0国0]际化 304</span><br><span class="line"></span><br><span class="line">7.1　Locale对象 304</span><br><span class="line"></span><br><span class="line">7.2　数字格式 309</span><br><span class="line"></span><br><span class="line">7.3　货币 314</span><br><span class="line"></span><br><span class="line">7.4　日期和时间 315</span><br><span class="line"></span><br><span class="line">7.5　排序和范化 321</span><br><span class="line"></span><br><span class="line">7.6　消息格式化 327</span><br><span class="line"></span><br><span class="line">7.6.1　格式化数字和日期 327</span><br><span class="line"></span><br><span class="line">7.6.2　选择格式 329</span><br><span class="line"></span><br><span class="line">7.7　文本文[亻牛]和字符集 331</span><br><span class="line"></span><br><span class="line">7.7.1　文本文[亻牛] 331</span><br><span class="line"></span><br><span class="line">7.7.2　行结束符 331</span><br><span class="line"></span><br><span class="line">7.7.3　控制台 331</span><br><span class="line"></span><br><span class="line">7.7.4　日志文[亻牛] 332</span><br><span class="line"></span><br><span class="line">7.7.5　UTF-8字节顺序标志 332</span><br><span class="line"></span><br><span class="line">7.7.6　源文[亻牛]的字符编码 333</span><br><span class="line"></span><br><span class="line">7.8　资源包 333</span><br><span class="line"></span><br><span class="line">7.8.1　定位资源包 334</span><br><span class="line"></span><br><span class="line">7.8.2　属性文[亻牛] 335</span><br><span class="line"></span><br><span class="line">7.8.3　包类 335</span><br><span class="line"></span><br><span class="line">7.9　一个完整的例子 337</span><br><span class="line"></span><br><span class="line">[0第0]8章　脚本、编译与注解处理 352</span><br><span class="line"></span><br><span class="line">8.1　Java平台的脚本 352</span><br><span class="line"></span><br><span class="line">8.1.1　获取脚本引擎 352</span><br><span class="line"></span><br><span class="line">8.1.2　脚本赋值与绑定 353</span><br><span class="line"></span><br><span class="line">8.1.3　重定向输入和输出 355</span><br><span class="line"></span><br><span class="line">8.1.4　调用脚本的函数和方[0法0] 356</span><br><span class="line"></span><br><span class="line">8.1.5　编译脚本 357</span><br><span class="line"></span><br><span class="line">8.1.6　一个示例：用脚本处理GUI事[亻牛] 358</span><br><span class="line"></span><br><span class="line">8.2　编译器API 363</span><br><span class="line"></span><br><span class="line">8.2.1　编译便捷之[0法0] 363</span><br><span class="line"></span><br><span class="line">8.2.2　使用编译工具 363</span><br><span class="line"></span><br><span class="line">8.2.3　一个示例：动态Java代码生成 368</span><br><span class="line"></span><br><span class="line">8.3　使用注解 373</span><br><span class="line"></span><br><span class="line">8.3.1　注解简介 373</span><br><span class="line"></span><br><span class="line">8.3.2　一个示例：注解事[亻牛]处理器 374</span><br><span class="line"></span><br><span class="line">8.4　注解语[0法0] 379</span><br><span class="line"></span><br><span class="line">8.4.1　注解接口 379</span><br><span class="line"></span><br><span class="line">8.4.2　注解 380</span><br><span class="line"></span><br><span class="line">8.4.3　注解各类声明 382</span><br><span class="line"></span><br><span class="line">8.4.4　注解类型用[0法0] 383</span><br><span class="line"></span><br><span class="line">8.4.5　注解this 384</span><br><span class="line"></span><br><span class="line">8.5　标准注解 385</span><br><span class="line"></span><br><span class="line">8.5.1　用于编译的注解 386</span><br><span class="line"></span><br><span class="line">8.5.2　用于管理资源的注解 386</span><br><span class="line"></span><br><span class="line">8.5.3　元注解 387</span><br><span class="line"></span><br><span class="line">8.6　源码级注解处理 389</span><br><span class="line"></span><br><span class="line">8.6.1　注解处理 389</span><br><span class="line"></span><br><span class="line">8.6.2　语言模型API 390</span><br><span class="line"></span><br><span class="line">8.6.3　使用注解来生成源码 390</span><br><span class="line"></span><br><span class="line">8.7　字节码工程 393</span><br><span class="line"></span><br><span class="line">8.7.1　修改类文[亻牛] 393</span><br><span class="line"></span><br><span class="line">8.7.2　在加载时修改字节码 398</span><br><span class="line"></span><br><span class="line">[0第0]9章　安全 401</span><br><span class="line"></span><br><span class="line">9.1　类加载器 401</span><br><span class="line"></span><br><span class="line">9.1.1　类加载过程 402</span><br><span class="line"></span><br><span class="line">9.1.2　类加载器的层次结构 403</span><br><span class="line"></span><br><span class="line">9.1.3　将类加载器作为命[0名0]空间 404</span><br><span class="line"></span><br><span class="line">9.1.4　编写你自己的类加载器 405</span><br><span class="line"></span><br><span class="line">9.1.5　字节码校验 410</span><br><span class="line"></span><br><span class="line">9.2　安全管理器与访问[0权0]限 414</span><br><span class="line"></span><br><span class="line">9.2.1　[0权0]限检查 414</span><br><span class="line"></span><br><span class="line">9.2.2　Java平台安全性 415</span><br><span class="line"></span><br><span class="line">9.2.3　安全策略文[亻牛] 418</span><br><span class="line"></span><br><span class="line">9.2.4　定制[0权0]限 424</span><br><span class="line"></span><br><span class="line">9.2.5　实现[0权0]限类 426</span><br><span class="line"></span><br><span class="line">9.3　用户认证 431</span><br><span class="line"></span><br><span class="line">9.3.1　JAAS框架 431</span><br><span class="line"></span><br><span class="line">9.3.2　JAAS登录模块 437</span><br><span class="line"></span><br><span class="line">9.4　数字签[0名0] 445</span><br><span class="line"></span><br><span class="line">9.4.1　消息摘要 445</span><br><span class="line"></span><br><span class="line">9.4.2　消息签[0名0] 448</span><br><span class="line"></span><br><span class="line">9.4.3　校验签[0名0] 449</span><br><span class="line"></span><br><span class="line">9.4.4　认证问题 452</span><br><span class="line"></span><br><span class="line">9.4.5　证书签[0名0] 454</span><br><span class="line"></span><br><span class="line">9.4.6　证书请求 454</span><br><span class="line"></span><br><span class="line">9.4.7　代码签[0名0] 455</span><br><span class="line"></span><br><span class="line">9.5　加密 460</span><br><span class="line"></span><br><span class="line">9.5.1　对称密码 461</span><br><span class="line"></span><br><span class="line">9.5.2　密钥生成 462</span><br><span class="line"></span><br><span class="line">9.5.3　密码流 466</span><br><span class="line"></span><br><span class="line">9.5.4　公共密钥密码 467</span><br><span class="line"></span><br><span class="line">[0第0]10章　高级Swing 472</span><br><span class="line"></span><br><span class="line">10.1　列表 472</span><br><span class="line"></span><br><span class="line">10.1.1　JList构[亻牛] 472</span><br><span class="line"></span><br><span class="line">10.1.2　列表模式 477</span><br><span class="line"></span><br><span class="line">10.1.3　插入和移除值 481</span><br><span class="line"></span><br><span class="line">10.1.4　值的绘制 482</span><br><span class="line"></span><br><span class="line">10.2　表格 486</span><br><span class="line"></span><br><span class="line">10.2.1　简单表格 486</span><br><span class="line"></span><br><span class="line">10.2.2　表格模型 489</span><br><span class="line"></span><br><span class="line">10.2.3　对行和列的操作 493</span><br><span class="line"></span><br><span class="line">10.2.4　单元格的绘制和编辑 506</span><br><span class="line"></span><br><span class="line">10.3　树 517</span><br><span class="line"></span><br><span class="line">10.3.1　简单的树 518</span><br><span class="line"></span><br><span class="line">10.3.2　编辑树和树的路径 524</span><br><span class="line"></span><br><span class="line">10.3.3　节点枚举 530</span><br><span class="line"></span><br><span class="line">10.3.4　绘制节点 532</span><br><span class="line"></span><br><span class="line">10.3.5　监听树事[亻牛] 534</span><br><span class="line"></span><br><span class="line">10.3.6　定制树模型 541</span><br><span class="line"></span><br><span class="line">10.4　文本构[亻牛] 548</span><br><span class="line"></span><br><span class="line">10.4.1　文本构[亻牛]中的修改跟踪 549</span><br><span class="line"></span><br><span class="line">10.4.2　格式化的输入框 552</span><br><span class="line"></span><br><span class="line">10.4.3　JSpinner构[亻牛] 567</span><br><span class="line"></span><br><span class="line">10.4.4　用JEditorPane显示HTML 574</span><br><span class="line"></span><br><span class="line">10.5　进度指示器 579</span><br><span class="line"></span><br><span class="line">10.5.1　进度条 580</span><br><span class="line"></span><br><span class="line">10.5.2　进度监视器 582</span><br><span class="line"></span><br><span class="line">10.5.3　监视输入流的进度 585</span><br><span class="line"></span><br><span class="line">10.6　构[亻牛]组织器和装饰器 590</span><br><span class="line"></span><br><span class="line">10.6.1　分割[mian]板 590</span><br><span class="line"></span><br><span class="line">10.6.2　选项卡[mian]板 592</span><br><span class="line"></span><br><span class="line">10.6.3　桌[mian][mian]板和内部框体 597</span><br><span class="line"></span><br><span class="line">10.6.4　层 613</span><br><span class="line"></span><br><span class="line">[0第0]11章　高级AWT 618</span><br><span class="line"></span><br><span class="line">11.1　绘图操作流程 618</span><br><span class="line"></span><br><span class="line">11.2　形状 620</span><br><span class="line"></span><br><span class="line">11.2.1　形状类层次结构 621</span><br><span class="line"></span><br><span class="line">11.2.2　使用形状类 623</span><br><span class="line"></span><br><span class="line">11.3　区域 634</span><br><span class="line"></span><br><span class="line">11.4　笔划 635</span><br><span class="line"></span><br><span class="line">11.5　着色 642</span><br><span class="line"></span><br><span class="line">11.6　坐标变换 644</span><br><span class="line"></span><br><span class="line">11.7　剪切 648</span><br><span class="line"></span><br><span class="line">11.8　透明与组合 650</span><br><span class="line"></span><br><span class="line">11.9　绘图[扌是]示 657</span><br><span class="line"></span><br><span class="line">11.10　图像的读取器和写入器 663</span><br><span class="line"></span><br><span class="line">11.10.1　获得适合图像文[亻牛]类型的读取器和写入器 663</span><br><span class="line"></span><br><span class="line">11.10.2　读取和写入带有多个图像的文[亻牛] 664</span><br><span class="line"></span><br><span class="line">11.11　图像处理 671</span><br><span class="line"></span><br><span class="line">11.11.1　构建[1光1]栅图像 672</span><br><span class="line"></span><br><span class="line">11.11.2　图像过滤 678</span><br><span class="line"></span><br><span class="line">11.12　打印 685</span><br><span class="line"></span><br><span class="line">11.12.1　图形打印 685</span><br><span class="line"></span><br><span class="line">11.12.2　打印多页文[亻牛] 693</span><br><span class="line"></span><br><span class="line">11.12.3　打印预览 694</span><br><span class="line"></span><br><span class="line">11.12.4　打印服务程序 702</span><br><span class="line"></span><br><span class="line">11.12.5　流打印服务程序 706</span><br><span class="line"></span><br><span class="line">11.12.6　打印属性 707</span><br><span class="line"></span><br><span class="line">11.13　剪贴板 712</span><br><span class="line"></span><br><span class="line">11.13.1　用于数据传递的类和接口 713</span><br><span class="line"></span><br><span class="line">11.13.2　传递文本 714</span><br><span class="line"></span><br><span class="line">11.13.3　Transferable接口和数据风格 717</span><br><span class="line"></span><br><span class="line">11.13.4　构建一个可传递的图像 718</span><br><span class="line"></span><br><span class="line">11.13.5　通过系统剪贴板传递Java对象 722</span><br><span class="line"></span><br><span class="line">11.13.6　使用本地剪贴板来传递对象引用 725</span><br><span class="line"></span><br><span class="line">11.14　拖放操作 725</span><br><span class="line"></span><br><span class="line">11.14.1　Swing对数据传递的支持 726</span><br><span class="line"></span><br><span class="line">11.14.2　拖曳源 730</span><br><span class="line"></span><br><span class="line">11.14.3　放置目标 732</span><br><span class="line"></span><br><span class="line">11.15　平台集成 739</span><br><span class="line"></span><br><span class="line">11.15.1　闪屏 739</span><br><span class="line"></span><br><span class="line">11.15.2　启动桌[mian]应用程序 743</span><br><span class="line"></span><br><span class="line">11.15.3　系统托盘 748</span><br><span class="line"></span><br><span class="line">[0第0]12章　本地方[0法0] 752</span><br><span class="line"></span><br><span class="line">12.1　从Java程序中调用C函数 752</span><br><span class="line"></span><br><span class="line">12.2　数值参数与返回值 757</span><br><span class="line"></span><br><span class="line">12.3　字符串参数 759</span><br><span class="line"></span><br><span class="line">12.4　访问域 764</span><br><span class="line"></span><br><span class="line">12.4.1　访问实例域 765</span><br><span class="line"></span><br><span class="line">12.4.2　访问静态域 768</span><br><span class="line"></span><br><span class="line">12.5　编码签[0名0] 769</span><br><span class="line"></span><br><span class="line">12.6　调用Java方[0法0] 770</span><br><span class="line"></span><br><span class="line">12.6.1　实例方[0法0] 771</span><br><span class="line"></span><br><span class="line">12.6.2　静态方[0法0] 774</span><br><span class="line"></span><br><span class="line">12.6.3　构造器 775</span><br><span class="line"></span><br><span class="line">12.6.4　另一种方[0法0]调用 775</span><br><span class="line"></span><br><span class="line">12.7　访问数组元素 777</span><br><span class="line"></span><br><span class="line">12.8　错误处理 780</span><br><span class="line"></span><br><span class="line">12.9　使用调用API 785</span><br><span class="line"></span><br><span class="line">12.10　完整的示例：访问Windows注册表 789</span><br><span class="line"></span><br><span class="line">12.10.1　Windows注册表概述 789</span><br><span class="line"></span><br><span class="line">12.10.2　访问注册表的Java平台接口 791</span><br><span class="line"></span><br><span class="line">12.10.3　以本地方[0法0]方式实现注册表访问函数 791</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java数据结构和算法_第二版 PDF</title>
    <url>/posts/32d0cec4/</url>
    <content><![CDATA[<h4 id="《Java数据结构和算法-第二版》"><a href="#《Java数据结构和算法-第二版》" class="headerlink" title="《Java数据结构和算法_第二版》"></a>《Java数据结构和算法_第二版》</h4><h6 id="链接-https-pan-baidu-com-s-1KAd08i5FTs7FaBazCq3NBw-提取码-f6y5"><a href="#链接-https-pan-baidu-com-s-1KAd08i5FTs7FaBazCq3NBw-提取码-f6y5" class="headerlink" title="链接: https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw 提取码: f6y5"></a>链接: <a href="https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw">https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw</a> 提取码: f6y5</h6><p>本书以一种易懂的方式教授如何安排和操纵数据，其中不乏一些难题；了解这些知识以期使计算机的应用获得佳性能。不管使用何种语言或平台，掌握了数据结构和算法将改进程序的质量和性能。<br><a id="more"></a></p>
<p>　　本书提供了一套的可视讨论专题用以阐明主要的论题；它使用Java 语言说明重要的概念，而避免了C/C 语言的复杂性，以便集中精力论述数据结构和算法。</p>
<p>　　经验丰富的作者Robert Lafore先生提供了许多简单明了的例子。避免了对于这类命题常见的冗长、繁琐的数学证明。在第二版中，他利用Java语言新特性，修改并扩充了书中的例子。在每一章后都有问题和练习，使读者有机会测试自己的理解程度。</p>
<p><img src="/images/74bf5669945549bad8e0d446144c2ac61.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">Introduction</span><br><span class="line"></span><br><span class="line">What’S New in the Second Edition</span><br><span class="line"></span><br><span class="line">Additional Topics</span><br><span class="line"></span><br><span class="line">End-of-Chapter Questions</span><br><span class="line"></span><br><span class="line">Experiments</span><br><span class="line"></span><br><span class="line">Programming Projects</span><br><span class="line"></span><br><span class="line">What This Book Is About</span><br><span class="line"></span><br><span class="line">What’S Different About This Book</span><br><span class="line"></span><br><span class="line">Easy tO Understand</span><br><span class="line"></span><br><span class="line">Workshop Applets</span><br><span class="line"></span><br><span class="line">Java Example Code</span><br><span class="line"></span><br><span class="line">Who This BookIs For</span><br><span class="line"></span><br><span class="line">What YoU Need to Know Before You Read This Book</span><br><span class="line"></span><br><span class="line">The Software You Need to Use This Book</span><br><span class="line"></span><br><span class="line">How This Book Is Organized</span><br><span class="line"></span><br><span class="line">Enjoy Yourself!</span><br><span class="line"></span><br><span class="line">1 Overvlew</span><br><span class="line"></span><br><span class="line">What Are Data Structures and Algorithms Good For?</span><br><span class="line"></span><br><span class="line">Real-World Data Storage</span><br><span class="line"></span><br><span class="line">Programmer’S Tools</span><br><span class="line"></span><br><span class="line">Real-World Modeling</span><br><span class="line"></span><br><span class="line">Overview of Data Structures</span><br><span class="line"></span><br><span class="line">Overview of Algorithms</span><br><span class="line"></span><br><span class="line">Some Definitions</span><br><span class="line"></span><br><span class="line">Database</span><br><span class="line"></span><br><span class="line">Record</span><br><span class="line"></span><br><span class="line">Field</span><br><span class="line"></span><br><span class="line">Key</span><br><span class="line"></span><br><span class="line">Object-Oriented Programming</span><br><span class="line"></span><br><span class="line">Problems with Procedural Languages</span><br><span class="line"></span><br><span class="line">Objects in a Nutshell</span><br><span class="line"></span><br><span class="line">A Runnable Object-Oriented Program</span><br><span class="line"></span><br><span class="line">Inheritance and Polymorphism</span><br><span class="line"></span><br><span class="line">Software Engineering</span><br><span class="line"></span><br><span class="line">Java for C Programmers</span><br><span class="line"></span><br><span class="line">No Pointers</span><br><span class="line"></span><br><span class="line">Overloaded Operators</span><br><span class="line"></span><br><span class="line">Primitive Variable Types</span><br><span class="line"></span><br><span class="line">Input／Output</span><br><span class="line"></span><br><span class="line">Java Library Data Structures</span><br><span class="line"></span><br><span class="line">Summary</span><br><span class="line"></span><br><span class="line">Questions</span><br><span class="line"></span><br><span class="line">2 Arrays</span><br><span class="line"></span><br><span class="line">The Array Workshop Applet</span><br><span class="line"></span><br><span class="line">Insertion</span><br><span class="line"></span><br><span class="line">Searching</span><br><span class="line"></span><br><span class="line">Deletion</span><br><span class="line"></span><br><span class="line">The Duplicates Issue</span><br><span class="line"></span><br><span class="line">NOtTbo Swift</span><br><span class="line"></span><br><span class="line">The Basics of Arrays in Iava</span><br><span class="line"></span><br><span class="line">Creating an Array</span><br><span class="line"></span><br><span class="line">Accessing Array Elements</span><br><span class="line"></span><br><span class="line">InitializatiOn</span><br><span class="line"></span><br><span class="line">An Array Example</span><br><span class="line"></span><br><span class="line">Dividing a Program into Classes</span><br><span class="line"></span><br><span class="line">Classes LowArray and LowArrayApp</span><br><span class="line"></span><br><span class="line">Class Interfaces</span><br><span class="line"></span><br><span class="line">NOt SO Convenient</span><br><span class="line"></span><br><span class="line">Who’s Responsible for What?</span><br><span class="line"></span><br><span class="line">The highArray．j ava Example</span><br><span class="line"></span><br><span class="line">The User’s Life Made Easier</span><br><span class="line"></span><br><span class="line">Abstraction</span><br><span class="line"></span><br><span class="line">The Ordered Workshop Applet</span><br><span class="line"></span><br><span class="line">Linear Search</span><br><span class="line"></span><br><span class="line">Binary Search</span><br><span class="line"></span><br><span class="line">Java Code for an Ordered Array</span><br><span class="line"></span><br><span class="line">Binary Search with the findMethod</span><br><span class="line"></span><br><span class="line">The OrdArray Class</span><br><span class="line"></span><br><span class="line">Advantages of Ordered Arrays</span><br><span class="line"></span><br><span class="line">Logarithms</span><br><span class="line"></span><br><span class="line">The Equation</span><br><span class="line"></span><br><span class="line">The Opposite of Raising Two to a Power</span><br><span class="line"></span><br><span class="line">3 Simple Sorting</span><br><span class="line"></span><br><span class="line">4 Stacks and Queues</span><br><span class="line"></span><br><span class="line">5 Linked Lists</span><br><span class="line"></span><br><span class="line">6 Recursion</span><br><span class="line"></span><br><span class="line">7 Advanced Sorting</span><br><span class="line"></span><br><span class="line">8 Binary Trees</span><br><span class="line"></span><br><span class="line">9 Red-Black Trees</span><br><span class="line"></span><br><span class="line">10 2-3-4 Trees and External Storage</span><br><span class="line"></span><br><span class="line">11 Hash Tables</span><br><span class="line"></span><br><span class="line">12 Heaps</span><br><span class="line"></span><br><span class="line">13 Graphs</span><br><span class="line"></span><br><span class="line">14 Weighted Graphs</span><br><span class="line"></span><br><span class="line">15 When to Use What</span><br><span class="line"></span><br><span class="line">Appendixes</span><br><span class="line"></span><br><span class="line">A Running the Workshop Applets and Example Programs</span><br><span class="line"></span><br><span class="line">B Further Reading</span><br><span class="line"></span><br><span class="line">C Answers to Questions</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java性能优化权威指南 PDF</title>
    <url>/posts/acb45b67/</url>
    <content><![CDATA[<h4 id="《Java性能优化权威指南》"><a href="#《Java性能优化权威指南》" class="headerlink" title="《Java性能优化权威指南》"></a>《Java性能优化权威指南》</h4><h6 id="链接-https-pan-baidu-com-s-1EuoHKZVa1zBympW96KFkUw-提取码-8emi"><a href="#链接-https-pan-baidu-com-s-1EuoHKZVa1zBympW96KFkUw-提取码-8emi" class="headerlink" title="链接: https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw 提取码: 8emi"></a>链接: <a href="https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw">https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw</a> 提取码: 8emi</h6><p>　　《Java性能优化专业指南》是Java应用性能调优的圣经，内容通俗易懂，介绍了大量的监控和测量工具，涉及各种硬件架构和操作系统。涵盖了如何构建实验、解释结果以及如何采取行动等技巧。<br><a id="more"></a></p>
<p>　Charlie Hunt，现任Salesforce公司的性能工程架构师。曾任Oracle公司首席JVM性能工程师，负责HotSpot Java虚拟机和Java SE类库性能的改进。Charlie拥有美国伊利诺伊理工大学的计算机科学硕士学位、爱荷华州立大学的计算机科学学士学位。</p>
<p>　　Binu John，世界上大的社交网站创建平台Ning.com的高级性能工程师。他目前的职责是着力改善Ning平台的性能和扩展性，以支持每月数百万PV的访问量。Binu拥有美国爱荷华大学生物医学工程和计算机科学硕士学位。</p>
<p><img src="/images/7b5da370ce88e48073c197ddb30deb261.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章　策略、方法和方法论　　</span><br><span class="line"></span><br><span class="line">1.1 　性能问题的现状　　</span><br><span class="line"></span><br><span class="line">1.2 　性能分析的两种方法：自顶向下和自底向上　　</span><br><span class="line"></span><br><span class="line">1.2.1 　自顶向下　　</span><br><span class="line"></span><br><span class="line">1.2.2 　自底向上　　</span><br><span class="line"></span><br><span class="line">1.3 　选择正确的平台并评估系统性能　　</span><br><span class="line"></span><br><span class="line">1.3.1 　选择正确的CPU架构　　</span><br><span class="line"></span><br><span class="line">1.3.2 　评估系统性能　　</span><br><span class="line"></span><br><span class="line">1.4 　参考资料　　</span><br><span class="line"></span><br><span class="line">第2章　操作系统性能监控　　</span><br><span class="line"></span><br><span class="line">2.1 　定义　　</span><br><span class="line"></span><br><span class="line">2.2 　CPU使用率　　</span><br><span class="line"></span><br><span class="line">2.2.1 　监控CPU使用率：Windows　　</span><br><span class="line"></span><br><span class="line">2.2.2 　监控CPU使用率：Windows typeperf　　</span><br><span class="line"></span><br><span class="line">2.2.3 　监控CPU使用率：Linux　　</span><br><span class="line"></span><br><span class="line">2.2.4 　监控CPU使用率：Solaris　　</span><br><span class="line"></span><br><span class="line">2.2.5 　命令行监控CPU使用率：Linux和Solaris　　</span><br><span class="line"></span><br><span class="line">2.3 　CPU调度程序运行队列　　</span><br><span class="line"></span><br><span class="line">2.3.1 　监控CPU调度程序运行队列：Windows　　</span><br><span class="line"></span><br><span class="line">2.3.2 　监控CPU调度程序运行队列：Solaris　　</span><br><span class="line"></span><br><span class="line">2.3.3 　监控CPU调度程序运行队列：Linux　　</span><br><span class="line"></span><br><span class="line">2.4 　内存使用率　　</span><br><span class="line"></span><br><span class="line">2.4.1 　监控内存利用率：Windows　　</span><br><span class="line"></span><br><span class="line">2.4.2 　监控内存使用率：Solaris　　</span><br><span class="line"></span><br><span class="line">2.4.3 　监控内存使用率：Linux　　</span><br><span class="line"></span><br><span class="line">2.4.4 　监控锁竞争：Solaris　　</span><br><span class="line"></span><br><span class="line">2.4.5 　监控锁竞争：Linux　　</span><br><span class="line"></span><br><span class="line">2.4.6 　监控锁竞争：Windows　　</span><br><span class="line"></span><br><span class="line">2.4.7 　隔离竞争锁　　</span><br><span class="line"></span><br><span class="line">2.4.8 　监控抢占式上下文切换　　</span><br><span class="line"></span><br><span class="line">2.4.9 　监控线程迁移　　</span><br><span class="line"></span><br><span class="line">2.5 　网络I&#x2F;O使用率　　</span><br><span class="line"></span><br><span class="line">2.5.1 　监控网络I&#x2F;O使用率：Solaris　　</span><br><span class="line"></span><br><span class="line">2.5.2 　监控网络I&#x2F;O使用率：Linux　　</span><br><span class="line"></span><br><span class="line">2.5.3 　监控网络I&#x2F;O使用率：Windows　　</span><br><span class="line"></span><br><span class="line">2.5.4 　应用性能改进的考虑　　</span><br><span class="line"></span><br><span class="line">2.6 　磁盘I&#x2F;O使用率　　</span><br><span class="line"></span><br><span class="line">2.7 　其他命令行工具　　</span><br><span class="line"></span><br><span class="line">2.8 　监控CPU使用率：SPARC T系列系统　　</span><br><span class="line"></span><br><span class="line">2.9 　参考资料　　</span><br><span class="line"></span><br><span class="line">第3章　JVM概览　　</span><br><span class="line"></span><br><span class="line">3.1 　HotSpot VM的基本架构　　</span><br><span class="line"></span><br><span class="line">3.2 　HotSpot VM运行时　　</span><br><span class="line"></span><br><span class="line">3.2.1 　命令行选项　　</span><br><span class="line"></span><br><span class="line">3.2.2 　VM生命周期　　</span><br><span class="line"></span><br><span class="line">3.2.3 　VM类加载　　</span><br><span class="line"></span><br><span class="line">3.2.4 　字节码验证　　</span><br><span class="line"></span><br><span class="line">3.2.5 　类数据共享　　</span><br><span class="line"></span><br><span class="line">3.2.6 　解释器　　</span><br><span class="line"></span><br><span class="line">3.2.7 　异常处理　　</span><br><span class="line"></span><br><span class="line">3.2.8 　同步　　</span><br><span class="line"></span><br><span class="line">3.2.9 　线程管理　　</span><br><span class="line"></span><br><span class="line">3.2.10 　C++堆管理　　</span><br><span class="line"></span><br><span class="line">3.2.11 　Java本地接口　　</span><br><span class="line"></span><br><span class="line">3.2.12 　VM致命错误处理　　</span><br><span class="line"></span><br><span class="line">3.3 　HotSpot VM垃圾收集器　　</span><br><span class="line"></span><br><span class="line">3.3.1 　分代垃圾收集　　</span><br><span class="line"></span><br><span class="line">3.3.2 　新生代　　</span><br><span class="line"></span><br><span class="line">3.3.3 　快速内存分配　　</span><br><span class="line"></span><br><span class="line">3.3.4 　垃圾收集器　　</span><br><span class="line"></span><br><span class="line">3.3.5 　Serial收集器　　</span><br><span class="line"></span><br><span class="line">3.3.6 　Parallel收集器：吞吐量为先！　　</span><br><span class="line"></span><br><span class="line">3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　</span><br><span class="line"></span><br><span class="line">3.3.8　　Garbage-First收集器：CMS替代者　　</span><br><span class="line"></span><br><span class="line">3.3.9 　垃圾收集器比较　　</span><br><span class="line"></span><br><span class="line">3.3.10 　应用程序对垃圾收集器的影响　　</span><br><span class="line"></span><br><span class="line">3.3.11 　简单回顾收集器历史　　</span><br><span class="line"></span><br><span class="line">3.4 　HotSpot VM JIT编译器　　</span><br><span class="line"></span><br><span class="line">3.4.1 　类型继承关系分析　　</span><br><span class="line"></span><br><span class="line">3.4.2 　编译策略　　</span><br><span class="line"></span><br><span class="line">3.4.3 　逆优化　　</span><br><span class="line"></span><br><span class="line">3.4.4 　Client JIT编译器概览　　</span><br><span class="line"></span><br><span class="line">3.4.5 　Server JIT编译器概览　　</span><br><span class="line"></span><br><span class="line">3.4.6 　静态单赋值--程序依赖图　　</span><br><span class="line"></span><br><span class="line">3.4.7 　未来增强展望　　</span><br><span class="line"></span><br><span class="line">3.5 　HotSpot VM自适应调优　　</span><br><span class="line"></span><br><span class="line">3.5.1 　Java 1.4.2的默认值　　</span><br><span class="line"></span><br><span class="line">3.5.2 　Java 5自动优化的默认值　　</span><br><span class="line"></span><br><span class="line">3.5.3 　Java 6 Update 18更新后的默认优化值　　</span><br><span class="line"></span><br><span class="line">3.5.4 　自适应Java堆调整　　</span><br><span class="line"></span><br><span class="line">3.5.5 　超越自动优化　　</span><br><span class="line"></span><br><span class="line">3.6 　参考资料　　</span><br><span class="line"></span><br><span class="line">第4章　JVM性能监控　　</span><br><span class="line"></span><br><span class="line">4.1 　定义　　</span><br><span class="line"></span><br><span class="line">4.2 　垃圾收集　　</span><br><span class="line"></span><br><span class="line">4.2.1 　重要的垃圾收集数据　　</span><br><span class="line"></span><br><span class="line">4.2.2 　垃圾收集报告　　</span><br><span class="line"></span><br><span class="line">4.2.3 　垃圾收集数据的离线分析　　</span><br><span class="line"></span><br><span class="line">4.2.4 　图形化工具　　</span><br><span class="line"></span><br><span class="line">4.3 　JIT编译器　　</span><br><span class="line"></span><br><span class="line">4.4 　类加载　　</span><br><span class="line"></span><br><span class="line">4.5 　Java应用监控　　</span><br><span class="line"></span><br><span class="line">4.6 　参考资料　　</span><br><span class="line"></span><br><span class="line">第5章　Java应用性能分析　　</span><br><span class="line"></span><br><span class="line">5.1 　术语　　</span><br><span class="line"></span><br><span class="line">5.1.1 　通用性能分析术语　　</span><br><span class="line"></span><br><span class="line">5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　</span><br><span class="line"></span><br><span class="line">5.1.3 　NetBeans Profiler术语　　</span><br><span class="line"></span><br><span class="line">5.2 　Oracle Solaris Studio Performance Analyzer　　</span><br><span class="line"></span><br><span class="line">5.2.1 　支持平台　　</span><br><span class="line"></span><br><span class="line">5.2.2 　下载&#x2F;安装Oracle Solaris Studio Performance Analyzer　　</span><br><span class="line"></span><br><span class="line">5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　</span><br><span class="line"></span><br><span class="line">5.2.4 　查看性能数据　　</span><br><span class="line"></span><br><span class="line">5.2.5 　数据表示　　</span><br><span class="line"></span><br><span class="line">5.2.6 　过滤性能数据　　</span><br><span class="line"></span><br><span class="line">5.2.7 　命令行工具er_print　　</span><br><span class="line"></span><br><span class="line">5.3 　NetBeans Profiler　　</span><br><span class="line"></span><br><span class="line">5.3.1 　支持平台　　</span><br><span class="line"></span><br><span class="line">5.3.2 　下载安装NetBeans Profiler　　</span><br><span class="line"></span><br><span class="line">5.3.3 　开始方法分析会话　　</span><br><span class="line"></span><br><span class="line">5.3.4 　Controls子面板　　</span><br><span class="line"></span><br><span class="line">5.3.5 　Status子面板　　</span><br><span class="line"></span><br><span class="line">5.3.6 　Profiling Results子面板　　</span><br><span class="line"></span><br><span class="line">5.3.7 　Saved Snapshots子面板　　</span><br><span class="line"></span><br><span class="line">5.3.8 　View子面板　　</span><br><span class="line"></span><br><span class="line">5.3.9 　Basic Telemetry子面板　　</span><br><span class="line"></span><br><span class="line">5.3.10 　查看动态结果　　</span><br><span class="line"></span><br><span class="line">5.3.11 　对结果进行快照　　</span><br><span class="line"></span><br><span class="line">5.3.12 　启动内存分析会话　　</span><br><span class="line"></span><br><span class="line">5.3.13 　查看实时结果　　</span><br><span class="line"></span><br><span class="line">5.3.14 　对结果进行快照　　</span><br><span class="line"></span><br><span class="line">5.3.15 　定位内存泄漏　　</span><br><span class="line"></span><br><span class="line">5.3.16 　分析堆转储　　</span><br><span class="line"></span><br><span class="line">5.4 　参考资料　　</span><br><span class="line"></span><br><span class="line">第6章　Java应用性能分析技巧　　</span><br><span class="line"></span><br><span class="line">6.1 　性能优化机会　　</span><br><span class="line"></span><br><span class="line">6.2 　系统或内核态CPU使用　　</span><br><span class="line"></span><br><span class="line">6.3 　锁竞争　　</span><br><span class="line"></span><br><span class="line">6.4 　Volatile的使用　　</span><br><span class="line"></span><br><span class="line">6.5 　调整数据结构的大小　　</span><br><span class="line"></span><br><span class="line">6.5.1 　StringBuilder或StringBuffer大小的调整　　</span><br><span class="line"></span><br><span class="line">6.5.2 　Java Collection类大小调整　　</span><br><span class="line"></span><br><span class="line">6.6 　增加并行性　　</span><br><span class="line"></span><br><span class="line">6.7 　过高的CPU使用率　　</span><br><span class="line"></span><br><span class="line">6.8 　其他有用的分析提示　　</span><br><span class="line"></span><br><span class="line">6.9 　参考资料　　</span><br><span class="line"></span><br><span class="line">第7章　JVM性能调优入门　　</span><br><span class="line"></span><br><span class="line">7.1 　方法　　</span><br><span class="line"></span><br><span class="line">7.1.1 　假设条件　　</span><br><span class="line"></span><br><span class="line">7.1.2 　测试基础设施需求　　</span><br><span class="line"></span><br><span class="line">7.2 　应用程序的系统需求　　</span><br><span class="line"></span><br><span class="line">7.2.1 　可用性　　</span><br><span class="line"></span><br><span class="line">7.2.2 　可管理性　　</span><br><span class="line"></span><br><span class="line">7.2.3 　吞吐量　　</span><br><span class="line"></span><br><span class="line">7.2.4 　延迟及响应性　　</span><br><span class="line"></span><br><span class="line">7.2.5 　内存占用　　</span><br><span class="line"></span><br><span class="line">7.2.6 　启动时间　　</span><br><span class="line"></span><br><span class="line">7.3 　对系统需求分级　　</span><br><span class="line"></span><br><span class="line">7.4 　选择JVM部署模式　　</span><br><span class="line"></span><br><span class="line">7.4.1 　单JVM部署模式　　</span><br><span class="line"></span><br><span class="line">7.4.2 　多JVM部署模式　　</span><br><span class="line"></span><br><span class="line">7.4.3 　通用建议　　</span><br><span class="line"></span><br><span class="line">7.5 　选择JVM运行模式　　</span><br><span class="line"></span><br><span class="line">7.5.1 　Client模式或Server模式　　</span><br><span class="line"></span><br><span class="line">7.5.2 　32位&#x2F;64位 JVM　　</span><br><span class="line"></span><br><span class="line">7.5.3 　垃圾收集器　　</span><br><span class="line"></span><br><span class="line">7.6 　垃圾收集调优基础　　</span><br><span class="line"></span><br><span class="line">7.6.1 　性能属性　　</span><br><span class="line"></span><br><span class="line">7.6.2 　原则　　</span><br><span class="line"></span><br><span class="line">7.6.3 　命令行选项及GC日志　　</span><br><span class="line"></span><br><span class="line">7.7 　确定内存占用　　</span><br><span class="line"></span><br><span class="line">7.7.1 　约束　　</span><br><span class="line"></span><br><span class="line">7.7.2 　HotSpot VM堆的布局　　</span><br><span class="line"></span><br><span class="line">7.7.3 　堆大小调优着眼点　　</span><br><span class="line"></span><br><span class="line">7.7.4 　计算活跃数据大小　　</span><br><span class="line"></span><br><span class="line">7.7.5 　初始堆空间大小配置　　</span><br><span class="line"></span><br><span class="line">7.7.6 　其他考量因素　　</span><br><span class="line"></span><br><span class="line">7.8 　调优延迟&#x2F;响应性　　</span><br><span class="line"></span><br><span class="line">7.8.1 　输入　　</span><br><span class="line"></span><br><span class="line">7.8.2 　优化新生代的大小　　</span><br><span class="line"></span><br><span class="line">7.8.3 　优化老年代的大小　　</span><br><span class="line"></span><br><span class="line">7.8.4 　为CMS调优延迟　　</span><br><span class="line"></span><br><span class="line">7.8.5 　Survivor空间介绍　　</span><br><span class="line"></span><br><span class="line">7.8.6 　解析晋升阈值　　</span><br><span class="line"></span><br><span class="line">7.8.7 　监控晋升阈值　　</span><br><span class="line"></span><br><span class="line">7.8.8 　调整Survivor空间的容量　　</span><br><span class="line"></span><br><span class="line">7.8.9 　显式的垃圾收集　　</span><br><span class="line"></span><br><span class="line">7.8.10 　并发永久代垃圾收集　　</span><br><span class="line"></span><br><span class="line">7.8.11 　调优CMS停顿时间　　</span><br><span class="line"></span><br><span class="line">7.8.12 　下一步　　</span><br><span class="line"></span><br><span class="line">7.9 　应用程序吞吐量调优　　</span><br><span class="line"></span><br><span class="line">7.9.1 　CMS吞吐量调优　　</span><br><span class="line"></span><br><span class="line">7.9.2 　Throughput收集器调优　　</span><br><span class="line"></span><br><span class="line">7.9.3 　Survivor空间调优　　</span><br><span class="line"></span><br><span class="line">7.9.4 　调优并行垃圾收集线程　　</span><br><span class="line"></span><br><span class="line">7.9.5 　在NUMA系统上部署　　</span><br><span class="line"></span><br><span class="line">7.9.6 　下一步　　</span><br><span class="line"></span><br><span class="line">7.10 　极端示例　　</span><br><span class="line"></span><br><span class="line">7.11 　其他性能命令行选项　　</span><br><span class="line"></span><br><span class="line">7.11.1 　实验性（最近最大）优化　　</span><br><span class="line"></span><br><span class="line">7.11.2 　逃逸分析　　</span><br><span class="line"></span><br><span class="line">7.11.3 　偏向锁　　</span><br><span class="line"></span><br><span class="line">7.11.4 　大页面支持　　</span><br><span class="line"></span><br><span class="line">7.12 　参考资料　　</span><br><span class="line"></span><br><span class="line">第8章　Java应用的基准测试　　</span><br><span class="line"></span><br><span class="line">8.1 　基准测试所面临的挑战　　</span><br><span class="line"></span><br><span class="line">8.1.1 　基准测试的预热阶段　　</span><br><span class="line"></span><br><span class="line">8.1.2 　垃圾收集　　</span><br><span class="line"></span><br><span class="line">8.1.3 　使用Java Time接口　　</span><br><span class="line"></span><br><span class="line">8.1.4 　剔除无效代码　　</span><br><span class="line"></span><br><span class="line">8.1.5 　内联　　</span><br><span class="line"></span><br><span class="line">8.1.6 　逆优化　　</span><br><span class="line"></span><br><span class="line">8.1.7 　创建微基准测试的注意事项　　</span><br><span class="line"></span><br><span class="line">8.2 　实验设计　　</span><br><span class="line"></span><br><span class="line">8.3 　使用统计方法　　</span><br><span class="line"></span><br><span class="line">8.3.1 　计算均值　　</span><br><span class="line"></span><br><span class="line">8.3.2 　计算标准差　　</span><br><span class="line"></span><br><span class="line">8.3.3 　计算置信区间　　</span><br><span class="line"></span><br><span class="line">8.3.4 　使用假设测试　　</span><br><span class="line"></span><br><span class="line">8.3.5 　使用统计方法的注意事项　　</span><br><span class="line"></span><br><span class="line">8.4 　参考文献　　</span><br><span class="line"></span><br><span class="line">8.5 　参考资料　　</span><br><span class="line"></span><br><span class="line">第9章　多层应用的基准测试　　</span><br><span class="line"></span><br><span class="line">9.1 　基准测试难题　　</span><br><span class="line"></span><br><span class="line">9.2 　企业级应用基准测试的考量　　</span><br><span class="line"></span><br><span class="line">9.2.1 　定义被测系统　　</span><br><span class="line"></span><br><span class="line">9.2.2 　制定微基准测试　　</span><br><span class="line"></span><br><span class="line">9.2.3 　定义用户交互模型　　</span><br><span class="line"></span><br><span class="line">9.2.4 　定义性能指标　　</span><br><span class="line"></span><br><span class="line">9.2.5 　扩展基准测试　　</span><br><span class="line"></span><br><span class="line">9.2.6 　用利特尔法则验证　　</span><br><span class="line"></span><br><span class="line">9.2.7 　思考时间　　</span><br><span class="line"></span><br><span class="line">9.2.8 　扩展性分析　　</span><br><span class="line"></span><br><span class="line">9.2.9 　运行基准测试　　</span><br><span class="line"></span><br><span class="line">9.3 　应用服务器监控　　</span><br><span class="line"></span><br><span class="line">9.3.1 　GlassFish监控　　</span><br><span class="line"></span><br><span class="line">9.3.2 　监控子系统　　</span><br><span class="line"></span><br><span class="line">9.3.3 　Solaris　　</span><br><span class="line"></span><br><span class="line">9.3.4 　Linux　　</span><br><span class="line"></span><br><span class="line">9.3.5 　Windows　　</span><br><span class="line"></span><br><span class="line">9.3.6 　外部系统的性能　　</span><br><span class="line"></span><br><span class="line">9.3.7 　磁盘I&#x2F;O　　</span><br><span class="line"></span><br><span class="line">9.3.8 　监控和调优资源池　　</span><br><span class="line"></span><br><span class="line">9.4 　企业级应用性能分析　　</span><br><span class="line"></span><br><span class="line">9.5 　参考资料　　</span><br><span class="line"></span><br><span class="line">第10章　Web应用的性能调优　　</span><br><span class="line"></span><br><span class="line">10.1 　Web应用的基准测试　　</span><br><span class="line"></span><br><span class="line">10.2 　Web容器的组件　　</span><br><span class="line"></span><br><span class="line">10.2.1 　HTTP连接器　　</span><br><span class="line"></span><br><span class="line">10.2.2 　Servlet引擎　　</span><br><span class="line"></span><br><span class="line">10.3 　Web容器的监控和性能调优　　</span><br><span class="line"></span><br><span class="line">10.3.1 　容器的开发和生产模式　　</span><br><span class="line"></span><br><span class="line">10.3.2 　安全管理器　　</span><br><span class="line"></span><br><span class="line">10.3.3 　JVM调优　　</span><br><span class="line"></span><br><span class="line">10.3.4 　HTTP服务和Web容器　　</span><br><span class="line"></span><br><span class="line">10.3.5 　HTTP监听器　　</span><br><span class="line"></span><br><span class="line">10.4 　最佳实践　　</span><br><span class="line"></span><br><span class="line">10.4.1 　Servlet和JSP最佳实践　　</span><br><span class="line"></span><br><span class="line">10.4.2 　内容缓存　　</span><br><span class="line"></span><br><span class="line">10.4.3 　会话持久化　　</span><br><span class="line"></span><br><span class="line">10.4.4 　HTTP服务器文件缓存　　</span><br><span class="line"></span><br><span class="line">10.5 　参考资料　　</span><br><span class="line"></span><br><span class="line">第11章　Web Service的性能　　</span><br><span class="line"></span><br><span class="line">11.1 　XML的性能　　</span><br><span class="line"></span><br><span class="line">11.1.1 　XML处理的生命周期　　</span><br><span class="line"></span><br><span class="line">11.1.2 　解析&#x2F;解编组　　</span><br><span class="line"></span><br><span class="line">11.1.3 　访问　　</span><br><span class="line"></span><br><span class="line">11.1.4 　修改　　</span><br><span class="line"></span><br><span class="line">11.1.5 　序列化&#x2F;编组　　</span><br><span class="line"></span><br><span class="line">11.2 　验证　　</span><br><span class="line"></span><br><span class="line">11.3 　解析外部实体　　</span><br><span class="line"></span><br><span class="line">11.4 　XML文档的局部处理　　</span><br><span class="line"></span><br><span class="line">11.5 　选择合适的API　　</span><br><span class="line"></span><br><span class="line">11.6 　JAX-WS参考实现栈　　</span><br><span class="line"></span><br><span class="line">11.7 　Web Service基准测试　　</span><br><span class="line"></span><br><span class="line">11.8 　影响Web Service性能的因素　　</span><br><span class="line"></span><br><span class="line">11.8.1 　消息大小的影响　　</span><br><span class="line"></span><br><span class="line">11.8.2 　不同Schema类型的性能特征　　</span><br><span class="line"></span><br><span class="line">11.8.3 　终端服务器的实现　　</span><br><span class="line"></span><br><span class="line">11.8.4 　处理程序的性能　　</span><br><span class="line"></span><br><span class="line">11.9 　最佳性能实践　　</span><br><span class="line"></span><br><span class="line">11.9.1 　二进制负载的处理　　</span><br><span class="line"></span><br><span class="line">11.9.2 　处理XML文档　　</span><br><span class="line"></span><br><span class="line">11.9.3 　使用MTOM发送XML文档　　</span><br><span class="line"></span><br><span class="line">11.9.4 　使用Provider接口　　</span><br><span class="line"></span><br><span class="line">11.9.5 　快速信息集　　</span><br><span class="line"></span><br><span class="line">11.9.6 　HTTP压缩　　</span><br><span class="line"></span><br><span class="line">11.9.7 　Web Service客户端的性能　　</span><br><span class="line"></span><br><span class="line">11.10 　参考资料　　</span><br><span class="line"></span><br><span class="line">第12章　Java持久化及Enterprise Java Bean的性能　　</span><br><span class="line"></span><br><span class="line">12.1 　EJB编程模型　　</span><br><span class="line"></span><br><span class="line">12.2 　Java持久化API及其参考实现　　</span><br><span class="line"></span><br><span class="line">12.3 　监控及调优EJB容器　　</span><br><span class="line"></span><br><span class="line">12.3.1 　线程池　　</span><br><span class="line"></span><br><span class="line">12.3.2 　Bean池和缓存　　</span><br><span class="line"></span><br><span class="line">12.3.3 　EclipseLink会话缓存　　</span><br><span class="line"></span><br><span class="line">12.4 　事务隔离级　　</span><br><span class="line"></span><br><span class="line">12.5 　Enterprise Java Bean的最佳实践　　</span><br><span class="line"></span><br><span class="line">12.5.1 　简要说明使用的EJB基准测试　　</span><br><span class="line"></span><br><span class="line">12.5.2 　EJB 2.1　　</span><br><span class="line"></span><br><span class="line">12.5.3 　EJB 3.0　　</span><br><span class="line"></span><br><span class="line">12.6 　Java持久化最佳实践　　</span><br><span class="line"></span><br><span class="line">12.6.1 　JPA查询语言中的查询　　</span><br><span class="line"></span><br><span class="line">12.6.2 　查询结果缓存　　</span><br><span class="line"></span><br><span class="line">12.6.3 　FetchType　　</span><br><span class="line"></span><br><span class="line">12.6.4 　连接池　　</span><br><span class="line"></span><br><span class="line">12.6.5 　批量更新　　</span><br><span class="line"></span><br><span class="line">12.6.6 　选择正确的数据库锁策略　　</span><br><span class="line"></span><br><span class="line">12.6.7 　不带事务的读取　　</span><br><span class="line"></span><br><span class="line">12.6.8 　继承　　</span><br><span class="line"></span><br><span class="line">12.7 　参考资料　　</span><br><span class="line"></span><br><span class="line">附录A 　重要的HotSpot VM选项　　</span><br><span class="line"></span><br><span class="line">附录B 　性能分析技巧示例源代码　　</span><br><span class="line"></span><br><span class="line">B.1 　锁竞争实现1　　</span><br><span class="line"></span><br><span class="line">B.2 　锁竞争实现2　　</span><br><span class="line"></span><br><span class="line">B.3 　锁竞争实现3　　</span><br><span class="line"></span><br><span class="line">B.4 　锁竞争实现4　　</span><br><span class="line"></span><br><span class="line">B.5 　锁竞争实现5　　</span><br><span class="line"></span><br><span class="line">B.6 　调整容量变化1　　</span><br><span class="line"></span><br><span class="line">B.7 　调整容量变化2　　</span><br><span class="line"></span><br><span class="line">B.8 　增加并发性的单线程实现　　</span><br><span class="line"></span><br><span class="line">B.9 　增加并发性的多线程实现</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Linux宝典 PDF</title>
    <url>/posts/dbb36bf1/</url>
    <content><![CDATA[<h4 id="《Linux宝典》"><a href="#《Linux宝典》" class="headerlink" title="《Linux宝典》"></a>《Linux宝典》</h4><h6 id="链接-https-pan-baidu-com-s-167PnlnHPp9-mzlYMjB7S-w-提取码-6rxa"><a href="#链接-https-pan-baidu-com-s-167PnlnHPp9-mzlYMjB7S-w-提取码-6rxa" class="headerlink" title="链接: https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w 提取码: 6rxa"></a>链接: <a href="https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w">https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w</a> 提取码: 6rxa</h6><p>丰富、、实用。发现适合自己的Linux发行版，掌握数千个Linux桌面和服务器应用程序。<br><a id="more"></a></p>
<p>本书共分29个章节，分别对Linux图形界面的基础、shell命令和基本的系统管理进行全面系统的论述。具体内容包括Linux初步、从shell运行命令、安装Linux、运行Yellow Dog Linux、运行Ubuntu Linux、运行邮件服务器、编程工具和实用程序等。它将帮助您全方位了解Linux，助您从头开始学习Linux。 该书可供各大专院校作为教材使用，也可供从事相关工作的人员作为参考用书使用。</p>
<p>使用这本全面指南掌握基本知识和更深入的知识。</p>
<p>LinUx的高效足以将其用作惟一的桌面系统，其强大足以运行整个公司的企业级安装。使用这本全面的参考作为指南，就可充分利用LinUX来满足家庭、小型企业或公司的需求。读者可在本书中学习16个不同的Linux发行版，了解逐步的说明，发现新的编程工具，并接触免费软件的世界。这是您借助Linux获得成功所需的书籍。</p>
<p>·掌握桌面、服务器和工作站上的Linux；</p>
<p>·找到、安装和使用大量免费的开放源代码软件；</p>
<p>·在Linux中运行音乐、、图像和文档程序；</p>
<p>·从Linux桌面进行Intemet浏览、收发电子邮件或聊天；</p>
<p>·设置自己的电子邮件和Web（LAMP）服务器；</p>
<p>·使用防火墙和其他安全工具进行安全的连接：</p>
<p>·可在老旧电脑到高端服务器上运行Linux。</p>
<p><img src="/images/956f292aa9019f1ae7535f71db0e852b1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">部分　Linux基础</span><br><span class="line"></span><br><span class="line">　章　Linux初步　</span><br><span class="line"></span><br><span class="line">　第2章　从shell运行命令　</span><br><span class="line"></span><br><span class="line">　第3章　进入桌面　</span><br><span class="line"></span><br><span class="line">第2部分　运行显示</span><br><span class="line"></span><br><span class="line">　第4章　学习基本的管理功能　</span><br><span class="line"></span><br><span class="line">　第5章　连接到Inter　</span><br><span class="line"></span><br><span class="line">　第6章　保护Linux　</span><br><span class="line"></span><br><span class="line">第3部分　挑选和安装Linux发行版</span><br><span class="line"></span><br><span class="line">　第7章　安装Linux　</span><br><span class="line"></span><br><span class="line">　第8章　运行Fedora和Red Hat Enterprise Linux　</span><br><span class="line"></span><br><span class="line">　第9章　运行Debian GNU&#x2F;Linux　</span><br><span class="line"></span><br><span class="line">　0章　运行SUSE和openSUSE Linux　</span><br><span class="line"></span><br><span class="line">　1章　运行KNOPPIX　</span><br><span class="line"></span><br><span class="line">　2章　运行Yellow Dog Linux　</span><br><span class="line"></span><br><span class="line">　3章　运行Gentoo Linux　</span><br><span class="line"></span><br><span class="line">　4章　运行Slackware Linux　</span><br><span class="line"></span><br><span class="line">　5章　运行Linspire和Freespire　</span><br><span class="line"></span><br><span class="line">　6章　运行Mandriva　</span><br><span class="line"></span><br><span class="line">　7章　运行Ubuntu Linux　</span><br><span class="line"></span><br><span class="line">　8章　运行Linux防火墙&#x2F;路由器　</span><br><span class="line"></span><br><span class="line">　9章　运行可引导的Linux发行版　</span><br><span class="line"></span><br><span class="line">第4部分　运行应用程序</span><br><span class="line"></span><br><span class="line">　第20章　播放音乐和视频　</span><br><span class="line"></span><br><span class="line">　第21章　处理文字和图像　</span><br><span class="line"></span><br><span class="line">　第22章　电子邮件和网页浏览　</span><br><span class="line"></span><br><span class="line">　第23章　通过Linux玩游戏　</span><br><span class="line"></span><br><span class="line">第5部分　运行服务器</span><br><span class="line"></span><br><span class="line">　第24章　运行Linux、Apache、MySQL和PHP(LAMP)服务器　</span><br><span class="line"></span><br><span class="line">　第25章　运行邮件服务器　</span><br><span class="line"></span><br><span class="line">　第26章　运行打印服务器　</span><br><span class="line"></span><br><span class="line">　第27章　运行文件服务器　</span><br><span class="line"></span><br><span class="line">第6部分　Linux编程</span><br><span class="line"></span><br><span class="line">　第28章　编程环境和接口　</span><br><span class="line"></span><br><span class="line">　第29章　编程工具和实用程序　</span><br><span class="line"></span><br><span class="line">附录A　创建Linux CD以及获得源代码　</span><br><span class="line"></span><br><span class="line">附录B　走入Linux社区</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令大全 PDF</title>
    <url>/posts/42ba3a4b/</url>
    <content><![CDATA[<h4 id="《linux常用命令大全》"><a href="#《linux常用命令大全》" class="headerlink" title="《linux常用命令大全》"></a>《linux常用命令大全》</h4><h6 id="链接-https-pan-baidu-com-s-1xktbfNa3IU4wpga-4GKLww-提取码-bsce"><a href="#链接-https-pan-baidu-com-s-1xktbfNa3IU4wpga-4GKLww-提取码-bsce" class="headerlink" title="链接: https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww 提取码: bsce"></a>链接: <a href="https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww">https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww</a> 提取码: bsce</h6><p><img src="/images/5ec9179eace8c536fccf430101ff29c01.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p>本书全面、系统地介绍了Linux命令、编辑器及Shell编程的相关内容。既便于读者深入了解Linux 命令强大的功能，又可以帮助Linux用户在较短的时间内学习和掌握Shell编程，开发出自己需要的实用程序。全书分上、中、下3篇，共20章，内容涵盖了Linux简介、Red Hat Linux 基础知识、系统管理与设置、用户和用户组管理、磁盘管理、文件和目录管理、备份与压缩、网络管理、正则表达式、vim编辑器、emacs、grep命令、awk与sed、常用的文本编辑命令、Shell编程基础、Shell变量、条件测试表达式、Shell的控制结构、函数以及Shell编辑实例。</p>
<p>　　本书内容丰富，语言通俗易懂，叙述深入浅出，适合于各层次Linux用户。既可以作为各类院校相关专业的教材，也可作为Linux培训的教程及广大Linux爱好者的专业参考书。</p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>LINUX防火墙原书第3版 PDF</title>
    <url>/posts/35bd0add/</url>
    <content><![CDATA[<h4 id="《LINUX防火墙原书第3版》"><a href="#《LINUX防火墙原书第3版》" class="headerlink" title="《LINUX防火墙原书第3版》"></a>《LINUX防火墙原书第3版》</h4><h6 id="链接-https-pan-baidu-com-s-1yzlny8xwa9CNzCxsLYak2g-提取码-wi4c"><a href="#链接-https-pan-baidu-com-s-1yzlny8xwa9CNzCxsLYak2g-提取码-wi4c" class="headerlink" title="链接: https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g 提取码: wi4c"></a>链接: <a href="https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g">https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g</a> 提取码: wi4c</h6><p>本书详细介绍Linux[*]作系统中构建防火墙的方[0法0]，以及入侵检测和系统安全的技术。[1主1]要内容包括：防火墙的基础[0知0]识，Linux防火墙管理程序iptable，构建防火墙的方[0法0]，防火墙的[0优0]化，数据包的转发，网络监控和攻[1击1]检测，内核强化等。本书[0独0]立于Linux某个发行版本，涉及常驻于Linux内核的Netfilter核心软[亻牛]。可帮助读者掌握Linux系统与网络安全技术。.<br><a id="more"></a></p>
<p>本书条理清晰，图示丰富，可供各类计算[1机1]专业技术人员参考。..</p>
<p>本书是Linux防火墙[0权0]威指南，包括如何使用Linux Netfilter／iptables来实现防火墙的[1主1]题。本书的[1主1]题既包括如何安装和设置防火墙的基础[0知0]识，也包括针对黑客攻[1击1]的防范。本身[*]有价值的部分莫过于对iptables、包过滤以及防火墙[0优0]化的详细介绍。同时还包含了通过自定义内核来增加安全性的高级[1主1]题。.</p>
<p><img src="/images/3df6fea48e45172a0c9e98fd0ae270421.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序.</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">[0第0]一部分 数据包过滤及基本安全措施</span><br><span class="line"></span><br><span class="line">[0第0]1章 防火墙的基本概念</span><br><span class="line"></span><br><span class="line">1．1 OSI网络参考模型</span><br><span class="line"></span><br><span class="line">1．2 IP协议</span><br><span class="line"></span><br><span class="line">1．3 传输[1机1]制</span><br><span class="line"></span><br><span class="line">1．4 不要忘记ARP协议</span><br><span class="line"></span><br><span class="line">1．5 [1主1][1机1][0名0]称和IP地址</span><br><span class="line"></span><br><span class="line">1．6 路由：数据包的传送</span><br><span class="line"></span><br><span class="line">1．7 服务端口：通向系统程序的[0大0]门</span><br><span class="line"></span><br><span class="line">1．8 小结</span><br><span class="line"></span><br><span class="line">笫2章 数据包过滤的概念</span><br><span class="line"></span><br><span class="line">2．1 一个数据包过滤防火墙</span><br><span class="line"></span><br><span class="line">2．2 选择一个默认的数据包过滤策略</span><br><span class="line"></span><br><span class="line">2．3 拒[纟色]与禁止一个数据包</span><br><span class="line"></span><br><span class="line">2．4 过滤入站数据包</span><br><span class="line"></span><br><span class="line">2．5 过滤出站数据包</span><br><span class="line"></span><br><span class="line">2．6 专用网络和公共网络服务</span><br><span class="line"></span><br><span class="line">2．7 小结</span><br><span class="line"></span><br><span class="line">[0第0]3章 iptables：Linux防火墙管理程序</span><br><span class="line"></span><br><span class="line">3．1 IP防火墙(IPFW)和网络过滤器</span><br><span class="line"></span><br><span class="line">3．2 iptables的基本语[0法0]</span><br><span class="line"></span><br><span class="line">3．3 iptables的特点</span><br><span class="line"></span><br><span class="line">3．4 iptables的语[0法0]规则</span><br><span class="line"></span><br><span class="line">3．5 小结</span><br><span class="line"></span><br><span class="line">[0第0]4章 构建和安装一个[0独0]立的防火墙</span><br><span class="line"></span><br><span class="line">4．1 iptables：Linux防火墙管理程序</span><br><span class="line"></span><br><span class="line">4．2 防火墙的初始化</span><br><span class="line"></span><br><span class="line">4．3 保护被分配在非特[0权0]端口上运行的服务</span><br><span class="line"></span><br><span class="line">4．4 启动基本但必要的Internet服务</span><br><span class="line"></span><br><span class="line">4．5 启动常用TCP服务</span><br><span class="line"></span><br><span class="line">4．6 启动常用的UDP服务</span><br><span class="line"></span><br><span class="line">4．7 过滤ICMP控制和状态信息</span><br><span class="line"></span><br><span class="line">4．8 记录被丢弃的入站数据包</span><br><span class="line"></span><br><span class="line">4．9 记录被丢弃的出站数据包</span><br><span class="line"></span><br><span class="line">4．10 预先设定禁止访问有问题的网站</span><br><span class="line"></span><br><span class="line">4．11 安装防火墙</span><br><span class="line"></span><br><span class="line">4．12 小结</span><br><span class="line"></span><br><span class="line">[0第0]二部分 高级议题。多个防火墙和网络防护带</span><br><span class="line"></span><br><span class="line">[0第0]5章 防火墙的[0优0]化</span><br><span class="line"></span><br><span class="line">5．1 规则的组织</span><br><span class="line"></span><br><span class="line">5．2 用户自定义规则链</span><br><span class="line"></span><br><span class="line">5．3 防火墙的[0优0]化示例</span><br><span class="line"></span><br><span class="line">5．4 [0优0]化带来的结果</span><br><span class="line"></span><br><span class="line">5．5 小结</span><br><span class="line"></span><br><span class="line">[0第0]6章 数据包的转发</span><br><span class="line"></span><br><span class="line">6．1 [0独0]立防火墙的局限性</span><br><span class="line"></span><br><span class="line">6．2 基本的网关防火墙设置</span><br><span class="line"></span><br><span class="line">6．3 局域网安全相关问题</span><br><span class="line"></span><br><span class="line">6．4 可信家庭局域网的配置选项</span><br><span class="line"></span><br><span class="line">6．5 更高或更低可信度局域网的配置选项</span><br><span class="line"></span><br><span class="line">6．6 屏蔽子网防火墙样板</span><br><span class="line"></span><br><span class="line">6．7 将网关从本地服务转变为转发服务</span><br><span class="line"></span><br><span class="line">6．8 小结</span><br><span class="line"></span><br><span class="line">[0第0]7章 NAT——网络地址转换</span><br><span class="line"></span><br><span class="line">7．1 NAT概念的背景</span><br><span class="line"></span><br><span class="line">7．2 iptables NAT语义</span><br><span class="line"></span><br><span class="line">7．3 SNAT和专用局域网的例子</span><br><span class="line"></span><br><span class="line">7．4 DNAT、局域网和代理的例子..</span><br><span class="line"></span><br><span class="line">7．5 小结</span><br><span class="line"></span><br><span class="line">[0第0]8章 防火墙规则的检错</span><br><span class="line"></span><br><span class="line">8．1 常用防火墙开发技巧</span><br><span class="line"></span><br><span class="line">8．2 罗列防火墙规则</span><br><span class="line"></span><br><span class="line">8．3 检查输入、输出和转发规则</span><br><span class="line"></span><br><span class="line">8．4 解释系统日志</span><br><span class="line"></span><br><span class="line">8．5 检查开启的端口</span><br><span class="line"></span><br><span class="line">8．6 小结</span><br><span class="line"></span><br><span class="line">[0第0]三部分 [0超0]越iptables</span><br><span class="line"></span><br><span class="line">[0第0]9章 入侵检测和响应</span><br><span class="line"></span><br><span class="line">9．1 入侵检测</span><br><span class="line"></span><br><span class="line">9．2 系统可能遭受入侵的症状</span><br><span class="line"></span><br><span class="line">9．3 系统受损后应采取的措施</span><br><span class="line"></span><br><span class="line">9．4 事[亻牛]报告</span><br><span class="line"></span><br><span class="line">9．5 小结</span><br><span class="line"></span><br><span class="line">[0第0]10章 入侵检测工具</span><br><span class="line"></span><br><span class="line">10．1 入侵检测工具包：网络工具</span><br><span class="line"></span><br><span class="line">10．2 Roofidt检测器</span><br><span class="line"></span><br><span class="line">10．3 文[亻牛]系统的完整性</span><br><span class="line"></span><br><span class="line">10．4 日志监控</span><br><span class="line"></span><br><span class="line">10．5 如何防止入侵</span><br><span class="line"></span><br><span class="line">10．6 小结</span><br><span class="line"></span><br><span class="line">[0第0]11章 网络监控和攻[1击1]检测</span><br><span class="line"></span><br><span class="line">11．1 监听以太网</span><br><span class="line"></span><br><span class="line">11．2 TCPDump：简单介绍</span><br><span class="line"></span><br><span class="line">11．3 使用TCPDump捕捉特定的协议</span><br><span class="line"></span><br><span class="line">11．4 使用s[0no0]rt自动检测入侵</span><br><span class="line"></span><br><span class="line">11．5 使用ARPWatch进行监视</span><br><span class="line"></span><br><span class="line">11．6 小结</span><br><span class="line"></span><br><span class="line">[0第0]12章 文[亻牛]系统的完整性</span><br><span class="line"></span><br><span class="line">12．1 定义文[亻牛]系统完整性</span><br><span class="line"></span><br><span class="line">12．2 安装AIDE</span><br><span class="line"></span><br><span class="line">12．3 配置AIDE</span><br><span class="line"></span><br><span class="line">12．4 监视AIDE</span><br><span class="line"></span><br><span class="line">12．5 清除AIDE数据库</span><br><span class="line"></span><br><span class="line">12．6 改变AIDE报告的输出信息</span><br><span class="line"></span><br><span class="line">12．7 在AIDE中定义宏</span><br><span class="line"></span><br><span class="line">12．8 AIDE的监测类型</span><br><span class="line"></span><br><span class="line">12．9 小结</span><br><span class="line"></span><br><span class="line">[0第0]13章 内核的强化</span><br><span class="line"></span><br><span class="line">13．1 [纟巠]过安全强化的Linux</span><br><span class="line"></span><br><span class="line">13．2 使用GrSecurity增强安全性</span><br><span class="line"></span><br><span class="line">13．3 内核快速浏览</span><br><span class="line"></span><br><span class="line">13．4 要不要打补丁</span><br><span class="line"></span><br><span class="line">13．5 使用GrSecurity内核</span><br><span class="line"></span><br><span class="line">13．6 GrSecurity</span><br><span class="line"></span><br><span class="line">13．7 结论：专用内核</span><br><span class="line"></span><br><span class="line">附 录</span><br><span class="line"></span><br><span class="line">附录A 安全资源</span><br><span class="line"></span><br><span class="line">附录B 防火墙示例与支持脚本</span><br><span class="line"></span><br><span class="line">附录C 虚拟专用网</span><br><span class="line"></span><br><span class="line">附录D 术语表 ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Linux高级程序设计中文第三版杨宗德 PDF</title>
    <url>/posts/674ce1ba/</url>
    <content><![CDATA[<h4 id="《Linux高级程序设计中文第三版杨宗德》"><a href="#《Linux高级程序设计中文第三版杨宗德》" class="headerlink" title="《Linux高级程序设计中文第三版杨宗德》"></a>《Linux高级程序设计中文第三版杨宗德》</h4><h6 id="链接-https-pan-baidu-com-s-1qrtRIP7Gy8uQBbQtNc-sVg-提取码-26ek"><a href="#链接-https-pan-baidu-com-s-1qrtRIP7Gy8uQBbQtNc-sVg-提取码-26ek" class="headerlink" title="链接: https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg 提取码: 26ek"></a>链接: <a href="https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg">https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg</a> 提取码: 26ek</h6><p>《Linux程序设计(第3版)》讲述了Linux系统及其他IJNIX风格的操作系统上的程序开发，主要内容包括标准Linux c语言函数库和由不同的Linux或UNIX标准指定的各种工具的使用方法，大多数标准Linux开发工具的使用方法，通过DBM和MySQL数据库系统存储Linux中的数据，为x视窗系统建立图形化用户界面等。《Linux程序设计(第3版)》通过先介绍程序设计理论，再以适当的例子和清晰的解释来阐明它的方式，帮助读者迅速掌握相关的知识。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 入门</span><br><span class="line"></span><br><span class="line">1.1 LNIX、Linux和GNU简介</span><br><span class="line"></span><br><span class="line">1.1.1 什么是IYNIX</span><br><span class="line"></span><br><span class="line">1.1.2 什么是Linux</span><br><span class="line"></span><br><span class="line">1.1.3 GNL，项目和自由软件基金会</span><br><span class="line"></span><br><span class="line">1.1.4 Linux发行版</span><br><span class="line"></span><br><span class="line">1.2 Linux程序设计.</span><br><span class="line"></span><br><span class="line">1.2.1 Linux程序</span><br><span class="line"></span><br><span class="line">1.2.2 文本编辑器</span><br><span class="line"></span><br><span class="line">1.2.3 C语言编译器</span><br><span class="line"></span><br><span class="line">1.2.4 开发系统导引</span><br><span class="line"></span><br><span class="line">1.3 获得帮助</span><br><span class="line"></span><br><span class="line">1.4 小结</span><br><span class="line"></span><br><span class="line">第2章 shell程序设计</span><br><span class="line"></span><br><span class="line">2.1 为什么使用shell编程</span><br><span class="line"></span><br><span class="line">2.2 一点哲学</span><br><span class="line"></span><br><span class="line">2.3 什么是shell</span><br><span class="line"></span><br><span class="line">2.4 管道和重定向</span><br><span class="line"></span><br><span class="line">2.4.1 重定向输出</span><br><span class="line"></span><br><span class="line">2.4.2 重定向输入</span><br><span class="line"></span><br><span class="line">2.4.3 管道</span><br><span class="line"></span><br><span class="line">2.5 作为程序设计语言的shell</span><br><span class="line"></span><br><span class="line">2.5.1 交互式程序</span><br><span class="line"></span><br><span class="line">2.5.2 创建脚本</span><br><span class="line"></span><br><span class="line">2.5.3 把脚本设置为可执行</span><br><span class="line"></span><br><span class="line">2.6 shell的语法</span><br><span class="line"></span><br><span class="line">2.6.1 变量</span><br><span class="line"></span><br><span class="line">2.6.2 条件</span><br><span class="line"></span><br><span class="line">2.6.3 控制结构</span><br><span class="line"></span><br><span class="line">2.6.4 函数</span><br><span class="line"></span><br><span class="line">2.6.5 命令</span><br><span class="line"></span><br><span class="line">2.6.6 命令的执行</span><br><span class="line"></span><br><span class="line">2.6.7 1aere文档</span><br><span class="line"></span><br><span class="line">2.6.8 调试脚本程序</span><br><span class="line"></span><br><span class="line">2.7 迈向图形化：dialog工具</span><br><span class="line"></span><br><span class="line">2.8 综合应用</span><br><span class="line"></span><br><span class="line">2.8.1 需求</span><br><span class="line"></span><br><span class="line">2.8.2 设计</span><br><span class="line"></span><br><span class="line">2.8.3 应用程序的说明</span><br><span class="line"></span><br><span class="line">2.9 小结</span><br><span class="line"></span><br><span class="line">第3章 文件操作.</span><br><span class="line"></span><br><span class="line">3.1 Linux文件结构</span><br><span class="line"></span><br><span class="line">3.1.1 目录</span><br><span class="line"></span><br><span class="line">3.1.2 文件和设备</span><br><span class="line"></span><br><span class="line">3.2 系统调用和设备驱动程序</span><br><span class="line"></span><br><span class="line">3.3 库函数</span><br><span class="line"></span><br><span class="line">3.4 底层文件访问</span><br><span class="line"></span><br><span class="line">3.4.1 write系统调用</span><br><span class="line"></span><br><span class="line">3.4.2 read系统调用</span><br><span class="line"></span><br><span class="line">3.4.3 open系统调用</span><br><span class="line"></span><br><span class="line">3.4.4 访问权限的初始值</span><br><span class="line"></span><br><span class="line">3.4.5 其他与文件管理有关的系统调用</span><br><span class="line"></span><br><span class="line">3.5 标准I／O库</span><br><span class="line"></span><br><span class="line">3.5.1 fopen函数</span><br><span class="line"></span><br><span class="line">3.5.2 fread函数</span><br><span class="line"></span><br><span class="line">3.5.3 fwrite函数</span><br><span class="line"></span><br><span class="line">3.5.4 fclose函数</span><br><span class="line"></span><br><span class="line">3.5.5 f￡1ush函数</span><br><span class="line"></span><br><span class="line">3.5.6 fseek函数</span><br><span class="line"></span><br><span class="line">3.5.7 fgetc、getc和getchar函数</span><br><span class="line"></span><br><span class="line">3.5.8 fputc、putc和putchar函数</span><br><span class="line"></span><br><span class="line">3.5.9 fgets和gets函数</span><br><span class="line"></span><br><span class="line">3.6 格式化输入和输出</span><br><span class="line"></span><br><span class="line">3.6.1 printf、fprintf和sprin七函数</span><br><span class="line"></span><br><span class="line">3.6.2 scanf、fscanf和sscanf函数</span><br><span class="line"></span><br><span class="line">3.6.3 其他流函数</span><br><span class="line"></span><br><span class="line">3.6.4 文件流错误</span><br><span class="line"></span><br><span class="line">3.6.5 文件流和文件描述符</span><br><span class="line"></span><br><span class="line">3.7 文件和目录的维护</span><br><span class="line"></span><br><span class="line">3.7.1 chIrrod系统调用</span><br><span class="line"></span><br><span class="line">3.7.2 chown系统调用</span><br><span class="line"></span><br><span class="line">3.7.3 unlink、1ink和symlink系统调用</span><br><span class="line"></span><br><span class="line">3.7.4 mkdJ.r和rmdir系统调用</span><br><span class="line"></span><br><span class="line">3.7.5 chdir系统调用和getcwd函数</span><br><span class="line"></span><br><span class="line">3.8 扫描目录</span><br><span class="line"></span><br><span class="line">3.8.1 opendir函数</span><br><span class="line"></span><br><span class="line">3.8.2 readdir函数</span><br><span class="line"></span><br><span class="line">3.8.3 elldir函数</span><br><span class="line"></span><br><span class="line">3.8.4 see]kdir函数</span><br><span class="line"></span><br><span class="line">3.8.5 closedir函数</span><br><span class="line"></span><br><span class="line">3.9 错误处理</span><br><span class="line"></span><br><span class="line">3.9.1 strerror函数</span><br><span class="line"></span><br><span class="line">3.9.2 perror函数</span><br><span class="line"></span><br><span class="line">3.10 proc文件系统</span><br><span class="line"></span><br><span class="line">3.11 高级主题：fcntl和mmap</span><br><span class="line"></span><br><span class="line">3.11.1 fcntl系统调用</span><br><span class="line"></span><br><span class="line">3.11.2 map函数</span><br><span class="line"></span><br><span class="line">3.12 小结</span><br><span class="line"></span><br><span class="line">第4章 Linux环境</span><br><span class="line"></span><br><span class="line">4.1 程序参数</span><br><span class="line"></span><br><span class="line">4.1.1 qetopt</span><br><span class="line"></span><br><span class="line">4.1.2 getooptlong</span><br><span class="line"></span><br><span class="line">4.2 环境变量</span><br><span class="line"></span><br><span class="line">4.2.1 环境变量的用途</span><br><span class="line"></span><br><span class="line">4.2.2 environ变量</span><br><span class="line"></span><br><span class="line">4.3 时间和日期</span><br><span class="line"></span><br><span class="line">4.4 临时文件</span><br><span class="line"></span><br><span class="line">4.5 用户信息</span><br><span class="line"></span><br><span class="line">4.6 主机信息</span><br><span class="line"></span><br><span class="line">4.7 日志</span><br><span class="line"></span><br><span class="line">4.8 资源和限制</span><br><span class="line"></span><br><span class="line">4.9 小结</span><br><span class="line"></span><br><span class="line">第5章 终端</span><br><span class="line"></span><br><span class="line">5.1 对终端进行读写</span><br><span class="line"></span><br><span class="line">5.2 与终端进行对话</span><br><span class="line"></span><br><span class="line">5.3 终端驱动程序和通用终端接口</span><br><span class="line"></span><br><span class="line">5.3.1 概述</span><br><span class="line"></span><br><span class="line">5.3.2 硬件模型</span><br><span class="line"></span><br><span class="line">5.4 temios结构</span><br><span class="line"></span><br><span class="line">5.4.1 输入模式</span><br><span class="line"></span><br><span class="line">5.4.2 输出模式</span><br><span class="line"></span><br><span class="line">5.4.3 控制模式</span><br><span class="line"></span><br><span class="line">5.4.4 本地模式</span><br><span class="line"></span><br><span class="line">5.4.5 特殊控制字符</span><br><span class="line"></span><br><span class="line">5.4.6 终端速度</span><br><span class="line"></span><br><span class="line">5.4.7 其他函数</span><br><span class="line"></span><br><span class="line">5.5 终端的输出</span><br><span class="line"></span><br><span class="line">5.5.1 终端的类型</span><br><span class="line"></span><br><span class="line">5.5.2 识别终端类型</span><br><span class="line"></span><br><span class="line">5.5.3 使用teminfo功能标志</span><br><span class="line"></span><br><span class="line">5.6 检测击键动作</span><br><span class="line"></span><br><span class="line">5.7 虚拟控制台</span><br><span class="line"></span><br><span class="line">5.8 伪终端</span><br><span class="line"></span><br><span class="line">5.9 小结</span><br><span class="line"></span><br><span class="line">第6章 使用curses函数库管理基于文本的屏幕</span><br><span class="line"></span><br><span class="line">6.1 用curses函数库进行编译</span><br><span class="line"></span><br><span class="line">6.2 curses术语和概念</span><br><span class="line"></span><br><span class="line">6.3 屏幕</span><br><span class="line"></span><br><span class="line">6.3.1 输出到屏幕</span><br><span class="line"></span><br><span class="line">6.3.2 从屏幕读取</span><br><span class="line"></span><br><span class="line">6.3.3 清除屏幕</span><br><span class="line"></span><br><span class="line">6.3.4 移动光标</span><br><span class="line"></span><br><span class="line">6.3.5 字符属性</span><br><span class="line"></span><br><span class="line">6.4 键盘</span><br><span class="line"></span><br><span class="line">6.4.1 键盘模式</span><br><span class="line"></span><br><span class="line">6.4.2 键盘输入</span><br><span class="line"></span><br><span class="line">6.5 窗口</span><br><span class="line"></span><br><span class="line">6.5.1 wINDOW结构</span><br><span class="line"></span><br><span class="line">6.5.2 通用函数</span><br><span class="line"></span><br><span class="line">6.5.3 移动和更新窗口</span><br><span class="line"></span><br><span class="line">6.5.4 优化屏幕刷新</span><br><span class="line"></span><br><span class="line">6.6 子窗口</span><br><span class="line"></span><br><span class="line">6.7 keypad模式</span><br><span class="line"></span><br><span class="line">6.8 彩色显示</span><br><span class="line"></span><br><span class="line">6.9 pad</span><br><span class="line"></span><br><span class="line">6.10 CD唱片应用程序</span><br><span class="line"></span><br><span class="line">6.10.1 新CD唱片应用程序的开始部分</span><br><span class="line"></span><br><span class="line">6.10.2 main函数</span><br><span class="line"></span><br><span class="line">6.10.3 建立菜单</span><br><span class="line"></span><br><span class="line">6.10.4 操作数据库文件</span><br><span class="line"></span><br><span class="line">6.10.5 查询CD数据库</span><br><span class="line"></span><br><span class="line">6.11 小结</span><br><span class="line"></span><br><span class="line">第7章 数据管理</span><br><span class="line"></span><br><span class="line">7.1 内存管理</span><br><span class="line"></span><br><span class="line">7.1.1 简单的内存分配</span><br><span class="line"></span><br><span class="line">7.1.2 分配大量的内存</span><br><span class="line"></span><br><span class="line">7.1.3 滥用内存</span><br><span class="line"></span><br><span class="line">7.1.4 空指针</span><br><span class="line"></span><br><span class="line">7.1.5 释放内存</span><br><span class="line"></span><br><span class="line">7.1.6 其他内存分配函数</span><br><span class="line"></span><br><span class="line">7.2 文件锁定</span><br><span class="line"></span><br><span class="line">7.2.1 创建锁文件</span><br><span class="line"></span><br><span class="line">7.2.2 区域锁定</span><br><span class="line"></span><br><span class="line">7.2.3 锁定状态下的读写操作</span><br><span class="line"></span><br><span class="line">7.2.4 文件锁的竞争</span><br><span class="line"></span><br><span class="line">7.2.5 其他锁命令</span><br><span class="line"></span><br><span class="line">7.2.6 死锁</span><br><span class="line"></span><br><span class="line">7.3 数据库</span><br><span class="line"></span><br><span class="line">7.3.1 dbm数据库</span><br><span class="line"></span><br><span class="line">7.3.2 dbm例程</span><br><span class="line"></span><br><span class="line">7.3.3 d.bm访问函数</span><br><span class="line"></span><br><span class="line">7.3.4 其他dbm函数</span><br><span class="line"></span><br><span class="line">7.4 CD唱片应用程序</span><br><span class="line"></span><br><span class="line">7.4.1 更新设计</span><br><span class="line"></span><br><span class="line">7.4.2 使用dbm数据库的CD唱片应用程序</span><br><span class="line"></span><br><span class="line">7.5 小结</span><br><span class="line"></span><br><span class="line">第8章 MySQL</span><br><span class="line"></span><br><span class="line">8.1 安装</span><br><span class="line"></span><br><span class="line">8.1.1 MySQL软件包</span><br><span class="line"></span><br><span class="line">8.1.2 安装后的配置</span><br><span class="line"></span><br><span class="line">8.1.3 安装后的故障修复</span><br><span class="line"></span><br><span class="line">8.2 MySQL管理</span><br><span class="line"></span><br><span class="line">8.2.1 命令</span><br><span class="line"></span><br><span class="line">8.2.2 创建用户并赋予权限</span><br><span class="line"></span><br><span class="line">8.2.3 密码</span><br><span class="line"></span><br><span class="line">8.2.4 创建数据库</span><br><span class="line"></span><br><span class="line">8.2.5 数据类型</span><br><span class="line"></span><br><span class="line">8.2.6 创建表</span><br><span class="line"></span><br><span class="line">8.2.7 图形化工具</span><br><span class="line"></span><br><span class="line">8.3 使用C语言访问。MySQL数据</span><br><span class="line"></span><br><span class="line">8.3.1 连接例程</span><br><span class="line"></span><br><span class="line">8.3.2 错误处理</span><br><span class="line"></span><br><span class="line">8.3.3 执行SQL语句</span><br><span class="line"></span><br><span class="line">8.3.4 更多的函数</span><br><span class="line"></span><br><span class="line">8.4 CD数据库应用程序</span><br><span class="line"></span><br><span class="line">8.4.1 创建表</span><br><span class="line"></span><br><span class="line">8.4.2 添加数据</span><br><span class="line"></span><br><span class="line">8.4.3 使用C语言访问数据</span><br><span class="line"></span><br><span class="line">8.5 小结</span><br><span class="line"></span><br><span class="line">第9章 开发工具</span><br><span class="line"></span><br><span class="line">9.1 多个源文件带来的问题</span><br><span class="line"></span><br><span class="line">9.2 make命令和makefile文件</span><br><span class="line"></span><br><span class="line">9.2.1 mekefile的语法</span><br><span class="line"></span><br><span class="line">9.2.2 make命令的选项和参数</span><br><span class="line"></span><br><span class="line">9.2.3 makefile文件中的注释</span><br><span class="line"></span><br><span class="line">9.2.4 mekefile文件中的宏</span><br><span class="line"></span><br><span class="line">9.2.5 多个目标</span><br><span class="line"></span><br><span class="line">9.2.6 内置规则</span><br><span class="line"></span><br><span class="line">9.2.7 后缀和模式规则</span><br><span class="line"></span><br><span class="line">9.2.8 用make管理函数库</span><br><span class="line"></span><br><span class="line">9.2.9 高级主题：makefile文件和子目录</span><br><span class="line"></span><br><span class="line">9.2.1 0GNUmake和qcc</span><br><span class="line"></span><br><span class="line">9.3 源代码控制</span><br><span class="line"></span><br><span class="line">9.3.1 RCS</span><br><span class="line"></span><br><span class="line">9.3.2 SCCS</span><br><span class="line"></span><br><span class="line">9.3.3 RCS和SCCS的比较</span><br><span class="line"></span><br><span class="line">9.3.4 CVS</span><br><span class="line"></span><br><span class="line">9.3.5 CVS的前端程序</span><br><span class="line"></span><br><span class="line">9.3.6 SubvcrsiOn</span><br><span class="line"></span><br><span class="line">9.4 编写手册页</span><br><span class="line"></span><br><span class="line">9.5 发行软件</span><br><span class="line"></span><br><span class="line">9.5.1 pach程序</span><br><span class="line"></span><br><span class="line">9.5.2 其他软件发行工具</span><br><span class="line"></span><br><span class="line">9.6 RPM软件包</span><br><span class="line"></span><br><span class="line">9.6.1 使用RPM软件包文件</span><br><span class="line"></span><br><span class="line">9.6.2 安装RPM软件包</span><br><span class="line"></span><br><span class="line">9.6.3 创建RPM软件包</span><br><span class="line"></span><br><span class="line">9.7 其他软件包格式</span><br><span class="line"></span><br><span class="line">9.8 开发环境</span><br><span class="line"></span><br><span class="line">9.8.1 KDevelop</span><br><span class="line"></span><br><span class="line">9.8.2 其他开发环境</span><br><span class="line"></span><br><span class="line">9.9 小结</span><br><span class="line"></span><br><span class="line">第10章 调试</span><br><span class="line"></span><br><span class="line">10.1 错误类型</span><br><span class="line"></span><br><span class="line">10.2 常用调试技巧</span><br><span class="line"></span><br><span class="line">10.2.1 有漏洞的程序</span><br><span class="line"></span><br><span class="line">10.2.2 代码检查</span><br><span class="line"></span><br><span class="line">10.2.3 取样法</span><br><span class="line"></span><br><span class="line">10.2.4 程序的受控执行</span><br><span class="line"></span><br><span class="line">10.3 使用gdb进行调试</span><br><span class="line"></span><br><span class="line">10.3.1 启动gdb</span><br><span class="line"></span><br><span class="line">10.3.2 运行一个程序</span><br><span class="line"></span><br><span class="line">10.3.3 栈跟踪</span><br><span class="line"></span><br><span class="line">10.3.4 检查变量</span><br><span class="line"></span><br><span class="line">10.3.5 列出程序源代码</span><br><span class="line"></span><br><span class="line">10.3.6 设置断点</span><br><span class="line"></span><br><span class="line">10.3.7 用调试器打补丁</span><br><span class="line"></span><br><span class="line">10.3.8 深入学习gdb</span><br><span class="line"></span><br><span class="line">10.4 其他调试工具</span><br><span class="line"></span><br><span class="line">10.4.1 lint清理程序中的“垃圾”</span><br><span class="line"></span><br><span class="line">10.4.2 函数调用工具</span><br><span class="line"></span><br><span class="line">10.4.3 用prof／gprof产生执行存档</span><br><span class="line"></span><br><span class="line">10.5 断言</span><br><span class="line"></span><br><span class="line">10.6 内存调试</span><br><span class="line"></span><br><span class="line">10.6.1 ElectnicFence函数库</span><br><span class="line"></span><br><span class="line">10.6.2 valgrind</span><br><span class="line"></span><br><span class="line">10.7 小结</span><br><span class="line"></span><br><span class="line">第11章 进程和信号</span><br><span class="line"></span><br><span class="line">11.1 什么是进程</span><br><span class="line"></span><br><span class="line">11.2 进程的结构</span><br><span class="line"></span><br><span class="line">11.2.1 进程表</span><br><span class="line"></span><br><span class="line">11.2.2 查看进程</span><br><span class="line"></span><br><span class="line">11.2.3 系统进程</span><br><span class="line"></span><br><span class="line">11.2.4 进程调度</span><br><span class="line"></span><br><span class="line">11.3 启动新进程</span><br><span class="line"></span><br><span class="line">11.3.1 等待一个进程</span><br><span class="line"></span><br><span class="line">11.3.2 僵尸进程</span><br><span class="line"></span><br><span class="line">11.3.3 输入和输出重定向</span><br><span class="line"></span><br><span class="line">11.3.4 线程</span><br><span class="line"></span><br><span class="line">11.4 信号</span><br><span class="line"></span><br><span class="line">11.4.1 发送信号</span><br><span class="line"></span><br><span class="line">11.4.2 信号集</span><br><span class="line"></span><br><span class="line">11.5 小结</span><br><span class="line"></span><br><span class="line">第12章 POSlX线程</span><br><span class="line"></span><br><span class="line">12.1 什么是线程</span><br><span class="line"></span><br><span class="line">12.2 线程的优点和缺点</span><br><span class="line"></span><br><span class="line">12.3 第一个线程程序</span><br><span class="line"></span><br><span class="line">12.4 同时执行</span><br><span class="line"></span><br><span class="line">12.5 同步</span><br><span class="line"></span><br><span class="line">12.5.1 用信号量进行同步</span><br><span class="line"></span><br><span class="line">12.5.2 用互斥量进行同步</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第13章 进程音通信：管道</span><br><span class="line"></span><br><span class="line">第14章 信号量、共享内存和消息队列</span><br><span class="line"></span><br><span class="line">第15章 套接字</span><br><span class="line"></span><br><span class="line">第16章 用GTK+进行+GNOME编程</span><br><span class="line"></span><br><span class="line">第17章 用Qt进行KDE编程</span><br><span class="line"></span><br><span class="line">第18章 Linux标准</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Linux环境编程从应用到内核 PDF</title>
    <url>/posts/104bd12c/</url>
    <content><![CDATA[<h4 id="《Linux环境编程从应用到内核》"><a href="#《Linux环境编程从应用到内核》" class="headerlink" title="《Linux环境编程从应用到内核》"></a>《Linux环境编程从应用到内核》</h4><h6 id="链接-https-pan-baidu-com-s-1-GcXj8yQmOveKrWjinoQ-提取码-fwi2"><a href="#链接-https-pan-baidu-com-s-1-GcXj8yQmOveKrWjinoQ-提取码-fwi2" class="headerlink" title="链接: https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ 提取码: fwi2"></a>链接: <a href="https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ">https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ</a> 提取码: fwi2</h6><p>高峰，北京理工大学通信与信息系统专业硕士学位。毕业后在A10 Networks公司工作六年多，任职Staff Software Engineer，目前在创业公司全讯汇聚（爱快路由）担任技术总监。多年来一直专注于网络领域，熟悉Linux内核、应用及服务端的设计、开发和架构，对TCP/IP网络协议有深刻的认识和理解。编码功力深厚，知识领域广博，擅长产品的性能改进和调优。撰写过大量技术文章，并为多个知名开源项目贡献过代码。<br><a id="more"></a></p>
<p>李彬，东南大学信号与信息处理专业硕士。毕业后先后任职中兴通讯、趋势科技，目前在存储公司Bigtera担任SEG部门技术负责人。一直专注于Linu台下的开发，多年分布式存储开发经验，熟悉Linux内核，编程基本功扎实，对性能优化、bug定位有异乎寻常的爱好，属于“死磕派”研发工程师。喜欢技术分享和交流，在社区和公司内部分享过大量技术文章。</p>
<p><img src="/images/dfe6a052e2d049163027d92f9baa92341.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前　言</span><br><span class="line"></span><br><span class="line">第0章　基础知识1</span><br><span class="line"></span><br><span class="line">0.1　一个Linux程序的诞生记1</span><br><span class="line"></span><br><span class="line">0.2　程序的构成2</span><br><span class="line"></span><br><span class="line">0.3　程序是如何“跑”的4</span><br><span class="line"></span><br><span class="line">0.4　背景概念介绍5</span><br><span class="line"></span><br><span class="line">0.4.1　系统调用5</span><br><span class="line"></span><br><span class="line">0.4.2　C库函数6</span><br><span class="line"></span><br><span class="line">0.4.3　线程安全7</span><br><span class="line"></span><br><span class="line">0.4.4　原子性9</span><br><span class="line"></span><br><span class="line">0.4.5　可重入函数9</span><br><span class="line"></span><br><span class="line">0.4.6　阻塞与非阻塞11</span><br><span class="line"></span><br><span class="line">0.4.7　同步与非同步11</span><br><span class="line"></span><br><span class="line">第1章　文件I&#x2F;O12</span><br><span class="line"></span><br><span class="line">1.1　Linux中的文件12</span><br><span class="line"></span><br><span class="line">1.1.1　文件、文件描述符和文件表12</span><br><span class="line"></span><br><span class="line">1.1.2　内核文件表的实现13</span><br><span class="line"></span><br><span class="line">1.2　打开文件14</span><br><span class="line"></span><br><span class="line">1.2.1　open介绍14</span><br><span class="line"></span><br><span class="line">1.2.2　更多选项15</span><br><span class="line"></span><br><span class="line">1.2.3　open源码跟踪16</span><br><span class="line"></span><br><span class="line">1.2.4　如何选择文件描述符17</span><br><span class="line"></span><br><span class="line">1.2.5　文件描述符fd与文件管理结构file18</span><br><span class="line"></span><br><span class="line">1.3　creat简介19</span><br><span class="line"></span><br><span class="line">1.4　关闭文件19</span><br><span class="line"></span><br><span class="line">1.4.1　close介绍19</span><br><span class="line"></span><br><span class="line">1.4.2　close源码跟踪19</span><br><span class="line"></span><br><span class="line">1.4.3　自定义files_operations21</span><br><span class="line"></span><br><span class="line">1.4.4　遗忘close造成的问题22</span><br><span class="line"></span><br><span class="line">1.4.5　如何查找文件资源泄漏25</span><br><span class="line"></span><br><span class="line">1.5　文件偏移26</span><br><span class="line"></span><br><span class="line">1.5.1　lseek简介26</span><br><span class="line"></span><br><span class="line">1.5.2　小心lseek的返回值26</span><br><span class="line"></span><br><span class="line">1.5.3　lseek源码分析27</span><br><span class="line"></span><br><span class="line">1.6　读取文件29</span><br><span class="line"></span><br><span class="line">1.6.1　read源码跟踪29</span><br><span class="line"></span><br><span class="line">1.6.2　部分读取30</span><br><span class="line"></span><br><span class="line">1.7　写入文件31</span><br><span class="line"></span><br><span class="line">1.7.1　write源码跟踪31</span><br><span class="line"></span><br><span class="line">1.7.2　追加写的实现33</span><br><span class="line"></span><br><span class="line">1.8　文件的原子读写33</span><br><span class="line"></span><br><span class="line">1.9　文件描述符的复制34</span><br><span class="line"></span><br><span class="line">1.10　文件数据的同步38</span><br><span class="line"></span><br><span class="line">1.11　文件的元数据41</span><br><span class="line"></span><br><span class="line">1.11.1　获取文件的元数据41</span><br><span class="line"></span><br><span class="line">1.11.2　内核如何维护文件的元数据42</span><br><span class="line"></span><br><span class="line">1.11.3　权限位解析43</span><br><span class="line"></span><br><span class="line">1.12　文件截断45</span><br><span class="line"></span><br><span class="line">1.12.1　truncate与ftruncate的简单介绍45</span><br><span class="line"></span><br><span class="line">1.12.2　文件截断的内核实现45</span><br><span class="line"></span><br><span class="line">1.12.3　为什么需要文件截断48</span><br><span class="line"></span><br><span class="line">第2章　标准I&#x2F;O库50</span><br><span class="line"></span><br><span class="line">2.1　stdin、stdout和stderr50</span><br><span class="line"></span><br><span class="line">2.2　I&#x2F;O缓存引出的趣题51</span><br><span class="line"></span><br><span class="line">2.3　fopen和open标志位对比52</span><br><span class="line"></span><br><span class="line">2.4　fdopen与fileno55</span><br><span class="line"></span><br><span class="line">2.5　同时读写的痛苦56</span><br><span class="line"></span><br><span class="line">2.6　ferror的返回值57</span><br><span class="line"></span><br><span class="line">2.7　clearerr的用途57</span><br><span class="line"></span><br><span class="line">2.8　小心fgetc和getc60</span><br><span class="line"></span><br><span class="line">2.9　注意fread和fwrite的返回值60</span><br><span class="line"></span><br><span class="line">2.10　创建临时文件61</span><br><span class="line"></span><br><span class="line">第3章　进程环境66</span><br><span class="line"></span><br><span class="line">3.1　main是C程序的开始吗66</span><br><span class="line"></span><br><span class="line">3.2　“活雷锋”exit70</span><br><span class="line"></span><br><span class="line">3.3　atexit介绍75</span><br><span class="line"></span><br><span class="line">3.3.1　使用atexit75</span><br><span class="line"></span><br><span class="line">3.3.2　atexit的局限性76</span><br><span class="line"></span><br><span class="line">3.3.3　atexit的实现机制77</span><br><span class="line"></span><br><span class="line">3.4　小心使用环境变量78</span><br><span class="line"></span><br><span class="line">3.5　使用动态库80</span><br><span class="line"></span><br><span class="line">3.5.1　动态库与静态库80</span><br><span class="line"></span><br><span class="line">3.5.2　编译生成和使用动态库80</span><br><span class="line"></span><br><span class="line">3.5.3　程序的“平滑无缝”升级82</span><br><span class="line"></span><br><span class="line">3.6　避免内存问题84</span><br><span class="line"></span><br><span class="line">3.6.1　尴尬的realloc84</span><br><span class="line"></span><br><span class="line">3.6.2　如何防止内存越界85</span><br><span class="line"></span><br><span class="line">3.6.3　如何定位内存问题86</span><br><span class="line"></span><br><span class="line">3.7　“长跳转”longjmp90</span><br><span class="line"></span><br><span class="line">3.7.1　setjmp与longjmp的使用90</span><br><span class="line"></span><br><span class="line">3.7.2　“长跳转”的实现机制91</span><br><span class="line"></span><br><span class="line">3.7.3　“长跳转”的陷阱93</span><br><span class="line"></span><br><span class="line">第4章　进程控制：进程的一生96</span><br><span class="line"></span><br><span class="line">4.1　进程ID96</span><br><span class="line"></span><br><span class="line">4.2　进程的层次98</span><br><span class="line"></span><br><span class="line">4.2.1　进程组99</span><br><span class="line"></span><br><span class="line">4.2.2　会话102</span><br><span class="line"></span><br><span class="line">4.3　进程的创建之fork()103</span><br><span class="line"></span><br><span class="line">4.3.1　fork之后父子进程的内存关系104</span><br><span class="line"></span><br><span class="line">4.3.2　fork之后父子进程与文件的关系107</span><br><span class="line"></span><br><span class="line">4.3.3　文件描述符复制的内核实现110</span><br><span class="line"></span><br><span class="line">4.4　进程的创建之vfork()115</span><br><span class="line"></span><br><span class="line">4.5　daemon进程的创建117</span><br><span class="line"></span><br><span class="line">4.6　进程的终止119</span><br><span class="line"></span><br><span class="line">4.6.1　_exit函数119</span><br><span class="line"></span><br><span class="line">4.6.2　exit函数120</span><br><span class="line"></span><br><span class="line">4.6.3　return退出122</span><br><span class="line"></span><br><span class="line">4.7　等待子进程122</span><br><span class="line"></span><br><span class="line">4.7.1　僵尸进程122</span><br><span class="line"></span><br><span class="line">4.7.2　等待子进程之wait()124</span><br><span class="line"></span><br><span class="line">4.7.3　等待子进程之waitpid()126</span><br><span class="line"></span><br><span class="line">4.7.4　等待子进程之等待状态值129</span><br><span class="line"></span><br><span class="line">4.7.5　等待子进程之waitid()131</span><br><span class="line"></span><br><span class="line">4.7.6　进程退出和等待的内核实现133</span><br><span class="line"></span><br><span class="line">4.8　exec家族141</span><br><span class="line"></span><br><span class="line">4.8.1　execve函数141</span><br><span class="line"></span><br><span class="line">4.8.2　exec家族142</span><br><span class="line"></span><br><span class="line">4.8.3　execve系统调用的内核实现144</span><br><span class="line"></span><br><span class="line">4.8.4　exec与信号151</span><br><span class="line"></span><br><span class="line">4.8.5　执行exec之后进程继承的属性152</span><br><span class="line"></span><br><span class="line">4.9　system函数152</span><br><span class="line"></span><br><span class="line">4.9.1　system函数接口153</span><br><span class="line"></span><br><span class="line">4.9.2　system函数与信号156</span><br><span class="line"></span><br><span class="line">4.10　总结157</span><br><span class="line"></span><br><span class="line">第5章　进程控制：状态、调度和优先级158</span><br><span class="line"></span><br><span class="line">5.1　进程的状态158</span><br><span class="line"></span><br><span class="line">5.1.1　进程状态概述159</span><br><span class="line"></span><br><span class="line">5.1.2　观察进程状态171</span><br><span class="line"></span><br><span class="line">5.2　进程调度概述173</span><br><span class="line"></span><br><span class="line">5.3　普通进程的优先级181</span><br><span class="line"></span><br><span class="line">5.4　完全公平调度的实现186</span><br><span class="line"></span><br><span class="line">5.4.1　时间片和虚拟运行时间186</span><br><span class="line"></span><br><span class="line">5.4.2　周期性调度任务190</span><br><span class="line"></span><br><span class="line">5.4.3　新进程的加入192</span><br><span class="line"></span><br><span class="line">5.4.4　睡眠进程醒来198</span><br><span class="line"></span><br><span class="line">5.4.5　唤醒抢占202</span><br><span class="line"></span><br><span class="line">5.5　普通进程的组调度204</span><br><span class="line"></span><br><span class="line">5.6　实时进程207</span><br><span class="line"></span><br><span class="line">5.6.1　实时调度策略和优先级207</span><br><span class="line"></span><br><span class="line">5.6.2　实时调度相关API211</span><br><span class="line"></span><br><span class="line">5.6.3　限制实时进程运行时间213</span><br><span class="line"></span><br><span class="line">5.7　CPU的亲和力214</span><br><span class="line"></span><br><span class="line">第6章　信号219</span><br><span class="line"></span><br><span class="line">6.1　信号的完整生命周期219</span><br><span class="line"></span><br><span class="line">6.2　信号的产生220</span><br><span class="line"></span><br><span class="line">6.2.1　硬件异常220</span><br><span class="line"></span><br><span class="line">6.2.2　终端相关的信号221</span><br><span class="line"></span><br><span class="line">6.2.3　软件事件相关的信号223</span><br><span class="line"></span><br><span class="line">6.3　信号的默认处理函数224</span><br><span class="line"></span><br><span class="line">6.4　信号的分类227</span><br><span class="line"></span><br><span class="line">6.5　传统信号的特点228</span><br><span class="line"></span><br><span class="line">6.5.1　信号的ONESHOT特性230</span><br><span class="line"></span><br><span class="line">6.5.2　信号执行时屏蔽自身的特性232</span><br><span class="line"></span><br><span class="line">6.5.3　信号中断系统调用的重启特性233</span><br><span class="line"></span><br><span class="line">6.6　信号的可靠性236</span><br><span class="line"></span><br><span class="line">6.6.1　信号的可靠性实验236</span><br><span class="line"></span><br><span class="line">6.6.2　信号可靠性差异的根源240</span><br><span class="line"></span><br><span class="line">6.7　信号的安装243</span><br><span class="line"></span><br><span class="line">6.8　信号的发送246</span><br><span class="line"></span><br><span class="line">6.8.1　kill、tkill和tgkill246</span><br><span class="line"></span><br><span class="line">6.8.2　raise函数247</span><br><span class="line"></span><br><span class="line">6.8.3　sigqueue函数247</span><br><span class="line"></span><br><span class="line">6.9　信号与线程的关系253</span><br><span class="line"></span><br><span class="line">6.9.1　线程之间共享信号处理函数254</span><br><span class="line"></span><br><span class="line">6.9.2　线程有独立的阻塞信号掩码255</span><br><span class="line"></span><br><span class="line">6.9.3　私有挂起信号和共享挂起信号257</span><br><span class="line"></span><br><span class="line">6.9.4　致命信号下，进程组全体退出260</span><br><span class="line"></span><br><span class="line">6.10　等待信号260</span><br><span class="line"></span><br><span class="line">6.10.1　pause函数261</span><br><span class="line"></span><br><span class="line">6.10.2　sigsuspend函数262</span><br><span class="line"></span><br><span class="line">6.10.3　sigwait函数和sigwaitinfo函数263</span><br><span class="line"></span><br><span class="line">6.11　通过文件描述符来获取信号265</span><br><span class="line"></span><br><span class="line">6.12　信号递送的顺序267</span><br><span class="line"></span><br><span class="line">6.13　异步信号安全272</span><br><span class="line"></span><br><span class="line">6.14　总结275</span><br><span class="line"></span><br><span class="line">第7章　理解Linux线程（1）276</span><br><span class="line"></span><br><span class="line">7.1　线程与进程276</span><br><span class="line"></span><br><span class="line">7.2　进程ID和线程ID281</span><br><span class="line"></span><br><span class="line">7.3　pthread库接口介绍284</span><br><span class="line"></span><br><span class="line">7.4　线程的创建和标识285</span><br><span class="line"></span><br><span class="line">7.4.1　pthread_create函数285</span><br><span class="line"></span><br><span class="line">7.4.2　线程ID及进程地址空间布局286</span><br><span class="line"></span><br><span class="line">7.4.3　线程创建的默认属性291</span><br><span class="line"></span><br><span class="line">7.5　线程的退出292</span><br><span class="line"></span><br><span class="line">7.6　线程的连接与分离293</span><br><span class="line"></span><br><span class="line">7.6.1　线程的连接293</span><br><span class="line"></span><br><span class="line">7.6.2　为什么要连接退出的线程295</span><br><span class="line"></span><br><span class="line">7.6.3　线程的分离299</span><br><span class="line"></span><br><span class="line">7.7　互斥量300</span><br><span class="line"></span><br><span class="line">7.7.1　为什么需要互斥量300</span><br><span class="line"></span><br><span class="line">7.7.2　互斥量的接口304</span><br><span class="line"></span><br><span class="line">7.7.3　临界区的大小305</span><br><span class="line"></span><br><span class="line">7.7.4　互斥量的性能306</span><br><span class="line"></span><br><span class="line">7.7.5　互斥锁的公平性310</span><br><span class="line"></span><br><span class="line">7.7.6　互斥锁的类型311</span><br><span class="line"></span><br><span class="line">7.7.7　死锁和活锁314</span><br><span class="line"></span><br><span class="line">7.8　读写锁316</span><br><span class="line"></span><br><span class="line">7.8.1　读写锁的接口317</span><br><span class="line"></span><br><span class="line">7.8.2　读写锁的竞争策略318</span><br><span class="line"></span><br><span class="line">7.8.3　读写锁总结323</span><br><span class="line"></span><br><span class="line">7.9　性能杀手：伪共享323</span><br><span class="line"></span><br><span class="line">7.10　条件等待328</span><br><span class="line"></span><br><span class="line">7.10.1　条件变量的创建和销毁328</span><br><span class="line"></span><br><span class="line">7.10.2　条件变量的使用329</span><br><span class="line"></span><br><span class="line">第8章　理解Linux线程（2）333</span><br><span class="line"></span><br><span class="line">8.1　线程取消333</span><br><span class="line"></span><br><span class="line">8.1.1　函数取消接口333</span><br><span class="line"></span><br><span class="line">8.1.2　线程清理函数335</span><br><span class="line"></span><br><span class="line">8.2　线程局部存储339</span><br><span class="line"></span><br><span class="line">8.2.1　使用NPTL库函数实现线程局部存储340</span><br><span class="line"></span><br><span class="line">8.2.2　使用__thread关键字实现线程局部存储342</span><br><span class="line"></span><br><span class="line">8.3　线程与信号343</span><br><span class="line"></span><br><span class="line">8.3.1　设置线程的信号掩码344</span><br><span class="line"></span><br><span class="line">8.3.2　向线程发送信号344</span><br><span class="line"></span><br><span class="line">8.3.3　多线程程序对信号的处理345</span><br><span class="line"></span><br><span class="line">8.4　多线程与fork()345</span><br><span class="line"></span><br><span class="line">第9章　进程间通信：管道349</span><br><span class="line"></span><br><span class="line">9.1　管道351</span><br><span class="line"></span><br><span class="line">9.1.1　管道概述351</span><br><span class="line"></span><br><span class="line">9.1.2　管道接口352</span><br><span class="line"></span><br><span class="line">9.1.3　关闭未使用的管道文件描述符356</span><br><span class="line"></span><br><span class="line">9.1.4　管道对应的内存区大小361</span><br><span class="line"></span><br><span class="line">9.1.5　shell管道的实现361</span><br><span class="line"></span><br><span class="line">9.1.6　与shell命令进行通信（popen）362</span><br><span class="line"></span><br><span class="line">9.2　命名管道FIFO365</span><br><span class="line"></span><br><span class="line">9.2.1　创建FIFO文件365</span><br><span class="line"></span><br><span class="line">9.2.2　打开FIFO文件366</span><br><span class="line"></span><br><span class="line">9.3　读写管道文件367</span><br><span class="line"></span><br><span class="line">9.4　使用管道通信的示例372</span><br><span class="line"></span><br><span class="line">第10章　进程间通信：System V IPC375</span><br><span class="line"></span><br><span class="line">10.1　System V IPC概述375</span><br><span class="line"></span><br><span class="line">10.1.1　标识符与IPC Key376</span><br><span class="line"></span><br><span class="line">10.1.2　IPC的公共数据结构379</span><br><span class="line"></span><br><span class="line">10.2　System V消息队列383</span><br><span class="line"></span><br><span class="line">10.2.1　创建或打开一个消息队列383</span><br><span class="line"></span><br><span class="line">10.2.2　发送消息385</span><br><span class="line"></span><br><span class="line">10.2.3　接收消息388</span><br><span class="line"></span><br><span class="line">10.2.4　控制消息队列390</span><br><span class="line"></span><br><span class="line">10.3　System **号量391</span><br><span class="line"></span><br><span class="line">10.3.1　信号量概述391</span><br><span class="line"></span><br><span class="line">10.3.2　创建或打开信号量393</span><br><span class="line"></span><br><span class="line">10.3.3　操作信号量395</span><br><span class="line"></span><br><span class="line">10.3.4　信号量撤销值399</span><br><span class="line"></span><br><span class="line">10.3.5　控制信号量400</span><br><span class="line"></span><br><span class="line">10.4　System V共享内存402</span><br><span class="line"></span><br><span class="line">10.4.1　共享内存概述402</span><br><span class="line"></span><br><span class="line">10.4.2　创建或打开共享内存403</span><br><span class="line"></span><br><span class="line">10.4.3　使用共享内存405</span><br><span class="line"></span><br><span class="line">10.4.4　分离共享内存407</span><br><span class="line"></span><br><span class="line">10.4.5　控制共享内存408</span><br><span class="line"></span><br><span class="line">第11章　进程间通信：POSIX IPC410</span><br><span class="line"></span><br><span class="line">11.1　POSIX IPC概述411</span><br><span class="line"></span><br><span class="line">11.1.1　IPC对象的名字411</span><br><span class="line"></span><br><span class="line">11.1.2　创建或打开IPC对象413</span><br><span class="line"></span><br><span class="line">11.1.3　关闭和删除IPC对象414</span><br><span class="line"></span><br><span class="line">11.1.4　其他414</span><br><span class="line"></span><br><span class="line">11.2　POSIX消息队列415</span><br><span class="line"></span><br><span class="line">11.2.1　消息队列的创建、打开、关闭及删除415</span><br><span class="line"></span><br><span class="line">11.2.2　消息队列的属性418</span><br><span class="line"></span><br><span class="line">11.2.3　消息的发送和接收422</span><br><span class="line"></span><br><span class="line">11.2.4　消息的通知423</span><br><span class="line"></span><br><span class="line">11.2.5　I&#x2F;O多路复用监控消息队列427</span><br><span class="line"></span><br><span class="line">11.3　POSIX信号量428</span><br><span class="line"></span><br><span class="line">11.3.1　创建、打开、关闭和删除有名信号量430</span><br><span class="line"></span><br><span class="line">11.3.2　信号量的使用431</span><br><span class="line"></span><br><span class="line">11.3.3　无名信号量的创建和销毁432</span><br><span class="line"></span><br><span class="line">11.3.4　信号量与futex433</span><br><span class="line"></span><br><span class="line">11.4　内存映射mmap436</span><br><span class="line"></span><br><span class="line">11.4.1　内存映射概述436</span><br><span class="line"></span><br><span class="line">11.4.2　内存映射的相关接口438</span><br><span class="line"></span><br><span class="line">11.4.3　共享文件映射439</span><br><span class="line"></span><br><span class="line">11.4.4　私有文件映射455</span><br><span class="line"></span><br><span class="line">11.4.5　共享匿名映射455</span><br><span class="line"></span><br><span class="line">11.4.6　私有匿名映射456</span><br><span class="line"></span><br><span class="line">11.5　POSIX共享内存456</span><br><span class="line"></span><br><span class="line">11.5.1　共享内存的创建、使用和删除457</span><br><span class="line"></span><br><span class="line">11.5.2　共享内存与tmpfs458</span><br><span class="line"></span><br><span class="line">第12章　网络通信：连接的建立462</span><br><span class="line"></span><br><span class="line">12.1　socket文件描述符462</span><br><span class="line"></span><br><span class="line">12.2　绑定IP地址463</span><br><span class="line"></span><br><span class="line">12.2.1　bind的使用464</span><br><span class="line"></span><br><span class="line">12.2.2　bind的源码分析465</span><br><span class="line"></span><br><span class="line">12.3　客户端连接过程468</span><br><span class="line"></span><br><span class="line">12.3.1　connect的使用468</span><br><span class="line"></span><br><span class="line">12.3.2　connect的源码分析469</span><br><span class="line"></span><br><span class="line">12.4　服务器端连接过程477</span><br><span class="line"></span><br><span class="line">12.4.1　listen的使用477</span><br><span class="line"></span><br><span class="line">12.4.2　listen的源码分析478</span><br><span class="line"></span><br><span class="line">12.4.3　accept的使用480</span><br><span class="line"></span><br><span class="line">12.4.4　accept的源码分析480</span><br><span class="line"></span><br><span class="line">12.5　TCP三次握手的实现分析483</span><br><span class="line"></span><br><span class="line">12.5.1　SYN包的发送483</span><br><span class="line"></span><br><span class="line">12.5.2　接收SYN包，发送SYN+ACK包485</span><br><span class="line"></span><br><span class="line">12.5.3　接收SYN+ACK数据包494</span><br><span class="line"></span><br><span class="line">12.5.4　接收ACK数据包，完成三次握手499</span><br><span class="line"></span><br><span class="line">第13章　网络通信：数据报文的发送505</span><br><span class="line"></span><br><span class="line">13.1　发送相关接口505</span><br><span class="line"></span><br><span class="line">13.2　数据包从用户空间到内核空间的流程506</span><br><span class="line"></span><br><span class="line">13.3　UDP数据包的发送流程510</span><br><span class="line"></span><br><span class="line">13.4　TCP数据包的发送流程517</span><br><span class="line"></span><br><span class="line">13.5　IP数据包的发送流程527</span><br><span class="line"></span><br><span class="line">13.5.1　ip_send_skb源码分析528</span><br><span class="line"></span><br><span class="line">13.5.2　ip_queue_xmit源码分析531</span><br><span class="line"></span><br><span class="line">13.6　底层模块数据包的发送流程532</span><br><span class="line"></span><br><span class="line">第14章　网络通信：数据报文的接收536</span><br><span class="line"></span><br><span class="line">14.1　系统调用接口536</span><br><span class="line"></span><br><span class="line">14.2　数据包从内核空间到用户空间的流程537</span><br><span class="line"></span><br><span class="line">14.3　UDP数据包的接收流程540</span><br><span class="line"></span><br><span class="line">14.4　TCP数据包的接收流程544</span><br><span class="line"></span><br><span class="line">14.5　TCP套接字的三个接收队列553</span><br><span class="line"></span><br><span class="line">14.6　从网卡到套接字556</span><br><span class="line"></span><br><span class="line">14.6.1　从硬中断到软中断556</span><br><span class="line"></span><br><span class="line">14.6.2　软中断处理557</span><br><span class="line"></span><br><span class="line">14.6.3　传递给协议栈流程559</span><br><span class="line"></span><br><span class="line">14.6.4　IP协议处理流程564</span><br><span class="line"></span><br><span class="line">14.6.5　大师的错误？原始套接字的接收568</span><br><span class="line"></span><br><span class="line">14.6.6　注册传输层协议571</span><br><span class="line"></span><br><span class="line">14.6.7　确定UDP套接字571</span><br><span class="line"></span><br><span class="line">14.6.8　确定TCP套接字576</span><br><span class="line"></span><br><span class="line">第15章　编写安全无错代码582</span><br><span class="line"></span><br><span class="line">15.1　不要用memcmp比较结构体582</span><br><span class="line"></span><br><span class="line">15.2　有符号数和无符号数的移位区别583</span><br><span class="line"></span><br><span class="line">15.3　数组和指针584</span><br><span class="line"></span><br><span class="line">15.4　再论数组首地址587</span><br><span class="line"></span><br><span class="line">15.5　“神奇”的整数类型转换588</span><br><span class="line"></span><br><span class="line">15.6　小心volatile的原子性误解589</span><br><span class="line"></span><br><span class="line">15.7　有趣的问题：“x &#x3D;&#x3D; x”何时为假？591</span><br><span class="line"></span><br><span class="line">15.8　小心浮点陷阱593</span><br><span class="line"></span><br><span class="line">15.8.1　浮点数的精度限制593</span><br><span class="line"></span><br><span class="line">15.8.2　两个特殊的浮点值593</span><br><span class="line"></span><br><span class="line">15.9　Intel移位指令陷阱595</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令详解词典施威铭研究室 PDF</title>
    <url>/posts/80f4ccbd/</url>
    <content><![CDATA[<h4 id="《Linux命令详解词典施威铭研究室》"><a href="#《Linux命令详解词典施威铭研究室》" class="headerlink" title="《Linux命令详解词典施威铭研究室》"></a>《Linux命令详解词典施威铭研究室》</h4><h6 id="链接-https-pan-baidu-com-s-1QEszuv4nvSAvY-bL16dXSw-提取码-rhpb"><a href="#链接-https-pan-baidu-com-s-1QEszuv4nvSAvY-bL16dXSw-提取码-rhpb" class="headerlink" title="链接: https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw 提取码: rhpb"></a>链接: <a href="https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw">https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw</a> 提取码: rhpb</h6><p>本书精选了381个Linux命令，详细罗列1729个范例，并提供3种查询索引方式。本书详细列出Linux命令的参数、功能说明、所属包、丰富的范例以及相关命令等信息，以统一的结构呈现，让Linux用户在短时间内找到需要的命令，了解命令的正确使用方式，并成功地将范例应用到实际中。<br><a id="more"></a></p>
<p>本书适合作为程序员和工程技术人员的工具手册。</p>
<p><img src="/images/fb19025c90c2624d25bd455cff02c3dd1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line"></span><br><span class="line">E</span><br><span class="line"></span><br><span class="line">F</span><br><span class="line"></span><br><span class="line">G</span><br><span class="line"></span><br><span class="line">H</span><br><span class="line"></span><br><span class="line">I</span><br><span class="line"></span><br><span class="line">J</span><br><span class="line"></span><br><span class="line">K</span><br><span class="line"></span><br><span class="line">L</span><br><span class="line"></span><br><span class="line">M</span><br><span class="line"></span><br><span class="line">N</span><br><span class="line"></span><br><span class="line">O</span><br><span class="line"></span><br><span class="line">P</span><br><span class="line"></span><br><span class="line">R</span><br><span class="line"></span><br><span class="line">S</span><br><span class="line"></span><br><span class="line">T</span><br><span class="line"></span><br><span class="line">U</span><br><span class="line"></span><br><span class="line">V</span><br><span class="line"></span><br><span class="line">W</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line"></span><br><span class="line">Y</span><br><span class="line"></span><br><span class="line">Z</span><br><span class="line"></span><br><span class="line">精选381个命令，详细列出1729个范例，提供3种查询索引，适合各种Linux发行版</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Maven实战 PDF</title>
    <url>/posts/f7f3fc2b/</url>
    <content><![CDATA[<h4 id="《Maven实战》"><a href="#《Maven实战》" class="headerlink" title="《Maven实战》"></a>《Maven实战》</h4><h6 id="链接-https-pan-baidu-com-s-1Dhme4PtAW8NhdvPB4xFM9A-提取码-x5xv"><a href="#链接-https-pan-baidu-com-s-1Dhme4PtAW8NhdvPB4xFM9A-提取码-x5xv" class="headerlink" title="链接: https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A 提取码: x5xv"></a>链接: <a href="https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A">https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A</a> 提取码: x5xv</h6><p>《Maven实战》由国内社区公认的Maven专家Juven Xu亲自执笔，内容的权威性毋庸置疑。《Maven实战》是国内第一本公开出版的Maven专著。它内容新颖，基于<strong>发布的Maven 3.0，不仅详尽讲解了 Maven 3.0的所有新功能和新特性，而且还将这些新功能和新特性与Maven 2.0版本进行了对比，以便于正在使用Maven 2.x版本的用户能更好地理解。《Maven实战》内容全面，以从专家的角度阐释Maven的价值开篇，全面介绍了Maven的安装、配置和基本使用方法，以便于初学者参考；详细讲解了坐标和依赖、Maven仓库、生命周期和插件、聚合与继承等Maven的核心概念，建议所有读者仔细阅读；系统性地阐述了使用Nexus建立私服、使用Maven进行测试、使用Hudson进行持续集成、使用Maven构建Web应用、Maven的版本管理、Maven的灵活构建、生成项目站点和Maven的m2eclipse插件等实用性较强的高级知识，读者可有选择性的阅读；扩展性地讲解了如何Maven和Archetype插件，这部分内容对需要编写插件扩展Maven或需要编写Archetype维护自己的项目骨架以更便于团队开发的读者来说尤为有帮助。它实战性强，不仅绝大部分知识点都有相应的案例，而且《Maven实战》还在第4章设计了一个背景案例，后面的很多章节都是围绕这个案例展开的，可操作性极强。《Maven实战》适合所有Java程序员阅读，无论你是从未使用过Maven，亦或是已经使用Maven很长一段时间了，相信你都能从《Maven实战》中获得有价值的</strong>参考。《Maven实战》也适合所有项目经理阅读，它能帮助你更规范、更高效地管理Java项目。<br><a id="more"></a></p>
<p><img src="/images/262f3b066518239b57613c8d3baa46be1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 Maven简介／1</span><br><span class="line"></span><br><span class="line">1.1 何为Maven／2</span><br><span class="line"></span><br><span class="line">1.1.1 何为构建／2</span><br><span class="line"></span><br><span class="line">1.1.2 Maven是优秀的构建工具／2</span><br><span class="line"></span><br><span class="line">1.1.3 Maven不仅仅是构建工具乃</span><br><span class="line"></span><br><span class="line">1.2 为什么需要Maven／4</span><br><span class="line"></span><br><span class="line">1.2.1 组装PC和品牌PC／4</span><br><span class="line"></span><br><span class="line">1.2.2 IDE不是万能的／4</span><br><span class="line"></span><br><span class="line">1.2.3 Make／5</span><br><span class="line"></span><br><span class="line">1.2.4 Ant／5</span><br><span class="line"></span><br><span class="line">1.2.5 不重复发明轮子／6</span><br><span class="line"></span><br><span class="line">1.3 Maven与极限编程／7</span><br><span class="line"></span><br><span class="line">1.4 被误解的Maven／8</span><br><span class="line"></span><br><span class="line">1.5 小结／9</span><br><span class="line"></span><br><span class="line">第2章 Maven的安装和配置／10</span><br><span class="line"></span><br><span class="line">2.1 在Windows上安装Maven／11</span><br><span class="line"></span><br><span class="line">2.1.]检查JDK安装／11</span><br><span class="line"></span><br><span class="line">2.1.2 下载Maven／11</span><br><span class="line"></span><br><span class="line">2.1.3 本地安装／12</span><br><span class="line"></span><br><span class="line">2.1.4 升级Maven／13</span><br><span class="line"></span><br><span class="line">2.2 在基于UNIX的系统上安装Maven／13</span><br><span class="line"></span><br><span class="line">2.2.1 下载和安装／13</span><br><span class="line"></span><br><span class="line">2.2.2 井级Maven／15</span><br><span class="line"></span><br><span class="line">2.3 安装目录分析／15</span><br><span class="line"></span><br><span class="line">2.3.1 M2－HOME／15</span><br><span class="line"></span><br><span class="line">2.4 设置HTTP代理／17</span><br><span class="line"></span><br><span class="line">2.5 安装m2eclipse／18</span><br><span class="line"></span><br><span class="line">2.6 安装NetBeansMaven插件／22</span><br><span class="line"></span><br><span class="line">2.7 Maven安装最佳实践／24</span><br><span class="line"></span><br><span class="line">2.7.1 设置MAVEN-OPTS环境变量／24</span><br><span class="line"></span><br><span class="line">2.7.2 配置用户范围settings.xmL／24</span><br><span class="line"></span><br><span class="line">2.7.3 不要使用IDE內嵌的Maven／25</span><br><span class="line"></span><br><span class="line">2.8 小结／26</span><br><span class="line"></span><br><span class="line">第3章 Maven使用入门／27</span><br><span class="line"></span><br><span class="line">3.1 编写POM／28</span><br><span class="line"></span><br><span class="line">3.2 编写主代码／29</span><br><span class="line"></span><br><span class="line">3.3 编写测试代码／30</span><br><span class="line"></span><br><span class="line">3.4 打包和运行／34</span><br><span class="line"></span><br><span class="line">3.5 使用Archetype生成项目骨架／36</span><br><span class="line"></span><br><span class="line">3.6 m2eclipse简单使用／37</span><br><span class="line"></span><br><span class="line">3.6.1 导入Maven项目／37</span><br><span class="line"></span><br><span class="line">3.6.2 创建Maven项目／39</span><br><span class="line"></span><br><span class="line">3.6.3 运行mvn命令／39</span><br><span class="line"></span><br><span class="line">3.7 NetBeansMaven插件简单使用／41</span><br><span class="line"></span><br><span class="line">3.7.1 打开Maven项目／41</span><br><span class="line"></span><br><span class="line">3.7.2 创建Maven项目／42</span><br><span class="line"></span><br><span class="line">3.7.3 运行mvn命令／43</span><br><span class="line"></span><br><span class="line">3.8 小结／44</span><br><span class="line"></span><br><span class="line">第4章 背景案例／45</span><br><span class="line"></span><br><span class="line">4.1 简单的账户注册服务／46</span><br><span class="line"></span><br><span class="line">4.2 需求阐述／46</span><br><span class="line"></span><br><span class="line">4.2.1 需求用例／46</span><br><span class="line"></span><br><span class="line">4.2.2 界面原型／48</span><br><span class="line"></span><br><span class="line">4.3 简要设计／49</span><br><span class="line"></span><br><span class="line">4.3.1 接口／49</span><br><span class="line"></span><br><span class="line">4.3.2 模块结构／49</span><br><span class="line"></span><br><span class="line">4.4 小结／50</span><br><span class="line"></span><br><span class="line">第5章 坐标和依赖／51</span><br><span class="line"></span><br><span class="line">5.1 何为Maven坐标／52</span><br><span class="line"></span><br><span class="line">5.2 坐标详解／53</span><br><span class="line"></span><br><span class="line">5.3 account－email／54</span><br><span class="line"></span><br><span class="line">5.3.1 account－email的POM／54</span><br><span class="line"></span><br><span class="line">5.3.2 account－email的主代码／56</span><br><span class="line"></span><br><span class="line">5.3.3 account－email的测试代码／60</span><br><span class="line"></span><br><span class="line">5.3.4 构建account－emaiL／62</span><br><span class="line"></span><br><span class="line">5.4 依赖的配置／62</span><br><span class="line"></span><br><span class="line">5.5 依赖范围／63</span><br><span class="line"></span><br><span class="line">5.6 传递性依赖／64</span><br><span class="line"></span><br><span class="line">5.6.1 何为传递性依赖／64</span><br><span class="line"></span><br><span class="line">5.6.2 传递性依赖和依赖范围／65</span><br><span class="line"></span><br><span class="line">5.7 依赖调解／66</span><br><span class="line"></span><br><span class="line">5.8 可选依赖／66</span><br><span class="line"></span><br><span class="line">5.9 最佳实践／68</span><br><span class="line"></span><br><span class="line">5.9.1 排除依赖／68</span><br><span class="line"></span><br><span class="line">5.9.2 归类依赖／69</span><br><span class="line"></span><br><span class="line">5.9.3 优化依赖／71</span><br><span class="line"></span><br><span class="line">5.10 小结／74</span><br><span class="line"></span><br><span class="line">第6章 仓库／75</span><br><span class="line"></span><br><span class="line">6.1 何为Maven仓库／76</span><br><span class="line"></span><br><span class="line">6.2 仓库的布局／76</span><br><span class="line"></span><br><span class="line">6.3 仓库的分类／78</span><br><span class="line"></span><br><span class="line">6.3.1 本地仓库／79</span><br><span class="line"></span><br><span class="line">6.3.2 远程仓库／80</span><br><span class="line"></span><br><span class="line">6.3.3 中央仓库／80</span><br><span class="line"></span><br><span class="line">6.3.4 私服／81</span><br><span class="line"></span><br><span class="line">6.4 远程仓库的配置／82</span><br><span class="line"></span><br><span class="line">6.4.1 远程仓库的认证／83</span><br><span class="line"></span><br><span class="line">6.4.2 部署至远程仓库／84</span><br><span class="line"></span><br><span class="line">6.5 快照版本／85</span><br><span class="line"></span><br><span class="line">6.6 从仓库解析依赖的机制／87</span><br><span class="line"></span><br><span class="line">6.7 镜像／89</span><br><span class="line"></span><br><span class="line">6.8 仓库搜索服务／90</span><br><span class="line"></span><br><span class="line">6.8.1 SonatypeNexus／90</span><br><span class="line"></span><br><span class="line">6.8.2 Jarvana／91</span><br><span class="line"></span><br><span class="line">6.8.3 MVNbrowser／91</span><br><span class="line"></span><br><span class="line">6.8.4 MVNrepository／92</span><br><span class="line"></span><br><span class="line">6.8.5 选择合适的仓库搜索服务／93</span><br><span class="line"></span><br><span class="line">6.9 小结／93</span><br><span class="line"></span><br><span class="line">第7章 生命周期和插件／94</span><br><span class="line"></span><br><span class="line">7.1 何为生命周期／95</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">第8章 聚合与继承</span><br><span class="line"></span><br><span class="line">第9章 Nexus创建私服</span><br><span class="line"></span><br><span class="line">第10章 使用 Maven进行测试</span><br><span class="line"></span><br><span class="line">第11章 使用Hudson进行持续集成</span><br><span class="line"></span><br><span class="line">第12章 使用Maven构建Web应用</span><br><span class="line"></span><br><span class="line">第13章 版本管理</span><br><span class="line"></span><br><span class="line">第14章 灵活的构建</span><br><span class="line"></span><br><span class="line">第15章 生成项目站点</span><br><span class="line"></span><br><span class="line">第16章 m2eclipse</span><br><span class="line"></span><br><span class="line">第17章 编写Maven插件</span><br><span class="line"></span><br><span class="line">第18章 Archetype</span><br><span class="line"></span><br><span class="line">附录</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB权威指南 PDF</title>
    <url>/posts/6efaad91/</url>
    <content><![CDATA[<h4 id="《MongoDB权威指南》"><a href="#《MongoDB权威指南》" class="headerlink" title="《MongoDB权威指南》"></a>《MongoDB权威指南》</h4><h6 id="链接-https-pan-baidu-com-s-181Mk5vRIzAJ6ZeJq2qrMqQ-提取码-sj6a"><a href="#链接-https-pan-baidu-com-s-181Mk5vRIzAJ6ZeJq2qrMqQ-提取码-sj6a" class="headerlink" title="链接: https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ 提取码: sj6a"></a>链接: <a href="https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ">https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ</a> 提取码: sj6a</h6><p>与传统的关系型数据库不同，MongoDB是一种面向文档的数据库。《MongoDB指南(第2版)》这一版共分为六部分，涵盖开发、管理以及部署的各个方面。分展示MongoDB基础知识、核心概念。第二部分介绍使用MongoDB进行开发，包括索引的概念以及各种特殊索引和集合的用法等。第三部分讲述复制，包括副本集的相关概念、创建方法，与应用程序的交互等。第四部讨论分片，包括分片的配置，片键的选择，集群的管理。第五部分阐述创建索引、移动和压缩数据等管理任务，以及MongoDB的持久数据存储。后一部分集中说明服务器管理。<br><a id="more"></a></p>
<p><img src="/images/c367d4220bb379b54821542cff7710871.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">部分 MongoDB介绍</span><br><span class="line"></span><br><span class="line">章 MongoDB简介 3</span><br><span class="line"></span><br><span class="line">1.1 易于使用 3</span><br><span class="line"></span><br><span class="line">1.2 易于扩展 4</span><br><span class="line"></span><br><span class="line">1.3 丰富的功能 4</span><br><span class="line"></span><br><span class="line">1.4 卓越的性能 5</span><br><span class="line"></span><br><span class="line">1.5 小结 5</span><br><span class="line"></span><br><span class="line">第2章 MongoDB基础知识 7</span><br><span class="line"></span><br><span class="line">2.1 文档 7</span><br><span class="line"></span><br><span class="line">2.2 集合 8</span><br><span class="line"></span><br><span class="line">2.2.1 动态模式 8</span><br><span class="line"></span><br><span class="line">2.2.2 命名 9</span><br><span class="line"></span><br><span class="line">2.3 数据库 10</span><br><span class="line"></span><br><span class="line">2.4 启动MongoDB 11</span><br><span class="line"></span><br><span class="line">2.5 MongoDBshell简介 12</span><br><span class="line"></span><br><span class="line">2.5.1 运行shell 12</span><br><span class="line"></span><br><span class="line">2.5.2 MongoDB客户端 13</span><br><span class="line"></span><br><span class="line">2.5.3 shell中的基本操作 14</span><br><span class="line"></span><br><span class="line">2.6 数据类型 16</span><br><span class="line"></span><br><span class="line">2.6.1 基本数据类型 16</span><br><span class="line"></span><br><span class="line">2.6.2 日期 18</span><br><span class="line"></span><br><span class="line">2.6.3 数组 18</span><br><span class="line"></span><br><span class="line">2. 内嵌文档 19</span><br><span class="line"></span><br><span class="line">2.6.5 _id和ObjectId 20</span><br><span class="line"></span><br><span class="line">2.7 使用MongoDBshell 21</span><br><span class="line"></span><br><span class="line">2.7.1 shell小贴士 22</span><br><span class="line"></span><br><span class="line">2.7.2 使用shell执行脚本 23</span><br><span class="line"></span><br><span class="line">2.7.3 创建mongorc.js文件 25</span><br><span class="line"></span><br><span class="line">2.7.4 定制shell提示 26</span><br><span class="line"></span><br><span class="line">2.7.5 编辑复合变量 26</span><br><span class="line"></span><br><span class="line">2.7.6 集合命名注意事项 27</span><br><span class="line"></span><br><span class="line">第3章 创建、更新和删除文档 29</span><br><span class="line"></span><br><span class="line">3.1 插入并保存文档 29</span><br><span class="line"></span><br><span class="line">3.1.1 批量插入 29</span><br><span class="line"></span><br><span class="line">3.1.2 插入校验 30</span><br><span class="line"></span><br><span class="line">3.2 删除文档 31</span><br><span class="line"></span><br><span class="line">3.3 更新文档 32</span><br><span class="line"></span><br><span class="line">3.3.1 文档替换 32</span><br><span class="line"></span><br><span class="line">3.3.2 使用修改器 34</span><br><span class="line"></span><br><span class="line">3.3.3 upsert 45</span><br><span class="line"></span><br><span class="line">3.3.4 更新多个文档 47</span><br><span class="line"></span><br><span class="line">3.3.5 返回被更新的文档 48</span><br><span class="line"></span><br><span class="line">3.4 写入安全机制 50</span><br><span class="line"></span><br><span class="line">第4章 查询 53</span><br><span class="line"></span><br><span class="line">4.1 find简介 53</span><br><span class="line"></span><br><span class="line">4.1.1 指定需要返回的键 54</span><br><span class="line"></span><br><span class="line">4.1.2 55</span><br><span class="line"></span><br><span class="line">4.2 查询条件 55</span><br><span class="line"></span><br><span class="line">4.2.1 查询条件 55</span><br><span class="line"></span><br><span class="line">4.2.2 OR查询 56</span><br><span class="line"></span><br><span class="line">4.2.3 $not 57</span><br><span class="line"></span><br><span class="line">4.2.4 条件语义 57</span><br><span class="line"></span><br><span class="line">4.3 特定类型的查询 58</span><br><span class="line"></span><br><span class="line">4.3.1 null 58</span><br><span class="line"></span><br><span class="line">4.3.2 正则表达式 59</span><br><span class="line"></span><br><span class="line">4.3.3 查询数组 59</span><br><span class="line"></span><br><span class="line">4.3.4 查询内嵌文档</span><br><span class="line"></span><br><span class="line">4.4 $where查询 65</span><br><span class="line"></span><br><span class="line">4.5 游标 67</span><br><span class="line"></span><br><span class="line">4.5.1 limit、skip和sort 69</span><br><span class="line"></span><br><span class="line">4.5.2 避免使用skip略过大量结果 70</span><br><span class="line"></span><br><span class="line">4.5.3 不错查询选项 72</span><br><span class="line"></span><br><span class="line">4.5.4 获取一致结果 73</span><br><span class="line"></span><br><span class="line">4.5.5 游标生命周期 75</span><br><span class="line"></span><br><span class="line">4.6 数据库命令 75</span><br><span class="line"></span><br><span class="line">第二部分 设计应用</span><br><span class="line"></span><br><span class="line">第5章 索引 81</span><br><span class="line"></span><br><span class="line">5.1 索引简介 81</span><br><span class="line"></span><br><span class="line">5.1.1 复合索引简介 84</span><br><span class="line"></span><br><span class="line">5.1.2 使用复合索引 90</span><br><span class="line"></span><br><span class="line">5.1.3 $操作符如何使用索引 91</span><br><span class="line"></span><br><span class="line">5.1.4 索引对象和数组 96</span><br><span class="line"></span><br><span class="line">5.1.5 索引基数 98</span><br><span class="line"></span><br><span class="line">5.2 使用explain（）和hint（） 98</span><br><span class="line"></span><br><span class="line">5.3 何时不应该使用索引 103</span><br><span class="line"></span><br><span class="line">5.4 索引类型 104</span><br><span class="line"></span><br><span class="line">5.4.1 索引 104</span><br><span class="line"></span><br><span class="line">5.4.2 稀疏索引 106</span><br><span class="line"></span><br><span class="line">5.5 索引管理 107</span><br><span class="line"></span><br><span class="line">5.5.1 标识索引 108</span><br><span class="line"></span><br><span class="line">5.5.2 修改索引 108</span><br><span class="line"></span><br><span class="line">第6章 特殊的索引和集合 111</span><br><span class="line"></span><br><span class="line">6.1 固定集合 111</span><br><span class="line"></span><br><span class="line">6.1.1 创建固定集合 113</span><br><span class="line"></span><br><span class="line">6.1.2 自然排序 113</span><br><span class="line"></span><br><span class="line">6.1.3 循环游标 115</span><br><span class="line"></span><br><span class="line">6.1.4 没有_id索引的集合 115</span><br><span class="line"></span><br><span class="line">6.2 TTL索引 116</span><br><span class="line"></span><br><span class="line">6.3 全文本索引 116</span><br><span class="line"></span><br><span class="line">6.3.1 搜索语法 119</span><br><span class="line"></span><br><span class="line">6.3.2 优化全文本搜索 120</span><br><span class="line"></span><br><span class="line">6.3.3 在其他语言中搜索 121</span><br><span class="line"></span><br><span class="line">地理空间索引 121</span><br><span class="line"></span><br><span class="line">.1 地理空间查询的类型 122</span><br><span class="line"></span><br><span class="line">.2 复合地理空间索引 123</span><br><span class="line"></span><br><span class="line">.3 2d索引 123</span><br><span class="line"></span><br><span class="line">6.5 使用GridFS存储文件 125</span><br><span class="line"></span><br><span class="line">6.5.1 GridFS入门 126</span><br><span class="line"></span><br><span class="line">6.5.2 在MongoDB驱动程序中使用GridFS 126</span><br><span class="line"></span><br><span class="line">6.5.3 揭开GridFS的面纱 127</span><br><span class="line"></span><br><span class="line">第7章 聚合 129</span><br><span class="line"></span><br><span class="line">7.1 聚合框架 129</span><br><span class="line"></span><br><span class="line">7.2 管道操作符 131</span><br><span class="line"></span><br><span class="line">7.2.1 $match 132</span><br><span class="line"></span><br><span class="line">7.2.2 $project 132</span><br><span class="line"></span><br><span class="line">7.2.3 $group 137</span><br><span class="line"></span><br><span class="line">7.2.4 $unwind 140</span><br><span class="line"></span><br><span class="line">7.2.5 $sort 141</span><br><span class="line"></span><br><span class="line">7.2.6 $limit 142</span><br><span class="line"></span><br><span class="line">7.2.7 $skip 142</span><br><span class="line"></span><br><span class="line">7.2.8 使用管道 142</span><br><span class="line"></span><br><span class="line">7.3 MapReduce 143</span><br><span class="line"></span><br><span class="line">7.3.1 示例1：找出集合中的所有键 143</span><br><span class="line"></span><br><span class="line">7.3.2 示例2：网页分类 145</span><br><span class="line"></span><br><span class="line">7.3.3 MongoDB和MapReduce 146</span><br><span class="line"></span><br><span class="line">7.4 聚合命令 148</span><br><span class="line"></span><br><span class="line">7.4.1 count 149</span><br><span class="line"></span><br><span class="line">7.4.2 distinct 149</span><br><span class="line"></span><br><span class="line">7.4.3 group 150</span><br><span class="line"></span><br><span class="line">第8章 应用程序设计 155</span><br><span class="line"></span><br><span class="line">8.1 范式化与反范式化 155</span><br><span class="line"></span><br><span class="line">8.1.1 数据表示的例子 156</span><br><span class="line"></span><br><span class="line">8.1.2 基数 159</span><br><span class="line"></span><br><span class="line">8.1.3 好友、粉丝，以及其他的麻烦事项 160</span><br><span class="line"></span><br><span class="line">8.2 优化数据操作 162</span><br><span class="line"></span><br><span class="line">8.2.1 优化文档增长 162</span><br><span class="line"></span><br><span class="line">8.2.2 删除旧数据 1</span><br><span class="line"></span><br><span class="line">8.3 数据库和集合的设计 1</span><br><span class="line"></span><br><span class="line">8.4 一致性管理 165</span><br><span class="line"></span><br><span class="line">8.5 模式迁移 166</span><br><span class="line"></span><br><span class="line">8.6 不适合使用MongoDB的场景 167</span><br><span class="line"></span><br><span class="line">第三部分 复制</span><br><span class="line"></span><br><span class="line">第9章 创建副本集 171</span><br><span class="line"></span><br><span class="line">9.1 复制简介 171</span><br><span class="line"></span><br><span class="line">9.2 建立副本集 172</span><br><span class="line"></span><br><span class="line">9.3 配置副本集 176</span><br><span class="line"></span><br><span class="line">9.3.1 rs辅助函数 178</span><br><span class="line"></span><br><span class="line">9.3.2 网络注意事项 178</span><br><span class="line"></span><br><span class="line">9.4 修改副本集配置 178</span><br><span class="line"></span><br><span class="line">9.5 设计副本集 180</span><br><span class="line"></span><br><span class="line">9.6 成员配置选项 184</span><br><span class="line"></span><br><span class="line">9.6.1 选举仲裁者 184</span><br><span class="line"></span><br><span class="line">9.6.2 优先级 185</span><br><span class="line"></span><br><span class="line">9.6.3 隐藏成员 186</span><br><span class="line"></span><br><span class="line">9. 延迟备份节点 187</span><br><span class="line"></span><br><span class="line">9.6.5 创建索引 187</span><br><span class="line"></span><br><span class="line">0章 副本集的组成 189</span><br><span class="line"></span><br><span class="line">10.1 同步 189</span><br><span class="line"></span><br><span class="line">10.1.1 初始化同步 190</span><br><span class="line"></span><br><span class="line">10.1.2 处理陈旧数据 193</span><br><span class="line"></span><br><span class="line">10.2 心跳 193</span><br><span class="line"></span><br><span class="line">10.3 选举 195</span><br><span class="line"></span><br><span class="line">10.4 回滚 195</span><br><span class="line"></span><br><span class="line">1章 从应用程序连接副本集 201</span><br><span class="line"></span><br><span class="line">11.1 客户端到副本集的连接 201</span><br><span class="line"></span><br><span class="line">11.2 等待写入复制 202</span><br><span class="line"></span><br><span class="line">11.2.1 可能导致错误的原因 203</span><br><span class="line"></span><br><span class="line">11.2.2 其他值 204</span><br><span class="line"></span><br><span class="line">11.3 自定义复制保证规则 204</span><br><span class="line"></span><br><span class="line">11.3.1 保证复制到每个数据中心的一台服务器上 204</span><br><span class="line"></span><br><span class="line">11.3.2 保证写操作被复制到可见节点中的“大多数” 206</span><br><span class="line"></span><br><span class="line">11.3.3 创建其他规则 206</span><br><span class="line"></span><br><span class="line">11.4 将读请求发送到备份节点 207</span><br><span class="line"></span><br><span class="line">11.4.1 出于一致性考虑 207</span><br><span class="line"></span><br><span class="line">11.4.2 出于负载的考虑 208</span><br><span class="line"></span><br><span class="line">11.4.3 何时可以从备份节点读取数据 208</span><br><span class="line"></span><br><span class="line">2章 管理 211</span><br><span class="line"></span><br><span class="line">12.1 以单机模式启动成员 211</span><br><span class="line"></span><br><span class="line">12.2 副本集配置 212</span><br><span class="line"></span><br><span class="line">12.2.1 创建副本集 212</span><br><span class="line"></span><br><span class="line">12.2.2 修改副本集成员 213</span><br><span class="line"></span><br><span class="line">12.2.3 创建比较大的副本集 213</span><br><span class="line"></span><br><span class="line">12.2.4 强制重新配置 214</span><br><span class="line"></span><br><span class="line">12.3 修改成员状态 215</span><br><span class="line"></span><br><span class="line">12.3.1 把主节点变为备份节点 215</span><br><span class="line"></span><br><span class="line">12.3.2 阻止选举 215</span><br><span class="line"></span><br><span class="line">12.3.3 使用维护模式 215</span><br><span class="line"></span><br><span class="line">12.4 监控复制 216</span><br><span class="line"></span><br><span class="line">12.4.1 获取状态 216</span><br><span class="line"></span><br><span class="line">12.4.2 复制图谱 218</span><br><span class="line"></span><br><span class="line">12.4.3 复制循环 220</span><br><span class="line"></span><br><span class="line">12.4.4 禁用复制链 220</span><br><span class="line"></span><br><span class="line">12.4.5 计算延迟 221</span><br><span class="line"></span><br><span class="line">12.4.6 调整oplog大小 222</span><br><span class="line"></span><br><span class="line">12.4.7 从延迟备份节点中恢复 223</span><br><span class="line"></span><br><span class="line">12.4.8 创建索引 224</span><br><span class="line"></span><br><span class="line">12.4.9 在预算有限的情况下进行复制 225</span><br><span class="line"></span><br><span class="line">12.4.10 主节点如何跟踪延迟 226</span><br><span class="line"></span><br><span class="line">12.5 主从模式 227</span><br><span class="line"></span><br><span class="line">12.5.1 从主从模式切换到副本集模式 228</span><br><span class="line"></span><br><span class="line">12.5.2 让副本集模仿主从模式的行为 228</span><br><span class="line"></span><br><span class="line">第四部分 分片</span><br><span class="line"></span><br><span class="line">3章 分片 233</span><br><span class="line"></span><br><span class="line">13.1 分片简介 233</span><br><span class="line"></span><br><span class="line">13.2 理解集群的组件 234</span><br><span class="line"></span><br><span class="line">13.3 快速建立一个简单的集群 235</span><br><span class="line"></span><br><span class="line">4章 配置分片 243</span><br><span class="line"></span><br><span class="line">14.1 何时分片 243</span><br><span class="line"></span><br><span class="line">14.2 启动服务器 244</span><br><span class="line"></span><br><span class="line">14.2.1 配置服务器 244</span><br><span class="line"></span><br><span class="line">14.2.2 mongos进程 245</span><br><span class="line"></span><br><span class="line">14.2.3 将副本集转换为分片 245</span><br><span class="line"></span><br><span class="line">14.2.4 增加集群容量 247</span><br><span class="line"></span><br><span class="line">14.2.5 数据分片 247</span><br><span class="line"></span><br><span class="line">14.3 MongoDB如何追踪集群数据 248</span><br><span class="line"></span><br><span class="line">14.3.1 块范围 249</span><br><span class="line"></span><br><span class="line">14.3.2 拆分块 250</span><br><span class="line"></span><br><span class="line">14.4 均衡器 254</span><br><span class="line"></span><br><span class="line">5章 选择片键 257</span><br><span class="line"></span><br><span class="line">15.1 检查使用情况 257</span><br><span class="line"></span><br><span class="line">15.2 数据分发 258</span><br><span class="line"></span><br><span class="line">15.2.1 升序片键 258</span><br><span class="line"></span><br><span class="line">15.2.2 随机分发的片键 261</span><br><span class="line"></span><br><span class="line">15.2.3 基于位置的片键 262</span><br><span class="line"></span><br><span class="line">15.3 片键策略 263</span><br><span class="line"></span><br><span class="line">15.3.1 散列片键 2</span><br><span class="line"></span><br><span class="line">15.3.2 GridFS的散列片键 265</span><br><span class="line"></span><br><span class="line">15.3.3 流水策略 266</span><br><span class="line"></span><br><span class="line">15.3.4 多热点 267</span><br><span class="line"></span><br><span class="line">15.4 片键规则和指导方针 270</span><br><span class="line"></span><br><span class="line">15.4.1 片键 270</span><br><span class="line"></span><br><span class="line">15.4.2 片键的势 270</span><br><span class="line"></span><br><span class="line">15.5 控制数据分发 270</span><br><span class="line"></span><br><span class="line">15.5.1 对多个数据库和集合使用一个集群 270</span><br><span class="line"></span><br><span class="line">15.5.2 手动分片 272</span><br><span class="line"></span><br><span class="line">6章 分片管理 275</span><br><span class="line"></span><br><span class="line">16.1 检查集群状态 275</span><br><span class="line"></span><br><span class="line">16.1.1 使用sh.status查看集群摘要信息 275</span><br><span class="line"></span><br><span class="line">16.1.2 检查配置信息 277</span><br><span class="line"></span><br><span class="line">16.2 查看网络连接 282</span><br><span class="line"></span><br><span class="line">16.2.1 查看连接统计 283</span><br><span class="line"></span><br><span class="line">16.2.2 连接数量 283</span><br><span class="line"></span><br><span class="line">16.3 服务器管理 285</span><br><span class="line"></span><br><span class="line">16.3.1 添加服务器 285</span><br><span class="line"></span><br><span class="line">16.3.2 修改分片的服务器 285</span><br><span class="line"></span><br><span class="line">16.3.3 删除分片 286</span><br><span class="line"></span><br><span class="line">16.3.4 修改配置服务器 288</span><br><span class="line"></span><br><span class="line">1 数据均衡 289</span><br><span class="line"></span><br><span class="line">1.1 均衡器 289</span><br><span class="line"></span><br><span class="line">1.2 修改块大小 290</span><br><span class="line"></span><br><span class="line">1.3 移动块 290</span><br><span class="line"></span><br><span class="line">1.4 特大块 292</span><br><span class="line"></span><br><span class="line">1.5 刷新配置 295</span><br><span class="line"></span><br><span class="line">第五部分 应用管理</span><br><span class="line"></span><br><span class="line">7章 了解应用的动态 299</span><br><span class="line"></span><br><span class="line">17.1 了解正在进行的操作 299</span><br><span class="line"></span><br><span class="line">17.1.1 寻找有问题的操作 301</span><br><span class="line"></span><br><span class="line">17.1.2 终止操作的执行 301</span><br><span class="line"></span><br><span class="line">17.1.3 假象 302</span><br><span class="line"></span><br><span class="line">17.1.4 避免幽灵操作 302</span><br><span class="line"></span><br><span class="line">17.2 使用系统分析器 303</span><br><span class="line"></span><br><span class="line">17.3 计算空间消耗 305</span><br><span class="line"></span><br><span class="line">17.3.1 文档 305</span><br><span class="line"></span><br><span class="line">17.3.2 集合 305</span><br><span class="line"></span><br><span class="line">17.3.3 数据库 306</span><br><span class="line"></span><br><span class="line">17.4 使用mongotop和monogostat 307</span><br><span class="line"></span><br><span class="line">8章 数据管理 311</span><br><span class="line"></span><br><span class="line">18.1 配置身份验证 311</span><br><span class="line"></span><br><span class="line">18.1.1 身份验证基本原理 312</span><br><span class="line"></span><br><span class="line">18.1.2 配置身份验证 313</span><br><span class="line"></span><br><span class="line">18.1.3 身份验证的工作原理 314</span><br><span class="line"></span><br><span class="line">18.2 建立和删除索引 315</span><br><span class="line"></span><br><span class="line">18.2.1 在独立的服务器上建立索引 315</span><br><span class="line"></span><br><span class="line">18.2.2 在副本集上建立索引 315</span><br><span class="line"></span><br><span class="line">18.2.3 在分片集群上建立索引 316</span><br><span class="line"></span><br><span class="line">18.2.4 删除索引 316</span><br><span class="line"></span><br><span class="line">18.2.5 注意内存溢出杀手 316</span><br><span class="line"></span><br><span class="line">18.3 预热数据 317</span><br><span class="line"></span><br><span class="line">18.3.1 将数据库移至内存 317</span><br><span class="line"></span><br><span class="line">18.3.2 将集合移至内存 318</span><br><span class="line"></span><br><span class="line">18.3.3 自定义预热 318</span><br><span class="line"></span><br><span class="line">18.4 压缩数据 320</span><br><span class="line"></span><br><span class="line">18.5 移动集合 321</span><br><span class="line"></span><br><span class="line">18.6 预分配数据文件 322</span><br><span class="line"></span><br><span class="line">9章 持久性 323</span><br><span class="line"></span><br><span class="line">19.1 日记系统的用途 323</span><br><span class="line"></span><br><span class="line">19.1.1 批量提交写入操作 324</span><br><span class="line"></span><br><span class="line">19.1.2 设定提交时间间隔 325</span><br><span class="line"></span><br><span class="line">19.2 关闭日记系统 325</span><br><span class="line"></span><br><span class="line">19.2.1 替换数据文件 325</span><br><span class="line"></span><br><span class="line">19.2.2 修复数据文件 326</span><br><span class="line"></span><br><span class="line">19.2.3 关于mongod.lock文件 326</span><br><span class="line"></span><br><span class="line">19.2.4 隐蔽的异常退出 327</span><br><span class="line"></span><br><span class="line">19.3 MongoDB无法保证的事项 327</span><br><span class="line"></span><br><span class="line">19.4 检验数据损坏 327</span><br><span class="line"></span><br><span class="line">19.5 副本集中的持久性 329</span><br><span class="line"></span><br><span class="line">第六部分 服务器管理</span><br><span class="line"></span><br><span class="line">第20章 启动和停止MongoDB 333</span><br><span class="line"></span><br><span class="line">20.1 从命令行启动 333</span><br><span class="line"></span><br><span class="line">20.2 停止MongoDB 336</span><br><span class="line"></span><br><span class="line">20.3 安全性 337</span><br><span class="line"></span><br><span class="line">20.3.1 数据加密 338</span><br><span class="line"></span><br><span class="line">20.3.2 SSL安全连接 338</span><br><span class="line"></span><br><span class="line">20.4 日志 338</span><br><span class="line"></span><br><span class="line">第21章 监控MongoDB 341</span><br><span class="line"></span><br><span class="line">21.1 监控内存使用状况 341</span><br><span class="line"></span><br><span class="line">21.1.1 有关电脑内存的介绍 341</span><br><span class="line"></span><br><span class="line">21.1.2 跟踪监测内存使用状况 342</span><br><span class="line"></span><br><span class="line">21.1.3 跟踪监测缺页中断 343</span><br><span class="line"></span><br><span class="line">21.1.4 减少索引树的脱靶次数 345</span><br><span class="line"></span><br><span class="line">21.1.5 IO延迟 345</span><br><span class="line"></span><br><span class="line">21.1.6 跟踪监测后台刷新平均时间 346</span><br><span class="line"></span><br><span class="line">21.2 计算工作集的大小 347</span><br><span class="line"></span><br><span class="line">21.3 跟踪监测性能状况 349</span><br><span class="line"></span><br><span class="line">21.4 监控副本集 352</span><br><span class="line"></span><br><span class="line">第22章 备份 355</span><br><span class="line"></span><br><span class="line">22.1 对服务器进行备份 355</span><br><span class="line"></span><br><span class="line">22.1.1 文件系统快照 355</span><br><span class="line"></span><br><span class="line">22.1.2 复制数据文件 356</span><br><span class="line"></span><br><span class="line">22.1.3 使用mongodump 357</span><br><span class="line"></span><br><span class="line">22.2 对副本集进行备份 359</span><br><span class="line"></span><br><span class="line">22.3 对分片集群进行备份 360</span><br><span class="line"></span><br><span class="line">22.3.1 备份和恢复整个集群 360</span><br><span class="line"></span><br><span class="line">22.3.2 备份和恢复单独的分片 360</span><br><span class="line"></span><br><span class="line">22.4 使用mongooplog进行增量备份 361</span><br><span class="line"></span><br><span class="line">第23章 部署MongoDB 363</span><br><span class="line"></span><br><span class="line">23.1 设计系统结构 363</span><br><span class="line"></span><br><span class="line">23.1.1 选择存储介质 363</span><br><span class="line"></span><br><span class="line">23.1.2 推荐的RAID配置 367</span><br><span class="line"></span><br><span class="line">23.1.3 CPU 368</span><br><span class="line"></span><br><span class="line">23.1.4 选择操作系统 368</span><br><span class="line"></span><br><span class="line">23.1.5 交换空间 369</span><br><span class="line"></span><br><span class="line">23.1.6 文件系统 369</span><br><span class="line"></span><br><span class="line">23.2 虚拟化 370</span><br><span class="line"></span><br><span class="line">23.2.1 禁止内存过度分配 370</span><br><span class="line"></span><br><span class="line">23.2.2 神秘的内存 370</span><br><span class="line"></span><br><span class="line">23.2.3 处理网络磁盘的IO问题 371</span><br><span class="line"></span><br><span class="line">23.2.4 使用非网络磁盘 372</span><br><span class="line"></span><br><span class="line">23.3 系统配置 372</span><br><span class="line"></span><br><span class="line">23.3.1 禁用NUMA 372</span><br><span class="line"></span><br><span class="line">23.3.2 更智能地预读取数据 375</span><br><span class="line"></span><br><span class="line">23.3.3 禁用大内存页面 376</span><br><span class="line"></span><br><span class="line">23.3.4 选择一种磁盘调度算法 377</span><br><span class="line"></span><br><span class="line">23.3.5 不要记录访问时间 377</span><br><span class="line"></span><br><span class="line">23.3.6 修改 378</span><br><span class="line"></span><br><span class="line">23.4 网络配置 379</span><br><span class="line"></span><br><span class="line">23.5 系统管理 381</span><br><span class="line"></span><br><span class="line">23.5.1 时钟同步 381</span><br><span class="line"></span><br><span class="line">23.5.2 OOMKiller 381</span><br><span class="line"></span><br><span class="line">23.5.3 关闭定期任务 382</span><br><span class="line"></span><br><span class="line">附录A 安装MongoDB 383</span><br><span class="line"></span><br><span class="line">附录B 深入MongoDB 387</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>MoreEffectiveC++中文版 PDF</title>
    <url>/posts/19fd9d07/</url>
    <content><![CDATA[<h4 id="《MoreEffectiveC-中文版》"><a href="#《MoreEffectiveC-中文版》" class="headerlink" title="《MoreEffectiveC++中文版》"></a>《MoreEffectiveC++中文版》</h4><h6 id="链接-https-pan-baidu-com-s-12hyN9W4EjEbsicLDrmdS-g-提取码-qdd3"><a href="#链接-https-pan-baidu-com-s-12hyN9W4EjEbsicLDrmdS-g-提取码-qdd3" class="headerlink" title="链接: https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g 提取码: qdd3"></a>链接: <a href="https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g">https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g</a> 提取码: qdd3</h6><p>继Effective C++之后，Scott Meyers于1996推出这本“续集”。条款变得比较少，页数倒是多了一些，原因是这次选材比“第一集”更高阶，尤其是第5章。Meyers将此章命名为技术（techniques），并明白告诉你，其中都是一些patterns，例如virtual constructors，smart pointers，reference counting，proxy classes，double dispatching……这一章的每个条款篇幅都达15~30 页之多，实在让人有“山重水复疑无路，柳暗花明又一村”之叹。<br><a id="more"></a></p>
<p>虽然出版年代稍嫌久远，但本书并没有第2版，原因是当其出版之时（1996），C++ Standard已经几乎定案，本书即依当时的标准草案而写，其与现今的C++ 标准规范几乎相同。而且可能变化的几个弹性之处，Meyers也都有所说明与提示</p>
<p><img src="/images/a20cfc239cf5ffe5c3582fc0036f2f9b1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目 录</span><br><span class="line"></span><br><span class="line">译序（侯捷） ix</span><br><span class="line"></span><br><span class="line">导读（Introduction） 001</span><br><span class="line"></span><br><span class="line">基础议题（Basics） 009</span><br><span class="line"></span><br><span class="line">条款1：仔细区别 pointers 和 references 009</span><br><span class="line"></span><br><span class="line">Distinguish between pointers and references．</span><br><span class="line"></span><br><span class="line">条款2：最好使用 C++ 转型操作符 012</span><br><span class="line"></span><br><span class="line">Prefer C++-style casts．</span><br><span class="line"></span><br><span class="line">条款3：绝对不要以多态（polymorphically）方式处理数组 016</span><br><span class="line"></span><br><span class="line">Never treat arrays polymorphically．</span><br><span class="line"></span><br><span class="line">条款4：非必要不提供 default constructor 019</span><br><span class="line"></span><br><span class="line">Avoid gratuitous default constructors．</span><br><span class="line"></span><br><span class="line">操作符（Operators） 024</span><br><span class="line"></span><br><span class="line">条款5：对定制的“类型转换函数”保持警觉 024</span><br><span class="line"></span><br><span class="line">Be wary of user-defined conversion functions．</span><br><span class="line"></span><br><span class="line">条款6：区别 increment&#x2F;decrement 操作符的</span><br><span class="line"></span><br><span class="line">前置（prefix）和后置（postfix）形式 031</span><br><span class="line"></span><br><span class="line">Distinguish between prefix and postfix forms of increment</span><br><span class="line"></span><br><span class="line">and decrement operators．</span><br><span class="line"></span><br><span class="line">条款7：千万不要重载＆＆，||和， 操作符 035</span><br><span class="line"></span><br><span class="line">Never overload ＆＆， ||， or ，．</span><br><span class="line"></span><br><span class="line">条款8：了解各种不同意义的 new 和 delete 038</span><br><span class="line"></span><br><span class="line">Understand the different meanings of new and delete</span><br><span class="line"></span><br><span class="line">异常（Exceptions） 044</span><br><span class="line"></span><br><span class="line">条款9：利用 destructors 避免泄漏资源 045</span><br><span class="line"></span><br><span class="line">Use destructors to prevent resource leaks．</span><br><span class="line"></span><br><span class="line">条款10：在 constructors 内阻止资源泄漏（resource leak） 050</span><br><span class="line"></span><br><span class="line">Prevent resource leaks in constructors．</span><br><span class="line"></span><br><span class="line">条款11：禁止异常（exceptions）流出 destructors 之外 058</span><br><span class="line"></span><br><span class="line">Prevent exceptions from leaving destructors．</span><br><span class="line"></span><br><span class="line">条款12：了解“抛出一个 exception”与“传递一个参数”</span><br><span class="line"></span><br><span class="line">或“调用一个虚函数”之间的差异 061</span><br><span class="line"></span><br><span class="line">Understand how throwing an exception differs from</span><br><span class="line"></span><br><span class="line">passing a parameter or calling a virtual function．</span><br><span class="line"></span><br><span class="line">条款13：以 by reference 方式捕捉 exceptions 068</span><br><span class="line"></span><br><span class="line">Catch exceptions by reference．</span><br><span class="line"></span><br><span class="line">条款14：明智运用 exception specifications 072</span><br><span class="line"></span><br><span class="line">Use exception specifications judiciously．</span><br><span class="line"></span><br><span class="line">条款15：了解异常处理（exception handling）的成本 078</span><br><span class="line"></span><br><span class="line">Understand the costs of exception handling．</span><br><span class="line"></span><br><span class="line">效率（Efficiency） 081</span><br><span class="line"></span><br><span class="line">条款16：谨记 80-20 法则 082</span><br><span class="line"></span><br><span class="line">Remember the 80-20 rule．</span><br><span class="line"></span><br><span class="line">条款17：考虑使用 lazy evaluation（缓式评估） 085</span><br><span class="line"></span><br><span class="line">Consider using lazy evaluation．</span><br><span class="line"></span><br><span class="line">条款18：分期摊还预期的计算成本 093</span><br><span class="line"></span><br><span class="line">Amortize the cost of expected computations．</span><br><span class="line"></span><br><span class="line">条款19：了解临时对象的来源 098</span><br><span class="line"></span><br><span class="line">Understand the origin of temporary objects．</span><br><span class="line"></span><br><span class="line">条款20：协助完成“返回值优化（RVO）” 101</span><br><span class="line"></span><br><span class="line">Facilitate the return value optimization．</span><br><span class="line"></span><br><span class="line">条款21：利用重载技术（overload）避免隐式类型转换（implict type conversions）105</span><br><span class="line"></span><br><span class="line">Overload to avoid implicit type conversions．</span><br><span class="line"></span><br><span class="line">条款22：考虑以操作符复合形式（op&#x3D;）取代其独身形式（op） 107</span><br><span class="line"></span><br><span class="line">Consider using op&#x3D; instead of stand-alone op．</span><br><span class="line"></span><br><span class="line">条款23：考虑使用其他程序库 110</span><br><span class="line"></span><br><span class="line">Consider alternative libraries．</span><br><span class="line"></span><br><span class="line">条款24：了解 virtual functions、multiple inheritance、virtual base classes、</span><br><span class="line"></span><br><span class="line">runtime type identification 的成本 113</span><br><span class="line"></span><br><span class="line">Understand the costs of virtual functions， multiple inheritance，</span><br><span class="line"></span><br><span class="line">virtual base classes， and RTTI．</span><br><span class="line"></span><br><span class="line">技术（Techniques， Idioms， Patterns） 123</span><br><span class="line"></span><br><span class="line">条款25：将 constructor 和 non-member functions 虚化 123</span><br><span class="line"></span><br><span class="line">Virtualizing constructors and non-member functions．</span><br><span class="line"></span><br><span class="line">条款26：限制某个 class 所能产生的对象数量 130</span><br><span class="line"></span><br><span class="line">Limiting the number of objects of a class．</span><br><span class="line"></span><br><span class="line">条款27：要求（或禁止）对象产生于 heap 之中 145</span><br><span class="line"></span><br><span class="line">Requiring or prohibiting heap-based objects．</span><br><span class="line"></span><br><span class="line">条款28：Smart Pointers（智能指针） 159</span><br><span class="line"></span><br><span class="line">条款29：Reference counting（引用计数） 183</span><br><span class="line"></span><br><span class="line">条款30：Proxy classes（替身类、代理类） 213</span><br><span class="line"></span><br><span class="line">条款31：让函数根据一个以上的对象类型来决定如何虚化 228</span><br><span class="line"></span><br><span class="line">Making functions virtual with respect to more than one object．</span><br><span class="line"></span><br><span class="line">杂项讨论（Miscellany） 252</span><br><span class="line"></span><br><span class="line">条款32：在未来时态下发展程序 252</span><br><span class="line"></span><br><span class="line">Program in the future tense．</span><br><span class="line"></span><br><span class="line">条款33：将非尾端类（non-leaf classes）设计为</span><br><span class="line"></span><br><span class="line">抽象类（abstract classes） 258</span><br><span class="line"></span><br><span class="line">Make non-leaf classes abstract．</span><br><span class="line"></span><br><span class="line">条款34：如何在同一个程序中结合 C++ 和 C 270</span><br><span class="line"></span><br><span class="line">Understand how to combine C++ and C in the same program．</span><br><span class="line"></span><br><span class="line">条款35：让自己习惯于标准 C++ 语言 277</span><br><span class="line"></span><br><span class="line">Familiarize yourself with the language standard．</span><br><span class="line"></span><br><span class="line">推荐读物 285</span><br><span class="line"></span><br><span class="line">auto_ptr 实现代码 291</span><br><span class="line"></span><br><span class="line">索引（一）（General Index） 295</span><br><span class="line"></span><br><span class="line">索引（二）（Index of Example Classes，Functions，and Templtes） 313</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL必知必会 PDF</title>
    <url>/posts/879908a4/</url>
    <content><![CDATA[<h4 id="《MySQL必知必会》"><a href="#《MySQL必知必会》" class="headerlink" title="《MySQL必知必会》"></a>《MySQL必知必会》</h4><h6 id="链接-https-pan-baidu-com-s-12QX4fDb70brt4exCvKYhuA-提取码-7xds"><a href="#链接-https-pan-baidu-com-s-12QX4fDb70brt4exCvKYhuA-提取码-7xds" class="headerlink" title="链接: https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA 提取码: 7xds"></a>链接: <a href="https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA">https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA</a> 提取码: 7xds</h6><p>《MySQL必知必会》是经典畅销书《SQL必知必会》之后，作者应众多读者的请求编写的，专门针对MySQL用户。书中继承了《MySQL必知必会》的优点，没有过多阐述数据库基础理论，而是紧贴实战需要，直接从数据检索开始，逐步深入各种复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。通过本书，读者能够掌握扎实的基本功，迅速成为MySQL高手。<br><a id="more"></a></p>
<p><img src="/images/da26083b226e849a5f9231be217ecf871.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第 1章　了解SQL　1</span><br><span class="line"></span><br><span class="line">1.1　数据库基础　1</span><br><span class="line"></span><br><span class="line">1.1.1　什么是数据库　2</span><br><span class="line"></span><br><span class="line">1.1.2　表　2</span><br><span class="line"></span><br><span class="line">1.1.3　列和数据类型　3</span><br><span class="line"></span><br><span class="line">1.1.4　行　4</span><br><span class="line"></span><br><span class="line">1.1.5　主键　4</span><br><span class="line"></span><br><span class="line">1.2　什么是SQL　5</span><br><span class="line"></span><br><span class="line">1.3　动手实践　6</span><br><span class="line"></span><br><span class="line">1.4　小结　7</span><br><span class="line"></span><br><span class="line">第 2章　MySQL简介　8</span><br><span class="line"></span><br><span class="line">2.1　什么是MySQL　8</span><br><span class="line"></span><br><span class="line">2.1.1　客户机—服务器软件　8</span><br><span class="line"></span><br><span class="line">2.1.2　MySQL版本　9</span><br><span class="line"></span><br><span class="line">2.2　MySQL工具　10</span><br><span class="line"></span><br><span class="line">2.2.1　mysql命令行实用程序　11</span><br><span class="line"></span><br><span class="line">2.2.2　MySQL Adminis-trator　12</span><br><span class="line"></span><br><span class="line">2.2.3　MySQL Query Browser　13</span><br><span class="line"></span><br><span class="line">2.3　小结　14</span><br><span class="line"></span><br><span class="line">第3章　使用MySQL　15</span><br><span class="line"></span><br><span class="line">3.1　连接　15</span><br><span class="line"></span><br><span class="line">3.2　选择数据库　16</span><br><span class="line"></span><br><span class="line">3.3　了解数据库和表　17</span><br><span class="line"></span><br><span class="line">3.4　小结　19</span><br><span class="line"></span><br><span class="line">第4章　检索数据　20</span><br><span class="line"></span><br><span class="line">4.1　SELECT语句　20</span><br><span class="line"></span><br><span class="line">4.2　检索单个列　20</span><br><span class="line"></span><br><span class="line">4.3　检索多个列　22</span><br><span class="line"></span><br><span class="line">4.4　检索所有列　23</span><br><span class="line"></span><br><span class="line">4.5　检索不同的行　24</span><br><span class="line"></span><br><span class="line">4.6　限制结果　25</span><br><span class="line"></span><br><span class="line">4.7　使用完全限定的表名　26</span><br><span class="line"></span><br><span class="line">4.8　小结　27</span><br><span class="line"></span><br><span class="line">第5章　排序检索数据　28</span><br><span class="line"></span><br><span class="line">5.1　排序数据　28</span><br><span class="line"></span><br><span class="line">5.2　按多个列排序　30</span><br><span class="line"></span><br><span class="line">5.3　指定排序方向　31</span><br><span class="line"></span><br><span class="line">5.4　小结　33</span><br><span class="line"></span><br><span class="line">第6章　过滤数据　34</span><br><span class="line"></span><br><span class="line">6.1　使用WHERE子句　34</span><br><span class="line"></span><br><span class="line">6.2　WHERE子句操作符　35</span><br><span class="line"></span><br><span class="line">6.2.1　检查单个值　36</span><br><span class="line"></span><br><span class="line">6.2.2　不匹配检查　37</span><br><span class="line"></span><br><span class="line">6.2.3　范围值检查　37</span><br><span class="line"></span><br><span class="line">6.2.4　空值检查　38</span><br><span class="line"></span><br><span class="line">6.3　小结　39</span><br><span class="line"></span><br><span class="line">第7章　数据过滤　40</span><br><span class="line"></span><br><span class="line">7.1　组合WHERE子句　40</span><br><span class="line"></span><br><span class="line">7.1.1　AND操作符　40</span><br><span class="line"></span><br><span class="line">7.1.2　OR操作符　41</span><br><span class="line"></span><br><span class="line">7.1.3　计算次序　42</span><br><span class="line"></span><br><span class="line">7.2　IN操作符　43</span><br><span class="line"></span><br><span class="line">7.3　NOT操作符　44</span><br><span class="line"></span><br><span class="line">7.4　小结　45</span><br><span class="line"></span><br><span class="line">第8章　用通配符进行过滤　46</span><br><span class="line"></span><br><span class="line">8.1　LIKE操作符　46</span><br><span class="line"></span><br><span class="line">8.1.1　百分号(%)通配符　47</span><br><span class="line"></span><br><span class="line">8.1.2　下划线(_)通配符　48</span><br><span class="line"></span><br><span class="line">8.2　使用通配符的技巧　49</span><br><span class="line"></span><br><span class="line">8.3　小结　50</span><br><span class="line"></span><br><span class="line">第9章　用正则表达式进行搜索　51</span><br><span class="line"></span><br><span class="line">9.1　正则表达式介绍　51</span><br><span class="line"></span><br><span class="line">9.2　使用MySQL正则表达式　52</span><br><span class="line"></span><br><span class="line">9.2.1　基本字符匹配　52</span><br><span class="line"></span><br><span class="line">9.2.2　进行OR匹配　54</span><br><span class="line"></span><br><span class="line">9.2.3　匹配几个字符之一　54</span><br><span class="line"></span><br><span class="line">9.2.4　匹配范围　55</span><br><span class="line"></span><br><span class="line">9.2.5　匹配特殊字符　56</span><br><span class="line"></span><br><span class="line">9.2.6　匹配字符类　58</span><br><span class="line"></span><br><span class="line">9.2.7　匹配多个实例　58</span><br><span class="line"></span><br><span class="line">9.2.8　定位符　59</span><br><span class="line"></span><br><span class="line">9.3　小结　61</span><br><span class="line"></span><br><span class="line">第 10章　创建计算字段　62</span><br><span class="line"></span><br><span class="line">10.1　计算字段　62</span><br><span class="line"></span><br><span class="line">10.2　拼接字段　63</span><br><span class="line"></span><br><span class="line">10.3　执行算术计算　66</span><br><span class="line"></span><br><span class="line">10.4　小结　67</span><br><span class="line"></span><br><span class="line">第 11章　使用数据处理函数　68</span><br><span class="line"></span><br><span class="line">11.1　函数　68</span><br><span class="line"></span><br><span class="line">11.2　使用函数　68</span><br><span class="line"></span><br><span class="line">11.2.1　文本处理函数　69</span><br><span class="line"></span><br><span class="line">11.2.2　日期和时间处理函数　71</span><br><span class="line"></span><br><span class="line">11.2.3　数值处理函数　74</span><br><span class="line"></span><br><span class="line">11.3　小结　74</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Spark快速大数据分析 PDF</title>
    <url>/posts/69976988/</url>
    <content><![CDATA[<h4 id="《Spark快速大数据分析》"><a href="#《Spark快速大数据分析》" class="headerlink" title="《Spark快速大数据分析》"></a>《Spark快速大数据分析》</h4><h6 id="链接-https-pan-baidu-com-s-1Vk0DSbD-x70BqghyU2hlaA-提取码-i6av"><a href="#链接-https-pan-baidu-com-s-1Vk0DSbD-x70BqghyU2hlaA-提取码-i6av" class="headerlink" title="链接: https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA 提取码: i6av"></a>链接: <a href="https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA">https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA</a> 提取码: i6av</h6><p>《Spark快速大数据分析》由 Spark 开发者及核心成员共同打造，讲解了网络大数据时代应运而生的、能高效迅捷地分析处理数据的工具——Spark，它带领读者快速掌握用 Spark 收集、计算、简化和保存海量数据的方法，学会交互、迭代和增量式分析，解决分区、数据本地化和自定义序列化等问题。<br><a id="more"></a></p>
<p><img src="/images/154781ecd5c7691028feb106be190aac1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">推荐序　　xi</span><br><span class="line"></span><br><span class="line">译者序　　xiv</span><br><span class="line"></span><br><span class="line">序　　xvi</span><br><span class="line"></span><br><span class="line">前言　　xvii</span><br><span class="line"></span><br><span class="line">第1章　Spark数据分析导论　　1</span><br><span class="line"></span><br><span class="line">1．1　Spark是什么　　1</span><br><span class="line"></span><br><span class="line">1．2　一个大一统的软件栈　　2</span><br><span class="line"></span><br><span class="line">1．2．1　Spark Core　　2</span><br><span class="line"></span><br><span class="line">1．2．2　Spark SQL　　3</span><br><span class="line"></span><br><span class="line">1．2．3　Spark Streaming　　3</span><br><span class="line"></span><br><span class="line">1．2．4　MLlib　　3</span><br><span class="line"></span><br><span class="line">1．2．5　GraphX　　3</span><br><span class="line"></span><br><span class="line">1．2．6　集群管理器　　4</span><br><span class="line"></span><br><span class="line">1．3　Spark的用户和用途　　4</span><br><span class="line"></span><br><span class="line">1．3．1　数据科学任务　　4</span><br><span class="line"></span><br><span class="line">1．3．2　数据处理应用　　5</span><br><span class="line"></span><br><span class="line">1．4　Spark简史　　5</span><br><span class="line"></span><br><span class="line">1．5　Spark的版本和发布　　6</span><br><span class="line"></span><br><span class="line">1．6　Spark的存储层次　　6</span><br><span class="line"></span><br><span class="line">第2章　Spark下载与入门　　7</span><br><span class="line"></span><br><span class="line">2．1　下载Spark　　7</span><br><span class="line"></span><br><span class="line">2．2　Spark中Python和Scala的shell　　9</span><br><span class="line"></span><br><span class="line">2．3　Spark 核心概念简介　　12</span><br><span class="line"></span><br><span class="line">2．4　独立应用　　14</span><br><span class="line"></span><br><span class="line">2．4．1　初始化SparkContext　　15</span><br><span class="line"></span><br><span class="line">2．4．2　构建独立应用　　16</span><br><span class="line"></span><br><span class="line">2．5　总结　　19</span><br><span class="line"></span><br><span class="line">第3章　RDD编程　　21</span><br><span class="line"></span><br><span class="line">3．1　RDD基础　　21</span><br><span class="line"></span><br><span class="line">3．2　创建RDD　　23</span><br><span class="line"></span><br><span class="line">3．3　RDD操作　　24</span><br><span class="line"></span><br><span class="line">3．3．1　转化操作　　24</span><br><span class="line"></span><br><span class="line">3．3．2　行动操作　　26</span><br><span class="line"></span><br><span class="line">3．3．3　惰性求值　　27</span><br><span class="line"></span><br><span class="line">3．4　向Spark传递函数　　27</span><br><span class="line"></span><br><span class="line">3．4．1　Python　　27</span><br><span class="line"></span><br><span class="line">3．4．2　Scala　　28</span><br><span class="line"></span><br><span class="line">3．4．3　Java　　29</span><br><span class="line"></span><br><span class="line">3．5　常见的转化操作和行动操作　　30</span><br><span class="line"></span><br><span class="line">3．5．1　基本RDD　　30</span><br><span class="line"></span><br><span class="line">3．5．2　在不同RDD类型间转换　　37</span><br><span class="line"></span><br><span class="line">3．6　持久化( 缓存)　　39</span><br><span class="line"></span><br><span class="line">3．7　总结　　40</span><br><span class="line"></span><br><span class="line">第4章　键值对操作　　41</span><br><span class="line"></span><br><span class="line">4．1　动机　　41</span><br><span class="line"></span><br><span class="line">4．2　创建Pair RDD　　42</span><br><span class="line"></span><br><span class="line">4．3　Pair RDD的转化操作　　42</span><br><span class="line"></span><br><span class="line">4．3．1　聚合操作　　45</span><br><span class="line"></span><br><span class="line">4．3．2　数据分组　　49</span><br><span class="line"></span><br><span class="line">4．3．3　连接　　50</span><br><span class="line"></span><br><span class="line">4．3．4　数据排序　　51</span><br><span class="line"></span><br><span class="line">4．4　Pair RDD的行动操作　　52</span><br><span class="line"></span><br><span class="line">4．5　数据分区（进阶）　　52</span><br><span class="line"></span><br><span class="line">4．5．1　获取RDD的分区方式　　55</span><br><span class="line"></span><br><span class="line">4．5．2　从分区中获益的操作　　56</span><br><span class="line"></span><br><span class="line">4．5．3　影响分区方式的操作　　57</span><br><span class="line"></span><br><span class="line">4．5．4　示例：PageRank　　57</span><br><span class="line"></span><br><span class="line">4．5．5　自定义分区方式　　59</span><br><span class="line"></span><br><span class="line">4．6　总结　　61</span><br><span class="line"></span><br><span class="line">第5章　数据读取与保存　　63</span><br><span class="line"></span><br><span class="line">5．1　动机　　63</span><br><span class="line"></span><br><span class="line">5．2　文件格式　　64</span><br><span class="line"></span><br><span class="line">5．2．1　文本文件　　64</span><br><span class="line"></span><br><span class="line">5．2．2　JSON　　66</span><br><span class="line"></span><br><span class="line">5．2．3　逗号分隔值与制表符分隔值　　68</span><br><span class="line"></span><br><span class="line">5．2．4　SequenceFile　　71</span><br><span class="line"></span><br><span class="line">5．2．5　对象文件　　73</span><br><span class="line"></span><br><span class="line">5．2．6　Hadoop输入输出格式　　73</span><br><span class="line"></span><br><span class="line">5．2．7　文件压缩　　77</span><br><span class="line"></span><br><span class="line">5．3　文件系统　　78</span><br><span class="line"></span><br><span class="line">5．3．1　本地&#x2F;“常规”文件系统　　78</span><br><span class="line"></span><br><span class="line">5．3．2　Amazon S3　　78</span><br><span class="line"></span><br><span class="line">5．3．3　HDFS　　79</span><br><span class="line"></span><br><span class="line">5．4　Spark SQL中的结构化数据　　79</span><br><span class="line"></span><br><span class="line">5．4．1　Apache Hive　　80</span><br><span class="line"></span><br><span class="line">5．4．2　JSON　　80</span><br><span class="line"></span><br><span class="line">5．5　数据库　　81</span><br><span class="line"></span><br><span class="line">5．5．1　Java数据库连接　　81</span><br><span class="line"></span><br><span class="line">5．5．2　Cassandra　　82</span><br><span class="line"></span><br><span class="line">5．5．3　HBase　　84</span><br><span class="line"></span><br><span class="line">5．5．4　Elasticsearch　　85</span><br><span class="line"></span><br><span class="line">5．6　总结　　86</span><br><span class="line"></span><br><span class="line">第6章　Spark编程进阶　　87</span><br><span class="line"></span><br><span class="line">6．1　简介　　87</span><br><span class="line"></span><br><span class="line">6．2　累加器　　88</span><br><span class="line"></span><br><span class="line">6．2．1　累加器与容错性　　90</span><br><span class="line"></span><br><span class="line">6．2．2　自定义累加器　　91</span><br><span class="line"></span><br><span class="line">6．3　广播变量　　91</span><br><span class="line"></span><br><span class="line">6．4　基于分区进行操作　　94</span><br><span class="line"></span><br><span class="line">6．5　与外部程序间的管道　　96</span><br><span class="line"></span><br><span class="line">6．6　数值RDD 的操作　　99</span><br><span class="line"></span><br><span class="line">6．7　总结　　100</span><br><span class="line"></span><br><span class="line">第7章　在集群上运行Spark　　101</span><br><span class="line"></span><br><span class="line">7．1　简介　　101</span><br><span class="line"></span><br><span class="line">7．2　Spark运行时架构　　101</span><br><span class="line"></span><br><span class="line">7．2．1　驱动器节点　　102</span><br><span class="line"></span><br><span class="line">7．2．2　执行器节点　　103</span><br><span class="line"></span><br><span class="line">7．2．3　集群管理器　　103</span><br><span class="line"></span><br><span class="line">7．2．4　启动一个程序　　104</span><br><span class="line"></span><br><span class="line">7．2．5　小结　　104</span><br><span class="line"></span><br><span class="line">7．3　使用spark-submit 部署应用　　105</span><br><span class="line"></span><br><span class="line">7．4　打包代码与依赖　　107</span><br><span class="line"></span><br><span class="line">7．4．1　使用Maven构建的用Java编写的Spark应用　　108</span><br><span class="line"></span><br><span class="line">7．4．2　使用sbt构建的用Scala编写的Spark应用　　109</span><br><span class="line"></span><br><span class="line">7．4．3　依赖冲突　　 111</span><br><span class="line"></span><br><span class="line">7．5　Spark应用内与应用间调度　　111</span><br><span class="line"></span><br><span class="line">7．6　集群管理器　　112</span><br><span class="line"></span><br><span class="line">7．6．1　独立集群管理器　　112</span><br><span class="line"></span><br><span class="line">7．6．2　Hadoop YARN　　115</span><br><span class="line"></span><br><span class="line">7．6．3　Apache Mesos　　116</span><br><span class="line"></span><br><span class="line">7．6．4　Amazon EC2　　117</span><br><span class="line"></span><br><span class="line">7．7　选择合适的集群管理器　　120</span><br><span class="line"></span><br><span class="line">7．8　总结　　121</span><br><span class="line"></span><br><span class="line">第8章　Spark调优与调试　　123</span><br><span class="line"></span><br><span class="line">8．1　使用SparkConf配置Spark　　123</span><br><span class="line"></span><br><span class="line">8．2　Spark执行的组成部分：作业、任务和步骤　　127</span><br><span class="line"></span><br><span class="line">8．3　查找信息　　131</span><br><span class="line"></span><br><span class="line">8．3．1　Spark网页用户界面　　131</span><br><span class="line"></span><br><span class="line">8．3．2　驱动器进程和执行器进程的日志　　134</span><br><span class="line"></span><br><span class="line">8．4　关键性能考量　　135</span><br><span class="line"></span><br><span class="line">8．4．1　并行度　　135</span><br><span class="line"></span><br><span class="line">8．4．2　序列化格式　　136</span><br><span class="line"></span><br><span class="line">8．4．3　内存管理　　137</span><br><span class="line"></span><br><span class="line">8．4．4　硬件供给　　138</span><br><span class="line"></span><br><span class="line">8．5　总结　　139</span><br><span class="line"></span><br><span class="line">第9章　Spark SQL　　141</span><br><span class="line"></span><br><span class="line">9．1　连接Spark SQL　　142</span><br><span class="line"></span><br><span class="line">9．2　在应用中使用Spark SQL　　144</span><br><span class="line"></span><br><span class="line">9．2．1　初始化Spark SQL　　144</span><br><span class="line"></span><br><span class="line">9．2．2　基本查询示例　　145</span><br><span class="line"></span><br><span class="line">9．2．3　SchemaRDD　　146</span><br><span class="line"></span><br><span class="line">9．2．4　缓存　　148</span><br><span class="line"></span><br><span class="line">9．3　读取和存储数据　　149</span><br><span class="line"></span><br><span class="line">9．3．1　Apache Hive　　149</span><br><span class="line"></span><br><span class="line">9．3．2　Parquet　　150</span><br><span class="line"></span><br><span class="line">9．3．3　JSON　　150</span><br><span class="line"></span><br><span class="line">9．3．4　基于RDD　　152</span><br><span class="line"></span><br><span class="line">9．4　JDBC&#x2F;ODBC服务器　　153</span><br><span class="line"></span><br><span class="line">9．4．1　使用Beeline　　155</span><br><span class="line"></span><br><span class="line">9．4．2　长生命周期的表与查询　　156</span><br><span class="line"></span><br><span class="line">9．5　用户自定义函数　　156</span><br><span class="line"></span><br><span class="line">9．5．1　Spark SQL UDF　　156</span><br><span class="line"></span><br><span class="line">9．5．2　Hive UDF　　157</span><br><span class="line"></span><br><span class="line">9．6　Spark SQL性能　　158</span><br><span class="line"></span><br><span class="line">9．7　总结　　159</span><br><span class="line"></span><br><span class="line">第10章　Spark Streaming　　161</span><br><span class="line"></span><br><span class="line">10．1　一个简单的例子　　162</span><br><span class="line"></span><br><span class="line">10．2　架构与抽象　　164</span><br><span class="line"></span><br><span class="line">10．3　转化操作　　167</span><br><span class="line"></span><br><span class="line">10．3．1　无状态转化操作　　167</span><br><span class="line"></span><br><span class="line">10．3．2　有状态转化操作　　169</span><br><span class="line"></span><br><span class="line">10．4　输出操作　　173</span><br><span class="line"></span><br><span class="line">10．5　输入源　　175</span><br><span class="line"></span><br><span class="line">10．5．1　核心数据源　　175</span><br><span class="line"></span><br><span class="line">10．5．2　附加数据源　　176</span><br><span class="line"></span><br><span class="line">10．5．3　多数据源与集群规模　　179</span><br><span class="line"></span><br><span class="line">10．6　24&#x2F;7不间断运行　　180</span><br><span class="line"></span><br><span class="line">10．6．1　检查点机制　　180</span><br><span class="line"></span><br><span class="line">10．6．2　驱动器程序容错　　181</span><br><span class="line"></span><br><span class="line">10．6．3　工作节点容错　　182</span><br><span class="line"></span><br><span class="line">10．6．4　接收器容错　　182</span><br><span class="line"></span><br><span class="line">10．6．5　处理保证　　183</span><br><span class="line"></span><br><span class="line">10．7　Streaming用户界面　　183</span><br><span class="line"></span><br><span class="line">10．8　性能考量　　184</span><br><span class="line"></span><br><span class="line">10．8．1　批次和窗口大小　　184</span><br><span class="line"></span><br><span class="line">10．8．2　并行度　　184</span><br><span class="line"></span><br><span class="line">10．8．3　垃圾回收和内存使用　　185</span><br><span class="line"></span><br><span class="line">10．9　总结　　185</span><br><span class="line"></span><br><span class="line">第11章　基于MLlib的机器学习　　187</span><br><span class="line"></span><br><span class="line">11．1　概述　　187</span><br><span class="line"></span><br><span class="line">11．2　系统要求　　188</span><br><span class="line"></span><br><span class="line">11．3　机器学习基础　　189</span><br><span class="line"></span><br><span class="line">11．4　数据类型　　192</span><br><span class="line"></span><br><span class="line">11．5　算法　　194</span><br><span class="line"></span><br><span class="line">11．5．1　特征提取　　194</span><br><span class="line"></span><br><span class="line">11．5．2　统计　　196</span><br><span class="line"></span><br><span class="line">11．5．3　分类与回归　　197</span><br><span class="line"></span><br><span class="line">11．5．4　聚类　　202</span><br><span class="line"></span><br><span class="line">11．5．5　协同过滤与推荐　　203</span><br><span class="line"></span><br><span class="line">11．5．6　降维　　204</span><br><span class="line"></span><br><span class="line">11．5．7　模型评估　　206</span><br><span class="line"></span><br><span class="line">11．6　一些提示与性能考量　　206</span><br><span class="line"></span><br><span class="line">11．6．1　准备特征　　206</span><br><span class="line"></span><br><span class="line">11．6．2　配置算法　　207</span><br><span class="line"></span><br><span class="line">11．6．3　缓存RDD以重复使用　　207</span><br><span class="line"></span><br><span class="line">11．6．4　识别稀疏程度　　207</span><br><span class="line"></span><br><span class="line">11．6．5　并行度　　207</span><br><span class="line"></span><br><span class="line">11．7　流水线API　　208</span><br><span class="line"></span><br><span class="line">11．8　总结　　209</span><br><span class="line"></span><br><span class="line">作者简介　　210</span><br><span class="line"></span><br><span class="line">封面介绍　　210</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Spring 实战 中文版第4版 PDF</title>
    <url>/posts/1e90591e/</url>
    <content><![CDATA[<h4 id="《Spring-实战-中文版第4版》"><a href="#《Spring-实战-中文版第4版》" class="headerlink" title="《Spring 实战 中文版第4版》"></a>《Spring 实战 中文版第4版》</h4><h6 id="链接-https-pan-baidu-com-s-1xQQ41VNvDxk-Fd-7Pq-x-w-提取码-gea5"><a href="#链接-https-pan-baidu-com-s-1xQQ41VNvDxk-Fd-7Pq-x-w-提取码-gea5" class="headerlink" title="链接: https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w 提取码: gea5"></a>链接: <a href="https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w">https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w</a> 提取码: gea5</h6><p>Spring 框架是以简化J2EE 应用程序开发为特定目标而创建的，是当前 流行的Java 开发框架。本书主要介绍Beans 的配置、依赖注入、定制bean、基于Java 的容器、AOP、Spring Data、Spring MVC 等内容。本书基于非常适合构建JavaWeb 微服务框架的Spring 5 编写，涵盖Java 的函数式编程、RxJava 2 的反应式编程、用Spring WebFlux、Spring Data 和Spring Security 开发反应式RESTful Web 服务等内容。 本书适合Web 开发者和想使用Spring 的初学者参考，也可供对Web 开发和Spring 感兴趣的读者参考。<br><a id="more"></a></p>
<p><img src="/images/6deb88c602ac05b316f00294677e8ad91.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第 1 章 Spring 框架概述</span><br><span class="line"></span><br><span class="line">1.1 简介</span><br><span class="line"></span><br><span class="line">1.2 Spring 框架的模块</span><br><span class="line"></span><br><span class="line">1.3 Spring IoC 容器</span><br><span class="line"></span><br><span class="line">1.4 使用Spring 框架的好处</span><br><span class="line"></span><br><span class="line">1.4.1 管理本地和全局事务的一致方法</span><br><span class="line"></span><br><span class="line">1.4.2 声明式事务管理</span><br><span class="line"></span><br><span class="line">1.4.3 安全</span><br><span class="line"></span><br><span class="line">1.4.4 Java 管理扩展</span><br><span class="line"></span><br><span class="line">1.4.5 Java 消息服务</span><br><span class="line"></span><br><span class="line">1.4.6 缓存</span><br><span class="line"></span><br><span class="line">1.5 一个简单的Spring 应用程序</span><br><span class="line"></span><br><span class="line">1.5.1 确定应用程序对象及其依赖关系</span><br><span class="line"></span><br><span class="line">1.5.2 根据确定的应用程序对象创建POJO 类</span><br><span class="line"></span><br><span class="line">1.5.3 创建配置元数据</span><br><span class="line"></span><br><span class="line">1.5.4 通过setter 方法注入依赖项</span><br><span class="line"></span><br><span class="line">1.5.5 创建一个Spring 容器的实例</span><br><span class="line"></span><br><span class="line">1.5.6 从Spring 容器访问bean</span><br><span class="line"></span><br><span class="line">1.6 Spring 框架5 的新功能</span><br><span class="line"></span><br><span class="line">1.7 建立在Spring 之上的框架</span><br><span class="line"></span><br><span class="line">1.8 小结</span><br><span class="line"></span><br><span class="line">第 2 章 Spring 框架基础</span><br><span class="line"></span><br><span class="line">2.1 简介</span><br><span class="line"></span><br><span class="line">2.2 面向接口编程的设计方法</span><br><span class="line"></span><br><span class="line">提高依赖类的可测试性</span><br><span class="line"></span><br><span class="line">Spring 对“面向接口编程”设计方法的</span><br><span class="line"></span><br><span class="line">支持</span><br><span class="line"></span><br><span class="line">2.3 使用静态和实例工厂方法创建Spring</span><br><span class="line"></span><br><span class="line">bean</span><br><span class="line"></span><br><span class="line">2.4 基于构造函数的DI</span><br><span class="line"></span><br><span class="line">2.5 将配置详细信息传递给bean</span><br><span class="line"></span><br><span class="line">2.6 bean 的作用域</span><br><span class="line"></span><br><span class="line">2.7 小结</span><br><span class="line"></span><br><span class="line">第3 章 bean 的配置</span><br><span class="line"></span><br><span class="line">3.1 简介</span><br><span class="line"></span><br><span class="line">3.2 bean 定义的继承</span><br><span class="line"></span><br><span class="line">3.3 构造函数参数匹配</span><br><span class="line"></span><br><span class="line">3.4 配置不同类型的bean 属性和构造函数   </span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line"></span><br><span class="line">相对应的默认实现</span><br><span class="line"></span><br><span class="line">3.5 内置属性编辑器</span><br><span class="line"></span><br><span class="line">3.6 向Spring 容器注册属性编辑器</span><br><span class="line"></span><br><span class="line">3.7 具有p 和c 命名空间的简明bean 定义</span><br><span class="line"></span><br><span class="line">3.8 Spring 的util 模式</span><br><span class="line"></span><br><span class="line">3.9 FactoryBean 接口</span><br><span class="line"></span><br><span class="line">2 目 录            </span><br><span class="line"></span><br><span class="line">3.10 模块化bean 配置</span><br><span class="line"></span><br><span class="line">3.11 小结</span><br><span class="line"></span><br><span class="line">第4 章 依赖注入</span><br><span class="line"></span><br><span class="line">4.1 简介</span><br><span class="line"></span><br><span class="line">4.2 内部bean</span><br><span class="line"></span><br><span class="line">4.3 使用depends-on 特性控制bean 的初始化            </span><br><span class="line"></span><br><span class="line">顺序</span><br><span class="line"></span><br><span class="line">4.4 singleton 和prototype 范围的bean 的            </span><br><span class="line"></span><br><span class="line">依赖项</span><br><span class="line"></span><br><span class="line">4.5 通过singleton bean 中获取prototype bean 的            </span><br><span class="line"></span><br><span class="line">新实例</span><br><span class="line"></span><br><span class="line">4.6 自动装配依赖项</span><br><span class="line"></span><br><span class="line">4.7 小结</span><br><span class="line"></span><br><span class="line">第5 章 自定义bean 和bean 定义</span><br><span class="line"></span><br><span class="line">5.1 简介</span><br><span class="line"></span><br><span class="line">5.2 自定义bean 的初始化和销毁逻辑</span><br><span class="line"></span><br><span class="line">5.3 使用BeanPostProcessor 与新创建的bean 实例              </span><br><span class="line"></span><br><span class="line">进行交互</span><br><span class="line"></span><br><span class="line">5.4 使用BeanFactoryPostProcessor 修改              </span><br><span class="line"></span><br><span class="line">bean 定义</span><br><span class="line"></span><br><span class="line">5.5 小结</span><br><span class="line"></span><br><span class="line">第6 章 使用Spring 进行注解驱动              </span><br><span class="line"></span><br><span class="line">开发</span><br><span class="line"></span><br><span class="line">6.1 简介</span><br><span class="line"></span><br><span class="line">6.2 用@Component 标识Spring bean</span><br><span class="line"></span><br><span class="line">6.3 @Autowired 通过类型自动装配依赖项</span><br><span class="line"></span><br><span class="line">6.4 @ ualifier 按名称自动装配依赖项</span><br><span class="line"></span><br><span class="line">6.5 JSR 330 的@Inject 和@Named 注解</span><br><span class="line"></span><br><span class="line">Java 8 的Optional 类型</span><br><span class="line"></span><br><span class="line">6.6 JSR 250 的@Resource 注解</span><br><span class="line"></span><br><span class="line">6.7 @Scope、@Lazy、@DependsOn 和              </span><br><span class="line"></span><br><span class="line">@Primary 注解</span><br><span class="line"></span><br><span class="line">6.7.1 @Scope</span><br><span class="line"></span><br><span class="line">6.7.2 @Lazy</span><br><span class="line"></span><br><span class="line">6.7.3 @DependsOn</span><br><span class="line"></span><br><span class="line">6.7.4 @Primary</span><br><span class="line"></span><br><span class="line">6.8 使用@Value 简化注解的bean 类的配置</span><br><span class="line"></span><br><span class="line">6.8.1 在@Value 注解中使用Spring              </span><br><span class="line"></span><br><span class="line">表达式语言（SpEL） </span><br><span class="line"></span><br><span class="line">6.8.2 在方法级和方法参数级使用              </span><br><span class="line"></span><br><span class="line">@Value 注解</span><br><span class="line"></span><br><span class="line">6.8.3 在SpEL 中使用数学、关系和              </span><br><span class="line"></span><br><span class="line">逻辑运算符</span><br><span class="line"></span><br><span class="line">6.8.4 使用SpEL 获取bean 的引用</span><br><span class="line"></span><br><span class="line">6.8.5 在SpEL 中使用正则表达式</span><br><span class="line"></span><br><span class="line">6.8.6 在SpEL 中使用映射和列表</span><br><span class="line"></span><br><span class="line">6.8.7 在基于XML 的bean 定义中指定              </span><br><span class="line"></span><br><span class="line">SpEL 表达式</span><br><span class="line"></span><br><span class="line">6.9 使用Spring 的Validator 接口验证对象</span><br><span class="line"></span><br><span class="line">6.10 使用JSR 380（Bean Validation 2.0）注解              </span><br><span class="line"></span><br><span class="line">指定约束</span><br><span class="line"></span><br><span class="line">目 录 3              </span><br><span class="line"></span><br><span class="line">Spring 中的JSR 380 支持</span><br><span class="line"></span><br><span class="line">JSR 380 有什么新功能</span><br><span class="line"></span><br><span class="line">6.11 bean 定义配置文件</span><br><span class="line"></span><br><span class="line">bean 定义配置文件示例</span><br><span class="line"></span><br><span class="line">6.12 小结</span><br><span class="line"></span><br><span class="line">第7 章 基于Java 的容器配置</span><br><span class="line"></span><br><span class="line">7.1 简介</span><br><span class="line"></span><br><span class="line">7.2 使用@Configuration 和@Bean 注解配置              </span><br><span class="line"></span><br><span class="line">bean</span><br><span class="line"></span><br><span class="line">在@Component 和JSR 330 的@Named 类              </span><br><span class="line"></span><br><span class="line">中定义@Bean 方法</span><br><span class="line"></span><br><span class="line">7.3 注入bean 依赖项</span><br><span class="line"></span><br><span class="line">7.4 配置Spring 容器</span><br><span class="line"></span><br><span class="line">7.5 生命周期回调</span><br><span class="line"></span><br><span class="line">7.6 导入基于Java 的配置</span><br><span class="line"></span><br><span class="line">解决依赖关系</span><br><span class="line"></span><br><span class="line">7.7 附加主题</span><br><span class="line"></span><br><span class="line">7.7.1 覆盖@Bean 方法</span><br><span class="line"></span><br><span class="line">7.7.2 配置BeanPostProcessors 和              </span><br><span class="line"></span><br><span class="line">BeanFactoryPostProcessors</span><br><span class="line"></span><br><span class="line">7.7.3 导入应用程序上下文XML 文件</span><br><span class="line"></span><br><span class="line">7.7.4 有条件地包含@Bean 和              </span><br><span class="line"></span><br><span class="line">@Configuration 类</span><br><span class="line"></span><br><span class="line">7.8 小结</span><br><span class="line"></span><br><span class="line">第8 章 使用Spring 进行数据库交互</span><br><span class="line"></span><br><span class="line">8.1 简介</span><br><span class="line"></span><br><span class="line">8.2 MyBank 应用程序的需求</span><br><span class="line"></span><br><span class="line">8.3 使用Spring JDBC 模块开发MyBank 应用              </span><br><span class="line"></span><br><span class="line">程序</span><br><span class="line"></span><br><span class="line">8.3.1 配置数据源</span><br><span class="line"></span><br><span class="line">8.3.2 创建使用Spring 的JDBC 模块类的              </span><br><span class="line"></span><br><span class="line">DAO </span><br><span class="line"></span><br><span class="line">8.4 使用Hibernate 开发MyBank 应用程序</span><br><span class="line"></span><br><span class="line">8.4.1 配置SessionFactory 实例</span><br><span class="line"></span><br><span class="line">8.4.2 创建使用Hibernate API 进行数据库              </span><br><span class="line"></span><br><span class="line">交互的DAO </span><br><span class="line"></span><br><span class="line">8.5 使用Spring 的事务管理</span><br><span class="line"></span><br><span class="line">8.5.1 MyBank 的事务管理需求</span><br><span class="line"></span><br><span class="line">8.5.2 编程式事务管理</span><br><span class="line"></span><br><span class="line">8.5.3 声明式事务管理</span><br><span class="line"></span><br><span class="line">8.5.4 Spring 对JTA 的支持</span><br><span class="line"></span><br><span class="line">8.6 使用基于Java 的配置开发MyBank 应用              </span><br><span class="line"></span><br><span class="line">程序</span><br><span class="line"></span><br><span class="line">8.6.1 配置javax.sql.DataSource </span><br><span class="line"></span><br><span class="line">8.6.2 配置Hibernate 的SessionFactory</span><br><span class="line"></span><br><span class="line">8.6.3 启用@Transactional 支持</span><br><span class="line"></span><br><span class="line">8.7 小结</span><br><span class="line"></span><br><span class="line">第9 章 Spring Data </span><br><span class="line"></span><br><span class="line">9.1 简介</span><br><span class="line"></span><br><span class="line">9.2 核心概念和接口</span><br><span class="line"></span><br><span class="line">9.3 Spring Data JPA</span><br><span class="line"></span><br><span class="line">9.3.1 代替存储库方法的自定义实现</span><br><span class="line"></span><br><span class="line">9.3.2 将自定义方法添加到存储库</span><br><span class="line"></span><br><span class="line">9.3.3 配置Spring Data JPA—基于              </span><br><span class="line"></span><br><span class="line">Java 的配置方法</span><br><span class="line"></span><br><span class="line">9.3.4 配置Spring Data JPA—              </span><br><span class="line"></span><br><span class="line">基于XML 的配置方法</span><br><span class="line"></span><br><span class="line">9.3.5 查询方法</span><br><span class="line"></span><br><span class="line">9.4 使用 uerydsl 创建查询</span><br><span class="line"></span><br><span class="line">9.4.1 将Spring Data 与 uerydsl 集成</span><br><span class="line"></span><br><span class="line">9.4.2 构造Predicate </span><br><span class="line"></span><br><span class="line">9.5 按示例查询</span><br><span class="line"></span><br><span class="line">9.6 Spring Data MongoDB</span><br><span class="line"></span><br><span class="line">9.6.1 建模域实体</span><br><span class="line"></span><br><span class="line">9.6.2 配置Spring Data MongoDB—              </span><br><span class="line"></span><br><span class="line">基于Java 的配置</span><br><span class="line"></span><br><span class="line">9.6.3 配置Spring Data MongoDB—              </span><br><span class="line"></span><br><span class="line">基于XML 的配置</span><br><span class="line"></span><br><span class="line">9.6.4 创建自定义存储库</span><br><span class="line"></span><br><span class="line">9.6.5 将自定义方法添加到存储库</span><br><span class="line"></span><br><span class="line">9.6.6 使用 uerydsl 创建查询</span><br><span class="line"></span><br><span class="line">9.6.7 使用 uery by Example 创建查询</span><br><span class="line"></span><br><span class="line">9.7 小结</span><br><span class="line"></span><br><span class="line">第 10 章 使用Spring 进行消息传递、              </span><br><span class="line"></span><br><span class="line">电子邮件发送、异步方法执行              </span><br><span class="line"></span><br><span class="line">和缓存</span><br><span class="line"></span><br><span class="line">10.1 简介</span><br><span class="line"></span><br><span class="line">10.2 MyBank 应用程序的需求</span><br><span class="line"></span><br><span class="line">10.3 发送JMS 消息</span><br><span class="line"></span><br><span class="line">10.3.1 配置ActiveM 代理以在内嵌              </span><br><span class="line"></span><br><span class="line">模式下运行</span><br><span class="line"></span><br><span class="line">10.3.2 配置一个JMS ConnectionFactory</span><br><span class="line"></span><br><span class="line">10.3.3 使用JmsTemplate 发送JMS 消息</span><br><span class="line"></span><br><span class="line">10.3.4 在事务中发送JMS 消息</span><br><span class="line"></span><br><span class="line">10.3.5 动态JMS 目标和JmsTemplate              </span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line"></span><br><span class="line">4 目 录              </span><br><span class="line"></span><br><span class="line">10.3.6 JmsTemplate 和消息转换</span><br><span class="line"></span><br><span class="line">10.4 接收JMS 消息</span><br><span class="line"></span><br><span class="line">10.4.1 使用JmsTemplate 同步接收JMS              </span><br><span class="line"></span><br><span class="line">消息</span><br><span class="line"></span><br><span class="line">10.4.2 使用消息侦听器容器异步接收              </span><br><span class="line"></span><br><span class="line">JMS 消息</span><br><span class="line"></span><br><span class="line">10.4.3 使用@JmsListener 注册JMS              </span><br><span class="line"></span><br><span class="line">侦听器端点</span><br><span class="line"></span><br><span class="line">10.4.4 使用spring-messaging 模块的消息              </span><br><span class="line"></span><br><span class="line">传递</span><br><span class="line"></span><br><span class="line">10.5 发送电子邮件</span><br><span class="line"></span><br><span class="line">10.5.1 使用MimeMessageHelper              </span><br><span class="line"></span><br><span class="line">准备MIME 消息</span><br><span class="line"></span><br><span class="line">10.5.2 使用MimeMessagePreparator 准备              </span><br><span class="line"></span><br><span class="line">MIME 消息</span><br><span class="line"></span><br><span class="line">10.6 任务调度和异步执行</span><br><span class="line"></span><br><span class="line">10.6.1 TaskExecutor 接口</span><br><span class="line"></span><br><span class="line">10.6.2 TaskScheduler 接口</span><br><span class="line"></span><br><span class="line">10.6.3 调度bean 方法的执行</span><br><span class="line"></span><br><span class="line">10.6.4 @Async 和@Scheduled 注解</span><br><span class="line"></span><br><span class="line">10.7 缓存</span><br><span class="line"></span><br><span class="line">10.7.1 配置一个CacheManager</span><br><span class="line"></span><br><span class="line">10.7.2 缓存注解—@Cacheable、              </span><br><span class="line"></span><br><span class="line">@CacheEvict 和@CachePut</span><br><span class="line"></span><br><span class="line">10.7.3 使用Spring cache 模式进行缓存              </span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line"></span><br><span class="line">10.8 运行MyBank 应用程序</span><br><span class="line"></span><br><span class="line">10.9 小结</span><br><span class="line"></span><br><span class="line">第 11 章 面向切面编程</span><br><span class="line"></span><br><span class="line">11.1 简介</span><br><span class="line"></span><br><span class="line">11.2 一个简单的AOP 示例</span><br><span class="line"></span><br><span class="line">11.3 Spring AOP 框架</span><br><span class="line"></span><br><span class="line">11.3.1 代理的创建</span><br><span class="line"></span><br><span class="line">11.3.2 expose-proxy 特性</span><br><span class="line"></span><br><span class="line">11.4 切入点表达式</span><br><span class="line"></span><br><span class="line">11.4.1 @Pointcut 注解</span><br><span class="line"></span><br><span class="line">11.4.2 execution 和args 切入点指示符</span><br><span class="line"></span><br><span class="line">11.4.3 bean 切入点指示器</span><br><span class="line"></span><br><span class="line">11.4.4 基于注解的切入点指示符</span><br><span class="line"></span><br><span class="line">11.5 通知类型</span><br><span class="line"></span><br><span class="line">11.5.1 前置通知</span><br><span class="line"></span><br><span class="line">11.5.2 返回后通知</span><br><span class="line"></span><br><span class="line">11.5.3 抛出后通知</span><br><span class="line"></span><br><span class="line">11.5.4 后置通知</span><br><span class="line"></span><br><span class="line">11.5.5 围绕通知</span><br><span class="line"></span><br><span class="line">11.5.6 通过实现特殊接口创建通知</span><br><span class="line"></span><br><span class="line">11.6 Spring AOP - XML 模式样式</span><br><span class="line"></span><br><span class="line">11.6.1 配置一个AOP 切面</span><br><span class="line"></span><br><span class="line">11.6.2 配置一个通知</span><br><span class="line"></span><br><span class="line">11.6.3 将切入点表达式与通知相关联</span><br><span class="line"></span><br><span class="line">11.7 小结</span><br><span class="line"></span><br><span class="line">第 12 章 Spring Web MVC 基础知识</span><br><span class="line"></span><br><span class="line">12.1 简介</span><br><span class="line"></span><br><span class="line">12.2 示例Web 项目的目录结构</span><br><span class="line"></span><br><span class="line">12.3 了解“Hello World”网络应用程序</span><br><span class="line"></span><br><span class="line">12.3.1 HelloWorldController.java—Hello              </span><br><span class="line"></span><br><span class="line">World Web 应用程序的控制器类</span><br><span class="line"></span><br><span class="line">12.3.2 helloworld.jsp—展示“Hello              </span><br><span class="line"></span><br><span class="line">World !!”消息的JSP 页面</span><br><span class="line"></span><br><span class="line">12.3.3 myapp-config.xml—Web 应用              </span><br><span class="line"></span><br><span class="line">程序上下文XML 文件</span><br><span class="line"></span><br><span class="line">12.3.4 web.xml—Web 应用程序部署              </span><br><span class="line"></span><br><span class="line">描述符</span><br><span class="line"></span><br><span class="line">12.4 DispatcherServlet—前端控制器</span><br><span class="line"></span><br><span class="line">访问ServletContext 和ServletConfig              </span><br><span class="line"></span><br><span class="line">对象</span><br><span class="line"></span><br><span class="line">12.5 使用@Controller 和@RequestMapping 注解              </span><br><span class="line"></span><br><span class="line">开发控制器</span><br><span class="line"></span><br><span class="line">使用注解控制器开发“Hello World”Web              </span><br><span class="line"></span><br><span class="line">应用程序</span><br><span class="line"></span><br><span class="line">12.6 MyBank Web 应用程序的需求</span><br><span class="line"></span><br><span class="line">12.7 Spring Web MVC 注解—              </span><br><span class="line"></span><br><span class="line">@RequestMapping 和@RequestParam </span><br><span class="line"></span><br><span class="line">12.7.1 使用@RequestMapping 将请求              </span><br><span class="line"></span><br><span class="line">映射到控制器或者控制器方法</span><br><span class="line"></span><br><span class="line">12.7.2 @RequestMapping 注解方法的              </span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line"></span><br><span class="line">12.7.3 @RequestMapping 注解方法的              </span><br><span class="line"></span><br><span class="line">返回类型</span><br><span class="line"></span><br><span class="line">12.7.4 使用@RequestParam 将请求参数              </span><br><span class="line"></span><br><span class="line">传递给控制器方法</span><br><span class="line"></span><br><span class="line">12.8 验证</span><br><span class="line"></span><br><span class="line">12.9 使用@ExceptionHandler 注解处理              </span><br><span class="line"></span><br><span class="line">异常</span><br><span class="line"></span><br><span class="line">12.10 加载根Web 应用程序上下文XML              </span><br><span class="line"></span><br><span class="line">文件</span><br><span class="line"></span><br><span class="line">12.11 小结</span><br><span class="line"></span><br><span class="line">目 录 5              </span><br><span class="line"></span><br><span class="line">第 13 章 Spring Web MVC 中的验证和              </span><br><span class="line"></span><br><span class="line">数据绑定</span><br><span class="line"></span><br><span class="line">13.1 简介</span><br><span class="line"></span><br><span class="line">13.2 使用@ModelAttribute 注解添加和获取              </span><br><span class="line"></span><br><span class="line">模型特性</span><br><span class="line"></span><br><span class="line">13.3 使用@SessionAttributes 注解缓存模型              </span><br><span class="line"></span><br><span class="line">特性</span><br><span class="line"></span><br><span class="line">13.4 Spring 中对数据绑定的支持</span><br><span class="line"></span><br><span class="line">13.4.1 WebDataBinder—Web 请求参数              </span><br><span class="line"></span><br><span class="line">的数据绑定器</span><br><span class="line"></span><br><span class="line">13.4.2 配置WebDataBinder 实例</span><br><span class="line"></span><br><span class="line">13.4.3 允许或禁止字段参与数据绑定              </span><br><span class="line"></span><br><span class="line">过程</span><br><span class="line"></span><br><span class="line">13.4.4 使用BindingResult 对象检查数据              </span><br><span class="line"></span><br><span class="line">绑定和验证错误</span><br><span class="line"></span><br><span class="line">13.5 Spring 中的验证支持</span><br><span class="line"></span><br><span class="line">13.6 Spring 的form 标签库</span><br><span class="line"></span><br><span class="line">Spring 的form 标签库对HTML5 的支持</span><br><span class="line"></span><br><span class="line">13.7 使用基于Java 的配置方式来配置Web              </span><br><span class="line"></span><br><span class="line">应用程序</span><br><span class="line"></span><br><span class="line">13.8 小结</span><br><span class="line"></span><br><span class="line">第 14 章 使用Spring Web MVC 开发              </span><br><span class="line"></span><br><span class="line">RESTful Web 服务</span><br><span class="line"></span><br><span class="line">14.1 简介</span><br><span class="line"></span><br><span class="line">14.2 定期存款Web 服务</span><br><span class="line"></span><br><span class="line">14.3 使用Spring Web MVC实现RESTful Web              </span><br><span class="line"></span><br><span class="line">服务</span><br><span class="line"></span><br><span class="line">14.3.1 JSON ( 对象表示法) </span><br><span class="line"></span><br><span class="line">14.3.2 FixedDepositWS Web 服务的              </span><br><span class="line"></span><br><span class="line">实现</span><br><span class="line"></span><br><span class="line">14.4 使用RestTemplate 和WebClient 访问              </span><br><span class="line"></span><br><span class="line">RESTful Web 服务</span><br><span class="line"></span><br><span class="line">14.5 使用HttpMessageConverter 将Java 对象              </span><br><span class="line"></span><br><span class="line">与HTTP 请求和响应相互转换</span><br><span class="line"></span><br><span class="line">14.5 使用HttpMessageConverter 将Java 对象与HTTP 请求和响应相互转换</span><br><span class="line"></span><br><span class="line">14.6 @PathVariable 和@MatrixVariable 注解</span><br><span class="line"></span><br><span class="line">14.7 小结</span><br><span class="line"></span><br><span class="line">第 15 章 Spring Web MVC 进阶—              </span><br><span class="line"></span><br><span class="line">化、文件上传和异步请求              </span><br><span class="line"></span><br><span class="line">处理</span><br><span class="line"></span><br><span class="line">15.1 简介</span><br><span class="line"></span><br><span class="line">15.2 使用处理程序拦截器对请求进行预处理              </span><br><span class="line"></span><br><span class="line">和后处理</span><br><span class="line"></span><br><span class="line">实现和配置处理程序拦截器</span><br><span class="line"></span><br><span class="line">15.3 使用资源束进行 化</span><br><span class="line"></span><br><span class="line">15.3.1 MyBank Web 应用程序的需求</span><br><span class="line"></span><br><span class="line">15.3.2 MyBank Web 应用程序的 化              </span><br><span class="line"></span><br><span class="line">和本地化</span><br><span class="line"></span><br><span class="line">15.4 异步地处理请求</span><br><span class="line"></span><br><span class="line">15.5 Spring 中的类型转换和格式化支持</span><br><span class="line"></span><br><span class="line">15.6 Spring Web MVC 中的文件上传支持</span><br><span class="line"></span><br><span class="line">15.6.1 使用CommonsMultipartResolver              </span><br><span class="line"></span><br><span class="line">上传文件</span><br><span class="line"></span><br><span class="line">6 目 录              </span><br><span class="line"></span><br><span class="line">15.6.2 使用StandardServletMultipartResolver              </span><br><span class="line"></span><br><span class="line">上传文件</span><br><span class="line"></span><br><span class="line">15.7 小结</span><br><span class="line"></span><br><span class="line">第 16 章 使用Spring Security 保护应用              </span><br><span class="line"></span><br><span class="line">程序</span><br><span class="line"></span><br><span class="line">16.1 简介</span><br><span class="line"></span><br><span class="line">16.2 MyBank Web 应用程序的安全性              </span><br><span class="line"></span><br><span class="line">需求</span><br><span class="line"></span><br><span class="line">16.3 使用Spring Security 保护MyBank Web              </span><br><span class="line"></span><br><span class="line">应用程序</span><br><span class="line"></span><br><span class="line">16.3.1 Web 请求安全的配置</span><br><span class="line"></span><br><span class="line">16.3.2 身份认证配置</span><br><span class="line"></span><br><span class="line">16.3.3 使用Spring Security 的JSP 标签库              </span><br><span class="line"></span><br><span class="line">保护JSP 内容</span><br><span class="line"></span><br><span class="line">16.3.4 保护方法</span><br><span class="line"></span><br><span class="line">16.4 MyBank Web 应用程序—使用Spring              </span><br><span class="line"></span><br><span class="line">Security 的ACL 模块保护FixedDeposit              </span><br><span class="line"></span><br><span class="line">Details 实例</span><br><span class="line"></span><br><span class="line">16.5 使用基于Java 的配置方法配置              </span><br><span class="line"></span><br><span class="line">Spring Security </span><br><span class="line"></span><br><span class="line">16.5.1 使用WebSecurityConfigurerAdapter              </span><br><span class="line"></span><br><span class="line">类配置Web 请求安全</span><br><span class="line"></span><br><span class="line">16.5.2 使用GlobalMethodSecurity              </span><br><span class="line"></span><br><span class="line">Configuration 类配置方法级安全</span><br><span class="line"></span><br><span class="line">16.5.3 将DelegatingFilterProxy 过滤器              </span><br><span class="line"></span><br><span class="line">注册到ServletContext </span><br><span class="line"></span><br><span class="line">16.5.4 将DispatcherServlet 和Context              </span><br><span class="line"></span><br><span class="line">LoaderListener 注册到              </span><br><span class="line"></span><br><span class="line">ServletContext </span><br><span class="line"></span><br><span class="line">16.6 小结</span><br><span class="line"></span><br><span class="line">第 17 章 Java 的函数式编程</span><br><span class="line"></span><br><span class="line">17.1 简介</span><br><span class="line"></span><br><span class="line">17.2 命令式和函数式编程风格</span><br><span class="line"></span><br><span class="line">17.3 lambda 表达式</span><br><span class="line"></span><br><span class="line">17.4 创建简单函数和高阶函数</span><br><span class="line"></span><br><span class="line">17.4.1 简单函数</span><br><span class="line"></span><br><span class="line">17.4.2 高阶函数</span><br><span class="line"></span><br><span class="line">17.5 流API</span><br><span class="line"></span><br><span class="line">中间 作和终结 作</span><br><span class="line"></span><br><span class="line">延迟求值</span><br><span class="line"></span><br><span class="line">顺序流和并行流</span><br><span class="line"></span><br><span class="line">17.6 方法引用</span><br><span class="line"></span><br><span class="line">17.7 小结</span><br><span class="line"></span><br><span class="line">第 18 章 RxJava 2 的反应式编程</span><br><span class="line"></span><br><span class="line">18.1 简介</span><br><span class="line"></span><br><span class="line">18.2 反应式流</span><br><span class="line"></span><br><span class="line">心跳监测应用程序</span><br><span class="line"></span><br><span class="line">18.3 冷发布者和热发布者</span><br><span class="line"></span><br><span class="line">Stock uote 应用程序</span><br><span class="line"></span><br><span class="line">18.4 背压</span><br><span class="line"></span><br><span class="line">18.5 小结</span><br><span class="line"></span><br><span class="line">第 19 章 用Spring WebFlux、Spring Data 和              </span><br><span class="line"></span><br><span class="line">Spring Security 开发反应式RESTful              </span><br><span class="line"></span><br><span class="line">Web 服务</span><br><span class="line"></span><br><span class="line">19.1 简介</span><br><span class="line"></span><br><span class="line">19.2 Reactor 和RxJava 2 定义的              </span><br><span class="line"></span><br><span class="line">反应式类型</span><br><span class="line"></span><br><span class="line">19.3 Developing the data access layer using              </span><br><span class="line"></span><br><span class="line">Spring Data </span><br><span class="line"></span><br><span class="line">Reactor</span><br><span class="line"></span><br><span class="line">RxJava 2 </span><br><span class="line"></span><br><span class="line">19.4 使用Spring WebFlux 开发Web 层</span><br><span class="line"></span><br><span class="line">编写反应式Web 控制器</span><br><span class="line"></span><br><span class="line">配置Spring WebFlux </span><br><span class="line"></span><br><span class="line">配置ServletContext </span><br><span class="line"></span><br><span class="line">使用WebClient 与反应式RESTful Web              </span><br><span class="line"></span><br><span class="line">服务交互</span><br><span class="line"></span><br><span class="line">使用 发送事件接收数据</span><br><span class="line"></span><br><span class="line">19.5 保护WebFlux 应用程序的安全性</span><br><span class="line"></span><br><span class="line">19.6 小结</span><br><span class="line"></span><br><span class="line">附录A 和安装MongoDB 数据库</span><br><span class="line"></span><br><span class="line">A.1 并安装MongoDB 数据库</span><br><span class="line"></span><br><span class="line">启动MongoDB 数据库 </span><br><span class="line"></span><br><span class="line">A.2 连接MongoDB 数据库</span><br><span class="line"></span><br><span class="line">目 录 7              </span><br><span class="line"></span><br><span class="line">附录B 在Eclipse IDE 中导入和运行示例              </span><br><span class="line"></span><br><span class="line">项目</span><br><span class="line"></span><br><span class="line">B.1 和安装Eclipse IDE 和Tomcat 9 </span><br><span class="line"></span><br><span class="line">B.2 将示例项目导入Eclipse IDE 中</span><br><span class="line"></span><br><span class="line">B.2.1 将示例项目导入Eclipse IDE 中</span><br><span class="line"></span><br><span class="line">B.2.2 在Eclipse IDE 中配置M2_REPO              </span><br><span class="line"></span><br><span class="line">类路径变量</span><br><span class="line"></span><br><span class="line">B.3 在Eclipse IDE 中配置Tomcat 9 </span><br><span class="line"></span><br><span class="line">B.4 在Tomcat 9 上部署Web 项目</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>SQL查询的艺术 PDF</title>
    <url>/posts/901a8eb6/</url>
    <content><![CDATA[<h4 id="《SQL查询的艺术》"><a href="#《SQL查询的艺术》" class="headerlink" title="《SQL查询的艺术》"></a>《SQL查询的艺术》</h4><h6 id="链接-https-pan-baidu-com-s-12qSyjdsLNPB5nRkqg7kH2Q-提取码-khvi"><a href="#链接-https-pan-baidu-com-s-12qSyjdsLNPB5nRkqg7kH2Q-提取码-khvi" class="headerlink" title="链接: https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q 提取码: khvi"></a>链接: <a href="https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q">https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q</a> 提取码: khvi</h6><p>SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。SQL是数据库领域的一种标准语言。任何需要从事数据库相关工作的程序员，都必须学习和掌握SQL。<br><a id="more"></a></p>
<p>　　《SQL查询的艺术》全面地介绍了数据库的基础知识和SQL查询的技巧，通过丰富的实例，帮助读者掌握常见的SQL应用。全书共分19章，按照数据定义、数据查询、数据操纵、数据控制、事务控制和程序化SQL的顺序，详细地讲解SQL编程的基础知识。全书共包括大小实例300多个，突出了实例教学、学用结合的特点。</p>
<p>　　《SQL查询的艺术》适用于学习SQL编程的读者阅读，尤其适用于SQL初学者阅读；本书对数据库架构师、数据库管理员也有一定的参考价值。</p>
<p><img src="/images/42824279d13e2a0f66b3bed33ab8e0551.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章　数据库与SQL基础</span><br><span class="line"></span><br><span class="line">1.1　数据库的基本概念</span><br><span class="line"></span><br><span class="line">1.1.1　数据库的由来</span><br><span class="line"></span><br><span class="line">1.1.2　数据库系统的概念</span><br><span class="line"></span><br><span class="line">1.2　数据库系统的结构、组成及工作流程</span><br><span class="line"></span><br><span class="line">1.2.1　数据库的体系结构</span><br><span class="line"></span><br><span class="line">1.2.2　数据库系统的组成</span><br><span class="line"></span><br><span class="line">1.2.3　数据库的工作流程</span><br><span class="line"></span><br><span class="line">1.3　关系数据库</span><br><span class="line"></span><br><span class="line">1.3.1　关系模型</span><br><span class="line"></span><br><span class="line">1.3.2　Codd十二法则</span><br><span class="line"></span><br><span class="line">1.3.3　范式</span><br><span class="line"></span><br><span class="line">1.4　SQL语言基础</span><br><span class="line"></span><br><span class="line">1.4.1　SQL的历史</span><br><span class="line"></span><br><span class="line">1.4.2　SQL语言的组成</span><br><span class="line"></span><br><span class="line">1.4.3　SQL语句的结构</span><br><span class="line"></span><br><span class="line">1.4.4　SQL的优点</span><br><span class="line"></span><br><span class="line">1.4.5　SQL的执行</span><br><span class="line"></span><br><span class="line">1.5　SQL环境</span><br><span class="line"></span><br><span class="line">1.5.1　环境</span><br><span class="line"></span><br><span class="line">1.5.2　SQL的层次结构</span><br><span class="line"></span><br><span class="line">1.5.3　客户程序和服务程序系统</span><br><span class="line"></span><br><span class="line">1.5.4　SQL环境中对象的命名规则</span><br><span class="line"></span><br><span class="line">第2章　主要的关系数据库与SQL</span><br><span class="line"></span><br><span class="line">2.1　SQL Server</span><br><span class="line"></span><br><span class="line">2.1.1　SQL Server的结构</span><br><span class="line"></span><br><span class="line">2.1.2　数据库访问标准化接口--ODBC</span><br><span class="line"></span><br><span class="line">2.1.3　使用查询分析器执行SQL语句</span><br><span class="line"></span><br><span class="line">2.2　Transact-SQL</span><br><span class="line"></span><br><span class="line">2.2.1　Transact-SQL概述</span><br><span class="line"></span><br><span class="line">2.2.2　Transact-SQL的主要组成</span><br><span class="line"></span><br><span class="line">2.2.3　Transact-SQL的一些重要命令</span><br><span class="line"></span><br><span class="line">第3章　创建、修改和删除表</span><br><span class="line"></span><br><span class="line">3.1　表的基础知识</span><br><span class="line"></span><br><span class="line">3.1.1　表的基本结构</span><br><span class="line"></span><br><span class="line">3.1.2　表的种类</span><br><span class="line"></span><br><span class="line">3.2　SQL数据类型</span><br><span class="line"></span><br><span class="line">3.2.1　字符型数据</span><br><span class="line"></span><br><span class="line">3.2.2　数字型数据</span><br><span class="line"></span><br><span class="line">3.2.3　日期数据类型</span><br><span class="line"></span><br><span class="line">3.2.4　二进制数据类型</span><br><span class="line"></span><br><span class="line">3.2.5　文本和图形数据类型</span><br><span class="line"></span><br><span class="line">3.2.6　自定义数据类型</span><br><span class="line"></span><br><span class="line">3.3　表的创建（CREATE）</span><br><span class="line"></span><br><span class="line">3.3.1　创建基本表</span><br><span class="line"></span><br><span class="line">3.3.2　非空约束</span><br><span class="line"></span><br><span class="line">3.3.3　DEFAULT指定缺省值</span><br><span class="line"></span><br><span class="line">3.4　表的修改</span><br><span class="line"></span><br><span class="line">3.4.1　增加新列</span><br><span class="line"></span><br><span class="line">3.4.2　删除列</span><br><span class="line"></span><br><span class="line">3.4.3　修改列</span><br><span class="line"></span><br><span class="line">3.5　表的删除与重命名</span><br><span class="line"></span><br><span class="line">3.5.1　重命名表</span><br><span class="line"></span><br><span class="line">3.5.2　删除表</span><br><span class="line"></span><br><span class="line">3.6　创建、删除数据库</span><br><span class="line"></span><br><span class="line">3.6.1　数据库的创建</span><br><span class="line"></span><br><span class="line">3.6.2　SQL Server中数据库的创建</span><br><span class="line"></span><br><span class="line">3.6.3　删除数据库</span><br><span class="line"></span><br><span class="line">第4章　索引与视图的创建</span><br><span class="line"></span><br><span class="line">4.1　索引的基础知识</span><br><span class="line"></span><br><span class="line">4.1.1　索引的概念</span><br><span class="line"></span><br><span class="line">4.1.2　索引的结构</span><br><span class="line"></span><br><span class="line">4.2　索引的创建与销毁　61</span><br><span class="line"></span><br><span class="line">4.2.1　基本创建语法</span><br><span class="line"></span><br><span class="line">4.2.2　本章实例用到的实例表</span><br><span class="line"></span><br><span class="line">4.2.3　创建简单的非簇索引</span><br><span class="line"></span><br><span class="line">4.2.4　多字段非簇索引的创建</span><br><span class="line"></span><br><span class="line">4.2.5　使用UNIQUE关键字创建惟一索引</span><br><span class="line"></span><br><span class="line">4.2.6　使用CLUSTERDE关键字创建簇索引</span><br><span class="line"></span><br><span class="line">4.2.7　索引的销毁</span><br><span class="line"></span><br><span class="line">4.2.8　使用索引的几点原则</span><br><span class="line"></span><br><span class="line">4.3　视图的基础知识</span><br><span class="line"></span><br><span class="line">4.3.1　视图简介</span><br><span class="line"></span><br><span class="line">4.3.2　视图的优缺点</span><br><span class="line"></span><br><span class="line">4.4　视图的创建与销毁</span><br><span class="line"></span><br><span class="line">4.4.1　基本创建语法</span><br><span class="line"></span><br><span class="line">4.4.2　创建简单的视图</span><br><span class="line"></span><br><span class="line">4.4.3　利用视图简化表的复杂连接</span><br><span class="line"></span><br><span class="line">4.4.4　利用视图简化复杂查询</span><br><span class="line"></span><br><span class="line">4.4.5　视图的销毁</span><br><span class="line"></span><br><span class="line">4.4.6　使用视图的几点原则</span><br><span class="line"></span><br><span class="line">第5章　简单的查询</span><br><span class="line"></span><br><span class="line">5.1　查询的基本结构</span><br><span class="line"></span><br><span class="line">5.1.1　SELECT语句的结构</span><br><span class="line"></span><br><span class="line">5.1.2　SELECT语句的执行步骤</span><br><span class="line"></span><br><span class="line">5.2　列的查询</span><br><span class="line"></span><br><span class="line">5.2.1　本章用到的实例表</span><br><span class="line"></span><br><span class="line">5.2.2　单列查询</span><br><span class="line"></span><br><span class="line">5.2.3　使用DISTINCT去除重复信息</span><br><span class="line"></span><br><span class="line">5.2.4　多列查询</span><br><span class="line"></span><br><span class="line">5.2.5　查询所有的列</span><br><span class="line"></span><br><span class="line">5.3　排序查询结果</span><br><span class="line"></span><br><span class="line">5.3.1　单列排序</span><br><span class="line"></span><br><span class="line">5.3.2　多列排序</span><br><span class="line"></span><br><span class="line">5.3.3　采用序号进行多列排序</span><br><span class="line"></span><br><span class="line">5.3.4　反向排序</span><br><span class="line"></span><br><span class="line">5.4　使用WHERE子句定义搜索条件查询</span><br><span class="line"></span><br><span class="line">5.4.1　WHERE子句单条件查询</span><br><span class="line"></span><br><span class="line">5.4.2　单值比较运算符</span><br><span class="line"></span><br><span class="line">5.4.3　BETWEEN运算符范围筛选</span><br><span class="line"></span><br><span class="line">5.4.4　NULL值的判断</span><br><span class="line"></span><br><span class="line">第6章　复杂搜索条件查询</span><br><span class="line"></span><br><span class="line">6.1　本章用到的实例表</span><br><span class="line"></span><br><span class="line">6.2　组合查询条件</span><br><span class="line"></span><br><span class="line">6.2.1　AND运算符</span><br><span class="line"></span><br><span class="line">6.2.2　OR运算符</span><br><span class="line"></span><br><span class="line">6.2.3　AND、OR运算符的组合使用</span><br><span class="line"></span><br><span class="line">6.3　IN运算符</span><br><span class="line"></span><br><span class="line">6.3.1　IN运算符的使用方法</span><br><span class="line"></span><br><span class="line">6.3.2　IN运算符与OR运算符</span><br><span class="line"></span><br><span class="line">6.4　NOT运算符</span><br><span class="line"></span><br><span class="line">6.4.1　使用NOT运算符</span><br><span class="line"></span><br><span class="line">6.4.2　NOT运算符与&lt;&gt;运算符</span><br><span class="line"></span><br><span class="line">6.5　使用LIKE进行模糊查询</span><br><span class="line"></span><br><span class="line">6.5.1　LIKE运算符</span><br><span class="line"></span><br><span class="line">6.5.2 &quot;%&quot;通配符</span><br><span class="line"></span><br><span class="line">6.5.3　&quot;_&quot;通配符</span><br><span class="line"></span><br><span class="line">6.5.4　&quot;[]&quot;通配符</span><br><span class="line"></span><br><span class="line">6.5.5　使用ESCAPE定义转义符</span><br><span class="line"></span><br><span class="line">第7章　连接符、数值运算与函数</span><br><span class="line"></span><br><span class="line">7.1　本章实例用到的表</span><br><span class="line"></span><br><span class="line">7.2　连接符</span><br><span class="line"></span><br><span class="line">7.2.1　连接符的应用</span><br><span class="line"></span><br><span class="line">7.2.2　使用别名</span><br><span class="line"></span><br><span class="line">7.3　数值运算</span><br><span class="line"></span><br><span class="line">7.3.1　数学运算符的种类</span><br><span class="line"></span><br><span class="line">7.3.2　数学运算符的运用</span><br><span class="line"></span><br><span class="line">7.3.3　使用CAST表达式转换数据类型</span><br><span class="line"></span><br><span class="line">7.3.4　使用CASE表达式</span><br><span class="line"></span><br><span class="line">7.4　函数</span><br><span class="line"></span><br><span class="line">7.4.1　有关函数的说明</span><br><span class="line"></span><br><span class="line">7.4.2　字符处理函数</span><br><span class="line"></span><br><span class="line">7.4.3　算术运算函数</span><br><span class="line"></span><br><span class="line">7.4.4　日期时间函数</span><br><span class="line"></span><br><span class="line">7.4.5　CONVERT（）函数转换日期、时间</span><br><span class="line"></span><br><span class="line">第8章　聚合分析与分组</span><br><span class="line"></span><br><span class="line">8.1　聚合分析的基本概念</span><br><span class="line"></span><br><span class="line">8.1.1　聚合分析</span><br><span class="line"></span><br><span class="line">8.1.2　聚合函数</span><br><span class="line"></span><br><span class="line">8.2　聚合函数的应用</span><br><span class="line"></span><br><span class="line">8.2.1　求和函数--SUM（）</span><br><span class="line"></span><br><span class="line">8.2.2　计数函数--COUNT（）</span><br><span class="line"></span><br><span class="line">8.2.3　最大&#x2F;最小值函数--MAX（）&#x2F;MIN（）</span><br><span class="line"></span><br><span class="line">8.2.4　均值函数--AVG（）</span><br><span class="line"></span><br><span class="line">8.2.5　聚合分析的重值处理</span><br><span class="line"></span><br><span class="line">8.2.6　聚合函数的组合使用</span><br><span class="line"></span><br><span class="line">8.3　组合查询</span><br><span class="line"></span><br><span class="line">8.3.1　GROUP BY子句创建分组</span><br><span class="line"></span><br><span class="line">8.3.2　GROUP BY子句根据多列组合行</span><br><span class="line"></span><br><span class="line">8.3.3　ROLLUP运算符和CUBE运算符</span><br><span class="line"></span><br><span class="line">8.3.4　GROUP BY子句中的NULL值处理</span><br><span class="line"></span><br><span class="line">8.3.5　HAVING子句</span><br><span class="line"></span><br><span class="line">8.3.6　HAVING子句与WHERE子句</span><br><span class="line"></span><br><span class="line">8.3.7　SELECT语句各查询子句总结</span><br><span class="line"></span><br><span class="line">第9章　多表查询</span><br><span class="line"></span><br><span class="line">9.1　本章用到的实例表</span><br><span class="line"></span><br><span class="line">9.2　表的基本连接</span><br><span class="line"></span><br><span class="line">9.2.1　连接表的目的</span><br><span class="line"></span><br><span class="line">9.2.2　简单的二表连接</span><br><span class="line"></span><br><span class="line">9.2.3　多表连接</span><br><span class="line"></span><br><span class="line">9.2.4　使用表别名</span><br><span class="line"></span><br><span class="line">9.2.5　采用JOIN关键字建立连接</span><br><span class="line"></span><br><span class="line">9.3　表的连接类型</span><br><span class="line"></span><br><span class="line">9.3.1　自连接</span><br><span class="line"></span><br><span class="line">9.3.2　自然连接（NATURAL JOIN）</span><br><span class="line"></span><br><span class="line">9.3.3　内连接（INNER JOIN）</span><br><span class="line"></span><br><span class="line">9.3.4　外连接（OUTER JOIN）</span><br><span class="line"></span><br><span class="line">9.3.5　交叉连接（CROSS JOIN）</span><br><span class="line"></span><br><span class="line">9.4　UNION与UNION JOIN</span><br><span class="line"></span><br><span class="line">9.4.1　关系的集合运算</span><br><span class="line"></span><br><span class="line">9.4.2　UNION运算符</span><br><span class="line"></span><br><span class="line">9.4.3　ORDER BY子句排序UNION运算结果</span><br><span class="line"></span><br><span class="line">9.4.4　对多表进行UNION运算</span><br><span class="line"></span><br><span class="line">9.4.5　UNION JOIN 连接表</span><br><span class="line"></span><br><span class="line">9.5　表连接的其他应用及注意问题</span><br><span class="line"></span><br><span class="line">9.5.1　连接表进行聚合运算</span><br><span class="line"></span><br><span class="line">9.5.2　多表连接的综合运用</span><br><span class="line"></span><br><span class="line">9.5.3　多表连接注意事项</span><br><span class="line"></span><br><span class="line">第10章　子查询</span><br><span class="line"></span><br><span class="line">10.1　创建和使用返回单值的子查询</span><br><span class="line"></span><br><span class="line">10.1.1　在多表查询中使用子查询</span><br><span class="line"></span><br><span class="line">10.1.2　在子查询中使用聚合函数</span><br><span class="line"></span><br><span class="line">10.2　创建和使用返回多行的子查询</span><br><span class="line"></span><br><span class="line">10.2.1　IN子查询</span><br><span class="line"></span><br><span class="line">10.2.2　IN子查询实现集合交和集合差运算</span><br><span class="line"></span><br><span class="line">10.2.3　EXISTS子查询</span><br><span class="line"></span><br><span class="line">10.2.4　EXISTS子查询实现两表交集</span><br><span class="line"></span><br><span class="line">10.2.5　SOME&#x2F;ALL子查询</span><br><span class="line"></span><br><span class="line">10.2.6　UNIQUE子查询</span><br><span class="line"></span><br><span class="line">10.3　相关子查询</span><br><span class="line"></span><br><span class="line">10.3.1　使用IN引入相关子查询</span><br><span class="line"></span><br><span class="line">10.3.2　比较运算符引入相关子查询</span><br><span class="line"></span><br><span class="line">10.3.3　在HAVING子句中使用相关子查询</span><br><span class="line"></span><br><span class="line">10.4　嵌套子查询</span><br><span class="line"></span><br><span class="line">10.5　使用子查询创建视图</span><br><span class="line"></span><br><span class="line">10.6　树查询</span><br><span class="line"></span><br><span class="line">第11章　数据插入操作</span><br><span class="line"></span><br><span class="line">11.1　插入单行记录</span><br><span class="line"></span><br><span class="line">11.1.1　基本语法</span><br><span class="line"></span><br><span class="line">11.1.2　整行插入</span><br><span class="line"></span><br><span class="line">11.1.3　NULL值的插入</span><br><span class="line"></span><br><span class="line">11.1.4　唯一值的插入</span><br><span class="line"></span><br><span class="line">11.1.5　特定字段数据插入</span><br><span class="line"></span><br><span class="line">11.1.6　通过视图插入行</span><br><span class="line"></span><br><span class="line">11.2　插入多行记录</span><br><span class="line"></span><br><span class="line">11.2.1　由VALUES关键字引入多行数据插入</span><br><span class="line"></span><br><span class="line">11.2.2　使用SELECT语句插入值</span><br><span class="line"></span><br><span class="line">11.3　表中数据的复制</span><br><span class="line"></span><br><span class="line">11.3.1　基本语法</span><br><span class="line"></span><br><span class="line">11.3.2　应用实例</span><br><span class="line"></span><br><span class="line">11.4　从外部数据源导入、导出数据</span><br><span class="line"></span><br><span class="line">11.4.1　Access数据库数据的导出</span><br><span class="line"></span><br><span class="line">11.4.2　Access数据库数据的导入</span><br><span class="line"></span><br><span class="line">11.4.3　SQL Server数据库数据导出</span><br><span class="line"></span><br><span class="line">11.4.4　SQL Server数据库数据导入</span><br><span class="line"></span><br><span class="line">第12章　数据的更新和删除</span><br><span class="line"></span><br><span class="line">12.1　更新表中的数据</span><br><span class="line"></span><br><span class="line">12.1.1　UPDATE语句的基本语法</span><br><span class="line"></span><br><span class="line">12.1.2　UPDATE语句更新列值</span><br><span class="line"></span><br><span class="line">12.1.3　利用子查询更新多行的值</span><br><span class="line"></span><br><span class="line">12.1.4　依据外表值更新数据</span><br><span class="line"></span><br><span class="line">12.1.5　分步更新表</span><br><span class="line"></span><br><span class="line">12.2　删除表中的数据</span><br><span class="line"></span><br><span class="line">12.2.1　DELETE语句基本语法</span><br><span class="line"></span><br><span class="line">12.2.2　DELETE语句删除单行数据</span><br><span class="line"></span><br><span class="line">12.2.3　DELETE语句删除多行数据</span><br><span class="line"></span><br><span class="line">12.2.4　DELETE语句删除所有行</span><br><span class="line"></span><br><span class="line">12.2.5　TRUNCATE TABLE语句</span><br><span class="line"></span><br><span class="line">12.3　通过视图更新表</span><br><span class="line"></span><br><span class="line">12.3.1　可更新视图的约束</span><br><span class="line"></span><br><span class="line">12.3.2　通过视图更新表数据</span><br><span class="line"></span><br><span class="line">12.3.3　通过视图删除表数据</span><br><span class="line"></span><br><span class="line">第13章　安全性控制</span><br><span class="line"></span><br><span class="line">13.1　SQL安全模式</span><br><span class="line"></span><br><span class="line">13.1.1　授权ID</span><br><span class="line"></span><br><span class="line">13.1.2　SQL的安全对象和权限</span><br><span class="line"></span><br><span class="line">13.1.3　授权图</span><br><span class="line"></span><br><span class="line">13.2　角色管理</span><br><span class="line"></span><br><span class="line">13.2.1　CREATE语句创建角色</span><br><span class="line"></span><br><span class="line">13.2.2　DROP语句删除角色</span><br><span class="line"></span><br><span class="line">13.2.3　GRANT语句授予角色</span><br><span class="line"></span><br><span class="line">13.2.4　REVOKE语句取消角色</span><br><span class="line"></span><br><span class="line">13.3　权限管理</span><br><span class="line"></span><br><span class="line">13.3.1　GRANT语句授予权限</span><br><span class="line"></span><br><span class="line">13.3.2　REVOKE语句取消权限</span><br><span class="line"></span><br><span class="line">13.3.3　SELECT权限控制</span><br><span class="line"></span><br><span class="line">13.3.4　INSERT权限控制</span><br><span class="line"></span><br><span class="line">13.3.5　UPDATE权限控制</span><br><span class="line"></span><br><span class="line">13.3.6　DELETE权限控制</span><br><span class="line"></span><br><span class="line">13.4　SQL Server安全管理</span><br><span class="line"></span><br><span class="line">13.4.1　SQL Server登录认证</span><br><span class="line"></span><br><span class="line">13.4.2　SQL Server用户ID的管理</span><br><span class="line"></span><br><span class="line">13.4.3　SQL Server权限管理</span><br><span class="line"></span><br><span class="line">13.4.4　SQL Server角色管理</span><br><span class="line"></span><br><span class="line">13.5　Oracle安全管理</span><br><span class="line"></span><br><span class="line">13.5.1　Oracle中用户、资源、概要文件、模式的概念</span><br><span class="line"></span><br><span class="line">13.5.2　Oracle中的用户管理</span><br><span class="line"></span><br><span class="line">13.5.3　Oracle中的资源管理</span><br><span class="line"></span><br><span class="line">13.5.4　Oracle中的权限管理</span><br><span class="line"></span><br><span class="line">13.5.5　Oracle中的角色管理</span><br><span class="line"></span><br><span class="line">第14章　完整性控制</span><br><span class="line"></span><br><span class="line">14.1　完整性约束简介</span><br><span class="line"></span><br><span class="line">14.1.1　数据的完整性</span><br><span class="line"></span><br><span class="line">14.1.2　完整性约束的类型</span><br><span class="line"></span><br><span class="line">14.2　与表有关的约束</span><br><span class="line"></span><br><span class="line">14.2.1　列约束与表约束的创建</span><br><span class="line"></span><br><span class="line">14.2.2　NOT NULL（非空）约束</span><br><span class="line"></span><br><span class="line">14.2.3　UNIQUE（惟一）约束</span><br><span class="line"></span><br><span class="line">14.2.4　PRIMARY KEY（主键）约束</span><br><span class="line"></span><br><span class="line">14.2.5　FOREIGN KEY（外键）约束</span><br><span class="line"></span><br><span class="line">14.2.6　CHECK（校验）约束</span><br><span class="line"></span><br><span class="line">14.3　深入探讨外键与完整性检查</span><br><span class="line"></span><br><span class="line">14.3.1　引用完整性检查</span><br><span class="line"></span><br><span class="line">14.3.2　MATCH子句</span><br><span class="line"></span><br><span class="line">14.3.3　更新、删除操作规则</span><br><span class="line"></span><br><span class="line">14.4　域约束与断言</span><br><span class="line"></span><br><span class="line">14.4.1　域与域约束</span><br><span class="line"></span><br><span class="line">14.4.2　利用断言创建多表约束</span><br><span class="line"></span><br><span class="line">14.5　SQL Server中的完整性控制</span><br><span class="line"></span><br><span class="line">14.5.1　创建规则（Rule）</span><br><span class="line"></span><br><span class="line">14.5.2　规则的绑定与松绑</span><br><span class="line"></span><br><span class="line">14.5.3　创建缺省值（Default）</span><br><span class="line"></span><br><span class="line">14.5.4　缺省值的绑定与松绑</span><br><span class="line"></span><br><span class="line">第15章　存储过程与函数</span><br><span class="line"></span><br><span class="line">15.1　SQL中的存储过程与函数</span><br><span class="line"></span><br><span class="line">15.2　SQL Server 中的流控制语句</span><br><span class="line"></span><br><span class="line">15.2.1　BEGIN…END语句</span><br><span class="line"></span><br><span class="line">15.2.2　IF…ELSE语句</span><br><span class="line"></span><br><span class="line">15.2.3　WHILE、BREAK和CONTINUE语句</span><br><span class="line"></span><br><span class="line">15.2.4　DECLARE语句</span><br><span class="line"></span><br><span class="line">15.2.5　GOTO label语句</span><br><span class="line"></span><br><span class="line">15.2.6　RETURN语句</span><br><span class="line"></span><br><span class="line">15.2.7　WAITFOR语句</span><br><span class="line"></span><br><span class="line">15.2.8　PRINT语句</span><br><span class="line"></span><br><span class="line">15.2.9　注释</span><br><span class="line"></span><br><span class="line">15.3　SQL Server中的存储过程和函数</span><br><span class="line"></span><br><span class="line">15.3.1　系统存储过程</span><br><span class="line"></span><br><span class="line">15.3.2　使用CREATE PROCEDURE创建存储过程</span><br><span class="line"></span><br><span class="line">15.3.3　使用EXECUTE语句调用存储过程</span><br><span class="line"></span><br><span class="line">15.3.4　使用CREATE FUNCTION创建函数</span><br><span class="line"></span><br><span class="line">15.3.5　使用Enterprise Manager（企业管理器）创建存储过程和函数</span><br><span class="line"></span><br><span class="line">15.3.6　修改和删除存储过程和函数</span><br><span class="line"></span><br><span class="line">15.4　Oracle中的流控制语句</span><br><span class="line"></span><br><span class="line">15.4.1　条件语句</span><br><span class="line"></span><br><span class="line">15.4.2　循环语句</span><br><span class="line"></span><br><span class="line">15.4.3　标号和GOTO</span><br><span class="line"></span><br><span class="line">15.5　Oracle数据库中的存储过程</span><br><span class="line"></span><br><span class="line">15.5.1　存储过程的创建与调用</span><br><span class="line"></span><br><span class="line">15.5.2　Oracle中存储过程和函数的管理</span><br><span class="line"></span><br><span class="line">第16章　SQL触发器</span><br><span class="line"></span><br><span class="line">16.1　触发器的基本概念</span><br><span class="line"></span><br><span class="line">16.1.1　触发器简介</span><br><span class="line"></span><br><span class="line">16.1.2　触发器执行环境</span><br><span class="line"></span><br><span class="line">16.2　SQL Server中的触发器</span><br><span class="line"></span><br><span class="line">16.2.1　SQL Server触发器的种类</span><br><span class="line"></span><br><span class="line">16.2.2　使用CREATE TRIGGER命令创建触发器</span><br><span class="line"></span><br><span class="line">16.2.3　INSERT触发器</span><br><span class="line"></span><br><span class="line">16.2.4　DELETE触发器</span><br><span class="line"></span><br><span class="line">16.2.5　UPDATE触发器</span><br><span class="line"></span><br><span class="line">16.2.6　INSTEAD OF触发器</span><br><span class="line"></span><br><span class="line">16.2.7　嵌套触发器</span><br><span class="line"></span><br><span class="line">16.2.8　递归触发器</span><br><span class="line"></span><br><span class="line">16.2.9　SQL Server中触发器的管理</span><br><span class="line"></span><br><span class="line">16.3　Oracle数据库中触发器的操作</span><br><span class="line"></span><br><span class="line">16.3.1　Oracle触发器类型</span><br><span class="line"></span><br><span class="line">16.3.2　触发器的创建</span><br><span class="line"></span><br><span class="line">16.3.3　创建系统触发器</span><br><span class="line"></span><br><span class="line">16.3.4　触发器的触发次序和触发谓词的使用</span><br><span class="line"></span><br><span class="line">16.3.5　Oracle触发器的管理</span><br><span class="line"></span><br><span class="line">第17章　SQL中游标的使用</span><br><span class="line"></span><br><span class="line">17.1　SQL游标的基本概念</span><br><span class="line"></span><br><span class="line">17.1.1　游标的概念</span><br><span class="line"></span><br><span class="line">17.1.2　游标的作用及其应用</span><br><span class="line"></span><br><span class="line">17.2　SQL游标的使用</span><br><span class="line"></span><br><span class="line">17.2.1　使用DECLARE CURSOR语句创建游标</span><br><span class="line"></span><br><span class="line">17.2.2　使用OPEN&#x2F;CLOSE语句打开&#x2F;关闭游标</span><br><span class="line"></span><br><span class="line">17.2.3　使用FETCH语句检索数据</span><br><span class="line"></span><br><span class="line">17.2.4　基于游标的定位DELETE语句</span><br><span class="line"></span><br><span class="line">17.2.5　基于游标的定位UPDATE语句</span><br><span class="line"></span><br><span class="line">17.3　SQL Server中游标的扩展</span><br><span class="line"></span><br><span class="line">17.3.1　Transact_SQL扩展DECLARE CURSOR语法</span><br><span class="line"></span><br><span class="line">17.3.2　@@CURSOR_ROWS全局变量确定游标的行数</span><br><span class="line"></span><br><span class="line">17.3.3　@@FETCH_STATUS全局变量检测FETCH操作的状态</span><br><span class="line"></span><br><span class="line">17.3.4　游标的关闭与释放</span><br><span class="line"></span><br><span class="line">17.3.5　游标变量</span><br><span class="line"></span><br><span class="line">17.3.6　使用系统过程管理游标</span><br><span class="line"></span><br><span class="line">17.4　Oracle中游标的使用</span><br><span class="line"></span><br><span class="line">17.4.1　显式游标与隐式游标</span><br><span class="line"></span><br><span class="line">17.4.2　游标的属性</span><br><span class="line"></span><br><span class="line">17.4.3　%TYPE、%ROWTYPE定义记录变量</span><br><span class="line"></span><br><span class="line">17.4.4　参数化游标</span><br><span class="line"></span><br><span class="line">17.4.5　游标中的循环</span><br><span class="line"></span><br><span class="line">17.4.6　游标变量</span><br><span class="line"></span><br><span class="line">17.5　小结</span><br><span class="line"></span><br><span class="line">第18章　事务控制与并发处理</span><br><span class="line"></span><br><span class="line">18.1　SQL事务控制</span><br><span class="line"></span><br><span class="line">18.1.1　事务控制的引入</span><br><span class="line"></span><br><span class="line">18.1.2　事务的特性</span><br><span class="line"></span><br><span class="line">18.1.3　SQL中与事务有关的语句</span><br><span class="line"></span><br><span class="line">18.2　事务控制的具体实现</span><br><span class="line"></span><br><span class="line">18.2.1　开始事务</span><br><span class="line"></span><br><span class="line">18.2.2　SET CONSTRAINTS语句设置约束的延期执行</span><br><span class="line"></span><br><span class="line">18.2.3　终止事务</span><br><span class="line"></span><br><span class="line">18.3　并发控制</span><br><span class="line"></span><br><span class="line">18.3.1　并发操作的问题</span><br><span class="line"></span><br><span class="line">18.3.2　事务隔离级别</span><br><span class="line"></span><br><span class="line">18.3.3　SET TRANSACTION设置事务属性</span><br><span class="line"></span><br><span class="line">18.4　SQL Server中的并发事务控制</span><br><span class="line"></span><br><span class="line">18.4.1　锁的分类</span><br><span class="line"></span><br><span class="line">18.4.2　SQL Server中表级锁的使用</span><br><span class="line"></span><br><span class="line">18.4.3　设置隔离级别实现并发控制</span><br><span class="line"></span><br><span class="line">18.4.4　死锁及其预防</span><br><span class="line"></span><br><span class="line">18.5　Oracle中的并发事务控制</span><br><span class="line"></span><br><span class="line">18.5.1　通过加锁避免写数据丢失</span><br><span class="line"></span><br><span class="line">18.5.2　设置只读事务（READ ONLY）</span><br><span class="line"></span><br><span class="line">18.5.3　Oracle中的隔离级别</span><br><span class="line"></span><br><span class="line">第19章　嵌入式SQL</span><br><span class="line"></span><br><span class="line">19.1　SQL的调用</span><br><span class="line"></span><br><span class="line">19.1.1　直接调用SQL</span><br><span class="line"></span><br><span class="line">19.1.2　嵌入式SQL</span><br><span class="line"></span><br><span class="line">19.1.3　SQL调用层接口（CLI）</span><br><span class="line"></span><br><span class="line">19.2　嵌入式SQL的使用</span><br><span class="line"></span><br><span class="line">19.2.1　创建嵌入式SQL语句</span><br><span class="line"></span><br><span class="line">19.2.2　SQL通信区</span><br><span class="line"></span><br><span class="line">19.2.3　主变量</span><br><span class="line"></span><br><span class="line">19.2.4　嵌入式SQL中使用游标</span><br><span class="line"></span><br><span class="line">19.3　检索、操作SQL数据</span><br><span class="line"></span><br><span class="line">19.3.1　不需要游标的SQL DML操作</span><br><span class="line"></span><br><span class="line">19.3.2　使用游标的SQL DML操作</span><br><span class="line"></span><br><span class="line">19.3.3　动态SQL技术</span><br><span class="line"></span><br><span class="line">19.4　SQL Server中嵌入式SQL的编译运行</span><br><span class="line"></span><br><span class="line">19.4.1　嵌入式SQL代码</span><br><span class="line"></span><br><span class="line">19.4.2　预编译文件</span><br><span class="line"></span><br><span class="line">19.4.3　设置Visual C++ 6.0连接</span><br><span class="line"></span><br><span class="line">19.4.4　编译运行程序</span><br><span class="line"></span><br><span class="line">19.5　Oracle中嵌入式SQL的编译运行</span><br><span class="line"></span><br><span class="line">19.5.1　嵌入式SQL代码</span><br><span class="line"></span><br><span class="line">19.5.2　预编译文件</span><br><span class="line"></span><br><span class="line">19.5.3　设置Visual C++ 6.0编译环境</span><br><span class="line"></span><br><span class="line">19.5.4　编译运行程序</span><br><span class="line"></span><br><span class="line">附录A　SQL保留字</span><br><span class="line"></span><br><span class="line">附录B　常用的SQL命令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>SQLite权威指南 PDF</title>
    <url>/posts/e71dbe20/</url>
    <content><![CDATA[<h4 id="《SQLite权威指南》"><a href="#《SQLite权威指南》" class="headerlink" title="《SQLite权威指南》"></a>《SQLite权威指南》</h4><h6 id="链接-https-pan-baidu-com-s-13LnE4T-UvITr3nDlgVhcw-提取码-9dqe"><a href="#链接-https-pan-baidu-com-s-13LnE4T-UvITr3nDlgVhcw-提取码-9dqe" class="headerlink" title="链接: https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw 提取码: 9dqe"></a>链接: <a href="https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw">https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw</a> 提取码: 9dqe</h6><p>本书是一本关于SQLite起源、特性、简介、使用、深度解析的书。全书首先从SQLite 初起源、特性、设计理念、实际应用讲解开始，逐步深入、全面地介绍了在各个平台如何使用SQLite。接着，介绍SQLite的一般SQL和高级功能的SQL，采取举例说明，使得本书内容生动有趣。然后，全面介绍了各种语言如何与SQLite进行编程交互，重点介绍SQLite原生语言C语言中的API，使得使用者可以不管扩展SQLite的功能。本书还介绍了目前火热的IOS和Android开发中如何使用SQLite，并给出实际例子。 后，介绍了SQLite内部架构设计，使得读者可以深入理解SQLite，高级开发者可以进一步参与SQLite开发或者开发自己的SQLite。<br><a id="more"></a></p>
<p>企业级计算之外，有一款数据库，它具备大量软硬件需要的关系数据库功能，同时没有传统数据库管理系统的复杂配置、维护，以及高昂的成本。它就是SQLite据库——一款极其紧凑的可嵌入的数据库，一款能处理巨大数据量的数据库。通过编程和开发，SQLite可以具备大量强大的特性。它也支持C、Java、Ped、PHP、Pvthon、Ruby、Td等语言。《SQLite指南（第二版）》包含了SQLite数据库版本的内容，全面介绍SQLite的功能和API，同时，以SQLite为基础，帮助新人开启数据库开发的次旅程。短时间内，您就能开发应用程序，诸如服务器端浏览器插件或者很有流行潜力的iPhone或Android应用！您将会了解到SQLltc的C、Java、Pd、PHP、Python、Ruby以及Tcl展。您将会掌握SQLite內核。您将会学习使用SQLitc开发iOS（iPhone）和Android应用。全世界范围内，从移动电话和GPS设备到机顶盒与Web浏览器，数以干计的产品选择了SQLite数据库。您可能每天都在不知不觉中使用SQLite。</p>
<p>——艾伦，Grant Allen和Mike Owens</p>
<p><img src="/images/bd2f5a532bafafbadc4790864f4b45311.jpg" width="50%" height="50%"></p>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>STL源码剖析 PDF</title>
    <url>/posts/77a2a3b1/</url>
    <content><![CDATA[<h4 id="《STL源码剖析》"><a href="#《STL源码剖析》" class="headerlink" title="《STL源码剖析》"></a>《STL源码剖析》</h4><h6 id="链接-https-pan-baidu-com-s-17P5s69-ENmHK7K9UW0MIrQ-提取码-w9x8"><a href="#链接-https-pan-baidu-com-s-17P5s69-ENmHK7K9UW0MIrQ-提取码-w9x8" class="headerlink" title="链接: https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ 提取码: w9x8"></a>链接: <a href="https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ">https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ</a> 提取码: w9x8</h6><p>书所呈现的源码，使你踏上了基度山岛。源码之前了无秘密，你将看到vector的实现、list的实现、heap的实现、deque的实现、RedBlack tree的实现、hashtable的实现、set/map的实现；你将看到各种算法（排序、查找、排列组合、数据移动与复技术）的实现；你甚至能够看到底层的memorypook和高阶抽象的traits机制的实现。<br><a id="more"></a></p>
<p><img src="/images/b14207ff8ea7398908e51caede3242d41.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">疱丁解牛（侯捷自序）</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">1章 STL概论与版本简介</span><br><span class="line"></span><br><span class="line">2章 空间配置器（allocator）</span><br><span class="line"></span><br><span class="line">3章 迭代器（iterators）概念与traits编程技法</span><br><span class="line"></span><br><span class="line">4章 序列式容器（sequence containers）</span><br><span class="line"></span><br><span class="line">5章 关联式容器（associattive containers）</span><br><span class="line"></span><br><span class="line">6章 算法（algorithms）</span><br><span class="line"></span><br><span class="line">7章 仿函数（functors，另名 函数对象function objects）</span><br><span class="line"></span><br><span class="line">8章 配接器（adapters）</span><br><span class="line"></span><br><span class="line">附录A 参考书籍与推荐读物</span><br><span class="line"></span><br><span class="line">附录B 候捷网站（本书支持站点简介）</span><br><span class="line"></span><br><span class="line">附录C STLPort 的移植经验（by孟岩）</span><br><span class="line"></span><br><span class="line">索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Tensorflow实战Google深度学习框架 PDF</title>
    <url>/posts/99acc29d/</url>
    <content><![CDATA[<h4 id="《Tensorflow实战Google深度学习框架》"><a href="#《Tensorflow实战Google深度学习框架》" class="headerlink" title="《Tensorflow实战Google深度学习框架》"></a>《Tensorflow实战Google深度学习框架》</h4><h6 id="链接-https-pan-baidu-com-s-1wJ0h86DA3kNf-8smoPNPeA-提取码-ybr9"><a href="#链接-https-pan-baidu-com-s-1wJ0h86DA3kNf-8smoPNPeA-提取码-ybr9" class="headerlink" title="链接: https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA 提取码: ybr9"></a>链接: <a href="https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA">https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA</a> 提取码: ybr9</h6><p>√ 前谷歌专家、现Tensorflow创业新贵，新版力邀现谷歌专家加盟，共话新版核心技术与前沿案例。<br><a id="more"></a></p>
<p>√ 本书前版作为业界首著伴随Tensorflow火遍全球，旨在面向生产|商业场景，彻底贯通原理|实践。</p>
<p>√ 深入原理|走访主创|结合真实项目，AI、ML团队争相赞誉推荐，与Tensorflow一道成为事实标准。</p>
<p>√ 代码全面升级为1.4+版，重点关注新版功能，增设专题论述TF高层封装和深度学习自然语言应用。</p>
<p>TensorFlow是谷歌2015年开源的主流深度学习框架，目前已得到广泛应用。《TensorFlow：实战Google深度学习框架（第2版）》为TensorFlow入门参考书，旨在帮助读者以快速、有效的方式上手TensorFlow和深度学习。书中省略了烦琐的数学模型推导，从实际应用问题出发，通过具体的TensorFlow示例介绍如何使用深度学习解决实际问题。书中包含深度学习的入门知识和大量实践经验，是走进这个前沿、热门的人工智能领域的优选参考书。</p>
<p>第2版将书中所有示例代码从TensorFlow 0.9.0升级到了TensorFlow 1.4.0。在升级API的同时，第2版也补充了更多只有TensorFlow 1.4.0才支持的功能。另外，第2版还新增两章分别介绍TensorFlow高层封装和深度学习在自然语言领域应用的内容。</p>
<p>《TensorFlow：实战Google深度学习框架（第2版）》适用于想要使用深度学习或TensorFlow的数据科学家、工程师，希望了解大数据平台工程师，对人工智能、深度学习感兴趣的计算机相关从业人员及在校学生等</p>
<p><img src="/images/2296ff220814751bfe5768050f1096ab1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">第1章 深度学习简介</span><br><span class="line"></span><br><span class="line">1.1 人工智能、机器学习与深度学习</span><br><span class="line"></span><br><span class="line">1.2 深度学习的发展历程</span><br><span class="line"></span><br><span class="line">1.3 深度学习的应用</span><br><span class="line"></span><br><span class="line">1.3.1 计算机视觉</span><br><span class="line"></span><br><span class="line">1.3.2 语音识别</span><br><span class="line"></span><br><span class="line">1.3.3 自然语言处理</span><br><span class="line"></span><br><span class="line">1.3.4 人机博弈</span><br><span class="line"></span><br><span class="line">1.4 深度学习工具介绍和对比</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第2章 TensorFlow环境搭建</span><br><span class="line"></span><br><span class="line">2.1 TensorFlow的主要依赖包</span><br><span class="line"></span><br><span class="line">2.1.1 Protocol Buffer</span><br><span class="line"></span><br><span class="line">2.1.2 Bazel</span><br><span class="line"></span><br><span class="line">2.2 TensorFlow安装</span><br><span class="line"></span><br><span class="line">2.2.1 使用Docker安装</span><br><span class="line"></span><br><span class="line">2.2.2 使用pip安装</span><br><span class="line"></span><br><span class="line">2.2.3 从源代码编译安装</span><br><span class="line"></span><br><span class="line">2.3 TensorFlow测试样例</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第3章 TensorFlow入门</span><br><span class="line"></span><br><span class="line">3.1 TensorFlow计算模型——计算图</span><br><span class="line"></span><br><span class="line">3.1.1 计算图的概念</span><br><span class="line"></span><br><span class="line">3.1.2 计算图的使用</span><br><span class="line"></span><br><span class="line">3.2 TensorFlow数据模型——张量</span><br><span class="line"></span><br><span class="line">3.2.1 张量的概念</span><br><span class="line"></span><br><span class="line">3.2.2 张量的使用</span><br><span class="line"></span><br><span class="line">3.3 TensorFlow运行模型——会话</span><br><span class="line"></span><br><span class="line">3.4 TensorFlow实现神经网络</span><br><span class="line"></span><br><span class="line">3.4.1 TensorFlow游乐场及神经网络简介</span><br><span class="line"></span><br><span class="line">3.4.2 前向传播算法简介</span><br><span class="line"></span><br><span class="line">3.4.3 神经网络参数与TensorFlow变量</span><br><span class="line"></span><br><span class="line">3.4.4 通过TensorFlow训练神经网络模型</span><br><span class="line"></span><br><span class="line">3.4.5 完整神经网络样例程序</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第4章 深层神经网络</span><br><span class="line"></span><br><span class="line">4.1 深度学习与深层神经网络</span><br><span class="line"></span><br><span class="line">4.1.1 线性模型的局限性</span><br><span class="line"></span><br><span class="line">4.1.2 激活函数实现去线性化</span><br><span class="line"></span><br><span class="line">4.1.3 多层网络解决异或运算</span><br><span class="line"></span><br><span class="line">4.2 损失函数定义</span><br><span class="line"></span><br><span class="line">4.2.1 经典损失函数</span><br><span class="line"></span><br><span class="line">4.2.2 自定义损失函数</span><br><span class="line"></span><br><span class="line">4.3 神经网络优化算法</span><br><span class="line"></span><br><span class="line">4.4 神经网络进一步优化</span><br><span class="line"></span><br><span class="line">4.4.1 学习率的设置</span><br><span class="line"></span><br><span class="line">4.4.2 过拟合问题</span><br><span class="line"></span><br><span class="line">4.4.3 滑动平均模型</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第5章 MNIST数字识别问题</span><br><span class="line"></span><br><span class="line">5.1 MNIST数据处理</span><br><span class="line"></span><br><span class="line">5.2 神经网络模型训练及不同模型结果对比</span><br><span class="line"></span><br><span class="line">5.2.1 TensorFlow训练神经网络</span><br><span class="line"></span><br><span class="line">5.2.2 使用验证数据集判断模型效果</span><br><span class="line"></span><br><span class="line">5.2.3 不同模型效果比较</span><br><span class="line"></span><br><span class="line">5.3 变量管理</span><br><span class="line"></span><br><span class="line">5.4 TensorFlow模型持久化</span><br><span class="line"></span><br><span class="line">5.4.1 持久化代码实现</span><br><span class="line"></span><br><span class="line">5.4.2 持久化原理及数据格式</span><br><span class="line"></span><br><span class="line">5.5 TensorFlow最佳实践样例程序</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第6章 图像识别与卷积神经网络</span><br><span class="line"></span><br><span class="line">6.1 图像识别问题简介及经典数据集</span><br><span class="line"></span><br><span class="line">6.2 卷积神经网络简介</span><br><span class="line"></span><br><span class="line">6.3 卷积神经网络常用结构</span><br><span class="line"></span><br><span class="line">6.3.1 卷积层</span><br><span class="line"></span><br><span class="line">6.3.2 池化层</span><br><span class="line"></span><br><span class="line">6.4 经典卷积网络模型</span><br><span class="line"></span><br><span class="line">6.4.1 LeNet-5模型</span><br><span class="line"></span><br><span class="line">6.4.2 Inception-v3模型</span><br><span class="line"></span><br><span class="line">6.5 卷积神经网络迁移学习</span><br><span class="line"></span><br><span class="line">6.5.1 迁移学习介绍</span><br><span class="line"></span><br><span class="line">6.5.2 TensorFlow实现迁移学习</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第7章 图像数据处理</span><br><span class="line"></span><br><span class="line">7.1 TFRecord输入数据格式</span><br><span class="line"></span><br><span class="line">7.1.1 TFRecord格式介绍</span><br><span class="line"></span><br><span class="line">7.1.2 TFRecord样例程序</span><br><span class="line"></span><br><span class="line">7.2 图像数据处理</span><br><span class="line"></span><br><span class="line">7.2.1 TensorFlow图像处理函数</span><br><span class="line"></span><br><span class="line">7.2.2 图像预处理完整样例</span><br><span class="line"></span><br><span class="line">7.3 多线程输入数据处理框架</span><br><span class="line"></span><br><span class="line">7.3.1 队列与多线程</span><br><span class="line"></span><br><span class="line">7.3.2 输入文件队列</span><br><span class="line"></span><br><span class="line">7.3.3 组合训练数据（batching）</span><br><span class="line"></span><br><span class="line">7.3.4 输入数据处理框架</span><br><span class="line"></span><br><span class="line">7.4 数据集（Dataset）</span><br><span class="line"></span><br><span class="line">7.4.1 数据集的基本使用方法</span><br><span class="line"></span><br><span class="line">7.4.2 数据集的高层操作</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第8章 循环神经网络</span><br><span class="line"></span><br><span class="line">8.1 循环神经网络简介</span><br><span class="line"></span><br><span class="line">8.2 长短时记忆网络（LSTM）结构</span><br><span class="line"></span><br><span class="line">8.3 循环神经网络的变种</span><br><span class="line"></span><br><span class="line">8.3.1 双向循环神经网络和深层循环神经网络</span><br><span class="line"></span><br><span class="line">8.3.2 循环神经网络的dropout</span><br><span class="line"></span><br><span class="line">8.4 循环神经网络样例应用</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第9章 自然语言处理</span><br><span class="line"></span><br><span class="line">9.1 语言模型的背景知识</span><br><span class="line"></span><br><span class="line">9.1.1 语言模型简介</span><br><span class="line"></span><br><span class="line">9.1.2 语言模型的评价方法</span><br><span class="line"></span><br><span class="line">9.2 神经语言模型</span><br><span class="line"></span><br><span class="line">9.2.1 PTB数据集的预处理</span><br><span class="line"></span><br><span class="line">9.2.2 PTB数据的batching方法</span><br><span class="line"></span><br><span class="line">9.2.3 基于循环神经网络的神经语言模型</span><br><span class="line"></span><br><span class="line">9.3 神经网络机器翻译</span><br><span class="line"></span><br><span class="line">9.3.1 机器翻译背景与Seq2Seq模型介绍</span><br><span class="line"></span><br><span class="line">9.3.2 机器翻译文本数据的预处理</span><br><span class="line"></span><br><span class="line">9.3.3 Seq2Seq模型的代码实现</span><br><span class="line"></span><br><span class="line">9.3.4 注意力机制</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第10章 TensorFlow高层封装</span><br><span class="line"></span><br><span class="line">10.1 TensorFlow高层封装总览</span><br><span class="line"></span><br><span class="line">10.2 Keras介绍</span><br><span class="line"></span><br><span class="line">10.2.1 Keras基本用法</span><br><span class="line"></span><br><span class="line">10.2.2 Keras高级用法</span><br><span class="line"></span><br><span class="line">10.3 Estimator介绍</span><br><span class="line"></span><br><span class="line">10.3.1 Estimator基本用法</span><br><span class="line"></span><br><span class="line">10.3.2 Estimator自定义模型</span><br><span class="line"></span><br><span class="line">10.3.3 使用数据集（Dataset）作为Estimator输入</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第11章 TensorBoard可视化</span><br><span class="line"></span><br><span class="line">11.1 TensorBoard简介</span><br><span class="line"></span><br><span class="line">11.2 TensorFlow计算图可视化</span><br><span class="line"></span><br><span class="line">11.2.1 命名空间与TensorBoard图上节点</span><br><span class="line"></span><br><span class="line">11.2.2 节点信息</span><br><span class="line"></span><br><span class="line">11.3 监控指标可视化</span><br><span class="line"></span><br><span class="line">11.4 高维向量可视化</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br><span class="line">第12章 TensorFlow计算加速</span><br><span class="line"></span><br><span class="line">12.1 TensorFlow使用GPU</span><br><span class="line"></span><br><span class="line">12.2 深度学习训练并行模式</span><br><span class="line"></span><br><span class="line">12.3 多GPU并行</span><br><span class="line"></span><br><span class="line">12.4 分布式TensorFlow</span><br><span class="line"></span><br><span class="line">12.4.1 分布式TensorFlow原理</span><br><span class="line"></span><br><span class="line">12.4.2 分布式TensorFlow模型训练</span><br><span class="line"></span><br><span class="line">小结</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>程序员代码面试指南-左程云 PDF</title>
    <url>/posts/70cf67a8/</url>
    <content><![CDATA[<h4 id="《程序员代码面试指南-左程云》"><a href="#《程序员代码面试指南-左程云》" class="headerlink" title="《程序员代码面试指南-左程云》"></a>《程序员代码面试指南-左程云》</h4><h6 id="链接-https-pan-baidu-com-s-1AmIzYkH9s1ycuLKwCm20bw-密码-pbdp"><a href="#链接-https-pan-baidu-com-s-1AmIzYkH9s1ycuLKwCm20bw-密码-pbdp" class="headerlink" title="链接: https://pan.baidu.com/s/1AmIzYkH9s1ycuLKwCm20bw 密码: pbdp"></a>链接: <a href="https://pan.baidu.com/s/1AmIzYkH9s1ycuLKwCm20bw">https://pan.baidu.com/s/1AmIzYkH9s1ycuLKwCm20bw</a> 密码: pbdp</h6><p>《程序员代码面试指南（第2版）》是一本程序员代码面试宝典！书中对IT名企代码面试各类题目的至优解进行了总结，并提供了相关代码实现。针对当前程序员面试缺乏题目汇总这一痛点，本书选取将近200道真实出现过的经典代码面试题，帮助广大程序员做充分的面试准备。“刷”完本书后，你就是“题王”！<br><a id="more"></a></p>
<p>《程序员代码面试指南（第2版）》采用“题目+解答”的方式组织内容，并把面试题类型相近或者解法相近的题目尽量放在一起，读者在学习本书时很容易看出面试题解法之间的联系，使知识的学习避免碎片化。本书将所有的面试题从难到易依次分为“将”“校”“尉”“士”四个档次，方便读者有针对性地选择“刷”题。本书收录的所有面试题都给出了至优解讲解和代码实现，并且提供了一些普通解法和至优解法的运行时间对比，让读者真切地感受到至优解的魅力！</p>
<p>《程序员代码面试指南：（第2版）》中的题目全面且经典，更重要的是，书中收录了大量新题目和至优解分析，这些内容源自笔者多年来“死磕自己”的深入思考。</p>
<p>程序员们做好准备在IT名企的面试中脱颖而出、一举成名了吗？《程序员代码面试指南（第2版）》就是你应该拥有的“神兵利器”。当然，对需要提升算法和数据结构等方面能力的程序员而言，《程序员代码面试指南（第2版）》的价值也是显而易见的。</p>
<p><img src="/images/91db84fe4372783ec5d870e8a6cc084e1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">【目录】</span><br><span class="line"></span><br><span class="line">第1章 栈和队列</span><br><span class="line"></span><br><span class="line">设计一个有getMin功能的栈</span><br><span class="line"></span><br><span class="line">由两个栈组成的队列</span><br><span class="line"></span><br><span class="line">如何仅用递归函数和栈操作逆序一个栈</span><br><span class="line"></span><br><span class="line">猫狗队列</span><br><span class="line"></span><br><span class="line">用一个栈实现另一个栈的排序</span><br><span class="line"></span><br><span class="line">用栈来求解汉诺塔问题</span><br><span class="line"></span><br><span class="line">生成窗口最大值数组</span><br><span class="line"></span><br><span class="line">单调栈结构</span><br><span class="line"></span><br><span class="line">求最大子矩阵的大小</span><br><span class="line"></span><br><span class="line">最大值减去最小值小于或等于num的子数组数量</span><br><span class="line"></span><br><span class="line">第2章 链表问题</span><br><span class="line"></span><br><span class="line">可见的山峰对数量</span><br><span class="line"></span><br><span class="line">打印两个有序链表的公共部分</span><br><span class="line"></span><br><span class="line">在单链表和双链表中删除倒数第K个节点</span><br><span class="line"></span><br><span class="line">删除链表的中间节点和a&#x2F;b处的节点</span><br><span class="line"></span><br><span class="line">反转单向和双向链表</span><br><span class="line"></span><br><span class="line">反转部分单向链表</span><br><span class="line"></span><br><span class="line">环形单链表的约瑟夫问题</span><br><span class="line"></span><br><span class="line">判断一个链表是否为回文结构</span><br><span class="line"></span><br><span class="line">将单向链表按某值划分成左边小、中间相等、右边大的形式</span><br><span class="line"></span><br><span class="line">复制含有随机指针节点的链表</span><br><span class="line"></span><br><span class="line">两个单链表生成相加链表</span><br><span class="line"></span><br><span class="line">两个单链表相交的一系列问题</span><br><span class="line"></span><br><span class="line">将单链表的每K个节点之间逆序</span><br><span class="line"></span><br><span class="line">删除无序单链表中值重复出现的节点</span><br><span class="line"></span><br><span class="line">在单链表中删除指定值的节点</span><br><span class="line"></span><br><span class="line">将搜索二叉树转换成双向链表</span><br><span class="line"></span><br><span class="line">单链表的选择排序</span><br><span class="line"></span><br><span class="line">一种怪异的节点删除方式</span><br><span class="line"></span><br><span class="line">向有序的环形单链表中插入新节点</span><br><span class="line"></span><br><span class="line">合并两个有序的单链表</span><br><span class="line"></span><br><span class="line">按照左右半区的方式重新组合单链表</span><br><span class="line"></span><br><span class="line">第3章 二叉树问题</span><br><span class="line"></span><br><span class="line">分别用递归和非递归方式实现二叉树先序、中序和后序遍历</span><br><span class="line"></span><br><span class="line">打印二叉树的边界节点</span><br><span class="line"></span><br><span class="line">如何较为直观地打印二叉树</span><br><span class="line"></span><br><span class="line">二叉树的序列化和反序列化</span><br><span class="line"></span><br><span class="line">遍历二叉树的神级方法</span><br><span class="line"></span><br><span class="line">在二叉树中找到累加和为指定值的最长路径长度</span><br><span class="line"></span><br><span class="line">找到二叉树中的最大搜索二叉子树</span><br><span class="line"></span><br><span class="line">找到二叉树中符合搜索二叉树条件的最大拓扑结构</span><br><span class="line"></span><br><span class="line">二叉树的按层打印与ZigZag打印</span><br><span class="line"></span><br><span class="line">调整搜索二叉树中两个错误的节点</span><br><span class="line"></span><br><span class="line">判断t1树是否包含t2树全部的拓扑结构</span><br><span class="line"></span><br><span class="line">判断t1树中是否有与t2树拓扑结构完全相同的子树</span><br><span class="line"></span><br><span class="line">判断二叉树是否为平衡二叉树</span><br><span class="line"></span><br><span class="line">根据后序数组重建搜索二叉树</span><br><span class="line"></span><br><span class="line">判断一棵二叉树是否为搜索二叉树和完全二叉树</span><br><span class="line"></span><br><span class="line">通过有序数组生成平衡搜索二叉树</span><br><span class="line"></span><br><span class="line">在二叉树中找到一个节点的后继节点</span><br><span class="line"></span><br><span class="line">在二叉树中找到两个节点的最近公共祖先</span><br><span class="line"></span><br><span class="line">Tarjan算法与并查集解决二叉树节点间最近公共祖先的批量查询问题</span><br><span class="line"></span><br><span class="line">二叉树节点间的最大距离问题</span><br><span class="line"></span><br><span class="line">派对的最大快乐值</span><br><span class="line"></span><br><span class="line">通过先序和中序数组生成后序数组</span><br><span class="line"></span><br><span class="line">统计和生成所有不同的二叉树</span><br><span class="line"></span><br><span class="line">统计完全二叉树的节点数</span><br><span class="line"></span><br><span class="line">第4章 递归和动态规划</span><br><span class="line"></span><br><span class="line">斐波那契数列问题的递归和动态规划</span><br><span class="line"></span><br><span class="line">矩阵的最小路径和</span><br><span class="line"></span><br><span class="line">换钱的最少货币数</span><br><span class="line"></span><br><span class="line">机器人达到指定位置方法数</span><br><span class="line"></span><br><span class="line">换钱的方法数</span><br><span class="line"></span><br><span class="line">打气球的最大分数</span><br><span class="line"></span><br><span class="line">最长递增子序列</span><br><span class="line"></span><br><span class="line">信封嵌套问题</span><br><span class="line"></span><br><span class="line">汉诺塔问题</span><br><span class="line"></span><br><span class="line">最长公共子序列问题</span><br><span class="line"></span><br><span class="line">最长公共子串问题</span><br><span class="line"></span><br><span class="line">子数组异或和为0的最多划分</span><br><span class="line"></span><br><span class="line">最小编辑代价</span><br><span class="line"></span><br><span class="line">字符串的交错组成</span><br><span class="line"></span><br><span class="line">龙与地下城游戏问题</span><br><span class="line"></span><br><span class="line">数字字符串转换为字母组合的种数</span><br><span class="line"></span><br><span class="line">表达式得到期望结果的组成种数</span><br><span class="line"></span><br><span class="line">排成一条线的纸牌博弈问题</span><br><span class="line"></span><br><span class="line">跳跃游戏</span><br><span class="line"></span><br><span class="line">数组中的最长连续序列</span><br><span class="line"></span><br><span class="line">N皇后问题</span><br><span class="line"></span><br><span class="line">第5章 字符串问题</span><br><span class="line"></span><br><span class="line">判断两个字符串是否互为变形词</span><br><span class="line"></span><br><span class="line">判断两个字符串是否互为旋转词</span><br><span class="line"></span><br><span class="line">将整数字符串转成整数值</span><br><span class="line"></span><br><span class="line">字符串的统计字符串</span><br><span class="line"></span><br><span class="line">判断字符数组中是否所有的字符都只出现过一次</span><br><span class="line"></span><br><span class="line">在有序但含有空的数组中查找字符串</span><br><span class="line"></span><br><span class="line">字符串的调整与替换</span><br><span class="line"></span><br><span class="line">翻转字符串</span><br><span class="line"></span><br><span class="line">完美洗牌问题</span><br><span class="line"></span><br><span class="line">删除多余字符得到字典序最小的字符串</span><br><span class="line"></span><br><span class="line">数组中两个字符串的最小距离</span><br><span class="line"></span><br><span class="line">字符串的转换路径问题</span><br><span class="line"></span><br><span class="line">添加最少字符使字符串整体都是回文字符串</span><br><span class="line"></span><br><span class="line">括号字符串的有效性和最长有效长度</span><br><span class="line"></span><br><span class="line">公式字符串求值</span><br><span class="line"></span><br><span class="line">0左边必有1的二进制字符串数量</span><br><span class="line"></span><br><span class="line">拼接所有字符串产生字典顺序最小的大写字符串</span><br><span class="line"></span><br><span class="line">找到字符串的最长无重复字符子串</span><br><span class="line"></span><br><span class="line">找到指定的新类型字符</span><br><span class="line"></span><br><span class="line">旋变字符串问题</span><br><span class="line"></span><br><span class="line">最小包含子串的长度</span><br><span class="line"></span><br><span class="line">回文最少分割数</span><br><span class="line"></span><br><span class="line">字符串匹配问题</span><br><span class="line"></span><br><span class="line">字典树（前缀树）的实现</span><br><span class="line"></span><br><span class="line">子数组的最大异或和</span><br><span class="line"></span><br><span class="line">第6章 大数据和空间限制</span><br><span class="line"></span><br><span class="line">认识布隆过滤器</span><br><span class="line"></span><br><span class="line">只用2GB内存在20亿个整数中找到出现次数最多的数</span><br><span class="line"></span><br><span class="line">40亿个非负整数中找到未出现的数</span><br><span class="line"></span><br><span class="line">找到100亿个URL中重复的URL及搜索词汇的Top K问题</span><br><span class="line"></span><br><span class="line">40亿个非负整数中找到出现两次的数和所有数的中位数</span><br><span class="line"></span><br><span class="line">一致性哈希算法的基本原理</span><br><span class="line"></span><br><span class="line">岛问题</span><br><span class="line"></span><br><span class="line">第7章 位运算</span><br><span class="line"></span><br><span class="line">不用额外变量交换两个整数的值</span><br><span class="line"></span><br><span class="line">不用做任何比较判断找出两个数中较大的数</span><br><span class="line"></span><br><span class="line">只用位运算不用算术运算实现整数的加减乘除运算</span><br><span class="line"></span><br><span class="line">整数的二进制数表达中有多少个1</span><br><span class="line"></span><br><span class="line">在其他数都出现偶数次的数组中找到出现奇数次的数</span><br><span class="line"></span><br><span class="line">在其他数都出现k次的数组中找到只出现一次的数</span><br><span class="line"></span><br><span class="line">第8章 数组和矩阵问题</span><br><span class="line"></span><br><span class="line">转圈打印矩阵</span><br><span class="line"></span><br><span class="line">将正方形矩阵顺时针转动90°</span><br><span class="line"></span><br><span class="line">“之”字形打印矩阵</span><br><span class="line"></span><br><span class="line">找到无序数组中最小的k个数</span><br><span class="line"></span><br><span class="line">需要排序的最短子数组长度</span><br><span class="line"></span><br><span class="line">在数组中找到出现次数大于N&#x2F;K的数</span><br><span class="line"></span><br><span class="line">在行列都排好序的矩阵中找指定数</span><br><span class="line"></span><br><span class="line">最长的可整合子数组的长度</span><br><span class="line"></span><br><span class="line">不重复打印排序数组中相加和为给定值的所有二元组和三元组</span><br><span class="line"></span><br><span class="line">未排序正数数组中累加和为给定值的最长子数组长度</span><br><span class="line"></span><br><span class="line">未排序数组中累加和为给定值的最长子数组系列问题</span><br><span class="line"></span><br><span class="line">未排序数组中累加和小于或等于给定值的最长子数组长度</span><br><span class="line"></span><br><span class="line">计算数组的小和</span><br><span class="line"></span><br><span class="line">自然数数组的排序</span><br><span class="line"></span><br><span class="line">奇数下标都是奇数或者偶数下标都是偶数</span><br><span class="line"></span><br><span class="line">子数组的最大累加和问题</span><br><span class="line"></span><br><span class="line">子矩阵的最大累加和问题</span><br><span class="line"></span><br><span class="line">在数组中找到一个局部最小的位置</span><br><span class="line"></span><br><span class="line">数组中子数组的最大累乘积</span><br><span class="line"></span><br><span class="line">打印N个数组整体最大的Top K</span><br><span class="line"></span><br><span class="line">边界都是1的最大正方形大小</span><br><span class="line"></span><br><span class="line">不包含本位置值的累乘数组</span><br><span class="line"></span><br><span class="line">数组的partition调整</span><br><span class="line"></span><br><span class="line">求最短通路值</span><br><span class="line"></span><br><span class="line">数组中未出现的最小正整数</span><br><span class="line"></span><br><span class="line">数组排序之后相邻数的最大差值</span><br><span class="line"></span><br><span class="line">做项目的最大收益问题</span><br><span class="line"></span><br><span class="line">分金条的最小花费</span><br><span class="line"></span><br><span class="line">大楼轮廓问题</span><br><span class="line"></span><br><span class="line">加油站良好出发点问题</span><br><span class="line"></span><br><span class="line">容器盛水问题</span><br><span class="line"></span><br><span class="line">第9章 其他题目</span><br><span class="line"></span><br><span class="line">从5随机到7随机及其扩展</span><br><span class="line"></span><br><span class="line">一行代码求两个数的最大公约数</span><br><span class="line"></span><br><span class="line">有关阶乘的两个问题</span><br><span class="line"></span><br><span class="line">判断一个点是否在矩形内部</span><br><span class="line"></span><br><span class="line">判断一个点是否在三角形内部</span><br><span class="line"></span><br><span class="line">折纸问题</span><br><span class="line"></span><br><span class="line">能否完美地拼成矩形</span><br><span class="line"></span><br><span class="line">蓄水池算法</span><br><span class="line"></span><br><span class="line">设计有setAll功能的哈希表</span><br><span class="line"></span><br><span class="line">最大的leftMax与rightMax之差的绝对值</span><br><span class="line"></span><br><span class="line">设计LRU缓存结构</span><br><span class="line"></span><br><span class="line">LFU缓存结构设计</span><br><span class="line"></span><br><span class="line">设计RandomPool结构</span><br><span class="line"></span><br><span class="line">并查集的实现</span><br><span class="line"></span><br><span class="line">调整[0,x)区间上的数出现的概率</span><br><span class="line"></span><br><span class="line">路径数组变为统计数组</span><br><span class="line"></span><br><span class="line">正数数组的最小不可组成和</span><br><span class="line"></span><br><span class="line">累加出整个范围所有的数最少还需几个数</span><br><span class="line"></span><br><span class="line">一种字符串和数字的对应关系</span><br><span class="line"></span><br><span class="line">1到n中1出现的次数</span><br><span class="line"></span><br><span class="line">从N个数中等概率打印M个数</span><br><span class="line"></span><br><span class="line">判断一个数是否是回文数</span><br><span class="line"></span><br><span class="line">在有序旋转数组中找到最小值</span><br><span class="line"></span><br><span class="line">在有序旋转数组中找到一个数</span><br><span class="line"></span><br><span class="line">数字的英文表达和中文表达</span><br><span class="line"></span><br><span class="line">分糖果问题</span><br><span class="line"></span><br><span class="line">一种消息接收并打印的结构设计</span><br><span class="line"></span><br><span class="line">随时找到数据流的中位数</span><br><span class="line"></span><br><span class="line">在两个长度相等的排序数组中找到上中位数</span><br><span class="line"></span><br><span class="line">在两个排序数组中找到第k小的数</span><br><span class="line"></span><br><span class="line">两个有序数组间相加和的Top k问题</span><br><span class="line"></span><br><span class="line">出现次数的Top k问题</span><br><span class="line"></span><br><span class="line">Manacher算法</span><br><span class="line"></span><br><span class="line">KMP算法</span><br><span class="line"></span><br><span class="line">丢棋子问题</span><br><span class="line"></span><br><span class="line">画匠问题</span><br><span class="line"></span><br><span class="line">邮局选址问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>《机器学习》周志华-西瓜书PDF</title>
    <url>/posts/d92a0946/</url>
    <content><![CDATA[<h4 id="书籍名称"><a href="#书籍名称" class="headerlink" title="书籍名称"></a>书籍名称</h4><p><strong>《机器学习》周志华-西瓜书 PDF</strong></p>
<p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a> 提取码:odp0</p>
<p><img src="/images/c04ff56125cfc9f61fe032af1498c7dd1.jpg" width="50%" height="50%"></p>
<a id="more"></a>
<p>机器学习是计算机科学与人工智能的重要分支领域. 本书作为该领域的入门教材，在内容上尽可能涵盖机器学习基础知识的各方面. 全书共16 章，大致分为3 个部分：第1 部分（第1～3 章）介绍机器学习的基础知识；第2 部分（第4～10 章）讨论一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11～16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习等. 每章都附有习题并介绍了相关阅读材料，以便有兴趣的读者进一步钻研探索。</p>
<p>本书可作为高等院校计算机、自动化及相关专业的本科生或研究生教材，也可供对机器学习感兴趣的研究人员和工程技术人员阅读参考。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 1</span><br><span class="line"></span><br><span class="line">1.1 引言 1</span><br><span class="line"></span><br><span class="line">1.2 基本术 2</span><br><span class="line"></span><br><span class="line">1.3 假设空间 4</span><br><span class="line"></span><br><span class="line">1.4 归纳偏好 6</span><br><span class="line"></span><br><span class="line">1.5 发展历程 10</span><br><span class="line"></span><br><span class="line">1.6 应用现状 13</span><br><span class="line"></span><br><span class="line">1.7 阅读材料 16</span><br><span class="line"></span><br><span class="line">习题 19</span><br><span class="line"></span><br><span class="line">参考文献 20</span><br><span class="line"></span><br><span class="line">休息一会儿 22</span><br><span class="line"></span><br><span class="line">第2章 模型评估与选择 23</span><br><span class="line"></span><br><span class="line">2.1 经验误差与过拟合 23</span><br><span class="line"></span><br><span class="line">2.2 评估方法 24</span><br><span class="line"></span><br><span class="line">2.2.1 留出法 25</span><br><span class="line"></span><br><span class="line">2.2.2 交叉验证法 26</span><br><span class="line"></span><br><span class="line">2.2.3 自助法 27</span><br><span class="line"></span><br><span class="line">2.2.4 调参与最终模型 28</span><br><span class="line"></span><br><span class="line">2.3 性能度量 28</span><br><span class="line"></span><br><span class="line">2.3.1 错误率与精度 29</span><br><span class="line"></span><br><span class="line">2.3.2 查准率、查全率与F1 30</span><br><span class="line"></span><br><span class="line">2.3.3 ROC与AUC 33</span><br><span class="line"></span><br><span class="line">2.3.4 代价敏感错误率与代价曲线 35</span><br><span class="line"></span><br><span class="line">2.4 比较检验 37</span><br><span class="line"></span><br><span class="line">2.4.1 假设检验 37</span><br><span class="line"></span><br><span class="line">2.4.2 交叉验证t检验 40</span><br><span class="line"></span><br><span class="line">2.4.3 McNemar检验 41</span><br><span class="line"></span><br><span class="line">2.4.4 Friedman检验与后续检验 42</span><br><span class="line"></span><br><span class="line">2.5 偏差与方差 44</span><br><span class="line"></span><br><span class="line">2.6 阅读材料 46</span><br><span class="line"></span><br><span class="line">习题 48</span><br><span class="line"></span><br><span class="line">参考文献 49</span><br><span class="line"></span><br><span class="line">休息一会儿 51</span><br><span class="line"></span><br><span class="line">第3章 线性模型 53</span><br><span class="line"></span><br><span class="line">3.1 基本形式 53</span><br><span class="line"></span><br><span class="line">3.2 线性回归 53</span><br><span class="line"></span><br><span class="line">3.3 对数几率回归 57</span><br><span class="line"></span><br><span class="line">3.4 线性判别分析 60</span><br><span class="line"></span><br><span class="line">3.5 多分类学习 63</span><br><span class="line"></span><br><span class="line">3.6 类别不平衡问题 66</span><br><span class="line"></span><br><span class="line">3.7 阅读材料 67</span><br><span class="line"></span><br><span class="line">习题 69</span><br><span class="line"></span><br><span class="line">参考文献 70</span><br><span class="line"></span><br><span class="line">休息一会儿 72</span><br><span class="line"></span><br><span class="line">第4章 决策树 73</span><br><span class="line"></span><br><span class="line">4.1 基本流程 73</span><br><span class="line"></span><br><span class="line">4.2 划分选择 75</span><br><span class="line"></span><br><span class="line">4.2.1 信息增益 75</span><br><span class="line"></span><br><span class="line">4.2.2 增益率 77</span><br><span class="line"></span><br><span class="line">4.2.3 基尼指数 79</span><br><span class="line"></span><br><span class="line">4.3 剪枝处理 79</span><br><span class="line"></span><br><span class="line">4.3.1 预剪枝 80</span><br><span class="line"></span><br><span class="line">4.3.2 后剪枝 82</span><br><span class="line"></span><br><span class="line">4.4 连续与缺失值 83</span><br><span class="line"></span><br><span class="line">4.4.1 连续值处理 83</span><br><span class="line"></span><br><span class="line">4.4.2 缺失值处理 85</span><br><span class="line"></span><br><span class="line">4.5 多变量决策树 88</span><br><span class="line"></span><br><span class="line">4.6 阅读材料 92</span><br><span class="line"></span><br><span class="line">习题 93</span><br><span class="line"></span><br><span class="line">参考文献 94</span><br><span class="line"></span><br><span class="line">休息一会儿 95</span><br><span class="line"></span><br><span class="line">第5章 神经网络 97</span><br><span class="line"></span><br><span class="line">5.1 神经元模型 97</span><br><span class="line"></span><br><span class="line">5.2 感知机与多层网络 98</span><br><span class="line"></span><br><span class="line">5.3 误差逆传播算法 101</span><br><span class="line"></span><br><span class="line">5.4 全局最小与局部极小 106</span><br><span class="line"></span><br><span class="line">5.5 其他常见神经网络 108</span><br><span class="line"></span><br><span class="line">5.5.1 RBF网络 108</span><br><span class="line"></span><br><span class="line">5.5.2 ART网络 108</span><br><span class="line"></span><br><span class="line">5.5.3 SOM网络 109</span><br><span class="line"></span><br><span class="line">5.5.4 级联相关网络 110</span><br><span class="line"></span><br><span class="line">5.5.5 Elman网络 111</span><br><span class="line"></span><br><span class="line">5.5.6 Boltzmann机 111</span><br><span class="line"></span><br><span class="line">5.6 深度学习 113</span><br><span class="line"></span><br><span class="line">5.7 阅读材料 115</span><br><span class="line"></span><br><span class="line">习题 116</span><br><span class="line"></span><br><span class="line">参考文献 117</span><br><span class="line"></span><br><span class="line">休息一会儿 120</span><br><span class="line"></span><br><span class="line">第6章 支持向量机 121</span><br><span class="line"></span><br><span class="line">6.1 间隔与支持向量 121</span><br><span class="line"></span><br><span class="line">6.2 对偶问题 123</span><br><span class="line"></span><br><span class="line">6.3 核函数 126</span><br><span class="line"></span><br><span class="line">6.4 软间隔与正则化 129</span><br><span class="line"></span><br><span class="line">6.5 支持向量回归 133</span><br><span class="line"></span><br><span class="line">6.6 核方法 137</span><br><span class="line"></span><br><span class="line">6.7 阅读材料 139</span><br><span class="line"></span><br><span class="line">习题 141</span><br><span class="line"></span><br><span class="line">参考文献 142</span><br><span class="line"></span><br><span class="line">休息一会儿 145</span><br><span class="line"></span><br><span class="line">第7章 贝叶斯分类器 147</span><br><span class="line"></span><br><span class="line">7.1 贝叶斯决策论 147</span><br><span class="line"></span><br><span class="line">7.2 极大似然估计 149</span><br><span class="line"></span><br><span class="line">7.3 朴素贝叶斯分类器 150</span><br><span class="line"></span><br><span class="line">7.4 半朴素贝叶斯分类器 154</span><br><span class="line"></span><br><span class="line">7.5 贝叶斯网 156</span><br><span class="line"></span><br><span class="line">7.5.1 结构 157</span><br><span class="line"></span><br><span class="line">7.5.2 学习 159</span><br><span class="line"></span><br><span class="line">7.5.3 推断 161</span><br><span class="line"></span><br><span class="line">7.6 EM算法 162</span><br><span class="line"></span><br><span class="line">7.7 阅读材料 164</span><br><span class="line"></span><br><span class="line">习题 166</span><br><span class="line"></span><br><span class="line">参考文献 167</span><br><span class="line"></span><br><span class="line">休息一会儿 169</span><br><span class="line"></span><br><span class="line">第8章 集成学习 171</span><br><span class="line"></span><br><span class="line">8.1 个体与集成 171</span><br><span class="line"></span><br><span class="line">8.2 Boosting 173</span><br><span class="line"></span><br><span class="line">8.3 Bagging与随机森林 178</span><br><span class="line"></span><br><span class="line">8.3.1 Bagging 178</span><br><span class="line"></span><br><span class="line">8.3.2 随机森林 179</span><br><span class="line"></span><br><span class="line">8.4 结合策略 181</span><br><span class="line"></span><br><span class="line">8.4.1 平均法 181</span><br><span class="line"></span><br><span class="line">8.4.2 投票法 182</span><br><span class="line"></span><br><span class="line">8.4.3 学习法 183</span><br><span class="line"></span><br><span class="line">8.5 多样性 185</span><br><span class="line"></span><br><span class="line">8.5.1 误差--分歧分解 185</span><br><span class="line"></span><br><span class="line">8.5.2 多样性度量 186</span><br><span class="line"></span><br><span class="line">8.5.3 多样性增强 188</span><br><span class="line"></span><br><span class="line">8.6 阅读材料 190</span><br><span class="line"></span><br><span class="line">习题 192</span><br><span class="line"></span><br><span class="line">参考文献 193</span><br><span class="line"></span><br><span class="line">休息一会儿 196</span><br><span class="line"></span><br><span class="line">第9章 聚类 197</span><br><span class="line"></span><br><span class="line">9.1 聚类任务 197</span><br><span class="line"></span><br><span class="line">9.2 性能度量 197</span><br><span class="line"></span><br><span class="line">9.3 距离计算 199</span><br><span class="line"></span><br><span class="line">9.4 原型聚类 202</span><br><span class="line"></span><br><span class="line">9.4.1 k均值算法 202</span><br><span class="line"></span><br><span class="line">9.4.2 学习向量量化 204</span><br><span class="line"></span><br><span class="line">9.4.3 高斯混合聚类 206</span><br><span class="line"></span><br><span class="line">9.5 密度聚类 211</span><br><span class="line"></span><br><span class="line">9.6 层次聚类 214</span><br><span class="line"></span><br><span class="line">9.7 阅读材料 217</span><br><span class="line"></span><br><span class="line">习题 220</span><br><span class="line"></span><br><span class="line">参考文献 221</span><br><span class="line"></span><br><span class="line">休息一会儿 224</span><br><span class="line"></span><br><span class="line">第10章 降维与度量学习 225</span><br><span class="line"></span><br><span class="line">10.1 k近邻学习 225</span><br><span class="line"></span><br><span class="line">10.2 低维嵌入 226</span><br><span class="line"></span><br><span class="line">10.3 主成分分析 229</span><br><span class="line"></span><br><span class="line">10.4 核化线性降维 232</span><br><span class="line"></span><br><span class="line">10.5 流形学习 234</span><br><span class="line"></span><br><span class="line">10.5.1 等度量映射 234</span><br><span class="line"></span><br><span class="line">10.5.2 局部线性嵌入 235</span><br><span class="line"></span><br><span class="line">10.6 度量学习 237</span><br><span class="line"></span><br><span class="line">10.7 阅读材料 240</span><br><span class="line"></span><br><span class="line">习题 242</span><br><span class="line"></span><br><span class="line">参考文献 243</span><br><span class="line"></span><br><span class="line">休息一会儿 246</span><br><span class="line"></span><br><span class="line">第11章 特征选择与稀疏学习 247</span><br><span class="line"></span><br><span class="line">11.1 子集搜索与评价 247</span><br><span class="line"></span><br><span class="line">11.2 过滤式选择 249</span><br><span class="line"></span><br><span class="line">11.3 包裹式选择 250</span><br><span class="line"></span><br><span class="line">11.4 嵌入式选择与L$_1$正则化 252</span><br><span class="line"></span><br><span class="line">11.5 稀疏表示与字典学习 254</span><br><span class="line"></span><br><span class="line">11.6 压缩感知 257</span><br><span class="line"></span><br><span class="line">11.7 阅读材料 260</span><br><span class="line"></span><br><span class="line">习题 262</span><br><span class="line"></span><br><span class="line">参考文献 263</span><br><span class="line"></span><br><span class="line">休息一会儿 266</span><br><span class="line"></span><br><span class="line">第12章 计算学习理论 267</span><br><span class="line"></span><br><span class="line">12.1 基础知识 267</span><br><span class="line"></span><br><span class="line">12.2 PAC学习 268</span><br><span class="line"></span><br><span class="line">12.3 有限假设空间 270</span><br><span class="line"></span><br><span class="line">12.3.1 可分情形 270</span><br><span class="line"></span><br><span class="line">12.3.2 不可分情形 272</span><br><span class="line"></span><br><span class="line">12.4 VC维 273</span><br><span class="line"></span><br><span class="line">12.5 Rademacher复杂度 279</span><br><span class="line"></span><br><span class="line">12.6 稳定性 284</span><br><span class="line"></span><br><span class="line">12.7 阅读材料 287</span><br><span class="line"></span><br><span class="line">习题 289</span><br><span class="line"></span><br><span class="line">参考文献 290</span><br><span class="line"></span><br><span class="line">休息一会儿 292</span><br><span class="line"></span><br><span class="line">第13章 半监督学习 293</span><br><span class="line"></span><br><span class="line">13.1 未标记样本 293</span><br><span class="line"></span><br><span class="line">13.2 生成式方法 295</span><br><span class="line"></span><br><span class="line">13.3 半监督SVM 298</span><br><span class="line"></span><br><span class="line">13.4 图半监督学习 300</span><br><span class="line"></span><br><span class="line">13.5 基于分歧的方法 304</span><br><span class="line"></span><br><span class="line">13.6 半监督聚类 307</span><br><span class="line"></span><br><span class="line">13.7 阅读材料 311</span><br><span class="line"></span><br><span class="line">习题 313</span><br><span class="line"></span><br><span class="line">参考文献 314</span><br><span class="line"></span><br><span class="line">休息一会儿 317</span><br><span class="line"></span><br><span class="line">第14章 概率图模型 319</span><br><span class="line"></span><br><span class="line">14.1 隐马尔可夫模型 319</span><br><span class="line"></span><br><span class="line">14.2 马尔可夫随机场 322</span><br><span class="line"></span><br><span class="line">14.3 条件随机场 325</span><br><span class="line"></span><br><span class="line">14.4 学习与推断 328</span><br><span class="line"></span><br><span class="line">14.4.1 变量消去 328</span><br><span class="line"></span><br><span class="line">14.4.2 信念传播 330</span><br><span class="line"></span><br><span class="line">14.5 近似推断 331</span><br><span class="line"></span><br><span class="line">14.5.1 MCMC采样 331</span><br><span class="line"></span><br><span class="line">14.5.2 变分推断 334</span><br><span class="line"></span><br><span class="line">14.6 话题模型 337</span><br><span class="line"></span><br><span class="line">14.7 阅读材料 339</span><br><span class="line"></span><br><span class="line">习题 341</span><br><span class="line"></span><br><span class="line">参考文献 342</span><br><span class="line"></span><br><span class="line">休息一会儿 345</span><br><span class="line"></span><br><span class="line">第15章 规则学习 347</span><br><span class="line"></span><br><span class="line">15.1 基本概念 347</span><br><span class="line"></span><br><span class="line">15.2 序贯覆盖 349</span><br><span class="line"></span><br><span class="line">15.3 剪枝优化 352</span><br><span class="line"></span><br><span class="line">15.4 一阶规则学习 354</span><br><span class="line"></span><br><span class="line">15.5 归纳逻辑程序设计 357</span><br><span class="line"></span><br><span class="line">15.5.1 最小一般泛化 358</span><br><span class="line"></span><br><span class="line">15.5.2 逆归结 359</span><br><span class="line"></span><br><span class="line">15.6 阅读材料 363</span><br><span class="line"></span><br><span class="line">习题 365</span><br><span class="line"></span><br><span class="line">参考文献 366</span><br><span class="line"></span><br><span class="line">休息一会儿 369</span><br><span class="line"></span><br><span class="line">第16章 强化学习 371</span><br><span class="line"></span><br><span class="line">16.1 任务与奖赏 371</span><br><span class="line"></span><br><span class="line">16.2 $K$-摇臂赌博机 373</span><br><span class="line"></span><br><span class="line">16.2.1 探索与利用 373</span><br><span class="line"></span><br><span class="line">16.2.2 $\epsilon $-贪心 374</span><br><span class="line"></span><br><span class="line">16.2.3 Softmax 375</span><br><span class="line"></span><br><span class="line">16.3 有模型学习 377</span><br><span class="line"></span><br><span class="line">16.3.1 策略评估 377</span><br><span class="line"></span><br><span class="line">16.3.2 策略改进 379</span><br><span class="line"></span><br><span class="line">16.3.3 策略迭代与值迭代 381</span><br><span class="line"></span><br><span class="line">16.4 免模型学习 382</span><br><span class="line"></span><br><span class="line">16.4.1 蒙特卡罗强化学习 383</span><br><span class="line"></span><br><span class="line">16.4.2 时序差分学习 386</span><br><span class="line"></span><br><span class="line">16.5 值函数近似 388</span><br><span class="line"></span><br><span class="line">16.6 模仿学习 390</span><br><span class="line"></span><br><span class="line">16.6.1 直接模仿学习 391</span><br><span class="line"></span><br><span class="line">16.6.2 逆强化学习 391</span><br><span class="line"></span><br><span class="line">16.7 阅读材料 393</span><br><span class="line"></span><br><span class="line">习题 394</span><br><span class="line"></span><br><span class="line">参考文献 395</span><br><span class="line"></span><br><span class="line">休息一会儿 397</span><br><span class="line"></span><br><span class="line">附录 399</span><br><span class="line"></span><br><span class="line">A 矩阵 399</span><br><span class="line"></span><br><span class="line">B 优化 403</span><br><span class="line"></span><br><span class="line">C 概率分布 409</span><br><span class="line"></span><br><span class="line">后记 417</span><br><span class="line"></span><br><span class="line">索引 419</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
</search>
