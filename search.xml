<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【速领福利】互联网技术类书籍集合下载</title>
    <url>/posts/cab6e6f6/</url>
    <content><![CDATA[<p>需要打包下载的，留言区留下邮箱，邮箱发送过去<br>【电子书籍】坚持书籍分享 … 完善中 …<br>【要善用Command/Ctrl+F查找资料哦】<br>资料馆分类：<br>零、互联网面试书籍集合<br>一、计算机技术语言类<br>C / C++<br>Java<br>Python<br>其他<br>二、数据结构和算法<br>数据结构<br>基本算法<br>周边算法思想<br>三、Python技术<br>Python 语言<br>Python 数据分析<br>Python 技巧<br>四、大数据技术<br>大数据技术基础<br>大数据平台开源工具<br>大数据集群<br>Linux<br>数据库<br>五、机器学习和人工智能AI<br>数学相关<br>机器学习<br>推荐算法<br>深度学习<br>其他<br>六、其他书籍<br>按需寻找哦！ 链接如果失效，随时随地联系作者 (^o^)/~<br><strong>需要打包下载的，留言区留下邮箱，邮箱发送过去</strong></p>
<h2 id="零、互联网面试书籍集合"><a href="#零、互联网面试书籍集合" class="headerlink" title="零、互联网面试书籍集合"></a>零、互联网面试书籍集合</h2><p>《labuladong的算法小抄官方完整版<br>《剑指offer名企面试官精讲典型编程题》<br>《阿里Java面试问题大全》<br>《程序员面试宝典》</p>
<h2 id="一、计算机技术语言类"><a href="#一、计算机技术语言类" class="headerlink" title="一、计算机技术语言类"></a>一、计算机技术语言类</h2><h4 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h4><p>《C和指针》 C语言经典书籍<br>《啊哈c语言》<br>《c++primerplus6》 C++经典书籍<br>《深入探索C++对象模型》<br>《C++编程规范-101条规则准则与最佳实践》<br>《C++编程思想两卷合订本》<br>《C++沉思录中文第2版》<br>《C++大学教程》<br>《深入探索C++对象模型》<br>《C++设计新思维-泛型编程与设计之应用》<br>《C++primer5th》<br>《C++ Templates》<br>《C语言编程精粹》<br>《C语言参考手册第五版》<br>《C语言解析教程》<br>《C语言深度解剖》<br>《C专家编程》<br>《EffectiveSTL中文版》<br>《MoreEffectiveC++中文版》<br>《STL源码剖析》</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>《Java核心技术 卷1 基础知识 原书第9版》<br>《阿里巴巴Java开发手册》<br>《码出高效》Java开发手册<br>《轻量级JavaEE企业应用实战》<br>《深入分析JavaWeb技术内幕》<br>《深入理解Java虚拟机第二版》<br>《深入剖析Tomcat》<br>《Java8实战》<br>《JAVA并发编程实践》<br>《EffectiveJava中文第二版》<br>《HeadFirstJava第二版涵盖java0》<br>《HeadFirstServletandJSP》(高清中文版)<br>《Java从小白到大牛精简版》<br>《Java核心技术卷1第8版》<br>《Java核心技术卷2第8版》<br>《Java性能优化权威指南》<br>《Spring 实战 中文版第4版》</p>
<h2 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h2><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>《大话数据结构》<br>《Java数据结构和算法》 第二版<br>《算法导论》<br>《啊哈算法》<br>《编程珠玑第二版》<br>《算法图解》</p>
<h2 id="三、Python技术"><a href="#三、Python技术" class="headerlink" title="三、Python技术"></a>三、Python技术</h2><h4 id="Python-语言"><a href="#Python-语言" class="headerlink" title="Python 语言"></a>Python 语言</h4><p>《Python进阶》<br>《Python基础教程（第二版）》<br>《Python核心编程第二版中文》<br>《Python开发实战》<br>《Python开发技术详解》<br>《Python灰帽子黑客与逆向工程师的Python编程之道》<br>《Python高级编程第2版》<br>《Python编程入门经典》<br>《Python编程初学者指南》<br>《Python网络编程基础》<br>《Python学习手册》<br>《Python学习手册》 第4版<br>《用Python写网络爬虫》</p>
<h4 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h4><p>《利用Python进行数据分析》<br>《NumPy学习指南（第2版）》<br>《常用的数据分析方法》<br>《Python数据处理》<br>《Python金融大数据分析》<br>《Python数据分析与挖掘实战》<br>《Python数据科学手册》<br>《Python数据可视化编程实战》<br>《PYTHON自然语言处理中文版》</p>
<h2 id="四、大数据技术"><a href="#四、大数据技术" class="headerlink" title="四、大数据技术"></a>四、大数据技术</h2><h4 id="大数据技术基础"><a href="#大数据技术基础" class="headerlink" title="大数据技术基础"></a>大数据技术基础</h4><p>《Hadoop全权威指南第三版（原版）》<br>《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理<br>《Hadoop技术内幕》深入解析YARN架构设计与实现原理<br>《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理<br>《Spark快速大数据分析》</p>
<h4 id="大数据平台开源工具"><a href="#大数据平台开源工具" class="headerlink" title="大数据平台开源工具"></a>大数据平台开源工具</h4><h4 id="大数据集群"><a href="#大数据集群" class="headerlink" title="大数据集群"></a>大数据集群</h4><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><p>《鸟哥的LINUX私房菜_基础学习篇(第三版)》<br>《鸟哥的LINUX私房菜_基础学习篇(第三版)》<br>《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)<br>《Linux宝典》<br>《linux常用命令大全》<br>《LINUX防火墙原书第3版》<br>《Linux高级程序设计中文第三版》<br>《Linux环境编程从应用到内核》<br>《Linux命令详解词典施威铭研究室》</p>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>《深入浅出MySQL++数据库开发优化与管理维护》<br>《高性能mysql第三版》<br>《MySQL必知必会》</p>
<h2 id="五、机器学习和人工智能AI"><a href="#五、机器学习和人工智能AI" class="headerlink" title="五、机器学习和人工智能AI"></a>五、机器学习和人工智能AI</h2><h4 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h4><p>《高等数学（同济）第六版/第七版课后习题答案》完整答案<br>《浙江大学概率论与数理统计(第四版)》<br>《数学之美》完整版</p>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><p>《Machine Learning Yearning》完整中文版<br>《百面机器学习》<br>《统计学习方法》<br>《机器学习》周志华-西瓜书<br>《Artificial Intelligence_ A Modern》<br>《贝叶斯思维统计建模的PYTHON学习法》<br>《机器学习实战》<br>《机器学习与数据挖掘方法和应用》<br>《机器学习》中文版<br>《人工智能》复杂问题求解的结构和策略<br>《数据挖掘-实用机器学习技术》中文第二版<br>《数据挖掘-数据-模型-算法》<br>《数据挖掘概念与技术(中文版)》<br>《数据挖掘实用案例分析》<br>《Web数据挖掘》</p>
<h4 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h4><p>《推荐算法在业界的应用实践合集》<br>《推荐系统实践》</p>
<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>2020最新版《神经网络与深度学习》中文版<br>《神经网络与机器学习》<br>《TensorFlow实践与智能系统》<br>《Tensorflow实战Google深度学习框架》</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h2 id="六、其他书籍"><a href="#六、其他书籍" class="headerlink" title="六、其他书籍"></a>六、其他书籍</h2><p>《计算广告：互联网商业变现的市场与技术-刘鹏》<br>Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】<br>《Go语言实战》<br>《第一行代码-Android》<br>《数据库原理（第5版）》<br>《VIM 思维导图》<br>《编程之美》完整版<br>《代码大全2中文版》<br>《代码整洁之道》<br>《高性能mysql第三版》<br>《黑客与画家》<br>《汇编语言》(第3版)王爽著<br>《计算机程序设计艺术(第一卷)》<br>《计算机程序设计艺术(第二卷)》<br>《计算机程序设计艺术(第三卷)》<br>《精通正则表达式》<br>《浪潮之巅》(完整版)<br>《图解设计模式》<br>《学习Go语言(Golang)》<br>《研磨设计模式》<br>《HeadFirst设计模式》<br>《Maven实战》<br>《MongoDB权威指南》<br>《Pro Git中文版》<br>《SQL查询的艺术》<br>《SQLite权威指南》<br><strong>需要打包下载的，留言区留下邮箱，邮箱发送过去</strong></p>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本页书籍均来自网络，如有侵权，请联系我立即删除<br>我的邮箱：yaojianguolq@com</p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>详解动态规划, 此一篇足矣！</title>
    <url>/posts/5faf7bc2/</url>
    <content><![CDATA[<p><img src="/images/b046fbe0f5ceead771b5ceeeaf5f7eed1.jpg" width="50%" height="50%"></p>
<p><em>六个案例由浅入深把动态规划说明白！！！</em><br><a id="more"></a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先，先大致列下这篇文章会讲到什么</span><br><span class="line">    1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</span><br><span class="line">    2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</span><br><span class="line">一、动态规划带给我们的优势</span><br><span class="line">传统递归 vs. DP</span><br><span class="line">    1. 先 递归解决</span><br><span class="line">    2. 后 动态规划解决</span><br><span class="line">    3. 动态规划 + 优化</span><br><span class="line">二、动态规划四大解题步骤处理问题</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：定义状态转移方程</span><br><span class="line">    步骤三：初始化过程转移的初始值</span><br><span class="line">    步骤四：可优化点(可选)</span><br><span class="line">案例一：打家劫舍I 「来自leetcode198」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例二：不同路径「来自leetcode62」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例三：不同路径II 「来自leetcode63」</span><br><span class="line">    步骤一：定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化数值设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例四：打家劫舍II 「来自leetcode213」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br><span class="line">    步骤四：优化</span><br><span class="line">案例五：打家劫舍III 「来自leetcode337」</span><br><span class="line">    步骤一： 定义dp数组的含义</span><br><span class="line">    步骤二：找出关系元素间的动态方程</span><br><span class="line">    步骤三：初始化设定</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态规划 - 超详细系列</p>
<p>该文章较长，比较详细的阐述了动态规划思想，请耐心跟着思路走下去</p>
</blockquote>
<h2 id="动态规划-超详细系列"><a href="#动态规划-超详细系列" class="headerlink" title="动态规划 - 超详细系列"></a>动态规划 - 超详细系列</h2><p><strong>动态规划</strong>，一直以来听着就是一种很高深莫测的算法思想。尤其是上学时候算法的第一堂课，老师巴拉巴拉列了一大堆的算法核心思想，<strong>贪心、回溯、动态规划</strong>… …，开始感觉要在算法世界里游刃有余的进行解决各种各样牛B问题了，没想到的还是稀里糊涂学过了之后还就真的是学过了（大学的课程还真是一个样子）。再后来才明白，大学的课程一般来说就是入门级讲解，用来开拓眼界的，真正想要有一番自己的见解，必须要在背后下一番辛苦，形成自己的<strong>思考逻辑</strong>。</p>
<p>再后来返回头来看，<strong>动态规划</strong>理解起来还是比较困难，什么<strong>重叠子问题、动态转移方程，优化点</strong>等等等等，稀里糊涂，最后痛定思痛，好好看着其他人的分享理解了一部分，疯狂刷题几十道。算是基本可以佛挡杀佛了.</p>
<p>在我的这些学习积累过程中，总结出来希望可以给到大家一点小小的帮助，相信在读完这篇文章的时候，你会感觉到<strong>动态规划</strong>给你带来的奇妙之处。也一定对<strong>动态规划</strong>形成自己的<strong>思考方式</strong>.     很🐂的DP！！！</p>
<h2 id="首先，先大致列下这篇文章会讲到什么"><a href="#首先，先大致列下这篇文章会讲到什么" class="headerlink" title="首先，先大致列下这篇文章会讲到什么"></a>首先，先大致列下这篇文章会讲到什么</h2><h4 id="1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的"><a href="#1-相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的" class="headerlink" title="1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?"></a>1.相较于暴力解法，动态规划带给我们的是什么？为什么会有重叠子问题以及怎么去避免的?</h4><h4 id="2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次"><a href="#2-用不同难度的动态规划问题举例说明，-最后会使用《打家劫舍》系列三个题再重温一次" class="headerlink" title="2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次."></a>2.用不同难度的动态规划问题举例说明， 最后会使用《打家劫舍》系列三个题再重温一次.</h4><p>看完本篇文章后，相信大家会对DP问题会有一个初步的思考，一定会入门。后面大家可以继续练习相关问题，熟能生巧，思考的多了就会形成自己的思维逻辑.</p>
<p>好了，话不多说，开搞…</p>
<h2 id="一、动态规划带给我们的优势"><a href="#一、动态规划带给我们的优势" class="headerlink" title="一、动态规划带给我们的优势"></a>一、动态规划带给我们的优势</h2><p><strong>很有趣，一定要看完，必定有收获，加油！💪💪💪</strong></p>
<p>平时在我们算法设计的过程中，一般讲求的是算法的执行效率和空间效率的利用情况</p>
<p>也就是我们熟知的<strong>时间复杂度</strong>（执行时耗费时间的长度）和<strong>空间复杂度</strong>（执行时占用存储单元的长度）</p>
<p>那下面用<strong>时间复杂度和空间复杂度</strong>来评估下<strong>传统算法设计</strong>和用<strong>动态规划思想</strong>解决下的效率情况</p>
<h4 id="传统递归-vs-DP"><a href="#传统递归-vs-DP" class="headerlink" title="传统递归 vs. DP"></a>传统递归 vs. DP</h4><p>先用一个被大佬们举例举到烂的🌰，这个栗子很烂，但是真的<strong>很香</strong>：必须着重<strong>强调</strong>.</p>
<p><strong>《斐波那契（Fibonacci）数列的第n项》</strong></p>
<p><strong>举荐理由：</strong>在我自己看来Fibonacci是动态规划设计中的入门级案例，就好比说编程中的“hello world”，大数据中的“word count”.</p>
<p>Fibonacci几乎完美的诠释了<strong>动态规划带来的思想和技巧</strong>然而没有任何其他的要考虑的细枝末节，这种很清晰的方法看起来很适合整个的动态规划的思维方式，很适合入门来进行的思考方式.</p>
<p>接下来咱们先来看题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line"></span><br><span class="line">F(0) &#x3D; 0, F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure>
<p>比较一下传统递归解法和动态规划思想下的解决对比</p>
<h4 id="1-先-递归解决"><a href="#1-先-递归解决" class="headerlink" title="1. 先 递归解决"></a>1. 先 递归解决</h4><p>传统对于这种题目的思考方式会利用递归求解，做起来比较简单，就是不断的去递归调用，看下面代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_recur</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;F(&quot;</span>,self.i,<span class="string">&quot;) = &quot;</span>, N   <span class="comment"># 此处仅仅来看递归输出的N</span></span><br><span class="line">        self.i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> N &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">return</span> self.fib_recur(N-<span class="number">1</span>) + self.fib_recur(N-<span class="number">2</span>)  <span class="comment"># 递归输出</span></span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F( <span class="number">0</span> ) =  <span class="number">4</span></span><br><span class="line">F( <span class="number">1</span> ) =  <span class="number">3</span></span><br><span class="line">F( <span class="number">2</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">3</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">4</span> ) =  <span class="number">0</span></span><br><span class="line">F( <span class="number">5</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">6</span> ) =  <span class="number">2</span></span><br><span class="line">F( <span class="number">7</span> ) =  <span class="number">1</span></span><br><span class="line">F( <span class="number">8</span> ) =  <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>重复计算</strong></p>
<p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p>
<p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p>
<p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p>
<blockquote>
<p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p>
<p>注意：递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p>
</blockquote>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106361.jpg" width="50%" height="50%"></p>
<p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗. </p>
<p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p>
<p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效. </p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106362.jpg" width="50%" height="50%"></p>
<blockquote>
<p>时间复杂度：$O(2^N)$   —-&gt; 指数级</p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<h4 id="2-后-动态规划解决"><a href="#2-后-动态规划解决" class="headerlink" title="2. 后 动态规划解决"></a>2. 后 动态规划解决</h4><p><strong>大概解释一下字面意思：</strong></p>
<p><strong>动态规划：</strong>我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用<strong>过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p>
<p><strong>规划：</strong>在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的<strong>一维表格</strong>还是复杂一点的<strong>二维表格</strong>，都是以<strong>开辟空间换时间</strong>的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p>
<p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p>
<p>因此，动态规划可以避免重复计算，达到了时间上的最优，从$O(2^N)$指数级变为$O(N)$常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p>
<p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p>
<p>依据题中的规则：</p>
<p>F(0) = 0, F(1) = 1</p>
<p>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</p>
<p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1<br>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   —&gt;  保存 F(2)<br>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   —&gt;  保存 F(3)<br>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   —&gt;  保存 F(4)</p>
<p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106363.jpg" width="50%" height="50%"></p>
<p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p>
<p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p>
<p>​    a. <strong>定义一个一维数组</strong>   —-&gt;  一般用dp来命名</p>
<p>​    b. <strong>动态方程的设定</strong>   —-&gt;  题中的F(N) = F(N - 1) + F(N - 2)</p>
<p>​    c. <strong>初始化数值</strong>   —-&gt;  F(0) = 0和F(1) = 1</p>
<p>上述的 a、b 和 c 点就是动态规划思想的几个核心要素</p>
<p>下面来看下要实现的代码（代码中，用dp来代替上面的F()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     </span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)] <span class="comment"># 1定义dp[i]保存第i个计算得到的数值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>       <span class="comment"># 2初始化</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>            <span class="comment"># 2初始化</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):    <span class="comment"># 3动态方程实现，由于0和1都实现了赋值，现在需要从第2个位置开始赋值</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">print</span> dp         <span class="comment"># 记录计算过程中的次数，与上述递归形成对比</span></span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>以上，最重要的就是1 2 3 点，而执行过程参照<strong>输出</strong>对比递归算法，计算少了很多，同样的计算只计算了一次。</p>
<blockquote>
<p>时间复杂度：$O(N)$ </p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<p>介绍了上面的内容了，此处来条分割线吧，针对上述的 <strong>递归 vs. DP</strong> </p>
<hr>
<p>既然动态规划的方案也介绍了，下面咱们再仔细看看，是否有优化的空间，毕竟对于一个算法方案的设计，都有找到其优化点，无论是时间还是空间的效率都想要达到一个理想的值。</p>
<h4 id="3-动态规划-优化"><a href="#3-动态规划-优化" class="headerlink" title="3. 动态规划 + 优化"></a>3. 动态规划 + 优化</h4><p>咱们看下这张图解，发现每个计算节点都<strong>只与前两个项有关系</strong>。换句话说，咱们只要保存两个值就好了，计算新的节点值的时候，把新的值赋值给前两个值的第一个就好了</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106364.jpg" width="50%" height="50%"></p>
<p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p>
<p>a. 初始化值 : F(0) = 0, F(1) = 1</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106365.jpg" width="50%" height="50%"><br>b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   —&gt;  保存 F(2)</p>
<p>​    顺带将F(1)赋值给dp1， f(2)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106366.jpg" width="50%" height="50%"></p>
<p>c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   —&gt;  保存 F(3)</p>
<p>​    顺带将F(2)赋值给dp1， F(3)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106367.jpg" width="50%" height="50%"></p>
<p>d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   —&gt;  保存 F(4)</p>
<p>​    顺带将F(3)赋值给dp1， F(4)赋值给dp2</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda106368.jpg" width="50%" height="50%"></p>
<p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p>
<p>咱们把代码也贴一下吧，供参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib_dp1</span>(<span class="params">self, N</span>):</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1, dp2 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, N+<span class="number">1</span>):</span><br><span class="line">            dp1 = dp1 + dp2</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<p>看起来是不是更加简洁了。</p>
<p>洋洋洒洒不知不觉写了这么多了。</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<p>大家感觉这个例子怎么样，三点说明：<strong>1.定义dp数组 2.动态方程 3.初始化数值</strong></p>
<p>这也说明了为什么用<strong>斐波那契数列</strong>来引入<strong>动态规划</strong>的，因为斐波那契数列本身就明确的告诉你动态方程是什么，初始化的值是什么，所以好好的体会这种思想，尤其是从传统递归 -&gt; 动态规划的思想解决，再到优化的方面，很值得深思。</p>
<p>那接下来，咱们就找几个有代表性的栗子来尝尝鲜<br><img src="/images/20521cf21f76b9359a5c9dbbeda106369.jpg" width="50%" height="50%"></p>
<blockquote>
<p>到这里有没有一种对动态规划的感觉了</p>
<p>文章较长，可以先关注或者收藏，也可以关注「计算广告生态」，回复“DP”获取本文pdf文件哦</p>
</blockquote>
<h2 id="二、动态规划四大解题步骤处理问题"><a href="#二、动态规划四大解题步骤处理问题" class="headerlink" title="二、动态规划四大解题步骤处理问题"></a>二、动态规划四大解题步骤处理问题</h2><p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p>
<p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p>
<blockquote>
<p>步骤一：定义dp数组的含义</p>
<p>步骤二：定义状态转移方程</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>步骤四：可优化点(可选)</p>
</blockquote>
<h4 id="步骤一：定义dp数组的含义"><a href="#步骤一：定义dp数组的含义" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h4><p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p>
<p><strong>所以，dp无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p>
<h4 id="步骤二：定义状态转移方程"><a href="#步骤二：定义状态转移方程" class="headerlink" title="步骤二：定义状态转移方程"></a>步骤二：定义状态转移方程</h4><p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p>
<p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p>
<h4 id="步骤三：初始化过程转移的初始值"><a href="#步骤三：初始化过程转移的初始值" class="headerlink" title="步骤三：初始化过程转移的初始值"></a>步骤三：初始化过程转移的初始值</h4><p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p>
<p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了</p>
<p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p>
<h4 id="步骤四：可优化点-可选"><a href="#步骤四：可优化点-可选" class="headerlink" title="步骤四：可优化点(可选)"></a>步骤四：可优化点(可选)</h4><p>可优化的这里，最重要的会是dp数组这块，也会有不同问题不同的优化点</p>
<p>在例子中，我们会进行不同的优化. </p>
<p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了. </p>
<h3 id="案例一：打家劫舍I-「来自leetcode198」"><a href="#案例一：打家劫舍I-「来自leetcode198」" class="headerlink" title="案例一：打家劫舍I 「来自leetcode198」"></a>案例一：打家劫舍I 「来自leetcode198」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure>
<p>把经典案例系列拆分开讨论下吧，咱们首先将「打家劫舍I」来看看</p>
<p>该题可以用动态规划的思想来解决的原因是，在小偷不断偷取的过程中，始终想要偷得的物品价值最大，最优，每一步骤都与之前的偷取情况有关系，而且每一步都要考虑是否能偷，是否会带来最大利益，这就使得我们可以用动态规划的思想来解决问题。  然后严格按照四步骤进行解题. </p>
<h5 id="步骤一：-定义dp数组的含义"><a href="#步骤一：-定义dp数组的含义" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    之前提到的，dp数组存储的值一般代表截止目前的最优值，在该题目中，我们定义：</p>
<p>​    <strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    无论房屋有几间，最后我们取到dp数组的最后一个值就求得小偷偷得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程"><a href="#步骤二：找出关系元素间的动态方程" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态规划解决的问题，一般来说就是解决最优子问题，“自顶向下” 的去不断的计算每一步骤的最优值。</p>
<p>​    也就是想要得到dp[i]的值，我们必须要知道dp[i-1]，dp[i-2]，dp[i-3] … 的每一步的最优值，在这个状态转移的过程中，我们必须要想清楚怎么去定义关系式。然而在每一步的计算中，都与前几项有关系，这个固定的关系就是我们要寻找的重叠子问题，也同样是接下来要详细定义的动态方程</p>
<p>​    该题目中，当小偷到达第 i 个屋子的时候，他的选择有两种：一种是偷，另外一种是不偷， 然后选择价值较大者</p>
<p>​    a. 偷的情况计算：必然是dp[3] = nums[2] + dp[1]，如果是偷取该屋子的话，相邻屋子是不能偷取的，因此，通项式子是：dp[i] =  nums[i-1] + dp[i-2]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063610.jpg" width="50%" height="50%"></p>
<p>​    b. 不偷的情况计算：必然是dp[3] = dp[2]，如果是不偷取该屋子的话，相邻屋子就是其最优值，因此，通项式子是：dp[i] =  dp[i-1]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063611.jpg" width="50%" height="50%"></p>
<p>​    最后，要想偷得最高金额，那么，必须选取在偷与不偷之间的最大值作为我们是否选取的关键点。即：</p>
<p>​    <strong>动态方程:</strong> dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</p>
<h5 id="步骤三：初始化数值设定"><a href="#步骤三：初始化数值设定" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        1 当size=0时，没有房子，dp[0]=0；<br>​        2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</p>
<p>那么，按照这个思路来整理一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">      <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">      <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</span></span><br><span class="line">      <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">      <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">      <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line">      size = <span class="built_in">len</span>(nums)</span><br><span class="line">      <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">      dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">      dp[<span class="number">1</span>] = nums[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[size]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
</blockquote>
<p>那下面想想看有没有可优化的地方，尽量的释放一部分计算机资源</p>
<h5 id="步骤四：优化"><a href="#步骤四：优化" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的.</p>
<p>​    所以，dp只需要定义两个变量就好，将空间复杂度降为O(1)    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob_o</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 依照上面的思路，其实我们用到的数据永远都是dp的dp[i-1]和dp[i-2]两个变量</span></span><br><span class="line">        <span class="comment"># 因此，我们可以使用两个变量来存放前两个状态值</span></span><br><span class="line">        <span class="comment"># 空间使用由O(N) -&gt; O(1)</span></span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dp1 = <span class="number">0</span></span><br><span class="line">        dp2 = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">            dp1, dp2 = dp2, dp1</span><br><span class="line">        <span class="keyword">return</span> dp2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>说完《打家劫舍I 》，中间穿插另外一道题目，利用二维dp来解决的一个问题。</p>
<p>最后再说说《打家劫舍II 》和《打家劫舍III》，把这一系列的<strong>打家劫舍</strong>问题搞明白了，相信你对动态规划有一个较为深刻的入门体验</p>
<blockquote>
<p>如果有读者说这太简单了，我这篇文章内容面对的是小白级别的，如果读者是中等往上的水平，可直接跳到后面的案例三开始参考。</p>
<p>另外，如果有任何的意见可随时对我的文章进行评论，欢迎&amp;感谢大家一起讨论</p>
</blockquote>
<h3 id="案例二：不同路径「来自leetcode62」"><a href="#案例二：不同路径「来自leetcode62」" class="headerlink" title="案例二：不同路径「来自leetcode62」"></a>案例二：不同路径「来自leetcode62」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063612.jpg" width="50%" height="50%"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure>
<p><em>提示：</em></p>
<p>1 &lt;= m, n &lt;= 100<br>题目数据保证答案小于等于 2 * 10 ^ 9</p>
<p>下面依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-1"><a href="#步骤一：定义dp数组的含义-1" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>​    当前这道题是从左上角到右下角的，题目中规定只能向右或者向下走，所以我们必须要定义一个二维数组来保存计算过程中的值。所以，这块定义：</p>
<p>​    <strong>dp[i][j]: 代表到达位置 (i, j) 的所有路径的总数</strong></p>
<p>​    即：机器人从左上角到右下角所有路径的总和，dp中每个位置的值代表行走到达 (i, j) 每个位置的总共的路径数</p>
<h5 id="步骤二：找出关系元素间的动态方程-1"><a href="#步骤二：找出关系元素间的动态方程-1" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    由于题目中规定只能向右或者向下走，所以在机器人行进的时候，只能是向右或向下.</p>
<p>​    那么，分别讨论下两种情况，想要到达位置(i, j)，可以从位置(i-1, j)或者(i, j-1)出发到达。因此，到达位置(i, j) 的总的路径数一定是 <strong>到达位置(i-1, j)路径数</strong> + <strong>到达位置(i, j-1)路径数</strong>。那么，现在可以定义动态方程：</p>
<p>​    <strong>动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong></p>
<h5 id="步骤三：初始化数值设定-1"><a href="#步骤三：初始化数值设定-1" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    很明显，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法。</p>
<p>​    因此，初始化值的设定，一定是 dp[0..m][1] 或者 dp[1][0..n] 都等于1</p>
<p>​    因此初始值如下：</p>
<p>​    <strong>dp[0] [0….n-1] = 1;</strong>  // 机器人一直向右走，第 0 列统统为 1</p>
<p>​    <strong>dp[0…m-1] [0] = 1;</strong>  // 机器人一直向下走，第 0 列统统为 1</p>
<p>​    现在，按照这个思路来整理一下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths1</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化表格，由于初始化0行 0列都为1。那么，先全部置为1</span></span><br><span class="line">        dp = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>上述代码中由于dp[0..m][1] 或者 dp[1][0..n] 都等于1，所以在定义二维数组dp时候，统统赋初始值为 1</p>
<p>然后从位置(1, 1)开始计算每个位置的总路径数</p>
<blockquote>
<p>时间复杂度：O(M*N)</p>
<p>空间复杂度：O(M*N)</p>
</blockquote>
<p>既然到这里了，下面再想想看有没有可优化的地方</p>
<h5 id="步骤四：优化-1"><a href="#步骤四：优化-1" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    可以依照前面的解决的思路，应该也可以从空间上进行一定的优化</p>
<p>​    参照前面的案例，之前定义的是一维数组dp，优化点是每一步骤都只与前面的两个计算好的数值有关系，然后优化点就是将dp[N] -&gt; dp1和dp2，空间复杂度由 O(N) -&gt; O(1)，如果是很大规模的数据计算的话，空间效率提升了不少.</p>
<p>​    现在这个例子中的动态方程是<strong>dp[i][j] = dp[i-1][j] + dp[i][j-1]</strong>，很明显，每一步骤中的状态值只与左边相邻的值和上面的值相关。举例（为了方便，用 3*4 来举例）：</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063613.jpg" width="50%" height="50%"></p>
<p>​    这个完整的图片描述中，机器人从左上角的位置(1, 1)开始移动，逐渐每一步都根据动态方程进行前进，明显的可以看出机器人每移动一格，所得到的路径总和只与它的上方和左方数值有关系。也就是我们会发现，机器人移动到第2行的时候，第0行数据完全是没有用的状态。</p>
<p>​    因此，这个优化点就出来了，在算法设计的时候，dp仅仅定义2行N列的数组就ok了，省去了m-2行的空间开销。这个代码如果大家想明白了请自行设计出来，自己写出来一定会有更加深刻的理解，再强调：多思考，形成潜移默化的思维方式.</p>
<p>​    看完这个步骤之后，是不是很明显的优化点，为什么上面没有给出大家代码呢？是因为我看到貌似可以继续优化的点（粘住空间优化项了哈哈哈），那就继续在空间开销上做文章。</p>
<p>​    <strong>引导：</strong>根据上述咱们的优化方案，说道 “机器人移动到第2行的时候，第0行数据完全是没有用的状态”，其实当前聪明的读者你想想，再看看，下面的图中（从上图截取过来）。 其实，不仅仅是第 0 行完全没用了，而且在第2 行做移动的时候，移动到位置(i, j)的时候，计算好位置(i, j)，那么接下来，位置(i-1, j)的数据也就没用了。换句话说，边走，第 1 行开始的某些数据也就没用了，还在占着空间</p>
<p>​    <strong>这块大家一定多想想，多理解，多画图</strong></p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063614.jpg" width="50%" height="50%"></p>
<p>下面按照这种思路，看下图的步骤，也画好了用一维数组进行解决问题，也画出来每一步骤与上图的类比过程：</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063615.jpg" width="50%" height="50%"></p>
<p>在这里，有犯困的同学可以自己动手画一画，理解一下，个人感觉是一个很好的思维扩展</p>
<p>接下来，就按照这样的思路进行代码实现，会发现码起来很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths2</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            m, n = n, m</span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">                dp[j] = dp[j] + dp[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(min(m ,n))</p>
</blockquote>
<p>是不是从思维方面简单干净了许多</p>
<p>搞清楚上面的栗子之后呢，我们将上面的例题进行一个简单的难度增加，说白了，就是在路上打几个阻碍点</p>
<p>来看:</p>
<h3 id="案例三：不同路径II-「来自leetcode63」"><a href="#案例三：不同路径II-「来自leetcode63」" class="headerlink" title="案例三：不同路径II 「来自leetcode63」"></a>案例三：不同路径II 「来自leetcode63」</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063616.jpg" width="50%" height="50%"></p>
<blockquote>
<p>说明：m 和 n 的值均不超过 100。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"></span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>咱们先看一下题中的两个关键点：</strong><br>关键点1：只能向右或者向下<br>关键点2：有障碍物为1， 无障碍物为0</p>
<p>根据 关键点1 和 关键点2 依然按照四个步骤来进行讨论：</p>
<h5 id="步骤一：定义dp数组的含义-2"><a href="#步骤一：定义dp数组的含义-2" class="headerlink" title="步骤一：定义dp数组的含义"></a>步骤一：定义dp数组的含义</h5><p>  这个题目中定义的dp数组是和上一个例题中定义的dp数组的含义是相同的，但由于该题中已经定义有数组obstacleGrid，可以直接利用，无需额外开辟空间<br>  那么，就利用obstacleGrid作为动态规划中存储计算过程中的最优值</p>
<h5 id="步骤二：找出关系元素间的动态方程-2"><a href="#步骤二：找出关系元素间的动态方程-2" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>  参照上一题目，规定动态方程: obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]<br>  由于机器人在移动过程中有障碍物，那么，对上面动态方程加一些限制条件<br>  a.若当前 obstacleGrid[i][j] 为0。那么，直接计算动态方程下的计算过程<br>  b.若当前 obstacleGrid[i][j] 不为0。那么，直接置该位置的值为0</p>
<p>  所以，在进行动态方程遍历的时候，先进行 obstacleGrid[i][j]的判断，再进行动态方程的计算执行</p>
<h5 id="步骤三：初始化数值设定-2"><a href="#步骤三：初始化数值设定-2" class="headerlink" title="步骤三：初始化数值设定"></a>步骤三：初始化数值设定</h5><p>​    相比于上一题目，相似的是，在机器人走第 0 行，第 0 列的时候，无论怎么走，都只有 1 种走法<br>​    但由于有障碍物，那走到障碍物的时候，后面都是走不下去的（下图用第一行来举例）。</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063617.jpg" width="50%" height="50%"></p>
<p>​    所以，初始化第 0 行，第 0 列的时候，障碍物 1 后面的都是不可达的。所以，初始化行和列的逻辑表达：</p>
<p>​    <strong>该位置是否可达=前一个位置的状态and该位置能否可达 得到能否到达这个位置</strong></p>
<p>​    只有前一个位置为1（可达，只有1种方式） ，当前位置为0（无障碍物）这种情况才能到达该位置，然后为该位置设 1 （可达，只有1种方式）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 行初始化表达式: </span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 0 列初始化表达式: </span></span><br><span class="line">obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>  这些都准备就绪之后，按照相关思路进行编码<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles1</span>(<span class="params">self, obstacleGrid</span>):</span></span><br><span class="line">          <span class="comment"># 行列长度</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果在位置(0, 0)，哪里都去不了，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，位置(0, 0)可以到达</span></span><br><span class="line">        obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 列</span></span><br><span class="line">        <span class="keyword">for</span> clo <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            obstacleGrid[clo][<span class="number">0</span>] = <span class="built_in">int</span>(obstacleGrid[clo][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[clo-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化 0 行</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][row] = <span class="built_in">int</span>(obstacleGrid[<span class="number">0</span>][row] == <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[<span class="number">0</span>][row-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从位置(1, 1)根据动态方程开始计算</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i-<span class="number">1</span>][j] + obstacleGrid[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>时间复杂度: O(mxn)</p>
<p>空间复杂度: O(1)</p>
</blockquote>
<h5 id="步骤四：优化-2"><a href="#步骤四：优化-2" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    这块的优化先不谈了，这里基本没有什么优化点，之前都是由于自己要开辟内存空间，通过空间的优化来进行，而本题是在给定的数组中进行操作的</p>
<p>有了这几个案例的基础之后，咱们后面把经典的《打家劫舍》系列剩下的两个题目讨论完，就先告一段落，后面也希望以不同的方式与大家多多交流，互相学习</p>
<p>如果有读者看着累了，可以先保存，收藏下来，待消化了前面的内容，方便再回来看看。</p>
<h3 id="案例四：打家劫舍II-「来自leetcode213」"><a href="#案例四：打家劫舍II-「来自leetcode213」" class="headerlink" title="案例四：打家劫舍II 「来自leetcode213」"></a>案例四：打家劫舍II 「来自leetcode213」</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 你不能先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">2</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">2</span>）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 你可以先偷窃 <span class="number">1</span> 号房屋（金额 = <span class="number">1</span>），然后偷窃 <span class="number">3</span> 号房屋（金额 = <span class="number">3</span>）。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>
<p>与《打家劫舍I》不同的是，《打家劫舍I》的屋子是线性的，而《打家劫舍II》是环状的，所以要考虑的点会增加一些，因为首位相连接的情况，咱们分为下面三种情况进行设定：</p>
<p>a. 不偷首偷尾</p>
<p>b. 偷首不偷尾</p>
<p>c. 首位都不偷<br>显然，c 种方式损失太大，不会获得最高的金额，故选取 a 和 b。<br>那么，下面分为两种情况，分别计算不包含首和不包含尾这两种情况来判断小偷哪种方式偷取的金额最高。</p>
<p>下面依然按照之前的四个步骤来进行分析</p>
<h5 id="步骤一：-定义dp数组的含义-1"><a href="#步骤一：-定义dp数组的含义-1" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i] 代表的含义和之前一致，dp数组存储的值一般代表截止目前的最优值</p>
<p>​    所以，<strong>dp[i] 代表到达第 i 个房屋偷得的最高金额，也就是当前最大子序和</strong></p>
<p>​    但是最后会讨论<strong>不包含首</strong>和<strong>不包含尾</strong>这两种情况下得到的dp数组的最后一位，然后获取其中较大者，就是我们要取得的最高金额</p>
<h5 id="步骤二：找出关系元素间的动态方程-3"><a href="#步骤二：找出关系元素间的动态方程-3" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    动态方程可参照《打家劫舍I》，有很详细的图解过程，该例子动态方程的变化和之前是完全一致的：</p>
<p>​    <strong>dp[i] = max(dp[i-1], nums[i-1]+dp[i-2])</strong></p>
<h5 id="步骤三：初始化设定"><a href="#步骤三：初始化设定" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    初始化: 给没有房子时，dp一个位置，即：dp[0]<br>​        a. 当size=0时，没有房子，小偷没办法偷：dp[0]=0；<br>​        b. 当size=1时，有一间房子，只要偷即可：dp[1]=nums[0]</p>
<p><img src="/images/20521cf21f76b9359a5c9dbbeda1063618.jpg" width="50%" height="50%"></p>
<p>​    由于屋子首位相连接，所以在计算时候，直接分为两种情况。第一种略过第一个屋子，第二种略过第二个屋子，这样得到的两个数组结果。最后只要比较最后一位数值的大小就ok了。解决！</p>
<p>该例子步骤三之后，感兴趣的同学可以自己写一下代码，和《打家劫舍I》的代码很类似，后面我写了优化后的代码，可能会更加的明白怎么写。咱们直接到步骤四，有了上面的案例，直接来看看优化后的方案:</p>
<h5 id="步骤四：优化-3"><a href="#步骤四：优化-3" class="headerlink" title="步骤四：优化"></a>步骤四：优化</h5><p>​    同样从 dp[i] = max(dp[i-1], nums[i-1]+dp[i-2]) 关系来看，每一次动态变化，都与前两次状态有关系（dp[i-1], dp[i-2])，而前面的一些值是没有必要留存的，只要保存两个变量来保存过程最优值就好.</p>
<p>​    代码中有详细的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="comment"># 点睛：与打家劫舍I的区别是屋子围成了一个环</span></span><br><span class="line">        <span class="comment">#   那么，很明显可以分为三种情况：</span></span><br><span class="line">        <span class="comment">#   1. 首位都不偷</span></span><br><span class="line">        <span class="comment">#   2. 偷首不偷尾</span></span><br><span class="line">        <span class="comment">#   3. 不偷首偷尾</span></span><br><span class="line">        <span class="comment"># 显然，第1种方式损失太大，选取2、3。</span></span><br><span class="line">        <span class="comment"># 那么，分为两种情况，分别计算不包含首和不包含尾这两种情况来判断哪个大哪个小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i] 代表当前最大子序和</span></span><br><span class="line">        <span class="comment"># 2.动态方程: dp[i] = max(dp[i-1] and , nums[i-1]+dp[i-2])</span></span><br><span class="line">        <span class="comment"># 3.初始化: 给没有房子时，dp一个位置，即：dp[0]</span></span><br><span class="line">        <span class="comment">#   3.1 当size=0时，没有房子，dp[0]=0；</span></span><br><span class="line">        <span class="comment">#   3.2 当size=1时，有一间房子，偷即可：dp[1]=nums[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 依照《打家劫舍I》的优化方案进行计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># nums处理，分别切割出去首和去尾的子串</span></span><br><span class="line">        nums1 = nums[<span class="number">1</span>:]</span><br><span class="line">        nums2 = nums[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        size = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">size, nums</span>):</span></span><br><span class="line">            dp1 = <span class="number">0</span></span><br><span class="line">            dp2 = nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, size+<span class="number">1</span>):</span><br><span class="line">                dp1 = <span class="built_in">max</span>(dp2, nums[i-<span class="number">1</span>]+dp1)</span><br><span class="line">                dp1, dp2 = dp2, dp1</span><br><span class="line">            <span class="keyword">return</span> dp2</span><br><span class="line"></span><br><span class="line">        res1 = handle(size-<span class="number">1</span>, nums1)</span><br><span class="line">        res2 = handle(size-<span class="number">1</span>, nums2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res1, res2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<p>再看看下面小偷遇到的情况，感叹：即使当小偷，也要步步规划才能拿到最高的金额啊…</p>
<h3 id="案例五：打家劫舍III-「来自leetcode337」"><a href="#案例五：打家劫舍III-「来自leetcode337」" class="headerlink" title="案例五：打家劫舍III 「来自leetcode337」"></a>案例五：打家劫舍III 「来自leetcode337」</h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,null,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">    \   \ </span><br><span class="line">     <span class="number">3</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出: <span class="number">7</span> </span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">3</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">7.</span></span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,null,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      <span class="number">3</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">  / \   \ </span><br><span class="line"> <span class="number">1</span>   <span class="number">3</span>   <span class="number">1</span></span><br><span class="line">输出: <span class="number">9</span></span><br><span class="line">解释: 小偷一晚能够盗取的最高金额 = <span class="number">4</span> + <span class="number">5</span> = <span class="number">9.</span></span><br></pre></td></tr></table></figure>
<p>题目出的很好，但是立马会给人一种小偷也不是好当的的赶脚…</p>
<p>言归正传，咱们先来说说题目本身</p>
<p>《打家劫舍》的小偷从一维线性到环形，再到二维矩形的屋子？是我想简单了，直接就干到树形了，是不是看着很香，而且很想，看下去，研究研究…</p>
<p>来整理几点思路，再来按照四步走：</p>
<p>1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)<br>2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历<br>3.得到每一节点的最优值，最后选取最优的结果</p>
<p>依然按照三个步骤来进行分析（无优化点）</p>
<h5 id="步骤一：-定义dp数组的含义-2"><a href="#步骤一：-定义dp数组的含义-2" class="headerlink" title="步骤一： 定义dp数组的含义"></a>步骤一： 定义dp数组的含义</h5><p>​    dp[i]代表该节点及以下打最多的劫（拿到最多的钱）</p>
<h5 id="步骤二：找出关系元素间的动态方程-4"><a href="#步骤二：找出关系元素间的动态方程-4" class="headerlink" title="步骤二：找出关系元素间的动态方程"></a>步骤二：找出关系元素间的动态方程</h5><p>​    根据我们每走到一个节点，都会有两种情况，那就是 <strong>偷(1)</strong> 与 <strong>不偷(0)</strong>。我们分开来讨论：</p>
<p>​    a. 用 <strong>dp[0]</strong> 代表不偷取该节点到目前为止拿到最多的钱，那么儿子节点偷不偷都ok。</p>
<p>​        所以： <strong>dp[0] = max(left[0], left[1]) + max(right[0], right[1])</strong></p>
<p>​    b. 用 <strong>dp[1]</strong> 代表偷了该节点到目前为止拿到最多的钱，则儿子节点都不能被偷。</p>
<p>​        所以：<strong>dp[1] = value + left[0] + right[0]</strong>  (value代表该节点的价值)</p>
<p>​    有看不懂的地方吗？再紧接着解释一下：</p>
<p>​        left[0]代表不偷取左孩子拿到最高的金额</p>
<p>​        left[1]代表偷取左孩子拿到最高的金额</p>
<p>​        right[0]代表不偷取右孩子拿到最高的金额</p>
<p>​        right[1]代表偷取右孩子拿到最高的金额</p>
<p>​    <em>如果还有不太懂的话，留言或者私信我联系我，随时骚扰我哈</em></p>
<h5 id="步骤三：初始化设定-1"><a href="#步骤三：初始化设定-1" class="headerlink" title="步骤三：初始化设定"></a>步骤三：初始化设定</h5><p>​    该例子的初始化比较简单，就是当前树的形状为空的时候，直接返回dp[0, 0]</p>
<p>下面贴出完整代码，其中包含<strong>树的初始化</strong>代码 &amp;&amp; 一大堆的注释：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, root</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 说明：</span></span><br><span class="line">        <span class="comment"># 1.由于房屋是树状的，因此，我们可以使用遍历树的传统方法进行遍历(前序、中序、后续)</span></span><br><span class="line">        <span class="comment"># 2.简单的思路是，从树低进行往上遍历，拿到最优的打劫值。可以选用后续遍历</span></span><br><span class="line">        <span class="comment"># 3.得到每一节点的最优值，最后选取最优的结果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.dp[i]代表该节点及以下拿到的最多的钱</span></span><br><span class="line">        <span class="comment"># 2.动态方程：</span></span><br><span class="line">        <span class="comment">#   2.1 dp[0]代表不偷该节点拿到最多的钱，则儿子节点偷不偷都ok。dp[0] = max(left[0], left[1]) + max(right[0], right[1])</span></span><br><span class="line">        <span class="comment">#   2.2 dp[1]代表偷了该节点拿到最多的钱，则儿子节点都不能被偷。dp[1] = var + left[0] + right[0]</span></span><br><span class="line">        <span class="comment"># 3.初始化：当前树的形状为空的时候，直接返回dp[0, 0]</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postTrasval</span>(<span class="params">root</span>):</span></span><br><span class="line">            dp = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> dp</span><br><span class="line">            left = postTrasval(root.left)</span><br><span class="line">            right = postTrasval(root.right)</span><br><span class="line"></span><br><span class="line">            dp[<span class="number">0</span>] = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + <span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>])</span><br><span class="line">            dp[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dp</span><br><span class="line"></span><br><span class="line">        dp = postTrasval(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># initial tree structure</span></span><br><span class="line">    T = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left = TreeNode(<span class="number">2</span>)</span><br><span class="line">    T.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.left.right = TreeNode(<span class="number">3</span>)</span><br><span class="line">    T.right.right = TreeNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The solution to the Question</span></span><br><span class="line">    s = Solution()</span><br><span class="line">    print(s.rob(T))</span><br></pre></td></tr></table></figure>
<p>至此为止，想要讲解的全部完毕了</p>
<p>洋洋洒洒过万字，自己都没想到写了这么多</p>
<p>在强调一点吧，这些题目全部理解 外加 自己另外练习，一定能够cover<strong>关于动态规划80%以上的题目</strong>，基本上都是dp为一维数组，二维数组的题目，很少有很奇怪的题型出现。所以，本文将《打家劫舍》经典案例详细讲解了一次，还有不同路径的问题，也是很经典的题目，而经典题目一定很具有代表性。优化方向很多，本文也只介绍了关于空间方面的优化，因为这个是最最常见的。</p>
<p>最后，大家一定多画图，多思考，题解百边其义自见（百边有点多哈哈哈）</p>
<p>还有，多理解四步骤， 加油！</p>
<p>后面有机会再细致的分享其他常见算法思想的文章</p>
<p>如果感觉对大家有帮助，不妨关注、点赞、转发起来哦！！！</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>几百本互联网图书PDF全部放出</title>
    <url>/posts/77172009/</url>
    <content><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<p><strong>【电子书籍】坚持书籍分享 … 完善中 …</strong></p>
<p><strong>【要善用Command/Ctrl+F查找资料哦】</strong></p>
<p>零、互联网面试书籍集合</p>
<p>一、计算机技术语言类</p>
<p>二、数据结构和算法</p>
<p>三、Python技术</p>
<p>四、大数据技术</p>
<p>五、机器学习和人工智能AI</p>
<p>六、其他书籍</p>
<p><strong>按需寻找哦！ 链接如果失效，随时随地联系作者 (^o^)/~</strong></p>
<hr>
<h4 id="零、互联网面试书籍集合"><a href="#零、互联网面试书籍集合" class="headerlink" title="零、互联网面试书籍集合"></a>零、互联网面试书籍集合</h4><h6 id="1-《labuladong的算法小抄官方完整版》"><a href="#1-《labuladong的算法小抄官方完整版》" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a> </p>
<p>密码: 密码:KfGM</p>
<h6 id="3-《剑指offer名企面试官精讲典型编程题》"><a href="#3-《剑指offer名企面试官精讲典型编程题》" class="headerlink" title="3.《剑指offer名企面试官精讲典型编程题》"></a>3.《剑指offer名企面试官精讲典型编程题》</h6><p>链接: <a href="https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw">https://pan.baidu.com/s/18vd8-X6sgcrArpHEmjqDxw</a>  </p>
<p>密码: jnnl</p>
<h6 id="4-《阿里Java面试问题大全》"><a href="#4-《阿里Java面试问题大全》" class="headerlink" title="4.《阿里Java面试问题大全》"></a>4.《阿里Java面试问题大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ">https://pan.baidu.com/s/1hQKvpq9_Nc0kErE4LY6UJQ</a> </p>
<p>提取码: es6v</p>
<h6 id="5-《程序员面试宝典》"><a href="#5-《程序员面试宝典》" class="headerlink" title="5.《程序员面试宝典》"></a>5.《程序员面试宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ">https://pan.baidu.com/s/1vWpQopsZviWI8c7WuDEeOQ</a> </p>
<p>提取码: aske</p>
<h4 id="一、计算机技术语言类"><a href="#一、计算机技术语言类" class="headerlink" title="一、计算机技术语言类"></a>一、计算机技术语言类</h4><h5 id="C-C"><a href="#C-C" class="headerlink" title="C / C++"></a>C / C++</h5><h6 id="1-《C和指针》-C语言经典书籍"><a href="#1-《C和指针》-C语言经典书籍" class="headerlink" title="1. 《C和指针》 C语言经典书籍"></a>1. 《C和指针》 C语言经典书籍</h6><p>PDF链接:<a href="https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ">https://pan.baidu.com/s/1iTcs-Bhver4u5k2njyPPWQ</a>  </p>
<p>密码:dr1q</p>
<h6 id="2-《啊哈c语言》"><a href="#2-《啊哈c语言》" class="headerlink" title="2. 《啊哈c语言》"></a>2. 《啊哈c语言》</h6><p>链接:<a href="https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA">https://pan.baidu.com/s/1WBw0eL9qahPL9IV4Zr8PGA</a>  </p>
<p>密码:gi21</p>
<h6 id="3-《c-primerplus6》-C-经典书籍"><a href="#3-《c-primerplus6》-C-经典书籍" class="headerlink" title="3. 《c++primerplus6》 C++经典书籍"></a>3. 《c++primerplus6》 C++经典书籍</h6><p>链接:<a href="https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw">https://pan.baidu.com/s/1--pVoMzb2HZ8aHfAXL0SOw</a>  </p>
<p>密码:0kat</p>
<h6 id="4-《深入探索C-对象模型》"><a href="#4-《深入探索C-对象模型》" class="headerlink" title="4. 《深入探索C++对象模型》"></a>4. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ">https://pan.baidu.com/s/1agw5Z6J86VKKPEaxjuAurQ</a> </p>
<p>提取码: k98m</p>
<h6 id="5-《C-编程规范-101条规则准则与最佳实践》"><a href="#5-《C-编程规范-101条规则准则与最佳实践》" class="headerlink" title="5. 《C++编程规范-101条规则准则与最佳实践》"></a>5. 《C++编程规范-101条规则准则与最佳实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="6-《C-编程思想两卷合订本》"><a href="#6-《C-编程思想两卷合订本》" class="headerlink" title="6. 《C++编程思想两卷合订本》"></a>6. 《C++编程思想两卷合订本》</h6><p>链接: <a href="https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g">https://pan.baidu.com/s/1pnMnVgmU6MYcxz7CSYyx7g</a> </p>
<p>提取码: ufnu</p>
<h6 id="7-《C-沉思录中文第2版》"><a href="#7-《C-沉思录中文第2版》" class="headerlink" title="7. 《C++沉思录中文第2版》"></a>7. 《C++沉思录中文第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA">https://pan.baidu.com/s/11XS8oFhwwlpYDCiXrXhvFA</a> </p>
<p>提取码: 4rk1</p>
<h6 id="8-《C-大学教程》"><a href="#8-《C-大学教程》" class="headerlink" title="8. 《C++大学教程》"></a>8. 《C++大学教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g">https://pan.baidu.com/s/1d6aCaGpyXxLmJxLJl5US9g</a> </p>
<p>提取码: 1ine</p>
<h6 id="9-《深入探索C-对象模型》"><a href="#9-《深入探索C-对象模型》" class="headerlink" title="9. 《深入探索C++对象模型》"></a>9. 《深入探索C++对象模型》</h6><p>链接: <a href="https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw">https://pan.baidu.com/s/1wgdmx-bfiJGCYnmuEimYdw</a> </p>
<p>提取码: s4ht</p>
<h6 id="10-《C-设计新思维-泛型编程与设计之应用》"><a href="#10-《C-设计新思维-泛型编程与设计之应用》" class="headerlink" title="10. 《C++设计新思维-泛型编程与设计之应用》"></a>10. 《C++设计新思维-泛型编程与设计之应用》</h6><p>链接: <a href="https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw">https://pan.baidu.com/s/1_filEqOMM0laa8HykZ7rqw</a> </p>
<p>提取码: a73e</p>
<h6 id="11-《C-primer5th》"><a href="#11-《C-primer5th》" class="headerlink" title="11. 《C++primer5th》"></a>11. 《C++primer5th》</h6><p>链接: <a href="https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g">https://pan.baidu.com/s/18XEECPX5Zfi4aCOxSdQR7g</a> </p>
<p>提取码: f66t</p>
<h6 id="12-《C-Templates》"><a href="#12-《C-Templates》" class="headerlink" title="12. 《C++ Templates》"></a>12. 《C++ Templates》</h6><p>链接: <a href="https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ">https://pan.baidu.com/s/1qOCGMBeqsCv3wk3mwNs4fQ</a> </p>
<p>提取码: bhmc</p>
<h6 id="13-《C语言编程精粹》"><a href="#13-《C语言编程精粹》" class="headerlink" title="13. 《C语言编程精粹》"></a>13. 《C语言编程精粹》</h6><p>链接: <a href="https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw">https://pan.baidu.com/s/10UmQgH1QaXLrx6IfL1QUxw</a> </p>
<p>提取码: xvas</p>
<h6 id="14-《C语言参考手册第五版》"><a href="#14-《C语言参考手册第五版》" class="headerlink" title="14. 《C语言参考手册第五版》"></a>14. 《C语言参考手册第五版》</h6><p>链接: <a href="https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg">https://pan.baidu.com/s/1uBQRP1LZmQnlZVNpSat1tg</a> </p>
<p>提取码: x3ns</p>
<h6 id="15-《C语言解析教程》"><a href="#15-《C语言解析教程》" class="headerlink" title="15. 《C语言解析教程》"></a>15. 《C语言解析教程》</h6><p>链接: <a href="https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg">https://pan.baidu.com/s/1_4ATuTRkfCZ7cV-SuTGyyg</a> </p>
<p>提取码: hn2i</p>
<h6 id="16-《C语言深度解剖》"><a href="#16-《C语言深度解剖》" class="headerlink" title="16. 《C语言深度解剖》"></a>16. 《C语言深度解剖》</h6><p>链接: <a href="https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww">https://pan.baidu.com/s/1x4-ZXgZnX3ifkc9cpOVjww</a> </p>
<p>提取码: ggfh</p>
<h6 id="17-《C专家编程》"><a href="#17-《C专家编程》" class="headerlink" title="17. 《C专家编程》"></a>17. 《C专家编程》</h6><p>链接: <a href="https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw">https://pan.baidu.com/s/15Zdcb5fYb6gZ0MzjPspyLw</a> </p>
<p>提取码: c8fu</p>
<h6 id="18-《EffectiveSTL中文版》"><a href="#18-《EffectiveSTL中文版》" class="headerlink" title="18. 《EffectiveSTL中文版》"></a>18. 《EffectiveSTL中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA">https://pan.baidu.com/s/1fxVIhRfeYNAT7sppBBUyTA</a> </p>
<p>提取码: arzc</p>
<h6 id="19-《MoreEffectiveC-中文版》"><a href="#19-《MoreEffectiveC-中文版》" class="headerlink" title="19. 《MoreEffectiveC++中文版》"></a>19. 《MoreEffectiveC++中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g">https://pan.baidu.com/s/12hyN9W4EjEbsicLDrmdS-g</a> </p>
<p>提取码: qdd3</p>
<h6 id="20-《STL源码剖析》"><a href="#20-《STL源码剖析》" class="headerlink" title="20. 《STL源码剖析》"></a>20. 《STL源码剖析》</h6><p>链接: <a href="https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ">https://pan.baidu.com/s/17P5s69-ENmHK7K9UW0MIrQ</a> </p>
<p>提取码: w9x8</p>
<h5 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h5><h6 id="1-《Java核心技术-卷1-基础知识-原书第9版》"><a href="#1-《Java核心技术-卷1-基础知识-原书第9版》" class="headerlink" title="1. 《Java核心技术 卷1 基础知识 原书第9版》"></a>1. 《Java核心技术 卷1 基础知识 原书第9版》</h6><p>链接:<a href="https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw">https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw</a>  </p>
<p>密码:x1x3</p>
<h6 id="2-《阿里巴巴Java开发手册》"><a href="#2-《阿里巴巴Java开发手册》" class="headerlink" title="2. 《阿里巴巴Java开发手册》"></a>2. 《阿里巴巴Java开发手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ">https://pan.baidu.com/s/1Q9pL5t5XMWDUsiMbMU_KEQ</a> </p>
<p>提取码: w6gc</p>
<h6 id="3-《码出高效》Java开发手册"><a href="#3-《码出高效》Java开发手册" class="headerlink" title="3. 《码出高效》Java开发手册"></a>3. 《码出高效》Java开发手册</h6><p>链接: <a href="https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg">https://pan.baidu.com/s/1j0R1BBAhdW4kaXQhrpo7jg</a> </p>
<p>提取码: sqhe</p>
<h6 id="3-《轻量级JavaEE企业应用实战》"><a href="#3-《轻量级JavaEE企业应用实战》" class="headerlink" title="3. 《轻量级JavaEE企业应用实战》"></a>3. 《轻量级JavaEE企业应用实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ">https://pan.baidu.com/s/1bNYeZHn2OuK1vOsVc6vVWQ</a> </p>
<p>提取码: rtzw</p>
<h6 id="4-《深入分析JavaWeb技术内幕》"><a href="#4-《深入分析JavaWeb技术内幕》" class="headerlink" title="4. 《深入分析JavaWeb技术内幕》"></a>4. 《深入分析JavaWeb技术内幕》</h6><p>链接: <a href="https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ">https://pan.baidu.com/s/18kVo23EaUYuusPtVfNzrHQ</a> </p>
<p>提取码: vivd</p>
<h6 id="5-《深入理解Java虚拟机第二版》"><a href="#5-《深入理解Java虚拟机第二版》" class="headerlink" title="5. 《深入理解Java虚拟机第二版》"></a>5. 《深入理解Java虚拟机第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA">https://pan.baidu.com/s/1ADYS7pjefl3gA4zWX3hUSA</a> </p>
<p>提取码: jj6z</p>
<h6 id="6-《深入剖析Tomcat》"><a href="#6-《深入剖析Tomcat》" class="headerlink" title="6. 《深入剖析Tomcat》"></a>6. 《深入剖析Tomcat》</h6><p>链接: <a href="https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg">https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg</a> </p>
<p>提取码: p42w</p>
<h6 id="7-《Java8实战》"><a href="#7-《Java8实战》" class="headerlink" title="7. 《Java8实战》"></a>7. 《Java8实战》</h6><p>链接: <a href="https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ">https://pan.baidu.com/s/15aXVvIX4lvGldhCU7fggdQ</a> </p>
<p>提取码: hh1e</p>
<h6 id="8-《JAVA并发编程实践》"><a href="#8-《JAVA并发编程实践》" class="headerlink" title="8. 《JAVA并发编程实践》"></a>8. 《JAVA并发编程实践》</h6><p>链接: <a href="https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw">https://pan.baidu.com/s/1QxgwO4qZQEaChi-l7r3YTw</a> </p>
<p>提取码: tcvd</p>
<h6 id="9-《EffectiveJava中文第二版》"><a href="#9-《EffectiveJava中文第二版》" class="headerlink" title="9. 《EffectiveJava中文第二版》"></a>9. 《EffectiveJava中文第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA">https://pan.baidu.com/s/1TZUpz5TwlE1HxMqFagQFIA</a> </p>
<p>提取码: ankv</p>
<h6 id="10-《HeadFirstJava第二版涵盖java5-0》"><a href="#10-《HeadFirstJava第二版涵盖java5-0》" class="headerlink" title="10. 《HeadFirstJava第二版涵盖java5.0》"></a>10. 《HeadFirstJava第二版涵盖java5.0》</h6><p>链接: <a href="https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng">https://pan.baidu.com/s/1mlFzvUoucefh8MePSUtGng</a> </p>
<p>提取码: bmkj</p>
<h6 id="11-《HeadFirstServletandJSP》-高清中文版"><a href="#11-《HeadFirstServletandJSP》-高清中文版" class="headerlink" title="11. 《HeadFirstServletandJSP》(高清中文版)"></a>11. 《HeadFirstServletandJSP》(高清中文版)</h6><p>链接: <a href="https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA">https://pan.baidu.com/s/16BEMBE1sAYB-JAx4-KPsaA</a> </p>
<p>提取码: vkmk</p>
<h6 id="12-《Java从小白到大牛精简版》"><a href="#12-《Java从小白到大牛精简版》" class="headerlink" title="12. 《Java从小白到大牛精简版》"></a>12. 《Java从小白到大牛精简版》</h6><p>链接: <a href="https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw">https://pan.baidu.com/s/1RVLm1dzPhc8yTbs0rdXyOw</a> </p>
<p>提取码: mz9r</p>
<h6 id="13-《Java核心技术卷1第8版》"><a href="#13-《Java核心技术卷1第8版》" class="headerlink" title="13. 《Java核心技术卷1第8版》"></a>13. 《Java核心技术卷1第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA">https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA</a> </p>
<p>提取码: 9i6e</p>
<h6 id="14-《Java核心技术卷2第8版》"><a href="#14-《Java核心技术卷2第8版》" class="headerlink" title="14. 《Java核心技术卷2第8版》"></a>14. 《Java核心技术卷2第8版》</h6><p>链接: <a href="https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg">https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg</a> </p>
<p>提取码: x58i</p>
<h6 id="15-《Java性能优化权威指南》"><a href="#15-《Java性能优化权威指南》" class="headerlink" title="15. 《Java性能优化权威指南》"></a>15. 《Java性能优化权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw">https://pan.baidu.com/s/1EuoHKZVa1zBympW96KFkUw</a> </p>
<p>提取码: 8emi</p>
<h6 id="16-《Spring-实战-中文版第4版》"><a href="#16-《Spring-实战-中文版第4版》" class="headerlink" title="16. 《Spring 实战 中文版第4版》"></a>16. 《Spring 实战 中文版第4版》</h6><p>链接: <a href="https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w">https://pan.baidu.com/s/1xQQ41VNvDxk-Fd-7Pq_x_w</a> </p>
<p>提取码: gea5</p>
<h4 id="二、数据结构和算法"><a href="#二、数据结构和算法" class="headerlink" title="二、数据结构和算法"></a>二、数据结构和算法</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><h6 id="1-《大话数据结构》"><a href="#1-《大话数据结构》" class="headerlink" title="1. 《大话数据结构》"></a>1. 《大话数据结构》</h6><p>链接: <a href="https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA">https://pan.baidu.com/s/1S9lZPNA_qydJKHn21ydThA</a> </p>
<p>提取码: 8i5k</p>
<h6 id="2-《Java数据结构和算法》-第二版"><a href="#2-《Java数据结构和算法》-第二版" class="headerlink" title="2. 《Java数据结构和算法》 第二版"></a>2. 《Java数据结构和算法》 第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw">https://pan.baidu.com/s/1KAd08i5FTs7FaBazCq3NBw</a> </p>
<p>提取码: f6y5</p>
<h5 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h5><h6 id="1-《labuladong的算法小抄官方完整版》-1"><a href="#1-《labuladong的算法小抄官方完整版》-1" class="headerlink" title="1.《labuladong的算法小抄官方完整版》"></a>1.《labuladong的算法小抄官方完整版》</h6><p>链接：<a href="https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg">https://pan.baidu.com/s/1qpL4t6jmZnZgRvGlt8SSxg</a><br>提取码：KfGM</p>
<h6 id="2-动态规划总结文档"><a href="#2-动态规划总结文档" class="headerlink" title="2. 动态规划总结文档"></a>2. 动态规划总结文档</h6><p>对动态规划的理解还是差那么一点？这一篇帮你安排的明明白白！</p>
<h6 id="3-《算法导论》"><a href="#3-《算法导论》" class="headerlink" title="3. 《算法导论》"></a>3. 《算法导论》</h6><p>链接: <a href="https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw">https://pan.baidu.com/s/1l7BS4GxuQGJE1he_5h0AXw</a>  </p>
<p>密码: s3sh</p>
<h6 id="4-《啊哈算法》"><a href="#4-《啊哈算法》" class="headerlink" title="4. 《啊哈算法》"></a>4. 《啊哈算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="5-《编程珠玑第二版》"><a href="#5-《编程珠玑第二版》" class="headerlink" title="5. 《编程珠玑第二版》"></a>5. 《编程珠玑第二版》</h6><p>链接: <a href="https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA">https://pan.baidu.com/s/1U726iEp6WADu4ZQ5fRZyzA</a> </p>
<p>提取码: ymvg</p>
<h6 id="6-《算法图解》"><a href="#6-《算法图解》" class="headerlink" title="6. 《算法图解》"></a>6. 《算法图解》</h6><p>链接: <a href="https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ">https://pan.baidu.com/s/138Di8I8K_iRkGr15PDswYQ</a> </p>
<p>提取码: r7wa</p>
<h5 id="周边算法思想"><a href="#周边算法思想" class="headerlink" title="周边算法思想"></a>周边算法思想</h5><h4 id="三、Python技术"><a href="#三、Python技术" class="headerlink" title="三、Python技术"></a>三、Python技术</h4><h5 id="Python-语言"><a href="#Python-语言" class="headerlink" title="Python 语言"></a>Python 语言</h5><h6 id="1-《Python进阶》"><a href="#1-《Python进阶》" class="headerlink" title="1. 《Python进阶》"></a>1. 《Python进阶》</h6><p>链接:<a href="https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg">https://pan.baidu.com/s/1wsOkqs_04RCSY-kOjOYJcg</a>  </p>
<p>密码:u9u0</p>
<h6 id="2-《Python基础教程（第二版）》"><a href="#2-《Python基础教程（第二版）》" class="headerlink" title="2. 《Python基础教程（第二版）》"></a>2. 《Python基础教程（第二版）》</h6><p>链接: <a href="https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw">https://pan.baidu.com/s/14XqoV2ZoF5YmYmGjHsY6nw</a>  </p>
<p>密码: lam6</p>
<h6 id="3-《Python核心编程第二版中文》"><a href="#3-《Python核心编程第二版中文》" class="headerlink" title="3. 《Python核心编程第二版中文》"></a>3. 《Python核心编程第二版中文》</h6><p>链接: <a href="https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ">https://pan.baidu.com/s/1CTA02Y9lOYteSzcXCMD1kQ</a>  </p>
<p>密码: hq9b</p>
<h6 id="4-《Python开发实战》"><a href="#4-《Python开发实战》" class="headerlink" title="4. 《Python开发实战》"></a>4. 《Python开发实战》</h6><p>链接: <a href="https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA">https://pan.baidu.com/s/16jATIJ3mFqT8T05H384hoA</a> </p>
<p>提取码: 2bnj</p>
<h6 id="5-《Python开发技术详解》"><a href="#5-《Python开发技术详解》" class="headerlink" title="5. 《Python开发技术详解》"></a>5. 《Python开发技术详解》</h6><p>链接: <a href="https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw">https://pan.baidu.com/s/1SEgxhjYLstG3aPU-LRbZMw</a> </p>
<p>提取码: 3kjn</p>
<h6 id="6-《Python灰帽子黑客与逆向工程师的Python编程之道》"><a href="#6-《Python灰帽子黑客与逆向工程师的Python编程之道》" class="headerlink" title="6. 《Python灰帽子黑客与逆向工程师的Python编程之道》"></a>6. 《Python灰帽子黑客与逆向工程师的Python编程之道》</h6><p>链接: <a href="https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA">https://pan.baidu.com/s/11b-tkIcexYXDe2Ge1a_kaA</a> </p>
<p>提取码: ev5v</p>
<h6 id="7-《Python高级编程第2版》"><a href="#7-《Python高级编程第2版》" class="headerlink" title="7. 《Python高级编程第2版》"></a>7. 《Python高级编程第2版》</h6><p>链接: <a href="https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw">https://pan.baidu.com/s/1tSk97zVE1iDboX9BJ1D_Rw</a> </p>
<p>提取码: 62qy</p>
<h6 id="8-《Python编程入门经典》"><a href="#8-《Python编程入门经典》" class="headerlink" title="8. 《Python编程入门经典》"></a>8. 《Python编程入门经典》</h6><p>链接: <a href="https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ">https://pan.baidu.com/s/10r_ljM2oHNKQogsiOGknJQ</a> </p>
<p>提取码: g4pr</p>
<h6 id="9-《Python编程初学者指南》"><a href="#9-《Python编程初学者指南》" class="headerlink" title="9. 《Python编程初学者指南》"></a>9. 《Python编程初学者指南》</h6><p>链接: <a href="https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw">https://pan.baidu.com/s/195kd2E0Euy4mIPBFjVlnEw</a> </p>
<p>提取码: k86q</p>
<h6 id="10-《Python网络编程基础》"><a href="#10-《Python网络编程基础》" class="headerlink" title="10. 《Python网络编程基础》"></a>10. 《Python网络编程基础》</h6><p>链接: <a href="https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA">https://pan.baidu.com/s/1EsiWhQFss66W5p5_7PS8DA</a> </p>
<p>提取码: vy2t</p>
<h6 id="11-《Python学习手册》"><a href="#11-《Python学习手册》" class="headerlink" title="11. 《Python学习手册》"></a>11. 《Python学习手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ">https://pan.baidu.com/s/1W6Q0FhpKiB2mFBtBt-h9JQ</a> </p>
<p>提取码: nikm</p>
<h6 id="12-《Python学习手册》-第4版"><a href="#12-《Python学习手册》-第4版" class="headerlink" title="12. 《Python学习手册》 第4版"></a>12. 《Python学习手册》 第4版</h6><p>链接: <a href="https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg">https://pan.baidu.com/s/17jJCAPuZfjoeiTlYr8Ijjg</a> </p>
<p>提取码: arcd</p>
<h6 id="13-《用Python写网络爬虫》"><a href="#13-《用Python写网络爬虫》" class="headerlink" title="13. 《用Python写网络爬虫》"></a>13. 《用Python写网络爬虫》</h6><p>链接: <a href="https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA">https://pan.baidu.com/s/1RfU0ec096nUmIiRWM_D1SA</a> </p>
<p>提取码: wm92</p>
<h5 id="Python-数据分析"><a href="#Python-数据分析" class="headerlink" title="Python 数据分析"></a>Python 数据分析</h5><h6 id="1-《利用Python进行数据分析》"><a href="#1-《利用Python进行数据分析》" class="headerlink" title="1. 《利用Python进行数据分析》"></a>1. 《利用Python进行数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g">https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g</a>  </p>
<p>密码: qune</p>
<h6 id="2-《NumPy学习指南（第2版）》"><a href="#2-《NumPy学习指南（第2版）》" class="headerlink" title="2. 《NumPy学习指南（第2版）》"></a>2. 《NumPy学习指南（第2版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw">https://pan.baidu.com/s/1JgvWbUdRzQtyvsaNTGu1Fw</a>  </p>
<p>密码:3nwc</p>
<h6 id="3-《常用的数据分析方法》"><a href="#3-《常用的数据分析方法》" class="headerlink" title="3. 《常用的数据分析方法》"></a>3. 《常用的数据分析方法》</h6><p>链接: <a href="https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g">https://pan.baidu.com/s/1Rj9XvBp_PdazA9I_zDYp2g</a> </p>
<p>提取码: u8p6</p>
<h6 id="4-《Python数据处理》"><a href="#4-《Python数据处理》" class="headerlink" title="4. 《Python数据处理》"></a>4. 《Python数据处理》</h6><p>链接: <a href="https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g">https://pan.baidu.com/s/1mgZhwNG_Qzz9C3YfJjl7-g</a> </p>
<p>提取码: m42q</p>
<h6 id="5-《Python金融大数据分析》"><a href="#5-《Python金融大数据分析》" class="headerlink" title="5. 《Python金融大数据分析》"></a>5. 《Python金融大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ">https://pan.baidu.com/s/1Y2X95od-ZdAywfRV8_-ZdQ</a> </p>
<p>提取码: rpqw</p>
<h6 id="6-《Python数据分析与挖掘实战》"><a href="#6-《Python数据分析与挖掘实战》" class="headerlink" title="6. 《Python数据分析与挖掘实战》"></a>6. 《Python数据分析与挖掘实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg">https://pan.baidu.com/s/1OjNqNn3nNVKXBkHUeZ2mVg</a> </p>
<p>提取码: evbm</p>
<h6 id="7-《Python数据科学手册》"><a href="#7-《Python数据科学手册》" class="headerlink" title="7. 《Python数据科学手册》"></a>7. 《Python数据科学手册》</h6><p>链接: <a href="https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw">https://pan.baidu.com/s/1400rpIEK3VQhbNrFyztjRw</a> </p>
<p>提取码: qyqh</p>
<h6 id="8-《Python数据可视化编程实战》"><a href="#8-《Python数据可视化编程实战》" class="headerlink" title="8. 《Python数据可视化编程实战》"></a>8. 《Python数据可视化编程实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw">https://pan.baidu.com/s/1b_36vxf3t-8ut5P5qHapaw</a> </p>
<p>提取码: b3sb</p>
<h6 id="9-《PYTHON自然语言处理中文版》"><a href="#9-《PYTHON自然语言处理中文版》" class="headerlink" title="9. 《PYTHON自然语言处理中文版》"></a>9. 《PYTHON自然语言处理中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA">https://pan.baidu.com/s/17LqxjzAmtX8UVMjOuwrVxA</a> </p>
<p>提取码: k8bs</p>
<h4 id="四、大数据技术"><a href="#四、大数据技术" class="headerlink" title="四、大数据技术"></a>四、大数据技术</h4><h5 id="大数据技术基础"><a href="#大数据技术基础" class="headerlink" title="大数据技术基础"></a>大数据技术基础</h5><h6 id="1-《Hadoop全权威指南第三版（原版）》"><a href="#1-《Hadoop全权威指南第三版（原版）》" class="headerlink" title="1.《Hadoop全权威指南第三版（原版）》"></a>1.《Hadoop全权威指南第三版（原版）》</h6><p>链接: <a href="https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww">https://pan.baidu.com/s/1O0AwkvstyRdB69Tiw8o7Ww</a>  </p>
<p>密码: 29li</p>
<h6 id="2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"><a href="#2-《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理" class="headerlink" title="2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理"></a>2.《Hadoop技术内幕》深入解析HadoopCommon和HDFS架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ">https://pan.baidu.com/s/1jOadD77nyb77JjvxQomioQ</a> </p>
<p>提取码: c3gx</p>
<h6 id="3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理"><a href="#3-《Hadoop技术内幕》深入解析YARN架构设计与实现原理" class="headerlink" title="3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理"></a>3.《Hadoop技术内幕》深入解析YARN架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg">https://pan.baidu.com/s/1vhJ4ETMwDztkR10tx90-Vg</a> </p>
<p>提取码: bdje</p>
<h6 id="4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"><a href="#4-《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理" class="headerlink" title="4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理"></a>4.《Hadoop技术内幕》深入理解MapReduce架构设计与实现原理</h6><p>链接: <a href="https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w">https://pan.baidu.com/s/16DxrvNwDO6FIQnU1GApa4w</a> </p>
<p>提取码: wfks</p>
<h6 id="5-《Spark快速大数据分析》"><a href="#5-《Spark快速大数据分析》" class="headerlink" title="5.《Spark快速大数据分析》"></a>5.《Spark快速大数据分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA">https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA</a> </p>
<p>提取码: i6av</p>
<h5 id="大数据平台开源工具"><a href="#大数据平台开源工具" class="headerlink" title="大数据平台开源工具"></a>大数据平台开源工具</h5><h5 id="大数据集群"><a href="#大数据集群" class="headerlink" title="大数据集群"></a>大数据集群</h5><h5 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h5><h6 id="1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#1-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>1. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA">https://pan.baidu.com/s/1Qbwa0iB0PMwpTdg3RGpPSA</a> </p>
<p>提取码: c276</p>
<h6 id="2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》"><a href="#2-《鸟哥的LINUX私房菜-基础学习篇-第三版-》" class="headerlink" title="2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》"></a>2. 《鸟哥的LINUX私房菜_基础学习篇(第三版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg">https://pan.baidu.com/s/1ZX_VTrvla6VzrHwI7tRaNg</a> </p>
<p>提取码: x4ej</p>
<h6 id="3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列"><a href="#3-《深入Linux内核架构》-图灵程序设计丛书LinuxUNIX系列" class="headerlink" title="3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)"></a>3. 《深入Linux内核架构》(图灵程序设计丛书LinuxUNIX系列)</h6><p>链接: <a href="https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg">https://pan.baidu.com/s/1mLoBn3tndC9HcCGneJMgIg</a> </p>
<p>提取码: ktff</p>
<h6 id="4-《Linux宝典》"><a href="#4-《Linux宝典》" class="headerlink" title="4. 《Linux宝典》"></a>4. 《Linux宝典》</h6><p>链接: <a href="https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w">https://pan.baidu.com/s/167PnlnHPp9_mzlYMjB7S_w</a> </p>
<p>提取码: 6rxa</p>
<h6 id="5-《linux常用命令大全》"><a href="#5-《linux常用命令大全》" class="headerlink" title="5. 《linux常用命令大全》"></a>5. 《linux常用命令大全》</h6><p>链接: <a href="https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww">https://pan.baidu.com/s/1xktbfNa3IU4wpga_4GKLww</a> </p>
<p>提取码: bsce</p>
<h6 id="6-《LINUX防火墙原书第3版》"><a href="#6-《LINUX防火墙原书第3版》" class="headerlink" title="6. 《LINUX防火墙原书第3版》"></a>6. 《LINUX防火墙原书第3版》</h6><p>链接: <a href="https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g">https://pan.baidu.com/s/1yzlny8xwa9CNzCxsLYak2g</a> </p>
<p>提取码: wi4c</p>
<h6 id="7-《Linux高级程序设计中文第三版》"><a href="#7-《Linux高级程序设计中文第三版》" class="headerlink" title="7. 《Linux高级程序设计中文第三版》"></a>7. 《Linux高级程序设计中文第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg">https://pan.baidu.com/s/1qrtRIP7Gy8uQBbQtNc-sVg</a> </p>
<p>提取码: 26ek</p>
<h6 id="8-《Linux环境编程从应用到内核》"><a href="#8-《Linux环境编程从应用到内核》" class="headerlink" title="8. 《Linux环境编程从应用到内核》"></a>8. 《Linux环境编程从应用到内核》</h6><p>链接: <a href="https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ">https://pan.baidu.com/s/1-__GcXj8yQmOveKrWjinoQ</a> </p>
<p>提取码: fwi2</p>
<h6 id="9-《Linux命令详解词典施威铭研究室》"><a href="#9-《Linux命令详解词典施威铭研究室》" class="headerlink" title="9. 《Linux命令详解词典施威铭研究室》"></a>9. 《Linux命令详解词典施威铭研究室》</h6><p>链接: <a href="https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw">https://pan.baidu.com/s/1QEszuv4nvSAvY-bL16dXSw</a> </p>
<p>提取码: rhpb</p>
<h5 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h5><h6 id="1-《深入浅出MySQL-数据库开发优化与管理维护》"><a href="#1-《深入浅出MySQL-数据库开发优化与管理维护》" class="headerlink" title="1. 《深入浅出MySQL++数据库开发优化与管理维护》"></a>1. 《深入浅出MySQL++数据库开发优化与管理维护》</h6><p>链接: <a href="https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A">https://pan.baidu.com/s/1ydnPTZ531FwRxOdOPDj51A</a> 提取码: 5eez</p>
<h6 id="2-《高性能mysql第三版》"><a href="#2-《高性能mysql第三版》" class="headerlink" title="2. 《高性能mysql第三版》"></a>2. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="3-《MySQL必知必会》"><a href="#3-《MySQL必知必会》" class="headerlink" title="3. 《MySQL必知必会》"></a>3. 《MySQL必知必会》</h6><p>链接: <a href="https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA">https://pan.baidu.com/s/12QX4fDb70brt4exCvKYhuA</a> </p>
<p>提取码: 7xds</p>
<h4 id="五、机器学习和人工智能AI"><a href="#五、机器学习和人工智能AI" class="headerlink" title="五、机器学习和人工智能AI"></a>五、机器学习和人工智能AI</h4><h5 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h5><h6 id="1-《高等数学（同济）第六版-第七版课后习题答案》完整答案"><a href="#1-《高等数学（同济）第六版-第七版课后习题答案》完整答案" class="headerlink" title="1.《高等数学（同济）第六版/第七版课后习题答案》完整答案"></a>1.《高等数学（同济）第六版/第七版课后习题答案》完整答案</h6><p>链接:<a href="https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw">https://pan.baidu.com/s/1q6fIHLmYd1pXsewlqfBfUw</a>  </p>
<p>密码:xlij</p>
<h6 id="2-《浙江大学概率论与数理统计-第四版-》"><a href="#2-《浙江大学概率论与数理统计-第四版-》" class="headerlink" title="2.《浙江大学概率论与数理统计(第四版)》"></a>2.《浙江大学概率论与数理统计(第四版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g">https://pan.baidu.com/s/1MqI_2Ch2Hqbw25yib00u1g</a> </p>
<p>提取码: zeda</p>
<h6 id="3-《数学之美》完整版"><a href="#3-《数学之美》完整版" class="headerlink" title="3.《数学之美》完整版"></a>3.《数学之美》完整版</h6><p>链接: <a href="https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA">https://pan.baidu.com/s/1-IGOG52cRgHM-7PMpTpTvA</a> </p>
<p>提取码: a95d</p>
<h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><h6 id="1-《Machine-Learning-Yearning》完整中文版"><a href="#1-《Machine-Learning-Yearning》完整中文版" class="headerlink" title="1.《Machine Learning Yearning》完整中文版"></a>1.《Machine Learning Yearning》完整中文版</h6><p>链接:<a href="https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw">https://pan.baidu.com/s/1_ypJ5I0dtYiiyTRekxtRDw</a> </p>
<p>提取码:wxoj </p>
<h6 id="2-《百面机器学习》"><a href="#2-《百面机器学习》" class="headerlink" title="2.《百面机器学习》"></a>2.《百面机器学习》</h6><p>链接:<a href="https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ">https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ</a>  </p>
<p>密码:xbhr</p>
<h6 id="3-《统计学习方法》"><a href="#3-《统计学习方法》" class="headerlink" title="3.《统计学习方法》"></a>3.《统计学习方法》</h6><p>链接:<a href="https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA">https://pan.baidu.com/s/1k0yGfLj7SNbJuLO_2VSgYA</a>  </p>
<p>密码:m5qp</p>
<h6 id="4-《机器学习》周志华-西瓜书"><a href="#4-《机器学习》周志华-西瓜书" class="headerlink" title="4.《机器学习》周志华-西瓜书"></a>4.《机器学习》周志华-西瓜书</h6><p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a>  </p>
<p>密码:odp0</p>
<h6 id="5-《Artificial-Intelligence-A-Modern》"><a href="#5-《Artificial-Intelligence-A-Modern》" class="headerlink" title="5.《Artificial Intelligence_ A Modern》"></a>5.《Artificial Intelligence_ A Modern》</h6><p>链接:<a href="https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ">https://pan.baidu.com/s/1q3WActdeURgZ71YYnIRJaQ</a>  </p>
<p>密码:2t6s</p>
<h6 id="6-《贝叶斯思维统计建模的PYTHON学习法》"><a href="#6-《贝叶斯思维统计建模的PYTHON学习法》" class="headerlink" title="6.《贝叶斯思维统计建模的PYTHON学习法》"></a>6.《贝叶斯思维统计建模的PYTHON学习法》</h6><p>链接: <a href="https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g">https://pan.baidu.com/s/102PeKZTCcz7POpfF20Vv0g</a> </p>
<p>提取码: 7t7x</p>
<h6 id="7-《机器学习实战》"><a href="#7-《机器学习实战》" class="headerlink" title="7.《机器学习实战》"></a>7.《机器学习实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA">https://pan.baidu.com/s/1_s7UYnjADjtj6N0I_oiVPA</a> </p>
<p>提取码: b9hw</p>
<h6 id="8-《机器学习与数据挖掘方法和应用》"><a href="#8-《机器学习与数据挖掘方法和应用》" class="headerlink" title="8.《机器学习与数据挖掘方法和应用》"></a>8.《机器学习与数据挖掘方法和应用》</h6><p>链接: <a href="https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw">https://pan.baidu.com/s/13b9k90a3-w6a0DlZGJCHlw</a> </p>
<p>提取码: rw5q</p>
<h6 id="9-《机器学习》中文版"><a href="#9-《机器学习》中文版" class="headerlink" title="9.《机器学习》中文版"></a>9.《机器学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw">https://pan.baidu.com/s/1lGHYAIwWxHAmow3RMGeGUw</a> </p>
<p>提取码: 387b</p>
<h6 id="10-《人工智能》复杂问题求解的结构和策略"><a href="#10-《人工智能》复杂问题求解的结构和策略" class="headerlink" title="10.《人工智能》复杂问题求解的结构和策略"></a>10.《人工智能》复杂问题求解的结构和策略</h6><p>链接: <a href="https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng">https://pan.baidu.com/s/1YKwaiTfWRd3Tb1WsSLfHng</a> </p>
<p>提取码: 5ji1</p>
<h6 id="11-《数据挖掘-实用机器学习技术》中文第二版"><a href="#11-《数据挖掘-实用机器学习技术》中文第二版" class="headerlink" title="11.《数据挖掘-实用机器学习技术》中文第二版"></a>11.《数据挖掘-实用机器学习技术》中文第二版</h6><p>链接: <a href="https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g">https://pan.baidu.com/s/1bvuhDW4kkkYOhvTnzXx16g</a> </p>
<p>提取码: ek29</p>
<h6 id="12-《数据挖掘-数据-模型-算法》"><a href="#12-《数据挖掘-数据-模型-算法》" class="headerlink" title="12.《数据挖掘-数据-模型-算法》"></a>12.《数据挖掘-数据-模型-算法》</h6><p>链接: <a href="https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg">https://pan.baidu.com/s/1sUWIK_GlV1SOz9y5aXhtNg</a> </p>
<p>提取码: iwde</p>
<h6 id="13-《数据挖掘概念与技术-中文版-》"><a href="#13-《数据挖掘概念与技术-中文版-》" class="headerlink" title="13.《数据挖掘概念与技术(中文版)》"></a>13.《数据挖掘概念与技术(中文版)》</h6><p>链接: <a href="https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ">https://pan.baidu.com/s/1aN__UitC-loKtgtGWlNIKQ</a> </p>
<p>提取码: 44c4</p>
<h6 id="14-《数据挖掘实用案例分析》"><a href="#14-《数据挖掘实用案例分析》" class="headerlink" title="14.《数据挖掘实用案例分析》"></a>14.《数据挖掘实用案例分析》</h6><p>链接: <a href="https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ">https://pan.baidu.com/s/1eEtpfuMhsyKoiu9gJn2yRQ</a> </p>
<p>提取码: d6fx</p>
<h6 id="15-《Web数据挖掘》"><a href="#15-《Web数据挖掘》" class="headerlink" title="15.《Web数据挖掘》"></a>15.《Web数据挖掘》</h6><p>链接: <a href="https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw">https://pan.baidu.com/s/1gXNWqo1v4vZWN9wZPa4svw</a> </p>
<p>提取码: tmy4</p>
<h5 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h5><h6 id="1-《推荐算法在业界的应用实践合集》"><a href="#1-《推荐算法在业界的应用实践合集》" class="headerlink" title="1.《推荐算法在业界的应用实践合集》"></a>1.《推荐算法在业界的应用实践合集》</h6><p>链接:<a href="https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ">https://pan.baidu.com/s/15DcwIbYf-XvOWCcpsX9uBQ</a>  </p>
<p>密码:3qbx</p>
<h6 id="2-《推荐系统实践》"><a href="#2-《推荐系统实践》" class="headerlink" title="2.《推荐系统实践》"></a>2.《推荐系统实践》</h6><p>链接:<a href="https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig">https://pan.baidu.com/s/1bAsYKO0H3c-me9FXhqlMig</a>  </p>
<p>密码:w1qj</p>
<h5 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h5><h6 id="1-2020最新版《神经网络与深度学习》中文版"><a href="#1-2020最新版《神经网络与深度学习》中文版" class="headerlink" title="1. 2020最新版《神经网络与深度学习》中文版"></a>1. 2020最新版《神经网络与深度学习》中文版</h6><p>链接: <a href="https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg">https://pan.baidu.com/s/1ZELUoiLo9cLhyRqzxo-6pg</a>  </p>
<p>密码: 7cor</p>
<h6 id="2-《神经网络与机器学习》"><a href="#2-《神经网络与机器学习》" class="headerlink" title="2. 《神经网络与机器学习》"></a>2. 《神经网络与机器学习》</h6><p>链接: <a href="https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg">https://pan.baidu.com/s/1qs9wAX-lYBwwE_bO4nhiNg</a> </p>
<p>提取码: 5py4</p>
<h6 id="3-《TensorFlow实践与智能系统》"><a href="#3-《TensorFlow实践与智能系统》" class="headerlink" title="3. 《TensorFlow实践与智能系统》"></a>3. 《TensorFlow实践与智能系统》</h6><p>链接: <a href="https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg">https://pan.baidu.com/s/1EccZH2ZtJoC5ujb-7hgRdg</a> </p>
<p>提取码: 9iq7</p>
<h6 id="4-《Tensorflow实战Google深度学习框架》"><a href="#4-《Tensorflow实战Google深度学习框架》" class="headerlink" title="4. 《Tensorflow实战Google深度学习框架》"></a>4. 《Tensorflow实战Google深度学习框架》</h6><p>链接: <a href="https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA">https://pan.baidu.com/s/1wJ0h86DA3kNf_8smoPNPeA</a> </p>
<p>提取码: ybr9</p>
<h4 id="六、其他书籍"><a href="#六、其他书籍" class="headerlink" title="六、其他书籍"></a>六、其他书籍</h4><h6 id="1-《计算广告：互联网商业变现的市场与技术-刘鹏》"><a href="#1-《计算广告：互联网商业变现的市场与技术-刘鹏》" class="headerlink" title="1. 《计算广告：互联网商业变现的市场与技术-刘鹏》"></a>1. 《计算广告：互联网商业变现的市场与技术-刘鹏》</h6><p>链接:<a href="https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg">https://pan.baidu.com/s/1IxhuOXTGnS11ETHmVGxEBg</a>  </p>
<p>密码:uj8o</p>
<h6 id="2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】"><a href="#2-Sed-and-Awk-101-Hacks-中文版【sed和awk经典书籍】" class="headerlink" title="2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】"></a>2. Sed and Awk 101 Hacks -中文版【sed和awk经典书籍】</h6><p>链接:<a href="https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ">https://pan.baidu.com/s/1L2hJuEQQJZuhamLirIi4rQ</a>  </p>
<p>密码:46s7</p>
<h6 id="3-《Go语言实战》"><a href="#3-《Go语言实战》" class="headerlink" title="3. 《Go语言实战》"></a>3. 《Go语言实战》</h6><p>链接:<a href="https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw">https://pan.baidu.com/s/1mWOzCk1VlWs_zCTo6tr3Mw</a>  密码:277h</p>
<h6 id="4-《第一行代码-Android》"><a href="#4-《第一行代码-Android》" class="headerlink" title="4. 《第一行代码-Android》"></a>4. 《第一行代码-Android》</h6><p>链接:<a href="https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g">https://pan.baidu.com/s/1f1uJXr3aLiFPhh9FtuBJ7g</a>  </p>
<p>密码:bvqp</p>
<h6 id="5-《数据库原理（第5版）》"><a href="#5-《数据库原理（第5版）》" class="headerlink" title="5. 《数据库原理（第5版）》"></a>5. 《数据库原理（第5版）》</h6><p>链接:<a href="https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q">https://pan.baidu.com/s/1jR-uS6VtNQYj6A_PfePm8Q</a>  </p>
<p>密码:kfi2</p>
<h6 id="5-《VIM-思维导图》"><a href="#5-《VIM-思维导图》" class="headerlink" title="5. 《VIM 思维导图》"></a>5. 《VIM 思维导图》</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="6-《编程之美》完整版"><a href="#6-《编程之美》完整版" class="headerlink" title="6. 《编程之美》完整版"></a>6. 《编程之美》完整版</h6><p>链接:<a href="https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g">https://pan.baidu.com/s/1b9kPg8nwanLDQRWeQjqm4g</a>  </p>
<p>密码:191m</p>
<h6 id="7-《代码大全2中文版》"><a href="#7-《代码大全2中文版》" class="headerlink" title="7. 《代码大全2中文版》"></a>7. 《代码大全2中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg">https://pan.baidu.com/s/1plrFrYNY4hyVr6wPV7ppKg</a> </p>
<p>提取码: ag4d</p>
<h6 id="8-《代码整洁之道》"><a href="#8-《代码整洁之道》" class="headerlink" title="8. 《代码整洁之道》"></a>8. 《代码整洁之道》</h6><p>链接: <a href="https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ">https://pan.baidu.com/s/1b6e2CgZ0GMvvwJykjMJ2RQ</a> </p>
<p>提取码: 5d2v</p>
<h6 id="9-《高性能mysql第三版》"><a href="#9-《高性能mysql第三版》" class="headerlink" title="9. 《高性能mysql第三版》"></a>9. 《高性能mysql第三版》</h6><p>链接: <a href="https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA">https://pan.baidu.com/s/1LNq9hI-Of7ogAidF1r3mqA</a> </p>
<p>提取码: imjb</p>
<h6 id="10-《黑客与画家》"><a href="#10-《黑客与画家》" class="headerlink" title="10. 《黑客与画家》"></a>10. 《黑客与画家》</h6><p>链接: <a href="https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg">https://pan.baidu.com/s/1UcPMzHEOm1I_pPS37Jz_dg</a> </p>
<p>提取码: rqem</p>
<h6 id="11-《汇编语言》-第3版-王爽著"><a href="#11-《汇编语言》-第3版-王爽著" class="headerlink" title="11. 《汇编语言》(第3版)王爽著"></a>11. 《汇编语言》(第3版)王爽著</h6><p>链接: <a href="https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg">https://pan.baidu.com/s/1VYJzDko9B8RsIwGKCK7xHg</a> </p>
<p>提取码: 9au5</p>
<h6 id="12-《计算机程序设计艺术-第一卷-》"><a href="#12-《计算机程序设计艺术-第一卷-》" class="headerlink" title="12. 《计算机程序设计艺术(第一卷)》"></a>12. 《计算机程序设计艺术(第一卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw">https://pan.baidu.com/s/1NMrn_qijPaLsuCiNUUF5Kw</a> </p>
<p>提取码: 5qgb</p>
<h6 id="13-《计算机程序设计艺术-第二卷-》"><a href="#13-《计算机程序设计艺术-第二卷-》" class="headerlink" title="13. 《计算机程序设计艺术(第二卷)》"></a>13. 《计算机程序设计艺术(第二卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ">https://pan.baidu.com/s/1cFeVVtNOWGbriu8-qcL-zQ</a> </p>
<p>提取码: 8rsz</p>
<h6 id="14-《计算机程序设计艺术-第三卷-》"><a href="#14-《计算机程序设计艺术-第三卷-》" class="headerlink" title="14. 《计算机程序设计艺术(第三卷)》"></a>14. 《计算机程序设计艺术(第三卷)》</h6><p>链接: <a href="https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w">https://pan.baidu.com/s/1cA_niupvuzgQzTLVtsLI3w</a> </p>
<p>提取码: dtwr </p>
<h6 id="15-《精通正则表达式》"><a href="#15-《精通正则表达式》" class="headerlink" title="15. 《精通正则表达式》"></a>15. 《精通正则表达式》</h6><p>链接: <a href="https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw">https://pan.baidu.com/s/18NhdlOz7r8ICwTfsKWp7Rw</a> </p>
<p>提取码: d762</p>
<h6 id="16-《浪潮之巅》-完整版"><a href="#16-《浪潮之巅》-完整版" class="headerlink" title="16. 《浪潮之巅》(完整版)"></a>16. 《浪潮之巅》(完整版)</h6><p>链接: <a href="https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA">https://pan.baidu.com/s/1d2F7DJYZobwXbBAIBX2JFA</a> </p>
<p>提取码: r5y2</p>
<h6 id="17-《图解设计模式》"><a href="#17-《图解设计模式》" class="headerlink" title="17. 《图解设计模式》"></a>17. 《图解设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog">https://pan.baidu.com/s/1S3jRtSGKvDVHDPP0QjApog</a> </p>
<p>提取码: p3wn</p>
<h6 id="18-《学习Go语言-Golang-》"><a href="#18-《学习Go语言-Golang-》" class="headerlink" title="18. 《学习Go语言(Golang)》"></a>18. 《学习Go语言(Golang)》</h6><p>链接: <a href="https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ">https://pan.baidu.com/s/1bP3MTPuB8HKe_MSP2GqzkQ</a> </p>
<p>提取码: vw22</p>
<h6 id="19-《研磨设计模式》"><a href="#19-《研磨设计模式》" class="headerlink" title="19. 《研磨设计模式》"></a>19. 《研磨设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg">https://pan.baidu.com/s/1izMuD7GHYo39E7U4B9tkOg</a> </p>
<p>提取码: nmyf</p>
<h6 id="20-《HeadFirst设计模式》"><a href="#20-《HeadFirst设计模式》" class="headerlink" title="20. 《HeadFirst设计模式》"></a>20. 《HeadFirst设计模式》</h6><p>链接: <a href="https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg">https://pan.baidu.com/s/10_UvT-8j_jwJLQzIULL2rg</a> </p>
<p>提取码: 33ff</p>
<h6 id="21-《Maven实战》"><a href="#21-《Maven实战》" class="headerlink" title="21. 《Maven实战》"></a>21. 《Maven实战》</h6><p>链接: <a href="https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A">https://pan.baidu.com/s/1Dhme4PtAW8NhdvPB4xFM9A</a> </p>
<p>提取码: x5xv</p>
<h6 id="22-《MongoDB权威指南》"><a href="#22-《MongoDB权威指南》" class="headerlink" title="22. 《MongoDB权威指南》"></a>22. 《MongoDB权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ">https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ</a> </p>
<p>提取码: sj6a</p>
<h6 id="21-《Pro-Git中文版》"><a href="#21-《Pro-Git中文版》" class="headerlink" title="21. 《Pro Git中文版》"></a>21. 《Pro Git中文版》</h6><p>链接: <a href="https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw">https://pan.baidu.com/s/1anGEASiinAIU3eo_tcnGUw</a> </p>
<p>提取码: eeg1</p>
<h6 id="22-《SQL查询的艺术》"><a href="#22-《SQL查询的艺术》" class="headerlink" title="22. 《SQL查询的艺术》"></a>22. 《SQL查询的艺术》</h6><p>链接: <a href="https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q">https://pan.baidu.com/s/12qSyjdsLNPB5nRkqg7kH2Q</a> </p>
<p>提取码: khvi</p>
<h6 id="23-《SQLite权威指南》"><a href="#23-《SQLite权威指南》" class="headerlink" title="23. 《SQLite权威指南》"></a>23. 《SQLite权威指南》</h6><p>链接: <a href="https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw">https://pan.baidu.com/s/13LnE4T_-UvITr3nDlgVhcw</a> </p>
<p>提取码: 9dqe</p>
<hr>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>【百度一面】怒喷面试官！不就是树遍历时增加一个行号？</title>
    <url>/posts/232fafd8/</url>
    <content><![CDATA[<p>读前福利：几百本互联网技术书籍送给大家<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<p><img src="/images/2186f8ac6fddd8d768ccb900aaa447551.jpg" width="98%" height="98%"></p>
<p>【0】</p>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这是今天我从同事跳槽到快手一面的一个题目，虽然不是太难，但是听说也是卡了好半天，抽空大家不妨也作为饭后甜点看看(^o^)/~</p>
<p>个人感觉这属于那种见过就一定会的那种题目，如果没太接触过这种类似leetcode题目的话，还是得想一会儿的</p>
<p>下面咱们来一起看看，从题目出发… </p>
<p>【1】</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>要求按照下面的格式将树信息打印出来，看着很是直观的打印结果</p>
<p><img src="/images/5ed84cfdcc9877d9acef2a7550a0901a1.jpg" width="98%" height="98%"></p>
<p><strong>要求输出格式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 第一行</span><br><span class="line">B C -&gt; 第二行</span><br><span class="line">D E F -&gt; 第三行</span><br><span class="line">G H -&gt; 第四行</span><br></pre></td></tr></table></figure>
<p>就是按照给定的格式进行结点的打印</p>
<p>【3】</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>很明显的可以看到，在实现该结果的同时，大致解决思路一定是基于过去咱们看到过的层次遍历的方式</p>
<p>在层次遍历的同时，记录每次换行操作时候的动作</p>
<p>在这所有之前，咱们先给出来结点信息，以便后面清楚的对图中二叉树进行操作</p>
<p>【利用Python看，简单又直观】</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.val = value        <span class="comment"># 结点值</span></span><br><span class="line">        self.left = <span class="literal">None</span>        <span class="comment"># 指向做孩子</span></span><br><span class="line">        self.right = <span class="literal">None</span>        <span class="comment"># 指向右孩子</span></span><br></pre></td></tr></table></figure>
<p>需要回顾层次遍历代码的可以翻到文末，进行了层次遍历的展现，这里有过去用<a href="https://mp.weixin.qq.com/s/-jadDaU_lGBXn5VIGHwJSQ">C语言实现</a>的代码</p>
<p>由于题目中要求在打印结点信息的同时，要求给出结点所在行和列的信息</p>
<p>利用层次遍历遍历的特点（<strong>重点！重点！重点！在当前层的所有结点元素入队之后，上一层最后一个结点元素才会弹出</strong>），初始化两个指针 last 和 cur</p>
<ul>
<li>last 指向上一层最右侧结点</li>
<li>cur 是当前结点位置【往队列中输入的结点】</li>
</ul>
<p>只有当弹出的元素 与 last 指向的结点相同，说明 cur 也遍历到了当前层的最右面。此时，可以令 last = cur</p>
<p>具体细节流程，看下面[长长长长长…]图</p>
<p><img src="/images/5ed84cfdcc9877d9acef2a7550a0901a2.jpg" width="98%" height="98%"></p>
<p>以上，基于给定的树状结构进行了细致的说明，供大家参考。另外个人不太喜欢动图，原因是想要看清楚每一步的时候，不容易控制</p>
<p>对于队列的操作，利用 Python 的 list 数据结构实现的方式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 入队</span></span><br><span class="line"><span class="built_in">list</span>.append(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 出队</span></span><br><span class="line"><span class="built_in">list</span>.append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>下面给出完整代码，并且给出构造树的代码已经层次遍历的代码</p>
<p>可以直接贴到自己的环境中进行实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># !/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 树结点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.val = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 队列queue</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        print(node.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            queue.append(node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order_traverse_datail</span>(<span class="params">root</span>):</span></span><br><span class="line">    last, n_last = root, root</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 队列queue</span></span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        print(node.val, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> node.left:</span><br><span class="line">            n_last = node.left</span><br><span class="line">            queue.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right:</span><br><span class="line">            n_last = node.right</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        <span class="comment"># 当弹出的结点是last指向的结点时，令 last = n_last</span></span><br><span class="line">        <span class="keyword">if</span> last <span class="keyword">is</span> node:</span><br><span class="line">            last = n_last</span><br><span class="line">            print(<span class="string">&quot; -&gt; 第 %d 行&quot;</span> % i)</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 新建节点</span></span><br><span class="line">    node_A = TreeNode(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">    node_B = TreeNode(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">    node_C = TreeNode(<span class="string">&quot;C&quot;</span>)</span><br><span class="line">    node_D = TreeNode(<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    node_E = TreeNode(<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    node_F = TreeNode(<span class="string">&quot;F&quot;</span>)</span><br><span class="line">    node_G = TreeNode(<span class="string">&quot;G&quot;</span>)</span><br><span class="line">    node_H = TreeNode(<span class="string">&quot;H&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建二叉树</span></span><br><span class="line">    <span class="comment">#      A</span></span><br><span class="line">    <span class="comment">#    /   \</span></span><br><span class="line">    <span class="comment">#   B     C</span></span><br><span class="line">    <span class="comment">#  /     / \</span></span><br><span class="line">    <span class="comment"># D     E   F</span></span><br><span class="line">    <span class="comment">#      / \</span></span><br><span class="line">    <span class="comment">#     G   H</span></span><br><span class="line"></span><br><span class="line">    node_A.left, node_A.right = node_B, node_C</span><br><span class="line">    node_B.left = node_D</span><br><span class="line">    node_C.left, node_C.right = node_E, node_F</span><br><span class="line">    node_E.left, node_E.right = node_G, node_H</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印结点元素</span></span><br><span class="line">    print(<span class="string">&quot;层次遍历结果：&quot;</span>)</span><br><span class="line">    level_order_traverse(node_A)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;\n层次遍历结果(打印行号)：&quot;</span>)</span><br><span class="line">    level_order_traverse_datail(node_A)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 统计各个年龄阶段的人数</title>
    <url>/posts/c7081fb8/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<p><img src="/images/3.jpg" width="90%" height="90%"></p>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：统计各个年龄阶段的人数</p>
<p>描述：</p>
<p>N个年龄通过调用随机函数获得，并存放在主函数的age中<br>要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</p>
<p>结果在主函数中输出</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>随机使用 rand() 函数，头文件为#include <stdlib.h></stdlib.h></p>
<p>rand()函数是按指定的顺序来产生整数，因此每次执行上面的语句都打印相同的两个值，所以说C语言的随机并不是真正意义上的随机，有时候也叫伪随机数，使用 rand() 生成随机数之前需要用随机发生器的初始化函数 srand(unsigned seed)（也位于 stdlib.h 中） 进行伪随机数序列初始化，seed 又叫随机种子，通俗讲就是，如果每次提供的 seed 是一样的话，最后每一轮生成的几个随机值也都是一样的，因此叫伪随机数，所以需要每次提供不同的 seed 达到完全的随机，我们通常用时间函数 time(NULL) 作为 seed ，因为时间值每秒都不同，但是在此题中使用不到time这个工具</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计各个年龄阶段的人数</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">N个年龄通过调用随机函数获得，并存放在主函数的age中</span></span><br><span class="line"><span class="comment">要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</span></span><br><span class="line"><span class="comment">结果在主函数中输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *age, <span class="keyword">int</span> *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(age+i)&lt;<span class="number">100</span>) &#123;</span><br><span class="line">            d[(*(age+i))/<span class="number">10</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d[M<span class="number">-1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> age[N];        <span class="comment">// 100个用户</span></span><br><span class="line">    <span class="keyword">int</span> d[M]=&#123;<span class="number">0</span>&#125;;         <span class="comment">// 11个年龄段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(age+i) = rand()%<span class="number">121</span>;    <span class="comment">// 设定年龄的范围是0-120</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(age, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;各年龄阶段人数数量：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex004.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">各年龄阶段人数数量：</span><br><span class="line">10 9 8 4 10 8 7 7 6 11 20</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 统计一行字符串单词的个数，作为函数值返回</title>
    <url>/posts/596c8a1b/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<p><img src="/images/2.jpg" width="90%" height="90%"></p>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：统计一行字符串单词的个数，作为函数值返回</p>
<p>一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>逐个字符进行判断是否为空</p>
<p><em>下面“空开处”指的是一个空格或者若干空格隔开单词的说法</em></p>
<ol>
<li>开头无空格，故需要判断结尾有没有空开出，如果有，直接计算空开出就是单词数，如果没有需要单词数加1</li>
<li>上述1中的空开出需要做处理，由于单词间由若干空格隔开，故判断一个空格的前一个是否为空格，如果不是，数量加1；如果是，不做处理</li>
</ol>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计一行字符串单词的个数，作为函数值返回</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>; 	<span class="comment">// 单词个数</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(*(s+i)!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (*(s+i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; *(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			cnt += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (*(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;	<span class="comment">// 如果单词结尾没有空格，则单词数需要空开数+1</span></span><br><span class="line">		<span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[] = <span class="string">&quot;hello world      i am c language&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;字符串内容：%s\n&quot;</span>, s);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;单词个数为：%d\n&quot;</span>, fun(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex003.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">字符串内容：hello world      i am c language</span><br><span class="line">单词个数为：6</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>布隆过滤器(BloomFilter)原理 | 亿级数据过滤解决方案</title>
    <url>/posts/ba26fe62/</url>
    <content><![CDATA[<p>读前福利：几百本互联网技术书籍送给大家<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw</a></p>
<p><img src="/images/15.jpg" width="100%" height="100%"></p>
<blockquote>
<p>1970 年，<strong>布隆先生</strong>提出了一种很优秀的过滤器算法，用来判断一个元素是否在集合中</p>
<p>「布隆过滤器算法」</p>
<p><strong>故事开始</strong>→_→</p>
</blockquote>
<p><strong>先看本故事结构</strong></p>
<p><img src="/images/7082216a05225e2828d568baab4754a31.jpg" width="80%" height="80%"></p>
<p>就当前互联网环境来说，头部的互联网生态越来越往高并发、分布式的形态发展。举例来说，各大网页的黑名单系统，爬虫的重复率判断。这些场景越来越多。</p>
<p>举例来说，实时状态下可能会对超过百亿级别的 URL 需要进行判断是否符合规范或者存在于系统中，能否正常使用。</p>
<p>通常情况下，每个 URL 的大小为 64B（字节），那么就按照100亿的 URL 数量来看，大概需要640GB的内存容量【$64 \times 100\text{亿}/1024^3$】，对于当前线上服务器来说，… 这个值依然还是很大的！但如果利用布隆过滤器的优势，在没有失误率的情况下只需要100亿个比特，即：1.2GB，即使为了降低失误率，也不会超过几十GB的空间【失误率后面会谈到】</p>
<p>那么在这种情况下，利用<strong>布隆过滤器</strong>来解决的确是很优秀，优秀到维基百科这样说「<strong>它的优点是空间效率和查询时间都远远超过一般的算法</strong>」，空间复杂度和时间复杂度都远超一般的算法，布隆过滤器存储空间和插入/查询时间都是常数O(1)！<strong>注意：远超！！</strong></p>
<p><strong><em>看着来自各方面这么牛B 的吹嘘，咱们把布隆过滤器安排到方方面面，来具体看看它的原理是怎么样的…</em></strong></p>
<p>维基百科的概念：布隆过滤器实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。基于这个解释，下面从  </p>
<p><img src="/images/7082216a05225e2828d568baab4754a32.jpg" width="80%" height="80%"></p>
<p>等方面系统性的说道说道…</p>
<p>【1】</p>
<h4 id="主要作用：判断一个元素是否在集合中"><a href="#主要作用：判断一个元素是否在集合中" class="headerlink" title="主要作用：判断一个元素是否在集合中"></a>主要作用：判断一个元素是否在集合中</h4><p>这样的场景会有很多。会去判断，要查询的元素是否存在于集合当中。【该网站是否允许该用户登录、该网站共是否接受这样的 url 请求】</p>
<p>通常在查询的时候，一般会先从 cache 中进行查询，如果没有的话会直接到磁盘或者数据库查询，这样的方式看起来很合理，但是如果在中间再加一层<strong>布隆顾虑器</strong>，这样就会更加合理了！为什么？</p>
<p>假设要查询的一个元素，而该元素不存在</p>
<p>a. 如果没有 BloomFilter，从cache中查询完就会直接到数据库做查询了，这样带来的现象是“慢”，毕竟从库中查耗时是比较长的，很大程度上对服务的性能产生影响。</p>
<p>b. 中间存在 BloomFilter，从cache中查询完就会首先查询 BloomFilter，就会发现该元素不存在，就可以不往后面进行查询了，而 BloomFilter 的性能是极其优越的。这样，对于机器或者说服务性能避免了很大不必要的消耗。</p>
<p><img src="/images/7082216a05225e2828d568baab4754a33.jpg" width="80%" height="80%"></p>
<p>就上图所示，假设元素不存在，如果没有布隆过滤器，就直接会查询【磁盘/数据库】，这样会带来很大不必要的性能消耗！</p>
<blockquote>
<p>既然效率这么高，那到底是什么原因呢？</p>
</blockquote>
<p>【2】</p>
<h4 id="数据结构：二进制数组-hash算法"><a href="#数据结构：二进制数组-hash算法" class="headerlink" title="数据结构：二进制数组+hash算法"></a>数据结构：二进制数组+hash算法</h4><h5 id="二进制数组"><a href="#二进制数组" class="headerlink" title="二进制数组"></a>二进制数组</h5><p>这个是最关键的一个数据结构，会将每一个元素经过 hash 算法映射到每一个二进制数组中去。</p>
<p>开篇讲到在时间复杂度和空间复杂度方面来说，都是在常数级别，这也归功于一个数据结构就是由比特位构成的数组，所以在空间这块是很有优势的。就拿一个URL 64B来说，对应比特位就是1，大概是 <strong>64*8:1</strong> 这个空间比例。</p>
<h5 id="hash-算法"><a href="#hash-算法" class="headerlink" title="hash 算法"></a>hash 算法</h5><p><img src="/images/7082216a05225e2828d568baab4754a34.jpg" width="80%" height="80%"></p>
<p>对于hash算法来说，应该是比较熟悉了，数据元素经过 hash 函数会映射到不同的数组中，如果发生冲突可以使用一些方法进行解决，比如说是拉链法解决。</p>
<p>hash 函数应用在 BloomFilter 中的时候，与一般的 hash 函数处理有区别的地方是：</p>
<p>a. BloomFilter 将值不会映射到一个地址，而是映射到对应的二进制数组位，然后将该数组为置为 1</p>
<p>b. BloomFilter 不会采用 hash 函数中常用的解决地址冲突的方法，而是会将同一个元素，经过几个 hash function 后，将对应二进制数组位置置为 1，后期如果进行查询的时候，<strong>只有经过hash函数后，几个位置同时为1，才可以判断该元素存在</strong>。</p>
<p>看下图：</p>
<p><img src="/images/7082216a05225e2828d568baab4754a35.jpg" width="80%" height="80%"></p>
<p>按照图例，每个数据元素会经过 3 个不同的 hash function，然后对应到不同的二进制数组位，并且置为 1，这样一方面减小了冲突的概率，另外一方面会减小误差率。</p>
<p>当一个客户端查询过来，对于 URL1、URL2 和 URL3 在BloomFilter 中都是存在的，所以对这三个元素进行查询的时候，一定是可以查到的。</p>
<p>下面咱们试着用 URL1、URL4 和 URL5 进行举例说明：查找成功、查找不存在以及查找失误这三种真实存在的情况。【下图👇】</p>
<p><img src="/images/7082216a05225e2828d568baab4754a36.jpg" width="80%" height="80%"></p>
<p>在 BloomFilter 的二进制数组右边是指的进行客户端查询 URL1、URL4 和 URL5时候的情况，可以看到：</p>
<ul>
<li>URL1：完全可以和存储 URL1 时候的数组位能够对应上并且同时都为1，即位置：1、5、9。查询成功！</li>
<li>URL4：在数组位 2 处为0，其余为 1，导致三个位置不全为1，查找不存在，返回空！</li>
<li>URL5：URL5 的三个二进制数组位都为 1，按原理说结果是URL5元素存在于BloomFilter中，但是可以清楚看到，查询有错误！这个就是查询产生失误的情况。</li>
</ul>
<p>这也就能够说明，BloomFIlter在空间和时间方面是极其优秀的，都达到了 O(1) 的级别，但是缺点是存在误识别率。</p>
<p>在这里注意，误识别率仅仅是存在查找成功的情况下，查询不存在是没有误识别率的。即：</p>
<ul>
<li>查询存在：存在误识别率，就上面图示所示</li>
<li>查询不存在：肯定不会存在都是 1 的情况，所以这方面不会存在误识别率</li>
</ul>
<p>【3】</p>
<h4 id="优势：省空间-高性能"><a href="#优势：省空间-高性能" class="headerlink" title="优势：省空间+高性能"></a>优势：省空间+高性能</h4><h5 id="省空间"><a href="#省空间" class="headerlink" title="省空间"></a>省空间</h5><p>这个在URL长度的案例说到，正是采用了二进制数组，一个元素经过 hash 函数对应着一个数组位（比特位），如果是真实存储一个URL（64B）的话，这就空间比例大约是<strong>64*8:1</strong>，即512:1</p>
<p>比特数组促使 BloomFilter 会省很大的空间，就空间效率来说，是极其高效的。</p>
<h5 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h5><p>BloomFilter 不存在像链表查询一样，需要一个一个去遍历。反而会像数组一样，类似于直接取下标就可以找到所需要的结果。</p>
<p>不同的是，BloomFilter 需要过几个hash function，去查找下标。所以，综合来看，性能是很高的！</p>
<p>综合时间和空间效率，在有很低的误识别率情况下，各方面都是远超其他算法的。</p>
<p>【4】</p>
<h4 id="不足：有误判-不能删除元素"><a href="#不足：有误判-不能删除元素" class="headerlink" title="不足：有误判+不能删除元素"></a>不足：有误判+不能删除元素</h4><h5 id="有误判的情况-hash存在冲突"><a href="#有误判的情况-hash存在冲突" class="headerlink" title="有误判的情况 - hash存在冲突"></a>有误判的情况 - hash存在冲突</h5><p>在前面举例 URL5 的时候，这种情况就会使得查询出现了失误，这也是传统hash冲突的直接表现，同时这也是使用了几个 hash 函数的原因。而这种错误识别，后期可以使用白名单的形式进行标记以补全这方面的不足。</p>
<p>但是在真正工业界的使用来看，这种冲突或者说查询失误也是保持在 0.01% 以下，一方面会考量 hash 函数的使用，另外一方面会增大 BloomFilter 二进制数组的位数来避免这种冲突。</p>
<p>那么，就上面两个考虑的方面，来具体看看：到底需要<strong>多大的二进制数组的长度</strong>以及<strong>多少个hash 函数</strong> 才可以使得上述案例的失误率保持在 0.01% 以下？</p>
<p><strong>二进制bit数组长度的选取</strong></p>
<p>记：$n=100$亿，$p=0.01%$， BloomFilter 的二进制bit数组长度 m 使用以下公式决定的：</p>
<script type="math/tex; mode=display">
m=\frac{n\times ln p}{(ln 2)^2}</script><p>可以求得：m=19.19n，即二进制bit数组长度大概是元素个数 n 的20倍，需要200亿个bit位，相当于大约25GB的空间，对于我们普通工业界的服务器来说，是足够容纳这个数组的</p>
<p><strong>最好需要多少个 hash 函数</strong></p>
<p>业界一般用这个公式来计算需要 k 个 hash 函数：</p>
<script type="math/tex; mode=display">
k=ln2 \times \frac {m}{n} = 0.7 \times \frac {m}{n} = 14</script><p>即：需要 14 个 hash 函数来进行构造</p>
<p>根据上述的计算，可以得到我们要使用 BloomFilter 的最佳方案</p>
<h5 id="不能删除元素"><a href="#不能删除元素" class="headerlink" title="不能删除元素"></a>不能删除元素</h5><p>这个就很好理解了，不同的元素通过 hash 函数使得相应位置都置为了 1，是绝对不能删除该元素，将它对应的位置置为 0 的。</p>
<p>下图中的 URL1 和 URL2，经过 hash 函数后，其中一个hash结果都指向了二进制数组中的3位置【红色箭头】，如果现在想要删除URL1，那么，按理说应该将 URL1 hash后指向的二进制数组对应位置都置为 0 才对，显然，这样做是不行的，会影响到 URL2 的查询。</p>
<p><img src="/images/7082216a05225e2828d568baab4754a37.jpg" width="80%" height="80%"></p>
<p>【5】</p>
<h4 id="业界应用"><a href="#业界应用" class="headerlink" title="业界应用"></a>业界应用</h4><p>工业界会有很多这种场景会使用到，例如：</p>
<ul>
<li><p>博客系统黑名单限制</p>
</li>
<li><p>爬虫重复率的判定</p>
</li>
<li><p>比特币的应用</p>
</li>
<li><p>垃圾邮件过滤</p>
<p>等等…</p>
</li>
</ul>
<p>不过大致都是很通用的一些解决方案，比如下图所示：</p>
<p>在信息写入的时候，会同时写入到缓存、数据库和布隆过滤器。需要查询的时候，先进行对缓存进行查询，如果找不到的话，就会先使用 BloomFilter 进行判断是否存在，如果存在就会继续向数据库查询；如果不存在，就直接返回空了。</p>
<p>这样在很大程度上提升了应用服务的效率！</p>
<p><img src="/images/7082216a05225e2828d568baab4754a38.jpg" width="80%" height="80%"></p>
<hr>
<h4 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</title>
    <url>/posts/2e6bba8d/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<p><img src="/images/1.jpg" width="90%" height="90%"></p>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>编写：fun()</p>
<p>功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</p>
<p>例如：</p>
<p>二维数组中的数据为：</p>
<p>W W W W</p>
<p>S S S S</p>
<p>H H H H</p>
<p>则字符串中的内容是：WSHWSHWSH</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>第一层循环按照列数进行，第二层循环按照行数</p>
<p>然后依次提出每一列的字符</p>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><p>为了熟悉二维数组的指针表示，部分代码给出了数组表示和指针表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写：fun()</span></span><br><span class="line"><span class="comment">功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">二维数组中的数据为：</span></span><br><span class="line"><span class="comment">W W W W</span></span><br><span class="line"><span class="comment">S S S S</span></span><br><span class="line"><span class="comment">H H H H</span></span><br><span class="line"><span class="comment">则字符串中的内容是：WSHWSHWSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   0 1 2 3</span></span><br><span class="line"><span class="comment">// 0 W W W W</span></span><br><span class="line"><span class="comment">// 1 S S S S</span></span><br><span class="line"><span class="comment">// 2 H H H H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[M][N], <span class="keyword">char</span> *res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            res[t++] = s[j][i];</span><br><span class="line">      <span class="comment">// res[t++] = *(*(a*i)+i);   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[t] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[M][N] = &#123;<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size_res = M*N;</span><br><span class="line">    <span class="keyword">char</span> res[size_res];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组中元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, a[i][j]);</span><br><span class="line">      <span class="comment">// printf(&quot;%c\t&quot;, *(*(a*i)+j));   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按列的顺序依次:\n%s\n&quot;</span>, fun(a, res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex002.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">二维数组中元素：</span><br><span class="line">M    M    M    M</span><br><span class="line">S    S    S    S</span><br><span class="line">H    H    H    H</span><br><span class="line">按列的顺序依次:</span><br><span class="line">MSHMSHMSHMSH</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例 | 将字符串转换为一个整数</title>
    <url>/posts/b762eb37/</url>
    <content><![CDATA[<blockquote>
<p>C经典88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<p><img src="/images/7.jpg" width="90%" height="90%"></p>
<h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><blockquote>
<p>函数：fun()</p>
<p>功能：将字符串转换为一个整数</p>
<p>描述：</p>
<p>【不能使用C语言提供的字符串函数】</p>
<p>输入：字符串”-1234”</p>
<p>输出：整型 -1234</p>
</blockquote>
<h2 id="2-思路"><a href="#2-思路" class="headerlink" title="2 思路"></a>2 思路</h2><p>思路：将字符串每个位置的字符进行对应的ASCII码转换</p>
<p>例如：字符 ‘0’-‘9’ 对应的十进制整数是48~57，那么，将对应的整数减去48就得到了对应的整数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：将字符串转换为一个整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">【不能使用C语言提供的字符串函数】</span></span><br><span class="line"><span class="comment">输入：字符串&quot;-1234&quot;</span></span><br><span class="line"><span class="comment">输出：整型 -1234</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>;		<span class="comment">//数字个数</span></span><br><span class="line">	<span class="keyword">long</span> res = <span class="number">0L</span>;	<span class="comment">// 转化后的数字</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;		<span class="comment">// 位数*10 *100 ...</span></span><br><span class="line">	<span class="keyword">int</span> size = <span class="built_in">strlen</span>(p); 	<span class="comment">// 字符串长度</span></span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">		r = size - <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		r = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从前往后转换的话，需要分情况去计算。即：不是负数的话从p[0] 和 如果是负数的话需要从p[1]开始</span></span><br><span class="line">	<span class="comment">// 所以，可以从后往前计算，循环次数是 r </span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">		res += (p[size<span class="number">-1</span>-i]<span class="number">-48</span>)*pos;</span><br><span class="line">		pos *= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>?-res:res; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">6</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">	gets(s);</span><br><span class="line">	<span class="keyword">long</span> res = fun(s);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Convert Result: %ld\n&quot;</span>, res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex1.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: -1234</span><br><span class="line">Convert Result: -1234</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: 9089</span><br><span class="line">Convert Result: 9089</span><br></pre></td></tr></table></figure>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>C经典88案例详解</title>
    <url>/posts/c065dba1/</url>
    <content><![CDATA[<blockquote>
<p>以下88案例打包下载地址<br>链接: <a href="https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw">https://pan.baidu.com/s/1niyqlgtX3AWWQ669aUHVNw</a><br>密码: uji4</p>
</blockquote>
<h3 id="案例ex01-将字符串转换为一个整数"><a href="#案例ex01-将字符串转换为一个整数" class="headerlink" title="案例ex01: 将字符串转换为一个整数"></a><strong>案例ex01: 将字符串转换为一个整数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：将字符串转换为一个整数<br>描述：</p>
<p>【不能使用C语言提供的字符串函数】</p>
<p>输入：字符串”-1234”</p>
<p>输出：整型 -1234</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>思路：将字符串每个位置的字符进行对应的ASCII码转换</p>
<p>例如：字符 ‘0’-‘9’ 对应的十进制整数是48~57，那么，将对应的整数减去48就得到了对应的整数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>二进制</th>
<th>十进制</th>
<th>十六进制</th>
<th>字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0011 0000</td>
<td>48</td>
<td>30</td>
<td>0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>49</td>
<td>31</td>
<td>1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>50</td>
<td>32</td>
<td>2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>51</td>
<td>33</td>
<td>3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>52</td>
<td>34</td>
<td>4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>53</td>
<td>35</td>
<td>5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>54</td>
<td>36</td>
<td>6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>55</td>
<td>37</td>
<td>7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>56</td>
<td>38</td>
<td>8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>57</td>
<td>39</td>
<td>9</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：将字符串转换为一个整数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">【不能使用C语言提供的字符串函数】</span></span><br><span class="line"><span class="comment">输入：字符串&quot;-1234&quot;</span></span><br><span class="line"><span class="comment">输出：整型 -1234</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;        <span class="comment">//数字个数</span></span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">0L</span>;    <span class="comment">// 转化后的数字</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">1</span>;        <span class="comment">// 位数*10 *100 ...</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(p);     <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        r = size - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前往后转换的话，需要分情况去计算。即：不是负数的话从p[0] 和 如果是负数的话需要从p[1]开始</span></span><br><span class="line">    <span class="comment">// 所以，可以从后往前计算，循环次数是 r</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; ++i) &#123;</span><br><span class="line">        res += (p[size<span class="number">-1</span>-i]<span class="number">-48</span>)*pos;</span><br><span class="line">        pos *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>?-res:res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">    gets(s);</span><br><span class="line">    <span class="keyword">long</span> res = fun(s);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Convert Result: %ld\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex1.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: -1234</span><br><span class="line">Convert Result: -1234</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Enter a string: 9089</span><br><span class="line">Convert Result: 9089</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex02-将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中"><a href="#案例ex02-将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中" class="headerlink" title="案例ex02: 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中"></a><strong>案例ex02: 将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>编写：fun()</p>
<p>功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</p>
<p>例如：</p>
<p>二维数组中的数据为：</p>
<p>W W W W</p>
<p>S S S S</p>
<p>H H H H</p>
<p>则字符串中的内容是：WSHWSHWSH</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>第一层循环按照列数进行，第二层循环按照行数</p>
<p>然后依次提出每一列的字符</p>
<p><strong>3 代码</strong></p>
<p>为了熟悉二维数组的指针表示，部分代码给出了数组表示和指针表示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">编写：fun()</span></span><br><span class="line"><span class="comment">功能：将M行N列的二维数组中的字符数据，按列的顺序依次放到一个字符串中</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">二维数组中的数据为：</span></span><br><span class="line"><span class="comment">W W W W</span></span><br><span class="line"><span class="comment">S S S S</span></span><br><span class="line"><span class="comment">H H H H</span></span><br><span class="line"><span class="comment">则字符串中的内容是：WSHWSHWSH</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   0 1 2 3</span></span><br><span class="line"><span class="comment">// 0 W W W W</span></span><br><span class="line"><span class="comment">// 1 S S S S</span></span><br><span class="line"><span class="comment">// 2 H H H H</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fun</span><span class="params">(<span class="keyword">char</span> s[M][N], <span class="keyword">char</span> *res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">            res[t++] = s[j][i];</span><br><span class="line">      <span class="comment">// res[t++] = *(*(a*i)+i);   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res[t] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[M][N] = &#123;<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;H&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size_res = M*N;</span><br><span class="line">    <span class="keyword">char</span> res[size_res];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二维数组中元素：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>, a[i][j]);</span><br><span class="line">      <span class="comment">// printf(&quot;%c\t&quot;, *(*(a*i)+j));   // 指针表示</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按列的顺序依次:\n%s\n&quot;</span>, fun(a, res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex002.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">二维数组中元素：</span><br><span class="line">M    M    M    M</span><br><span class="line">S    S    S    S</span><br><span class="line">H    H    H    H</span><br><span class="line">按列的顺序依次:</span><br><span class="line">MSHMSHMSHMSH</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex03-统计一行字符串单词的个数，作为函数值返回"><a href="#案例ex03-统计一行字符串单词的个数，作为函数值返回" class="headerlink" title="案例ex03: 统计一行字符串单词的个数，作为函数值返回"></a><strong>案例ex03: 统计一行字符串单词的个数，作为函数值返回</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：统计一行字符串单词的个数，作为函数值返回</p>
<p>一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>逐个字符进行判断是否为空</p>
<p><em>下面“空开处”指的是一个空格或者若干空格隔开单词的说法</em></p>
<ol>
<li>开头无空格，故需要判断结尾有没有空开出，如果有，直接计算空开出就是单词数，如果没有需要单词数加1</li>
<li>上述1中的空开出需要做处理，由于单词间由若干空格隔开，故判断一个空格的前一个是否为空格，如果不是，数量加1；如果是，不做处理</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计一行字符串单词的个数，作为函数值返回</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">一行字符串在主函数中输入，规定所有单词都是由小写字母组成，单词之间由若干空格隔开，一行的开始没有空格</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;     <span class="comment">// 单词个数</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*(s+i)!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(s+i) == <span class="string">&#x27; &#x27;</span> &amp;&amp; *(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*(s+i<span class="number">-1</span>) != <span class="string">&#x27; &#x27;</span>)&#123;    <span class="comment">// 如果单词结尾没有空格，则单词数需要空开数+1</span></span><br><span class="line">        <span class="keyword">return</span> cnt + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;hello world      i am c language&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符串内容：%s\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;单词个数为：%d\n&quot;</span>, fun(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex003.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">字符串内容：hello world      i am c language</span><br><span class="line">单词个数为：6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex04-统计各个年龄阶段的人数"><a href="#案例ex04-统计各个年龄阶段的人数" class="headerlink" title="案例ex04: 统计各个年龄阶段的人数"></a><strong>案例ex04: 统计各个年龄阶段的人数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：统计各个年龄阶段的人数</p>
<p>描述：</p>
<p>N个年龄通过调用随机函数获得，并存放在主函数的age中<br>要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</p>
<p>结果在主函数中输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>随机使用 rand() 函数，头文件为#include <stdlib.h></stdlib.h></p>
<p>rand()函数是按指定的顺序来产生整数，因此每次执行上面的语句都打印相同的两个值，所以说C语言的随机并不是真正意义上的随机，有时候也叫伪随机数，使用 rand() 生成随机数之前需要用随机发生器的初始化函数 srand(unsigned seed)（也位于 stdlib.h 中） 进行伪随机数序列初始化，seed 又叫随机种子，通俗讲就是，如果每次提供的 seed 是一样的话，最后每一轮生成的几个随机值也都是一样的，因此叫伪随机数，所以需要每次提供不同的 seed 达到完全的随机，我们通常用时间函数 time(NULL) 作为 seed ，因为时间值每秒都不同，但是在此题中使用不到time这个工具</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：统计各个年龄阶段的人数</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">N个年龄通过调用随机函数获得，并存放在主函数的age中</span></span><br><span class="line"><span class="comment">要求函数把0-9岁年龄段的放在d[0]中，把10-19岁年龄段的放在d[1]中，依次类推。把100岁及以上的放在d[10]中</span></span><br><span class="line"><span class="comment">结果在主函数中输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *age, <span class="keyword">int</span> *d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(age+i)&lt;<span class="number">100</span>) &#123;</span><br><span class="line">            d[(*(age+i))/<span class="number">10</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            d[M<span class="number">-1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age[N];        <span class="comment">// 100个用户</span></span><br><span class="line">    <span class="keyword">int</span> d[M]=&#123;<span class="number">0</span>&#125;;         <span class="comment">// 11个年龄段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(age+i) = rand()%<span class="number">121</span>;    <span class="comment">// 设定年龄的范围是0-120</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun(age, d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;各年龄阶段人数数量：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex004.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">各年龄阶段人数数量：</span><br><span class="line">10 9 8 4 10 8 7 7 6 11 20</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex05-删除一维数组中所有相同的数，使之只剩一个。"><a href="#案例ex05-删除一维数组中所有相同的数，使之只剩一个。" class="headerlink" title="案例ex05: 删除一维数组中所有相同的数，使之只剩一个。"></a><strong>案例ex05: 删除一维数组中所有相同的数，使之只剩一个。</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：删除一维数组中所有相同的数，使之只剩一个。</p>
<p>描述：数组中的数据已经按照从小到大排列，函数返回删除后数组中元素的个数<br>举例：</p>
<p>一维数组中的数据是：2,2,2,2,3,3,4,4,5,6,6,6,7,7,8,9,9,9,10,10</p>
<p>删除后数组中的内容是：2,3,4,5,6,7,8,9,10</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>初始化没有重复元素最右方的指针 a</p>
<p>当前元素与前一个元素进行比较，如果相同，则调到下一个，否则指针a+1</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：删除一维数组中所有相同的数，使之只剩一个。</span></span><br><span class="line"><span class="comment">描述：数组中的数据已经按照从小到大排列，函数返回删除后数组中元素的个数</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">一维数组中的数据是：2,2,2,2,3,3,4,4,5,6,6,6,7,7,8,9,9,9,10,10</span></span><br><span class="line"><span class="comment">删除后数组中的内容是：2,3,4,5,6,7,8,9,10</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(s+i) != *(s+i<span class="number">-1</span>)) &#123;  <span class="comment">// 当前元素与前一个元素进行比较，如果相同，则调到下一个，否则a+1</span></span><br><span class="line">            *(s+a) = *(s+i);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s[N] = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> cnt = fun(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除后的数组元素个数为：%d\n&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex005.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">删除后的数组元素个数为：9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex06-移动字符串中内容"><a href="#案例ex06-移动字符串中内容" class="headerlink" title="案例ex06: 移动字符串中内容"></a><strong>案例ex06: 移动字符串中内容</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：移动字符串中内容</p>
<p>描述：移动规则如下：把第1到第m个字符，平移到字符串的最后，把m+1到最后的字符移到字符串的前部</p>
<p>举例：字符串原有内容为ABCDEFGHIJK，m的值为3，则移动后，字符串中的内容应该是DEFGHIJKABC</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>为了不产生额外的空间复杂度，本次解决将一位一位移动</p>
<p>将数组第一个位置的元素保存到一个临时变量temp中，从第二位开始集体向左移动，最后将temp元素保存到最后一位</p>
<p>循环 m 次，从而达到最后的效果</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：移动字符串中内容</span></span><br><span class="line"><span class="comment">描述：移动规则如下：把第1到第m个字符，平移到字符串的最后，把m+1到最后的字符移到字符串的前部。</span></span><br><span class="line"><span class="comment">举例：字符串原有内容为ABCDEFGHIJK，m的值为3，则移动后，字符串中的内容应该是DEFGHIJKABC</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        temp = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            s[j<span class="number">-1</span>] = s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        s[N<span class="number">-1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[N] = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动前的字符串：%s\n&quot;</span>, s);</span><br><span class="line">    fun(s, m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移动后的字符串：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex006.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">移动前的字符串：ABCDEFGHIJ</span><br><span class="line">移动后的字符串：DEFGHIJABC</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex07-求数字的低n-1位的数"><a href="#案例ex07-求数字的低n-1位的数" class="headerlink" title="案例ex07: 求数字的低n-1位的数"></a><strong>案例ex07: 求数字的低n-1位的数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：unsigned fun(unsigned w)</p>
<p>功能：求数字的低n-1位的数</p>
<p>描述：w 是一个大于10的无符号整数，若 w 是 n(n&gt;=2)位的整数，函数求出来w的低n-1位的数作为函数值返回</p>
<p>举例：w 值为5923，则函数返回 923</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>两步走：</p>
<ol>
<li>先判断当前无符号整数的位数，记录位数*10。例如：如果有三位，那么记录time=100</li>
<li>根据time计算后 n-1 位，即：w-((w/time)*time)</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：unsigned fun(unsigned w)</span></span><br><span class="line"><span class="comment">功能：求数字的低n-1位的数</span></span><br><span class="line"><span class="comment">描述：w 是一个大于10的无符号整数，若 w 是 n(n&gt;=2)位的整数，函数求出来w的低n-1位的数作为函数值返回</span></span><br><span class="line"><span class="comment">举例：w 值为5923，则函数返回 923</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">fun</span><span class="params">(<span class="keyword">unsigned</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断数字的位数</span></span><br><span class="line">    <span class="keyword">int</span> temp_w = w;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">1</span>;   <span class="comment">// 位数10的指数次</span></span><br><span class="line">    <span class="keyword">while</span>(temp_w &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        time*=<span class="number">10</span>;</span><br><span class="line">        temp_w = temp_w/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    time = time/<span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 计算返回</span></span><br><span class="line">    <span class="keyword">return</span> w-((w/time)*time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请一个大于10的无符号整数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无符号整数低n-1位的数为：%d\n&quot;</span>, fun(w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex007.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请一个大于10的无符号整数：12345</span><br><span class="line">无符号整数低n-1位的数为：2345</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请一个大于10的无符号整数：765432</span><br><span class="line">无符号整数低n-1位的数为：65432</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex08-使数组的左下三角元素中的值乘以n"><a href="#案例ex08-使数组的左下三角元素中的值乘以n" class="headerlink" title="案例ex08: 使数组的左下三角元素中的值乘以n"></a><strong>案例ex08: 使数组的左下三角元素中的值乘以n</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun(int a[][N], int n)</p>
<p>功能：使数组的左下三角元素中的值乘以n</p>
<p>描述：程序定义了 N*N 的二维数组，并在主函数中自动赋值。</p>
<p>举例：<br>若 n 的值为3，a数组中的值为<br>1  9  7<br>3  9  7<br>2  3  8<br>则返回主程序后 a 数组中的值应该为<br>3  9  7<br>9  27 7<br>6  9  24</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用二重循环解决</p>
<p>在第二层需要进行一点注意的地方</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun(int a[][N], int n)</span></span><br><span class="line"><span class="comment">功能：使数组的左下三角元素中的值乘以n</span></span><br><span class="line"><span class="comment">描述：程序定义了 N*N 的二维数组，并在主函数中自动赋值。</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">若 n 的值为3，a数组中的值为</span></span><br><span class="line"><span class="comment">1  9  7</span></span><br><span class="line"><span class="comment">3  9  7</span></span><br><span class="line"><span class="comment">2  3  8</span></span><br><span class="line"><span class="comment">则返回主程序后 a 数组中的值应该为</span></span><br><span class="line"><span class="comment">3  9  7</span></span><br><span class="line"><span class="comment">9  27 7</span></span><br><span class="line"><span class="comment">6  9  24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[][N], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            a[i][j] = a[i][j] * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N][N] = &#123;&#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>&#125;, &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原数组为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;计算后数组：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex008.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原数组为：</span><br><span class="line">1    9    7</span><br><span class="line">3    9    7</span><br><span class="line">2    3    8</span><br><span class="line">计算后数组：</span><br><span class="line">3    9    7</span><br><span class="line">9    27    7</span><br><span class="line">6    9    24</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex09-移动一维数组的内容"><a href="#案例ex09-移动一维数组的内容" class="headerlink" title="案例ex09: 移动一维数组的内容"></a><strong>案例ex09: 移动一维数组的内容</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：移动一维数组的内容</p>
<p>描述：若数组中有n个整数，要求把下标从0到p（含p，p&lt;=n-1）的元素平移到数组的最后<br>举例：</p>
<p>一维数组：1,2,3,4,5,6,7,8,9,10，p的值为3</p>
<p>移动后：5,6,7,8,9,10,1,2,3,4</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>循环 p 次：</p>
<p>将下标为0的数字进行临时存放，然后将后面的数字平移到前面，最后将临时存放的数字放到最后一位</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：移动一维数组的内容</span></span><br><span class="line"><span class="comment">描述：若数组中有n个整数，要求把下标从0到p（含p，p&lt;=n-1）的元素平移到数组的最后</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">一维数组：1,2,3,4,5,6,7,8,9,10，p的值为3</span></span><br><span class="line"><span class="comment">移动后：5,6,7,8,9,10,1,2,3,4</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p; ++i) &#123;</span><br><span class="line">        temp = a[<span class="number">0</span>];    <span class="comment">// 临时存放第一个数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; ++j) &#123;     <span class="comment">// 循环将后续数字进行平移</span></span><br><span class="line">            a[j<span class="number">-1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        a[N<span class="number">-1</span>] = temp;    <span class="comment">// 临时数字存放到最后一位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始数组内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fun(a, p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;平移后数组内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex009.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原始数组内容：</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">平移后数组内容：</span><br><span class="line">5 6 7 8 9 10 1 2 3 4</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex10-删除字符串中所有的空格"><a href="#案例ex10-删除字符串中所有的空格" class="headerlink" title="案例ex10: 删除字符串中所有的空格"></a><strong>案例ex10: 删除字符串中所有的空格</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：删除字符串中所有的空格</p>
<p>举例：</p>
<p>主函数中输入“fds afadsf adf d  dsf   67d”</p>
<p>则输出：“fdsafadsfadfddsf67d”</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>设置两指针，begin 和 end</p>
<p>begin 和 end 同时从头开始向后移动：</p>
<ul>
<li>当遇到空格的时候，end 向后移动，begin不变</li>
<li>当 end 位置不为空格的时候，将 end 位置的字符填充到 begin 的位置</li>
</ul>
<p>最后，在完成去除空格的操作后，在最后添加 ‘\0’</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：删除字符串中所有的空格</span></span><br><span class="line"><span class="comment">举例：</span></span><br><span class="line"><span class="comment">主函数中输入“fds afadsf adf d  dsf   67d”</span></span><br><span class="line"><span class="comment">则输出：“fdsafadsfadfddsf67d”</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(s[end]!=<span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[end] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[begin] = s[end];</span><br><span class="line">            begin++;</span><br><span class="line">            end++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[begin] = <span class="string">&#x27;\0&#x27;</span>;      <span class="comment">// 去除空格后，在最后一位加 &#x27;\0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[N] = <span class="string">&quot;fds afadsf adf d  dsf   67d&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始字符串：%s\n&quot;</span>, s);</span><br><span class="line">    fun(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;去空格后字符串：%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex010.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">原始字符串：fds afadsf adf d  dsf   67d</span><br><span class="line">去空格后字符串：fdsafadsfadfddsf67d</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex11-使用指针实现整数逆序排序"><a href="#案例ex11-使用指针实现整数逆序排序" class="headerlink" title="案例ex11: 使用指针实现整数逆序排序"></a><strong>案例ex11: 使用指针实现整数逆序排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：fun()</p>
<p>功能：使用指针实现整数逆序排序</p>
<p>描述：在main函数中实现，输入三个数字，使用指针实现三个数字的逆序排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针实现数字的操作</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指针实现整数逆序排序</span></span><br><span class="line"><span class="comment">描述：在main函数中实现，输入三个数字，使用指针实现三个数字的逆序排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2, <span class="keyword">int</span> *p3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*p1 &lt; *p2)</span><br><span class="line">        swap(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (*p1 &lt; *p3)</span><br><span class="line">        swap(p1, p3);</span><br><span class="line">    <span class="keyword">if</span> (*p2 &lt; *p3)</span><br><span class="line">        swap(p2, p3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">int</span> *q1, *q2, *q3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入三个数字：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    q1 = &amp;a;</span><br><span class="line">    q2 = &amp;b;</span><br><span class="line">    q3 = &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆序前的数字：%d, %d, %d\n&quot;</span>, *q1, *q2, *q3);</span><br><span class="line">    fun(q1, q2, q3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆序后的数字：%d, %d, %d\n&quot;</span>, *q1, *q2, *q3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex011.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入三个数字：3,9,1</span><br><span class="line">逆序前的数字：3, 9, 1</span><br><span class="line">逆序后的数字：9, 3, 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入三个数字：1,2,3</span><br><span class="line">逆序前的数字：1, 2, 3</span><br><span class="line">逆序后的数字：3, 2, 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex12-指向结构体变量的指针"><a href="#案例ex12-指向结构体变量的指针" class="headerlink" title="案例ex12: 指向结构体变量的指针"></a><strong>案例ex12: 指向结构体变量的指针</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：指向结构体变量的指针</p>
<p>描述：通过结构体指针变量实现显示学生信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>熟悉结构体的使用</p>
<p>熟悉指针和结构体的混合使用</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：指向结构体变量的指针</span></span><br><span class="line"><span class="comment">描述：通过结构体指针变量实现显示学生信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span> =</span> &#123;</span><br><span class="line">        <span class="number">1001</span>, <span class="string">&quot;计算广告生态&quot;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">28</span>, <span class="number">98.5</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">s</span> =</span> &amp;stu;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No.\t%d\n&quot;</span>, s-&gt;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name.\t%s\n&quot;</span>, s-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sex.\t%c\n&quot;</span>, s-&gt;sex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age.\t%d\n&quot;</span>, s-&gt;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Score.\t%d\n&quot;</span>, s-&gt;score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex012.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">No.    1001</span><br><span class="line">Name.    计算广告生态</span><br><span class="line">Sex.    M</span><br><span class="line">Age.    28</span><br><span class="line">Score.    73896</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex13-使用指针输出数组元素"><a href="#案例ex13-使用指针输出数组元素" class="headerlink" title="案例ex13: 使用指针输出数组元素"></a><strong>案例ex13: 使用指针输出数组元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>目标：熟悉指针和数组的底层逻辑</p>
<p>功能：使用指针输出数组元素</p>
<p>描述：通过指针将数组中你那个各个元素值进行打印输出</p>
</blockquote>
<p><strong>2 要点</strong></p>
<p>a. 指向数组的指针实现输出数组元素，定义一个指向数组的指针用来灵活操作数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="comment">// 指针 p 指向数组的方法，下面两种都是可以的.</span></span><br><span class="line"><span class="comment">// a 本身就是数组的其实地址，&amp;a[0] 也是数组的起始地址</span></span><br><span class="line">p = a;                 </span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>b. 指针既是指向变量地址的又是决定指向变量地址的位数的。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>既是指向数组a的首地址 又是说明了每次指向都int类型的数据，即 4 个字节。</p>
<p>所以，在指定 p 的<strong>基类型</strong>后，通过指针指向数组，每次 p++ 都是会跳动4个字节，到达下一个位置a[1]。</p>
<p>即：*(p+1) 即取得 a[1] 的数据</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">目标：熟悉指针和数组的底层逻辑</span></span><br><span class="line"><span class="comment">功能：使用指针输出数组元素</span></span><br><span class="line"><span class="comment">描述：通过指针将数组中你那个各个元素值进行打印输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N];</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 10 个数字: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = a; p &lt; a+<span class="number">10</span>; ++p)    &#123;    <span class="comment">// 指针指向进行数组内容打印</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;数组中的内容：\n%d\n&quot;</span>, *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex013.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 10 个数字:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">数组中的内容：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex14-找出数列中的最大值和最小值"><a href="#案例ex14-找出数列中的最大值和最小值" class="headerlink" title="案例ex14: 找出数列中的最大值和最小值"></a><strong>案例ex14: 找出数列中的最大值和最小值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：max_min()</p>
<p>功能：找出数列中的最大值和最小值</p>
<p>描述：使用指针查找数列中的最大值和最小值（使用指针从而避免使用返回值）</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针从而避免使用返回值</p>
<p>在主函数中定义最大值 max 和最小值 min，将 max 和 min 的地址传递给函数处理，计算结果直接放到主函数中定义的 max 和 min 的地址中</p>
<p>这样做代码执行高效并且思路清晰</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：max_min()</span></span><br><span class="line"><span class="comment">功能：找出数列中的最大值和最小值</span></span><br><span class="line"><span class="comment">描述：使用指针查找数列中的最大值和最小值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_min</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *max, <span class="keyword">int</span> *min)</span> </span>&#123;</span><br><span class="line">    *max = *a;        <span class="comment">// 将数组下标为 0 的数字初始化给max</span></span><br><span class="line">    *min = *a;        <span class="comment">// 将数组下标为 0 的数字初始化给min</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*max &lt; *(a+i))        <span class="comment">// 将大于max的值赋值给max</span></span><br><span class="line">            *max = *(a+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*min &gt; *(a+i))        <span class="comment">// 将小于min的值赋值给min</span></span><br><span class="line">            *min = *(a+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, a[N];</span><br><span class="line">    <span class="keyword">int</span> max, min;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 10 个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">        <span class="comment">// scanf(&quot;%d&quot;, &amp;a[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    max_min(a, &amp;max, &amp;min);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的 10 个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n最大值为：%d\n&quot;</span>, max);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n最小值为：%d\n&quot;</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex014.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 10 个数字：</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">10</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">输入的 10 个数字为： 3 2 1 10 9 8 7 6 5 4</span><br><span class="line">最大值为：10</span><br><span class="line"></span><br><span class="line">最小值为：1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex15-使用指针的指针输出字符串"><a href="#案例ex15-使用指针的指针输出字符串" class="headerlink" title="案例ex15: 使用指针的指针输出字符串"></a><strong>案例ex15: 使用指针的指针输出字符串</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用指针的指针输出字符串</p>
<p>描述：</p>
<p>使用指针的指针输出字符串。</p>
<p>首先要使用指针数组创建一个字符串数组，然后定义指向指针的指针，使其指向字符串数组，并使用其输出数组的字符串</p>
</blockquote>
<p><strong>2 思路</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> **p;</span><br></pre></td></tr></table></figure>
<p>这里指向指针的指针，表示指针变量 p 是指向一个指针变量。*p 就表示 p 指向另外一个指针变量，即一个地址。</p>
<p><em>*p 表示 p 指向指针变量指向的对象的值。 例如：\</em> (p+1) 表示 accounts[1] 的内容，指向 accounts[1] 的首地址</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指针的指针输出字符串</span></span><br><span class="line"><span class="comment">描述：使用指针的指针输出字符串。</span></span><br><span class="line"><span class="comment">首先要使用指针数组创建一个字符串数组，然后定义指向指针的指针，使其指向字符串数组，并使用其输出数组的字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *accounts[] = &#123;</span><br><span class="line">        <span class="string">&quot;你好 C语言 1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 2&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 3&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;你好 C语言 5&quot;</span></span><br><span class="line">    &#125;;                                                                        <span class="comment">// 指针数组创建字符串数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    p = accounts;                                                    <span class="comment">// 注意这里一定是二重指针来指向accounts</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(p+i));                            <span class="comment">// 使用指针将字符串数组中的字符串打印出来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex015.c -o demo</span></span><br><span class="line">yaojianguodeMacBook-Pro:ex100 yaojianguo$ ./demo</span><br><span class="line">欢迎关注公众号, 计算广告生态1</span><br><span class="line">欢迎关注公众号, 计算广告生态2</span><br><span class="line">欢迎关注公众号, 计算广告生态3</span><br><span class="line">欢迎关注公众号, 计算广告生态4</span><br><span class="line">欢迎关注公众号, 计算广告生态5</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex16-使用指向指针的指针对字符串排序"><a href="#案例ex16-使用指向指针的指针对字符串排序" class="headerlink" title="案例ex16: 使用指向指针的指针对字符串排序"></a><strong>案例ex16: 使用指向指针的指针对字符串排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：sort()</p>
<p>功能：使用指向指针的指针对字符串排序</p>
<p>描述：</p>
<p>使用指向指针的指针对字符串排序，输出是按照字母顺序进行排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>a. 熟悉指向指针的指针的使用</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *nums[]=&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> **p;</span><br><span class="line">p = nums;</span><br></pre></td></tr></table></figure>
<p>熟悉 *p 指向的是 nums[0] 的首地址</p>
<p><strong>b. 引用模块#include <string.h></string.h></strong></p>
<p>使用函数 int strcmp(const char <em>str1, const char </em>str2) 进行字符串的比较</p>
<p>该函数返回值如下：</p>
<ul>
<li>如果返回值小于 0，则表示 str1 小于 str2。</li>
<li>如果返回值大于 0，则表示 str1 大于 str2。</li>
<li>如果返回值等于 0，则表示 str1 等于 str2。</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用指向指针的指针对字符串排序</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">使用指向指针的指针对字符串排序，输出是按照字母顺序进行排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> **p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;     <span class="comment">// 排序交换时的临时变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(*(p+i), *(p+j)) &gt; <span class="number">0</span>) &#123;     <span class="comment">// 使用strcmp进行字符串的比较</span></span><br><span class="line">                temp = *(p+i);</span><br><span class="line">                *(p+i) = *(p+j);</span><br><span class="line">                *(p+j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> **p;</span><br><span class="line">    <span class="keyword">char</span> *nums[] = &#123;</span><br><span class="line">        <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>, <span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>, <span class="string">&quot;six&quot;</span>, <span class="string">&quot;seven&quot;</span>, <span class="string">&quot;eight&quot;</span>, <span class="string">&quot;nine&quot;</span>, <span class="string">&quot;ten&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    p = nums;            <span class="comment">// 使用指向指针的指针指向字符串数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前的数组内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sort(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex016.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">排序前的数组内容为：</span><br><span class="line">one two three four five six seven eight nine ten</span><br><span class="line">排序后的数组内容为：</span><br><span class="line">eight five four nine one seven six ten three two</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex17-使用指针连接两个字符串"><a href="#案例ex17-使用指针连接两个字符串" class="headerlink" title="案例ex17: 使用指针连接两个字符串"></a><strong>案例ex17: 使用指针连接两个字符串</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：connect()</p>
<p>功能：使用指针连接两个字符串</p>
<p>描述：</p>
<p>实现两个已知字符串的连接，放到另外一个字符串数组中，然后将连接好的字符串进行打印显示</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用<strong>字符型指针变量</strong>和<strong>指向字符串的指针</strong>做函数的参数来实现字符串的连接</p>
<p>注意初始化 char *conn来存储新字符串的时候，必须先分配存储空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *conn = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(conn, <span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 可选，初始化填充内存空间</span></span><br></pre></td></tr></table></figure>
<p>另外，使用指针的特性，使得 conn 不断被赋值， str1 和 str2 指向的存储地址，达到字符串的连接</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：connect()</span></span><br><span class="line"><span class="comment">功能：使用指针连接两个字符串</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">实现两个已知字符串的连接，放到另外一个字符串数组中，然后将连接好的字符串进行打印显示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2, <span class="keyword">char</span> *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(*str1 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *conn = *str1;</span><br><span class="line">        conn++;</span><br><span class="line">        str1++;</span><br><span class="line">    &#125;</span><br><span class="line">    *conn = <span class="string">&#x27;,&#x27;</span>;     <span class="comment">// 两个字符串直接添加逗号</span></span><br><span class="line">    conn++;</span><br><span class="line">    <span class="keyword">while</span>(*str2 != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *conn = *str2;</span><br><span class="line">        conn++;</span><br><span class="line">        str2++;</span><br><span class="line">    &#125;</span><br><span class="line">    *conn = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str1 = <span class="string">&quot;技术分享园子&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> *conn = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>);      <span class="comment">// 为 conn 分配空间，否则是无效地址</span></span><br><span class="line">    <span class="built_in">memset</span>(conn, <span class="built_in">strlen</span>(str1)+<span class="built_in">strlen</span>(str2)+<span class="number">1</span>, <span class="number">0</span>);               <span class="comment">// 初始化 conn 指向的存储地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个字符串：%s\n&quot;</span>, str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个字符串：%s\n&quot;</span>, str2);</span><br><span class="line">    connect(str1, str2, conn);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连接后的字符串是：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex017.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">第一个字符串：技术分享园子</span><br><span class="line">第二个字符串：计算广告生态</span><br><span class="line">连接后的字符串是：</span><br><span class="line">技术分享园子,计算广告生态</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex18-用指针实现逆序存放数组元素的值"><a href="#案例ex18-用指针实现逆序存放数组元素的值" class="headerlink" title="案例ex18: 用指针实现逆序存放数组元素的值"></a><strong>案例ex18: 用指针实现逆序存放数组元素的值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：invert()</p>
<p>功能：用指针实现逆序存放数组元素的值</p>
<p>描述：使用指针将数组中的元素值逆序放置，并且将结果打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>1. 程序变量中两个数字进行交换的三种方法</strong></p>
<p> 第一种：引入一个中间量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp=a;</span><br><span class="line">a=b;</span><br><span class="line">b=temp;</span><br></pre></td></tr></table></figure>
<p> 第二种：要注意的是a+b可能会超过int的范围，这个是该方法的缺点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=a+b;</span><br><span class="line">b=a-b;</span><br><span class="line">a=a-b;</span><br></pre></td></tr></table></figure>
<p>第三种：这种方法效率最高，推荐使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=a^b;</span><br><span class="line">b=a^b;</span><br><span class="line">a=a^b;</span><br></pre></td></tr></table></figure>
<p><strong>2. 指针的使用</strong></p>
<p>使用指针对数组内容进行操作，数组 a， a 指向数组首位置，a+N-1 指向最后一位。从而利用循环对数组的首尾数字逐个替换</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：invert()</span></span><br><span class="line"><span class="comment">功能：用指针实现逆序存放数组元素的值</span></span><br><span class="line"><span class="comment">描述：使用指针将数组中的元素值逆序放置，并且将结果打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *begin, *end, mid;   <span class="comment">// 定义首尾指针</span></span><br><span class="line">    begin = a;</span><br><span class="line">    end = a+N<span class="number">-1</span>;</span><br><span class="line">    mid = (N<span class="number">-1</span>)/<span class="number">2</span>;             <span class="comment">// 中间位置</span></span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mid; ++i)&#123;    <span class="comment">// 循环，首尾指针内容变换</span></span><br><span class="line">        <span class="comment">// temp = *begin;</span></span><br><span class="line">        <span class="comment">// *begin = *end;</span></span><br><span class="line">        <span class="comment">// *end = temp;</span></span><br><span class="line">        *begin = *begin ^ *end;</span><br><span class="line">        *end = *begin ^ *end;</span><br><span class="line">        *begin = *begin ^ *end;</span><br><span class="line"></span><br><span class="line">        ++begin;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前数组中的值为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    invert(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用指针逆序后数组中的值为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex018.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">当前数组中的值为：1 2 3 4 5 6 7 8 9 10</span><br><span class="line">使用指针逆序后数组中的值为：10 9 8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex19-用指针数组构造字符串数组"><a href="#案例ex19-用指针数组构造字符串数组" class="headerlink" title="案例ex19: 用指针数组构造字符串数组"></a><strong>案例ex19: 用指针数组构造字符串数组</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用<strong>指针数组</strong>构造字符串数组</p>
<p>描述：实现输入一个星期中对应的第几天，可以显示其英文名</p>
<p>目标：熟悉对字符串数组对应的指针的使用</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p>要点：通过构造一个字符串数组来指定数组中元素的元素值。</p>
</li>
<li><p>指针数组：即数组中都是指针类型的数据，指针数组中的每个元素都是一个指针</p>
<p>定义：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">类型名 *数组名[数组长度];</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">char</span> *[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>​        其中 p 是一个指针数组，该数组是由 5 个数据元素组成，每个元素相当于一个指针变量，都可以指向一个字符串变量</p>
<ul>
<li>注意点：<em>p[4] 与 (\</em>p)[4] 的区别要知道， <strong>(*p)[4] 中的 p 是一个指向一维数组的指针变量</strong></li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：用指针数组构造字符串数组</span></span><br><span class="line"><span class="comment">描述：实现输入一个星期中对应的第几天，可以显示其英文名</span></span><br><span class="line"><span class="comment">目标：熟悉对字符串数组对应的指针的使用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *week[] = &#123;</span><br><span class="line">        <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>, <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> w;    <span class="comment">// 用来记录周几</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入星期几(输入阿拉伯数字)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Today is %s.\n&quot;</span>, *(week+w<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex019.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入星期几(输入阿拉伯数字)：5</span><br><span class="line">Today is Friday</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex20-用指针函数输出学生成绩"><a href="#案例ex20-用指针函数输出学生成绩" class="headerlink" title="案例ex20: 用指针函数输出学生成绩"></a><strong>案例ex20: 用指针函数输出学生成绩</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：search()</p>
<p>功能：用指针函数输出学生成绩</p>
<p>描述：指针函数的使用，输入学生的序号，将在窗口输出该序号对应的学生的成绩</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p>指向函数的指针变量的形式如下：</p>
<p>数据类型 (*指针变量名)()</p>
<p>例如;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>*(p)() 表示定义一个指向函数的指针变量，用来存放函数入口地址。在程序设计过程中，将一个函数地址赋值给它，它就指向那个函数。函数指针变量赋值写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = min;</span><br></pre></td></tr></table></figure>
<p>在赋值的时候，只给出函数名即可<strong>，函数名即地址</strong></p>
<p>在使用函数指针调用函数的时候，要写出函数的参数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">m = (*p)(a,b);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：search()</span></span><br><span class="line"><span class="comment">功能：用指针函数输出学生成绩</span></span><br><span class="line"><span class="comment">描述：指针函数的使用，输入学生的序号，将在窗口输出该序号对应的学生的成绩</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> (*p)[<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pt = *(p+n);</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> score[][<span class="number">4</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">98</span>,<span class="number">56</span>,<span class="number">89</span>,<span class="number">87</span>&#125;,</span><br><span class="line">        &#123;<span class="number">88</span>,<span class="number">56</span>,<span class="number">87</span>,<span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">92</span>,<span class="number">56</span>,<span class="number">84</span>,<span class="number">82</span>&#125;,</span><br><span class="line">        &#123;<span class="number">78</span>,<span class="number">56</span>,<span class="number">90</span>,<span class="number">67</span>&#125;</span><br><span class="line">    &#125;;                    <span class="comment">// 声明数组，对应四个学生的各科成绩</span></span><br><span class="line">    <span class="keyword">int</span> no;                <span class="comment">// 保存学生编号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入学生编号：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;no);</span><br><span class="line">    <span class="keyword">int</span> *p = search(score, no);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;学生编号为 %d 的学生成绩为：\n&quot;</span>, no);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex020.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入学生编号：3</span><br><span class="line">学生编号为3的学生成绩为：</span><br><span class="line">78    56    90    67</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex21-寻找相同元素的指针"><a href="#案例ex21-寻找相同元素的指针" class="headerlink" title="案例ex21: 寻找相同元素的指针"></a><strong>案例ex21: 寻找相同元素的指针</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：find()</p>
<p>功能：寻找相同元素的指针</p>
<p>描述：比较两个有序数组的元素，输出两个数组中第一个相同的值</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用有序数组有序的特点</p>
<p>建立一个指针函数，这个函数返回值为指针类型，即一个地址。定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在程序中调用该函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = find(a, b, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>
<p>返回一个指向整型变量的指针</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：find()</span></span><br><span class="line"><span class="comment">功能：寻找相同元素的指针</span></span><br><span class="line"><span class="comment">描述：比较两个有序数组的元素，输出两个数组中第一个相同的值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">find</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pa = a;</span><br><span class="line">    <span class="keyword">int</span> *pb = b;</span><br><span class="line">    <span class="keyword">while</span>(pa &lt; a+m &amp;&amp; pb &lt; b+n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt; *pb) &#123;</span><br><span class="line">            pa++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*pa &gt; *pb) &#123;</span><br><span class="line">            pb++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">34</span>,<span class="number">56</span>&#125;;        <span class="comment">// 声明两个数组</span></span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">59</span>&#125;;    <span class="comment">// 声明两个数组    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两个数组的内容分别是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]); ++i) &#123;     <span class="comment">// 打印数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]); ++j) &#123;     <span class="comment">// 打印数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line">    p = find(a, b, <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]), <span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(b[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n相同的数字是：%d\n&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex021.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">两个数组的内容分别是：</span><br><span class="line">2 5 7 9 11 34 56</span><br><span class="line">3 6 8 10 12 34 59</span><br><span class="line">相同的数字是：34</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex22-查找成绩不及格的学生"><a href="#案例ex22-查找成绩不及格的学生" class="headerlink" title="案例ex22: 查找成绩不及格的学生"></a><strong>案例ex22: 查找成绩不及格的学生</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：search()</p>
<p>功能：查找成绩不及格的学生</p>
<p>描述：有 4 名学生的成绩，找出至少有一科不及格的学生，并将成绩列表输出（规定60以下为不及格）</p>
<p>目标：重点理解 int (*p)[N] 的使用方法</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>int*p[5] 和 int(*p)[5] 的区别</strong></p>
<ul>
<li><p>int *p[5],首先它是一个数组，它的大小是5，p里面存放的数据都是类型是int *,也就是整型指针。 所以它叫指针数组。</p>
</li>
<li><p>int (*p)[5]，首先p是一个指针，<strong>指向大小为5的数组</strong>，因此这叫数组指针。通常用在二维数组的操作上</p>
<ul>
<li>注意指针的类型，从 int(*p)[5] 可以看到， p 的类型不是int *， 而是 int(*)[5]，p 被定义为指向一维数组的指针变量，里面有 5 个元素，因此，p 的基类型是一维数组，长度为 20 字节。</li>
<li>*(p+2)+3， 括号中的 2 是指的以 p 的基类型（一维整型数组）的长度为单位的，即，p 每增加 1，地址就增加 20 个字节（5 个元素，每个元素4个字节）。而 *(p+2)+3 括号外的数字 3，不是以 p 的基类型的长度为单位的，而是一维数组的下一个位置</li>
</ul>
</li>
<li><p>先看一个简单的引例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">float</span> (*p)[<span class="number">4</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;序号为 %d 的学生的成绩：\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5.2f &quot;</span>, *(*(p+n)+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> score[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">60</span>,<span class="number">75</span>,<span class="number">82</span>,<span class="number">91</span>&#125;,&#123;<span class="number">75</span>,<span class="number">81</span>,<span class="number">91</span>,<span class="number">90</span>&#125;,&#123;<span class="number">51</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">84</span>&#125;&#125;;</span><br><span class="line">    search(score, <span class="number">2</span>);  <span class="comment">// 计算得出序号为 2 的学生的成绩</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~操作结果~~~~~~~~~~~~</span><br><span class="line">$ gcc ex022<span class="number">-1.</span>c -o demo</span><br><span class="line">./yaojianguodeMacBook-Pro:C语言<span class="number">100</span>题集合代码 yaojianguo$ ./demo</span><br><span class="line">序号为 <span class="number">2</span> 的学生的成绩：</span><br><span class="line"><span class="number">51.00</span> <span class="number">65.00</span> <span class="number">78.00</span> <span class="number">84.00</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：search()</span></span><br><span class="line"><span class="comment">功能：查找成绩不及格的学生</span></span><br><span class="line"><span class="comment">描述：有 4 名学生的成绩，找出至少有一科不及格的学生，并将成绩列表输出（规定60以下为不及格）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">search</span><span class="params">(<span class="keyword">int</span> (*p)[N])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * pt = *(p+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(*(p+<span class="number">0</span>)+i) &lt; <span class="number">60</span>) &#123;   <span class="comment">// 这块可以写成*(*p+i) &lt; 60，也就是平常看到了*(*(p+m)+n）)来取到二维数组中列向的值</span></span><br><span class="line">            pt = *p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p;</span><br><span class="line">    <span class="keyword">int</span> score[][N]=&#123;&#123;<span class="number">60</span>,<span class="number">75</span>,<span class="number">82</span>,<span class="number">91</span>&#125;,&#123;<span class="number">75</span>,<span class="number">81</span>,<span class="number">91</span>,<span class="number">90</span>&#125;,&#123;<span class="number">51</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">84</span>&#125;,&#123;<span class="number">65</span>,<span class="number">72</span>,<span class="number">78</span>,<span class="number">72</span>&#125;,&#123;<span class="number">75</span>,<span class="number">70</span>,<span class="number">98</span>,<span class="number">92</span>&#125;&#125;;     <span class="comment">// 四个学生的成绩</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        p = search(score+i);</span><br><span class="line">        <span class="keyword">if</span> (p==*(score+i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;成绩不及格学生的成绩分别是:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+j));</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex022.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">成绩不及格学生的成绩分别是:</span><br><span class="line">51 65 78 84</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex23-使用指针实现冒泡排序"><a href="#案例ex23-使用指针实现冒泡排序" class="headerlink" title="案例ex23: 使用指针实现冒泡排序"></a><strong>案例ex23: 使用指针实现冒泡排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：bubble_order()</p>
<p>功能：使用指针实现冒泡排序</p>
<p>描述：实现C语言经典的冒泡排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>冒泡排序的基本思路:</strong></p>
<p>如果对 n 个数进行冒泡排序，则需要进行 n-1 躺比较，在第 1 趟比较中要进行 n-1 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：bubble_order()</span></span><br><span class="line"><span class="comment">功能：使用指针实现冒泡排序</span></span><br><span class="line"><span class="comment">描述：实现C语言经典的冒泡排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_order</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>-i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(a+j) &gt; *(a+j+<span class="number">1</span>)) &#123;</span><br><span class="line">                *(a+j) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">                *(a+j+<span class="number">1</span>) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">                *(a+j) = *(a+j) ^ *(a+j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">20</span>], n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要排序元素的个数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入各个元素\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序前元素的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+j));</span><br><span class="line">    &#125;</span><br><span class="line">    bubble_order(a, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n排序后元素的内容为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex023.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入要排序元素的个数：</span><br><span class="line">5</span><br><span class="line">请输入各个元素</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">1</span><br><span class="line">9</span><br><span class="line">4</span><br><span class="line">排序前元素的内容为：</span><br><span class="line">3 7 1 9 4</span><br><span class="line">排序后元素的内容为：</span><br><span class="line">1 3 4 7 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex24-输入月份号并输出英文月份名"><a href="#案例ex24-输入月份号并输出英文月份名" class="headerlink" title="案例ex24: 输入月份号并输出英文月份名"></a><strong>案例ex24: 输入月份号并输出英文月份名</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输入月份号并输出英文月份名</p>
<p>描述：</p>
<p>使用指针数组创建一个含有月份英文名的字符串数组</p>
<p>并使用指向指针的指针指向这个字符串数组，实现输出数组中的指定字符串</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用指针的指针实现对字符串数组中的字符串的输出</p>
<p>*month[] 属于指针数组，*month本身就是指针，数组中都是存放着指针。那么 month是指针数组的首地址，**p=month 指向数组中的每个元素</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输入月份号并输出英文月份名</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">使用指针数组创建一个含有月份英文名的字符串数组</span></span><br><span class="line"><span class="comment">并使用指向指针的指针指向这个字符串数组，实现输出数组中的指定字符串</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *month[] = &#123;</span><br><span class="line">        <span class="string">&quot;January&quot;</span>,</span><br><span class="line">        <span class="string">&quot;February&quot;</span>,</span><br><span class="line">        <span class="string">&quot;March&quot;</span>,</span><br><span class="line">        <span class="string">&quot;April&quot;</span>,</span><br><span class="line">        <span class="string">&quot;May&quot;</span>,</span><br><span class="line">        <span class="string">&quot;June&quot;</span>,</span><br><span class="line">        <span class="string">&quot;July&quot;</span>,</span><br><span class="line">        <span class="string">&quot;August&quot;</span>,</span><br><span class="line">        <span class="string">&quot;September&quot;</span>,</span><br><span class="line">        <span class="string">&quot;October&quot;</span>,</span><br><span class="line">        <span class="string">&quot;November&quot;</span>,</span><br><span class="line">        <span class="string">&quot;December&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">char</span> **p;           <span class="comment">// 指向指针的指针变量</span></span><br><span class="line">    p = month;        <span class="comment">// 数组首地址赋值给指针变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入一个月份号(阿拉伯数组)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;本月是：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *(p+m<span class="number">-1</span>));</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex024.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入一个月份号(阿拉伯数组)：3</span><br><span class="line">本月是：March</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入一个月份号(阿拉伯数组)：9</span><br><span class="line">本月是：September</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex25-使用指针插入元素"><a href="#案例ex25-使用指针插入元素" class="headerlink" title="案例ex25: 使用指针插入元素"></a><strong>案例ex25: 使用指针插入元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：insert()</p>
<p>功能：使用指针插入元素</p>
<p>描述：在有序（升序)的数组中插入一个数，使得插入的数组仍然有序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>参数传递，使用指针变量</li>
<li>插入数字，找到插入点，<strong>从数组的末端逐个向后移动</strong>，最后将要插入的数字放到插入点</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：insert()</span></span><br><span class="line"><span class="comment">功能：使用指针插入元素</span></span><br><span class="line"><span class="comment">描述：在有序（升序)的数组中插入一个数，使得插入的数组仍然有序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=N+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; *(a+i))</span><br><span class="line">            <span class="keyword">break</span>;            <span class="comment">// 插入的数据记录大于数组中数据的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ( ; j &gt; i; --j) &#123;</span><br><span class="line">        *(a+j) = *(a+j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    *(a+i) = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N+<span class="number">1</span>], add_num;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入十个数字:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要插入的数字: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;add_num);</span><br><span class="line"></span><br><span class="line">    insert(a, add_num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入后的数组为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex025.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入十个数字:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">输入要插入的数字: 6</span><br><span class="line">6</span><br><span class="line">插入后的数组为： 1 2 3 4 5 6 7 8 9 10 11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex26-使用指针交换两个数组中的最大值"><a href="#案例ex26-使用指针交换两个数组中的最大值" class="headerlink" title="案例ex26: 使用指针交换两个数组中的最大值"></a><strong>案例ex26: 使用指针交换两个数组中的最大值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：max()、swap()</p>
<p>功能：使用指针交换两个数组中的最大值</p>
<p>描述：</p>
<p>输入两个五个元素的数组，使用指针将两个数组中的最大值进行交换</p>
<p>并输出最大值交换之后的两个数组</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>以下都使用指针来进行实现</p>
<ol>
<li>找到最大值<br> 创建 int <em>max(int </em>a) 函数，指针指向找出的最大值</li>
<li>交换最大值<br> 创建 void swap(int <em>p1, int </em>p2) 找到的两个最大值进行交换，即进行指针指向的内容进行交换</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：max()、swap()</span></span><br><span class="line"><span class="comment">功能：使用指针交换两个数组中的最大值</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">输入两个五个元素的数组，使用指针将两个数组中的最大值进行交换</span></span><br><span class="line"><span class="comment">并输出最大值交换之后的两个数组</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p = a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(a+i) &gt; *p)</span><br><span class="line">            p = a+i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span> </span>&#123;</span><br><span class="line">    *p1 = *p1 ^ *p2;</span><br><span class="line">    *p2 = *p1 ^ *p2;</span><br><span class="line">    *p1 = *p1 ^ *p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="keyword">int</span> * max_a, * max_b;</span><br><span class="line">    <span class="comment">// 1. 初始化两个数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数组 a 的5个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数组 b 的5个数字：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (b+j));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 a 的5个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 b 的5个数字为： &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 找出各数组中的最大值</span></span><br><span class="line">    max_a = max(a);</span><br><span class="line">    max_b = max(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 a 的最大值：%d&quot;</span>, *max_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n数组 b 的最大值：%d&quot;</span>, *max_b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对两个最大值进行交换</span></span><br><span class="line">    swap(max_a, max_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n交换最大值之后的数组 a 的5个数字为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n交换最大值之后的数组 b 的5个数字为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex026.c -o demo</span></span><br><span class="line">yaojianguodeMacBook-Pro:C语言100题集合代码 yaojianguo$ ./demo</span><br><span class="line">输入数组 a 的5个数字：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">输入数组 b 的5个数字：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">数组 a 的5个数字为： 1 3 5 7 9</span><br><span class="line">数组 b 的5个数字为： 2 4 6 8 10</span><br><span class="line">数组 a 的最大值：9</span><br><span class="line">数组 b 的最大值：10</span><br><span class="line">交换最大值之后的数组 a 的5个数字为：1 3 5 7 10</span><br><span class="line">交换最大值之后的数组 b 的5个数字为：2 4 6 8 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex27-输出二维数组有关值-二维数组的经典案例-非常重要"><a href="#案例ex27-输出二维数组有关值-二维数组的经典案例-非常重要" class="headerlink" title="案例ex27: 输出二维数组有关值(二维数组的经典案例,非常重要)"></a><strong>案例ex27: 输出二维数组有关值(二维数组的经典案例,非常重要)</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输出二维数组有关值(二维数组的经典案例,非常重要)</p>
<p>描述：输出二维数组中的有关值，以及指向二维数组的指针变量的应用</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>非常重要！非常重要！非常重要！</strong></p>
<p>a+1 是二维数组 a 中序号为 1 的行的首地址（序号从0起算），而*(a+1) 并不是 a+1 单元的内容(值)，因为 a+1 并不是一个变量的存储单元，也就谈不上他的内容了。*(a+1) 就是 a[1]，而 a[1] 是一维数组名，所以也是地址，它指向 a[1][0]。a[1] 和 *(a+1) 都是二维数组中地址的不同表现形式</p>
<p><img src="/images/54dca58dd5321010bbf45b00a98173971.jpg" width="50%" height="50%"></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输出二维数组有关值(二维数组的经典案例,非常重要)</span></span><br><span class="line"><span class="comment">描述：输出二维数组中的有关值，以及指向二维数组的指针变量的应用</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,  <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a, *a);                                 <span class="comment">// 0 行的首地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">0</span>], *(a+<span class="number">0</span>));                    <span class="comment">// 0 行 0 列元素地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, &amp;a[<span class="number">0</span>], &amp;a[<span class="number">0</span>][<span class="number">0</span>]);            <span class="comment">// 0 行的首地址, 0 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">1</span>], a+<span class="number">1</span>);                        <span class="comment">// 1 行 0 列的元素地址, 1 行首地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, &amp;a[<span class="number">1</span>][<span class="number">0</span>], *(a+<span class="number">1</span>)+<span class="number">0</span>);        <span class="comment">// 1 行 0 列的元素地址, 1 行 0 列元素地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a[<span class="number">1</span>][<span class="number">1</span>], *(*(a+<span class="number">1</span>)+<span class="number">1</span>));    <span class="comment">// 1 行 1 列的值，1 行 1 列的值</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex027.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746704,-302746704</span><br><span class="line">-302746688,-302746688</span><br><span class="line">-302746688,-302746688</span><br><span class="line">6,6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex28-输出二维数组任一行任一列值"><a href="#案例ex28-输出二维数组任一行任一列值" class="headerlink" title="案例ex28: 输出二维数组任一行任一列值"></a><strong>案例ex28: 输出二维数组任一行任一列值</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：输出二维数组任一行任一列值</p>
<p>描述：一个 3 行 4 列的数组，输入要显示数组元素的所在行数和列数，将在终端显示该数组元素的值</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>熟悉ex027的案例，对上一个案例的简单应用</p>
<p>要彻底理解指针和二维数组的操作以及其内在的联系</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：输出二维数组任一行任一列值</span></span><br><span class="line"><span class="comment">描述：一个 3 行 4 列的数组，输入要显示数组元素的所在行数和列数，将在终端显示该数组元素的值</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p, (*pt)[<span class="number">4</span>], i, j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组内容为:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (p = a[<span class="number">0</span>]; p &lt; a[<span class="number">0</span>] + <span class="number">12</span>; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p - a[<span class="number">0</span>]) % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,  *p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入想要获取的数字的位置: i=, j= \n&quot;</span>);</span><br><span class="line">    pt = a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;i=%d, j=%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d行%d列的值为；\na[%d, %d]=%d\n&quot;</span>, i, j, i, j, *(*(pt + i) + j));</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex028.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">数组内容为:</span><br><span class="line">   1   2   3   4</span><br><span class="line">   5   6   7   8</span><br><span class="line">   9  10  11  12</span><br><span class="line">请输入想要获取的数字的位置: i=, j=</span><br><span class="line"> i=1, j=2</span><br><span class="line">1行2列的值为；</span><br><span class="line">a[1, 2]=7</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex29-将若干字符串按照字母顺序输出"><a href="#案例ex29-将若干字符串按照字母顺序输出" class="headerlink" title="案例ex29: 将若干字符串按照字母顺序输出"></a><strong>案例ex29: 将若干字符串按照字母顺序输出</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：sort()</p>
<p>功能：将若干字符串按照字母顺序输出</p>
<p>描述：实现对程序中几个字符串按照从小到大的顺序进行排序，并打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>运用字符串数组的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * week[] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>将 week 传递到 sort() 函数，然后利用 C 语言提供的 strcmp() 进行字符类的比较</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：sort()</span></span><br><span class="line"><span class="comment">功能：将若干字符串按照字母顺序输出</span></span><br><span class="line"><span class="comment">描述：实现对程序中几个字符串按照从小到大的顺序进行排序，并打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">char</span> *p[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(*(p+i), *(p+j)) &gt; <span class="number">0</span>) &#123;    <span class="comment">// 比较大小，交换位置</span></span><br><span class="line">                temp = *(p+i);</span><br><span class="line">                *(p+i) = *(p+j);</span><br><span class="line">                *(p+j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * week[] = &#123;</span><br><span class="line">        <span class="string">&quot;Monday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Tuesday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Wednesday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Thursday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Friday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Saturday&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Sunday&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    sort(week);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的周为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, *(week+i));</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex029.c -o de</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">排序后的周为：</span><br><span class="line">Friday Monday Saturday Sunday Thursday Tuesday Wednesday</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex30-用指向函数的指针比较大小"><a href="#案例ex30-用指向函数的指针比较大小" class="headerlink" title="案例ex30: 用指向函数的指针比较大小"></a><strong>案例ex30: 用指向函数的指针比较大小</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：min() / max()</p>
<p>功能：用指向函数的指针比较大小</p>
<p>描述：实现输入两个整数后，打印较小和较大的那个数字（规定使用指向函数的指针实现）</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>函数指针</strong></p>
<ul>
<li><p>函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。一个函数的地址是该函数的进入点，也是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。</p>
</li>
<li><p>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</p>
</li>
<li><p>定义形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型 (*指针变量名)(参数列表)；</span></span><br><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">int</span> (*p)(<span class="keyword">int</span> i,<span class="keyword">int</span> j);</span><br></pre></td></tr></table></figure></li>
<li>p是一个指针，它指向一个函数，该函数有2个整形参数，返回类型为int。p首先和*结合，表明p是一个指针。然后再与()结合，表明它指向的是一个函数。指向函数的指针也称为函数指针。</li>
</ul>
<p><strong>本案例中，利用指向函数的指针，在不同情况同一个指针指向不同的函数实现不同的功能</strong></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：min() / max()</span></span><br><span class="line"><span class="comment">功能：用指向函数的指针比较大小</span></span><br><span class="line"><span class="comment">描述：实现输入两个整数后，打印较小的那个数字（规定使用指向函数的指针实现）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>(*p)();</span><br><span class="line">    <span class="keyword">int</span> a, b, max_v, min_v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请你输入两个数字(如：a, b): \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d, %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="comment">// 取小值</span></span><br><span class="line">    p = min;</span><br><span class="line">    min_v = (*p)(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min=%d\n&quot;</span>, min_v);</span><br><span class="line">    <span class="comment">// 取大值</span></span><br><span class="line">    p = max;</span><br><span class="line">    max_v = (*p)(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max=%d\n&quot;</span>, max_v);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex030.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请你输入两个数字(如：a, b):</span><br><span class="line">1,5</span><br><span class="line">min=1</span><br><span class="line">max=5</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请你输入两个数字(如：a, b):</span><br><span class="line">10,50</span><br><span class="line">min=1</span><br><span class="line">max=50</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex31-字符串的匹配"><a href="#案例ex31-字符串的匹配" class="headerlink" title="案例ex31: 字符串的匹配"></a><strong>案例ex31: 字符串的匹配</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：match()</p>
<p>功能：字符串的匹配</p>
<p>描述：</p>
<p>本例实现两个字符串的匹配操作，即在第一个字符串中查找是否存在第二个字符串。</p>
<p>如果字符串完全匹配，则提示”匹配“，并显示第二个字符串在第一个字符串中的开始位置。</p>
<p>否则：提示”不匹配“</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本案例自定义 match(char <em>B, char </em>A) 函数进行匹配，使用循环进行每个字符进行比较，从而找出是否包含子串</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：match()</span></span><br><span class="line"><span class="comment">功能：字符串的匹配    </span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">本例实现两个字符串的匹配操作，即在第一个字符串中查找是否存在第二个字符串。</span></span><br><span class="line"><span class="comment">如果字符串完全匹配，则提示”匹配“，并显示第二个字符串在第一个字符串中的开始位置。</span></span><br><span class="line"><span class="comment">否则：提示”不匹配“</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> *B, <span class="keyword">char</span> *A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastB = <span class="built_in">strlen</span>(B) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lastA = <span class="built_in">strlen</span>(A) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endmatch = lastA;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; endmatch &lt;= lastB; endmatch++, start++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[endmatch] == A[lastA])</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>, i = start; j &lt; lastA &amp;&amp; B[i] == A[j];)</span><br><span class="line">                i++, j++;</span><br><span class="line">        <span class="keyword">if</span> (j == lastA)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (start + <span class="number">1</span>); <span class="comment">/*成功  */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endmatch &gt; lastB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;字符串不匹配!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;Computational advertising ecology&quot;</span>; <span class="comment">// 计算广告生态</span></span><br><span class="line">    <span class="keyword">char</span> t[] = <span class="string">&quot;advertising&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> p = match(s, t);</span><br><span class="line">    <span class="keyword">if</span> (p !=  - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配的开始位置在: %d&quot;</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex031.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">匹配!</span><br><span class="line">匹配的开始位置在: 15</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex32-使用malloc-函数分配内存"><a href="#案例ex32-使用malloc-函数分配内存" class="headerlink" title="案例ex32: 使用malloc()函数分配内存"></a><strong>案例ex32: 使用malloc()函数分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用malloc()函数分配内存</p>
<p>描述：</p>
<p>要求创建一个结构体类型的指针，其中包含两个成员，一个是整型，另外一个是结构体指针</p>
<p>使用 malloc() 函数分配一个结构体的内存空间，然后给这两个成员赋值并显示</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>malloc() 函数的语法格式如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><br>该函数的作用是在内存中的动态存储区域动态分配指定长度的存储空间。该函数返回一个指针，然后指向所分配存储空间的起始地址。<br>如果返回值 0，那么表示没有成功申请到内存空间。函数类型为 void * ，表示返回的指针不指向任何类型。</p>
<p>本例中，使用 malloc() 函数申请返回指向结构体的指针，利用该指针可以进行结构体成员的赋值和取值操作<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">st s = (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用malloc()函数分配内存</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">要求创建一个结构体类型的指针，其中包含两个成员，一个是整型，另外一个是结构体指针。</span></span><br><span class="line"><span class="comment">使用 malloc() 函数分配一个结构体的内存空间，然后给这两个成员赋值并显示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">next</span>;</span>    <span class="comment">// 结构体成员，指针类型</span></span><br><span class="line">&#125;*st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    st s = (struct stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct stu));     <span class="comment">// 开辟存储空间</span></span><br><span class="line">    s-&gt;n = <span class="number">1</span>;                 <span class="comment">// 成员 n 赋值</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;            <span class="comment">// 成员 next 赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成员的 n = %d, 成员 next = %d\n&quot;</span>, s-&gt;n, s-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex032.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">成员的 n = 1, 成员 next = 0</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex33-调用calloc-函数动态分配内存存放若干数据"><a href="#案例ex33-调用calloc-函数动态分配内存存放若干数据" class="headerlink" title="案例ex33: 调用calloc()函数动态分配内存存放若干数据"></a><strong>案例ex33: 调用calloc()函数动态分配内存存放若干数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：调用calloc()函数动态分配内存存放若干数据</p>
<p>返回值分配域的起始地址吗，如果分配失败返回 0</p>
<hr>
<p>理解<strong>malloc() 和 calloc() 异同点</strong></p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li><p><strong>calloc() 函数</strong><br>的语法格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">calloc</span><span class="params">(<span class="keyword">unsigned</span> n, <span class="keyword">unsigned</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在内存中动态分配 n 个长度为 size 的连续内存空间数组，calloc() 函数会返回一个指针<br>该指针指向动态分配的连续内存空间地址。<br>当分配错误的时候，会返回 0</p>
</li>
</ul>
<ul>
<li><p><strong>malloc() 和 calloc() 异同点</strong></p>
<ul>
<li><p><strong>共同点：</strong><br>都为了分配存储空间，<br>它们返回的是 void <em> 类型，也就是说如果我们要为int或者其他类型的数据分配空间<em>*必须显式强制转换</em></em>；</p>
</li>
<li><p><strong>不同点：</strong><br>malloc() 1个形参，因此如果是数组，必须由我们计算需要的字节总数作为形参传递<br>用malloc只分配空间不初始化，也就是依然保留着这段内存里的数据，<br>calloc() 2个形参，因此如果是数组，需要传递个数和数据类型<br>而calloc则进行了初始化，<strong>calloc分配的空间全部初始化为0</strong>，这样就避免了可能的一些数据错误</p>
</li>
</ul>
</li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：调用calloc()函数动态分配内存存放若干数据</span></span><br><span class="line"><span class="comment">返回值分配域的起始地址吗，如果分配失败返回 0</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> *p, *q;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数据的个数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">// 分配内存空间，并且会进行初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;为 %d 个数据分配内存空间 \n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (q = p; q &lt; p+n; ++q) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给 p 指向的一段内存空间存储的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex033.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入数据的个数：</span><br><span class="line">5</span><br><span class="line">为 5 个数据分配内存空间</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">给 p 指向的一段内存空间存储的内容是：</span><br><span class="line">1 5 6 8 9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex34-为具有-5-个数组元素的数组分配内存"><a href="#案例ex34-为具有-5-个数组元素的数组分配内存" class="headerlink" title="案例ex34: 为具有 5 个数组元素的数组分配内存"></a><strong>案例ex34: 为具有 5 个数组元素的数组分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：为具有 5 个数组元素的数组分配内存</p>
<p>描述：为具有 5 个元素的数组动态分配内存，并赋值输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用 calloc() 函数为数组的 5 个元素进行分配存储空间，然后进行赋值</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：为具有 5 个数组元素的数组分配内存</span></span><br><span class="line"><span class="comment">描述：为具有 5 个元素的数组动态分配内存，并赋值输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * p;</span><br><span class="line">    p = (<span class="keyword">int</span> *)<span class="built_in">calloc</span>(N, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;看使用 calloc() 函数后，初始化的内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        *(p+i) = i*<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化后的数组的内容：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(p+i));</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex034.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">看使用 calloc() 函数后，初始化的内容：</span><br><span class="line">0 0 0 0 0</span><br><span class="line">初始化后的数组的内容：</span><br><span class="line">0 3 6 9 12</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex35-为二维数组动态分配内存"><a href="#案例ex35-为二维数组动态分配内存" class="headerlink" title="案例ex35: 为二维数组动态分配内存"></a><strong>案例ex35: 为二维数组动态分配内存</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：为二维数组动态分配内存</p>
<p>描述：为二维数组动态分配内存，然后输出并释放内存</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li>在C语言中，一维数组是通过 malloc() 函数动态分配空间来实现的，动态的二维数组也能够通过malloc()函数动态分配空间来实现。实际上，C语言中没有二维数组，至少对二维数组没有直接的支持，取而代之的是“数组的数组”，二维数组能够看成是由指向数组的指针构成的数组。</li>
<li>对于一个二维数组p[i][j]，编译器通过公式 *(*(p+i)+j) 求出数组元素的值，其中，p+i表示计算行指针；*(p+i)表示具体的行，是指针，指向该行首元素地址 *(*(p+i)+j 表示得到具体元素的地址；*(*(p+i)+j)表示得到元素的值。基于这个原理，通过分配一个指针数组，再对指针数组的每一个元素分配空间实现动态的分配二维数组</li>
</ul>
<p>案例中实现的步骤<br>1.定义二维指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> **p;         <span class="comment">// 二维数组指针</span></span><br></pre></td></tr></table></figure>
<p>2.分配行动态空间<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *[M]));     <span class="comment">// 指向指针的指针</span></span><br></pre></td></tr></table></figure><br>3.再为每一行的每一列进行动态分配<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(p+i) = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>[N]));</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：为二维数组动态分配内存</span></span><br><span class="line"><span class="comment">描述：为二维数组动态分配内存，然后输出并释放内存</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> **p;         <span class="comment">// 二维数组指针</span></span><br><span class="line">    p = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *[M]));     <span class="comment">// 指向指针的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        *(p+i) = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>[N]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            *(*(p+i)+j) = i + j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;给二维数组分配空间后，内存的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d \t&quot;</span>, *(*(p+i)+j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex035.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">给二维数组分配空间后，内存的内容是：</span><br><span class="line">0     1     2     3     4</span><br><span class="line">1     2     3     4     5</span><br><span class="line">2     3     4     5     6</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex36-商品信息的动态存放"><a href="#案例ex36-商品信息的动态存放" class="headerlink" title="案例ex36: 商品信息的动态存放"></a><strong>案例ex36: 商品信息的动态存放</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：商品信息的动态存放</p>
<p>描述：</p>
<p>创建一个商品的结构体</p>
<p>动态分配一块内存区域，存放一个商品信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ul>
<li>定义一个商品信息的结构体类型，同时声明一个结构体类型的指针COMM</li>
<li>调用 malloc() 函数分配空间，地址存放在指针变量 commodity 中</li>
<li>利用指针变量访问该地址空间中的每个成员数据，并为成员赋值，主要要使用 “-&gt;” 去访问，例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COMM commodity = (struct commodity *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct commodity));</span><br><span class="line">commodity-&gt;num = <span class="number">1011</span>;</span><br><span class="line">commodity-&gt;name = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">commodity-&gt;count = <span class="number">10001</span>;</span><br><span class="line">commodity-&gt;price = <span class="number">15000.1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：商品信息的动态存放</span></span><br><span class="line"><span class="comment">描述：创建一个商品的结构体， 动态分配一块内存区域，存放一个商品信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">commodity</span> &#123;</span>    <span class="comment">// 结构体定义</span></span><br><span class="line">    <span class="keyword">int</span> num;                                     <span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">char</span> *name;                             <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">int</span> count;                              <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">double</span> price;                         <span class="comment">// 商品单价</span></span><br><span class="line">&#125;*COMM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    COMM commodity = (struct commodity *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct commodity));</span><br><span class="line">    commodity-&gt;num = <span class="number">1011</span>;</span><br><span class="line">    commodity-&gt;name = <span class="string">&quot;计算广告生态&quot;</span>;</span><br><span class="line">    commodity-&gt;count = <span class="number">10001</span>;</span><br><span class="line">    commodity-&gt;price = <span class="number">15000.1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;编号：%d\n商品名称：%s\n商品数量：%d\n商品单价：%f\n&quot;</span>,    </span><br><span class="line">        commodity-&gt;num, commodity-&gt;name, commodity-&gt;count, commodity-&gt;price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex036.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">编号：1011</span><br><span class="line">商品名称：计算广告生态</span><br><span class="line">商品数量：10001</span><br><span class="line">商品单价：15000.100000</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex37-用不带参数的宏定义求平行四边形面积"><a href="#案例ex37-用不带参数的宏定义求平行四边形面积" class="headerlink" title="案例ex37: 用不带参数的宏定义求平行四边形面积"></a><strong>案例ex37: 用不带参数的宏定义求平行四边形面积</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用不带参数的宏定义求平行四边形面积</p>
<p>描述：利用不带参数的宏的形式(一般宏大写字母，以便与其他的操作符进行区别)</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>不带参数的宏名定义如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名 字符串</span></span><br></pre></td></tr></table></figure><br>一般情况下 “#” 表示这是一条预处理命令，宏名是一个标识符，必须符合 C 语言规定<br>字符串可以是常数、表达式、格式字符串等<br>后面几节分别就这几种进行讲解</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A  8  <span class="comment">// 定义宏，设置底边的长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> H  6  <span class="comment">// 定义宏，设置高的长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：用不带参数的宏定义求平行四边形面积</span></span><br><span class="line"><span class="comment">描述：利用不带参数的宏的形式(一般宏大写字母，以便与其他的操作符进行区别)</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area;                                                <span class="comment">// 存储平行四边形面积</span></span><br><span class="line">    area = A * H;                                        <span class="comment">// 计算平行四边形面积</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 = %d\n&quot;</span>, area);         <span class="comment">// 输出面积值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex037.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">面积 = 48</span><br></pre></td></tr></table></figure>
<p>&gt;</p>
<hr>
<h3 id="案例ex38-使用宏定义实现数组值的互换"><a href="#案例ex38-使用宏定义实现数组值的互换" class="headerlink" title="案例ex38: 使用宏定义实现数组值的互换"></a><strong>案例ex38: 使用宏定义实现数组值的互换</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用宏定义实现数组值的互换</p>
<p>描述：定义一个宏 swap(a, b)，以实现两个整数的交换，并利用它将一维数组 a 和 b 进行交换</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>宏关于函数的运用<br>一般形式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 宏名(参数表) 字符串函数定义</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>对带参数的宏的展开只是将语句中的宏名后面括号内的实参字符串代替 #define 命令行中的形参</li>
<li>在宏定义时，在宏名与带参数的括号之间不可以加空格，否则将空格以后的字符都作为替代字符串的一部分</li>
<li><strong>在带参宏定义中，形式参数不分配内存单元，因此不必作类型定义</strong></li>
</ul>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123;int temp; temp=a;a=b;b=temp;&#125; <span class="comment">// 宏swap(a,b)进行两个整数的交换</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用宏定义实现数组值的互换</span></span><br><span class="line"><span class="comment">描述：定义一个宏 swap(a, b)，以实现两个整数的交换，并利用它将一维数组 a 和 b 进行交换</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[N], b[N];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数组a：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数组b：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, b+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组a的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组b的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换数组a 和 数组b的内容</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        swap(*(a+i), *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后数组a的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(a+i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;交换后数组b的内容是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(b+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex038.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个数组a：</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">15</span><br><span class="line">17</span><br><span class="line">19</span><br><span class="line">请输入一个数组b：</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">18</span><br><span class="line">20</span><br><span class="line">数组a的内容是：</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br><span class="line">数组b的内容是：</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br><span class="line">交换后数组a的内容是：</span><br><span class="line">2 4 6 8 10 12 14 16 18 20</span><br><span class="line">交换后数组b的内容是：</span><br><span class="line">1 3 5 7 9 11 13 15 17 19</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex39-编写头文件包含圆面积的计算公式"><a href="#案例ex39-编写头文件包含圆面积的计算公式" class="headerlink" title="案例ex39: 编写头文件包含圆面积的计算公式"></a><strong>案例ex39: 编写头文件包含圆面积的计算公式</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：编写头文件包含圆面积的计算公式</p>
<p>描述：</p>
<p>计算圆的面积，宏定义存储在一个头文件中</p>
<p>输入半径就可以得到面积</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>使用不同的文件需要包含不同的 #include 指令，包含两种格式<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;文件名&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;文件名&quot;</span></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>需要注意的是，这两种格式的区别是</p>
<ul>
<li>用尖括号时，系统到存放C库函数头文件所在的目录中寻找要包含的文件，这种称为标准方式</li>
<li>用双引号时，系统先在用户当前目录中寻找要包含的文件，若找不到，再到存放C库函数头文件所在的目录中寻找要包含的文件</li>
</ul>
</li>
<li><p>如果为调用库函数用 #include 命令来包含相关的头文件，则用尖括号，可以节省査找的时间</p>
</li>
<li>如果要包含的是用户自己编写的文件，一般用双引号，用户自己编写的文件通常是在当前目录中</li>
</ul>
<p><strong>如果文件不在当前目录中，双引号可给出文件路径</strong></p>
<p><strong>3 代码</strong></p>
<p>主函数代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ex039_area.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：编写头文件包含圆面积的计算公式</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">计算圆的面积，宏定义存储在一个头文件中</span></span><br><span class="line"><span class="comment">输入半径就可以得到面积</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> r;                            <span class="comment">// 定义园的半径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入半径:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;r);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;面积 =%.2f \n&quot;</span>,area(r));    <span class="comment">// 调用 ex039_area.h 中的 area函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ex039_area.h：</p>
<figure class="highlight h"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> area(r) PI*(r)*(r)</span></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex039.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入半径:</span><br><span class="line">3</span><br><span class="line">面积 =28.26</span><br><span class="line">~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入半径:</span><br><span class="line">10</span><br><span class="line">面积 =314.00</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex40-利用宏定义求偶数和"><a href="#案例ex40-利用宏定义求偶数和" class="headerlink" title="案例ex40: 利用宏定义求偶数和"></a><strong>案例ex40: 利用宏定义求偶数和</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：利用宏定义求偶数和</p>
<p>描述：</p>
<p>定义一个宏实现求 1~100 的偶数和</p>
<p>定义一个宏判断一个数是否为偶数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>1、先熟悉带参数的宏已经参数宏利用其它的宏定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVEN(x) (((x)%2==0)?TRUE:FALSE)</span></span><br></pre></td></tr></table></figure>
<p><strong>2、要点</strong><br>在累加求和过程中需要不断判断数据是否为偶数，因此要创建带参数的宏<br>把判断偶数的过程定义为常量，由于C语言中不提供逻辑常量，因此自定义宏 TRUE 和 FALSE,表示1和0<br>因此，判断偶数的宏又可以演变为下面的形式：</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVEN(x) (((x)%2==0)?TRUE:FALSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：利用宏定义求偶数和</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">定义一个宏实现求 1~100 的偶数和</span></span><br><span class="line"><span class="comment">定义一个宏判断一个数是否为偶数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(EVEN(i))    </span><br><span class="line">            sum+=i;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SUM = %d\n&quot;</span>,sum);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex040.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">SUM = 2550</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex41-利用文件包含设计输出模式"><a href="#案例ex41-利用文件包含设计输出模式" class="headerlink" title="案例ex41: 利用文件包含设计输出模式"></a><strong>案例ex41: 利用文件包含设计输出模式</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：利用文件包含设计输出模式</p>
<p>描述：</p>
<p>在程序设计时需要很多输出格式，如整型、实型及字符型等，在编写稈序时会经常使用这些输出格式<br>如果经常书写这些格式会很繁琐，要求设计一个头文件，将经常使用的<br>输出模式都写进头文件中，方便编写代码</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本稈序中仅举一个简单的例子，将整型数据的输出写入到头文件中，并将这个头文件<br>命名为 ex041_format.h 声明整型数据并输出的形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTEGER(d) printf(<span class="meta-string">&quot;%4d\n&quot;</span>,d)</span></span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<p>主函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ex041_format.h&quot;</span>    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：利用文件包含设计输出模式</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">在程序设计时需要很多输出格式，如整型、实型及字符型等，在编写稈序时会经常使用这些输出格式</span></span><br><span class="line"><span class="comment">如果经常书写这些格式会很繁琐，要求设计一个头文件，将经常使用的</span></span><br><span class="line"><span class="comment">输出模式都写进头文件中，方便编写代码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;                    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数:&quot;</span>);    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);        </span><br><span class="line">    INTEGER(d);        <span class="comment">// 使用宏定义的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ex041_format.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTEGER(d) printf(<span class="meta-string">&quot;计算结果: %4d\n&quot;</span>,d)</span></span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex041.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个整数:10</span><br><span class="line">计算结果:   10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex42-使用条件编译隐藏密码"><a href="#案例ex42-使用条件编译隐藏密码" class="headerlink" title="案例ex42: 使用条件编译隐藏密码"></a><strong>案例ex42: 使用条件编译隐藏密码</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用条件编译隐藏密码</p>
<p>描述：一般输入密码时都会用拿号来替代，用以增强安全性。要求设置一个宏，规定宏体为<br>1,在正常情况下密码显示为审号的形式，在某些特殊的时候，显示为字符串。运行结果</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>C 语言预编译命令 <strong>#if··· #else··· #endif</strong></p>
<p>这个方法一般可以用来调试的时候用，也可以作为控制语句进行使用。有时候串口打印信息太多，一条条注释就很麻烦，于是就用这种方法，定义个宏变量，判断宏变量的条件，来达到改变宏变量的值控制那些代码编译</p>
<p>指令格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span></span></span><br><span class="line">    语句段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    语句段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>对于一个字符串要求有两种输出形式<br>一种是原样输出<br>另一种是用相同数目输出<br>可以通过选择语句来实现，但是使用条件编译指令可以在编译阶段就决定要怎样操作</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWD 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：使用条件编译隐藏密码</span></span><br><span class="line"><span class="comment">描述：一般输入密码时都会用拿号来替代，用以增强安全性。要求设置一个宏，规定宏体为</span></span><br><span class="line"><span class="comment">1,在正常情况下密码显示为审号的形式，在某些特殊的时候，显示为字符串。运行结果</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s=<span class="string">&quot;mrsoft&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> PWD    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;******\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,s);    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex042.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">******</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex43-关闭所有打开的文件"><a href="#案例ex43-关闭所有打开的文件" class="headerlink" title="案例ex43: 关闭所有打开的文件"></a><strong>案例ex43: 关闭所有打开的文件</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：用fgetc函数从键盘逐个输入字符，然后用fputc函数写到磁盘文件中</p>
<p>描述：</p>
<p>用 fgetc 函数从键盘逐个输入字符，然后用 fputc函数写到磁盘文件即可</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>用来存储数据的文件名可以在fopen函数中直接写成字符串常量形式(如指定”1”)，也可以在程序运行时由用户临时指定。本程序采取的方法是由键盘输入文件名。为此设立一个字符数组filename,用来存放文件名。运行时，从键盘输入磁盘文件名”ex043_file.dat”, 操作系统就新建立一个磁盘文件ex043_file.dat,用来接收程序输出的数据</li>
<li>用fopen函数打开一个”只写”的文件(“w”表示只能写入不能从中读数据)，如果打开文件成功，函数的返回值是该文件所建立的信息区的起始地址，把它赋给指针变量fp(fp已定义为指向文件的指针变量)。如果不能成功地打开文件，则在显示器的屏幕上显示”无法打开此文件”,然后用exit函数终止程序运行</li>
<li>exit是标准C的库函数，作用是使程序终止，用此函数时在程序的开头应包含 <stdlib.h> 头文件</stdlib.h></li>
<li>用getchar函数接收用户从键盘输入的字符。注意每次只能接收一个字符。今输入字符串”公众号：计算广告生态”是用来向程序表示：输入的字符串到此结束。用什么字符作为结束标志是人为的，由程序指定的，也可以用别的字符(如或其他字符)作为结束标志。但应注意：如果字符串中包含”#”,就不能用”# “作结束标志</li>
<li>执行过程是：先从键盘读入一个字符，检查它是否如果是，表示字符串已结束，不执行循环体。如果不是’#’,则执行一次循环体，将该字符输出到磁盘文件filel.datₒ然后在屏幕上显示出该字符，接着再从键盘读入一个字符。如此反复，直到读入’#’字符为止。这时,程序已将”公众号：计算广告生态”写到以”filel. dat”命名的磁盘文件中了，同时在屏幕上也显示出了这些字符，以便核对。</li>
<li>ex043_file.dat 中是否确实存储了这些内容，可以在资源管理器中，按记事本的打开方式打开文件,或者在其他系统有其他查看方式</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：关闭所有打开的文件</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">用 fgetc 函数从键盘逐个输入字符，然后用 fputc函数写到磁盘文件即可</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> ch, filename[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要操作的文件名：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, filename);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(filename, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) &#123;     <span class="comment">// 打开输入文件并使 fp 指向此文件    </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开此文件！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);                                         <span class="comment">// 终止程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch = getchar();                                <span class="comment">// 用来接收最后输入的回车符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个准备存储到磁盘的字符串（以&#x27;#&#x27;结束）\n&quot;</span>);</span><br><span class="line">    ch = getchar();                                <span class="comment">// 用来接收从键盘输入的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span>) &#123;                        <span class="comment">// 当输入&quot;#&quot;时结束循环</span></span><br><span class="line">        fputc(ch, fp);                            <span class="comment">// 用来向磁盘输出第一个字符</span></span><br><span class="line">        <span class="built_in">putchar</span>(ch);                                <span class="comment">// 将输出的字符显示在屏幕上</span></span><br><span class="line">        ch = getchar();                            <span class="comment">// 接收从键盘输入的一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);                                        <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                                    <span class="comment">// 向屏幕输出一个换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例结果：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex043.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入要操作的文件名：</span><br><span class="line">ex043_file.dat</span><br><span class="line">请输入一个准备存储到磁盘的字符串（以&#x27;#&#x27;结束）</span><br><span class="line">公众号:计算广告生态</span><br><span class="line">公众号:计算广告生态</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p><strong>文件中的显示：</strong></p>
<p>ex043_file.dat：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">公众号:计算广告生态</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex44-将文件中的内容从一个文件拷贝到另外一个文件"><a href="#案例ex44-将文件中的内容从一个文件拷贝到另外一个文件" class="headerlink" title="案例ex44: 将文件中的内容从一个文件拷贝到另外一个文件"></a><strong>案例ex44: 将文件中的内容从一个文件拷贝到另外一个文件</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将文件中的内容从一个文件拷贝到另外一个文件</p>
<p>描述：将上一个案例中的ex043_file.dat 赋值内容到 ex044_file.data</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>1、在访问磁盘文件时，是<strong>逐个字符(字节)</strong>进行的，为了知道当前访问到第几个字节，系统用 “<strong>文件读写位置标记</strong>“ 来表示当前所访问的位置。开始时“文件读写位置标记”指向第1个字节, <strong>每访问完一个字节后，当前读写位置就指向下一个字节</strong>，即当前读写位置自动后移。</p>
<p>2、为了知道对文件的访问是否完成，只须看文件读写位置是否移到文件的末尾。用<strong>feof函数</strong>可以检查到”<strong>文件读写位置标记</strong>“是否移到<strong>文件的末尾</strong>，即磁盘文件是否结束。程序第 26 行中的feof(in)是检查in所指向的文件是否结束。如果是，则函数值为1(真)，否则为0(假)，也就是“ !feof(in) ”为真，在while循环中检査“!feof(in)”为真，就执行循环体。</p>
<p>3、运行结果是将file.dat文件中的内容复制到file2.dat中去。打开这两个文件，可以看到<br>filel. dat 和 file2. dat 的内容都是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<p>4、以上程序是按文本文件方式处理的。也可以用此程序来复制一个二进制文件，只须将两个fopen函数中的“r”和“w”分别改为“rb”和“wb”即可。</p>
<p>5、C 系统已把fputc和fgetc函数定义为宏名putc和getc：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> putc(ch, fp) fputc(ch, fp)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> getc(fp) fgetc(fp)</span></span><br></pre></td></tr></table></figure>
<p>这是在 <stdio.h> 中定义的。因此，在程序中用putc和fputc作用是一样的，用getc和fgetc<br>作用是一样的。在使用的形式上，可以把它们当作相同的函数对待。</stdio.h></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将文件中的内容从一个文件拷贝到另外一个文件</span></span><br><span class="line"><span class="comment">描述：将上一个案例中的ex043_file.dat 赋值内容到 ex044_file.dat</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE *in, *out;                                        <span class="comment">// 指向文件的变量</span></span><br><span class="line">    <span class="keyword">char</span> ch, infile[<span class="number">20</span>], outfile[<span class="number">20</span>];    <span class="comment">// 定义的两个字符数组，分别存放两个数据文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入读入文件的名称(ex043_file.dat)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, infile);                            <span class="comment">// 输入第一个要读取文件的文件名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入输出文件的名称(ex044_file.dat)：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, outfile);                            <span class="comment">// 输入第一个要读取文件的文件名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((in = fopen(infile, <span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>) &#123;     <span class="comment">// 打卡输入文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输入文件..\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((out = fopen(outfile, <span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>) &#123;     <span class="comment">// 打卡输出文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开输出文件..\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">while</span>(!feof(in)) &#123;                    <span class="comment">// 如果未遇到输入文件的结束标志，每次访问完一个字节后自动指向下一个字节</span></span><br><span class="line">        ch = fgetc(in);                        <span class="comment">// 从输入文件中读取一个</span></span><br><span class="line">        fputc(ch, out);                        <span class="comment">// 将 ch 写到 outfile 中</span></span><br><span class="line">        <span class="built_in">putchar</span>(ch);                             <span class="comment">// 显示到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                                <span class="comment">// 最后进行换行</span></span><br><span class="line">    fclose(in);                                    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    fclose(out);                                <span class="comment">// 关闭输出文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex044.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入读入文件的名称(ex043_file.dat)：ex043_file.dat</span><br><span class="line">输入输出文件的名称(ex044_file.dat)：ex044_file.dat</span><br><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<p>原来文件中的内容：</p>
<blockquote>
<p>This is the first message<br>copy to another file</p>
</blockquote>
<p>赋值过去的文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is the first message</span><br><span class="line">copy to another file</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex45-将排好序的字符串保存到磁盘文件中"><a href="#案例ex45-将排好序的字符串保存到磁盘文件中" class="headerlink" title="案例ex45: 将排好序的字符串保存到磁盘文件中"></a><strong>案例ex45: 将排好序的字符串保存到磁盘文件中</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将排好序的字符串保存到磁盘文件中</p>
<p>描述：从键盘读入若干个字符串，对它们按字母大小的顺序排序，然后把排好序的字符串送到磁盘文件中保存</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p><strong>2.1 处理字符串的两个函数</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>调用形式</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>fgets</td>
<td>fgets(str, n, fp)</td>
<td>从fp指向的文件读入一个长度为 (n-1) 的字符串，存放到字符数组str中</td>
<td>读成功，返回地址str，失败则返回 NULL</td>
</tr>
<tr>
<td>fputs</td>
<td>fputs(str, fp)</td>
<td>把str所指向的字符串写到文件指针变量 fp 所指向的文件中</td>
<td>输出成功，返回0；否则返回非 0 值</td>
</tr>
</tbody>
</table>
</div>
<p>fgets 中最后一个字母 s 表示字符串（string）。fgets 的含义是，从文件读取一个字符串</p>
<p><strong>1. fgets 函数的函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fgets</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">int</span> n, fILE * fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其作用是从文件中读取一个字符串。调用时可以写成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fgets(str, n, fp)</span><br></pre></td></tr></table></figure>
<p>其中 n 是要求得到的字符的个数，<strong>但实际上只从fp所指向的文件中读取 n-1 个字符，然后在最后加 ‘\0’ 字符</strong>，这样得到的字符串共有 n 个字符，把它们放到数组 str 中。如果在读完 n-1 个字符之前遇到了换行符 ‘\n’ 或者结束符EOF，读入即结束，这块遇到换行符 ‘\n’ 也作为一个字符读入。若执行 fgets函数成功，则返回值为 str 数组元素的地址，如果一开始就遇到文件尾或者读取数据出错，则返回 NULL</p>
<p><strong>2.fputs函数的函数原型</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fputs</span><span class="params">(<span class="keyword">char</span> * str, fILE * fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其作用是将str所指向的字符串输出到fp所指向的文件中。调用时可以写成</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fputs</span>(<span class="string">&quot;China&quot;</span>, fp);</span><br></pre></td></tr></table></figure>
<p>把字符串“China”输出到fp指向的文件中。fputs函数中第 1 个参数可以是字符串常量、字符数组名或者字符型指针。字符串末尾的 ‘\0’ 不输出，若输出成功，函数值为 0；失败时，函数值为 EOF。</p>
<p>fgets 和 fgets 这两个函数的功能类似于 gets 和 puts 函数，只是 gets 和 puts 以终端为读写对象，而 fgets 和 fputs 函数以指定的文件作为读写对象。</p>
<p><strong>3 思路</strong></p>
<ol>
<li>从键盘读入n个字符串，存放在一个二维字符数组中，每个一维数组存放一个字符串</li>
<li>对字符数组中的n个字符串按字母顺序排序，排好序的字符串仍存放在字符数组中</li>
<li>将字符数组中的字符串顺序输出</li>
</ol>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将排好序的字符串保存到磁盘文件中</span></span><br><span class="line"><span class="comment">描述：从键盘读入若干个字符串，对它们按字母大小的顺序排序，然后把排好序的字符串送到磁盘文件中保存</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">3</span>][<span class="number">20</span>], temp[<span class="number">10</span>];                <span class="comment">// str保存存放字符串的二维数组，temp 临时数组</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入三个字符串: \n&quot;</span>);                <span class="comment">// 提示输入字符串</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        gets(str[i]);                                         <span class="comment">// 终端输入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;                     <span class="comment">// 用选择法对字符串排序</span></span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str[k], str[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                k=j;</span><br><span class="line">        <span class="keyword">if</span>(k != i) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(temp, str[i]);</span><br><span class="line">            <span class="built_in">strcpy</span>(str[i], str[k]);</span><br><span class="line">            <span class="built_in">strcpy</span>(str[k], temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;save_string.dat&quot;</span>, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) &#123;     <span class="comment">// 打开磁盘文件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新的语句是：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(str[i], fp);</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;\n&quot;</span>, fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex045.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入三个字符串:</span><br><span class="line">grasp</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">新的语句是：</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">grasp</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex46-用二进制方式向文件读写一组数据"><a href="#案例ex46-用二进制方式向文件读写一组数据" class="headerlink" title="案例ex46: 用二进制方式向文件读写一组数据"></a><strong>案例ex46: 用二进制方式向文件读写一组数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：save()/read()</p>
<p>功能：用二进制方式向文件读写一组数据</p>
<p>描述：从键盘输入 10 个学生的有关数据，然后把他们转存到磁盘文件中去</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p>在程序中不仅需要一次输入输出一个数据， 而且常常需要一次输入输出一组数据(如数组或结构体变量的值)， C语言允许用fread函数从文件中读一个数据块， 用fwrite函数向文件写一个数据块。在读写时是以二进制形式进行的。向磁盘写数据时， 直接将内存中一组数据原封不动、不加转换地复制到磁盘文件上， 在读入时也是将磁盘文件中若干字节的内容一批读入内存<br>它们的一般调用形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(buffer， size， count， fp);</span><br><span class="line">fwrite(buffer， size， count， fp);</span><br></pre></td></tr></table></figure>
<p>buffer：是一个地址</p>
<p><em>对fread来说，它是用来存放从文件读入的数据的存储区的地址</em></p>
<p><em>对fwrite来说，是要把此地址开始的存储区中的数据向文件输出(以上指的是起始地址)</em></p>
<p>size：要读写的字节数</p>
<p>count：要读写多少个数据项(每个数据项长度为size)</p>
<p>fp： FILE类型指针</p>
<p>在打开文件时指定用二进制文件， 这样就可以用 fread 和 fwrite 函数读写任何类型的信息， 例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(f, <span class="number">4</span>, <span class="number">10</span>, fp);</span><br></pre></td></tr></table></figure>
<p>其中 f 是一个 float 型数组名(代表数组首元素地址)。这个函数从 fp 所指向的文件读入10个4字节的数据，存储到数组 f 中。</p>
<p><strong>3 思路</strong></p>
<p>定义一个有 10 个元素的结构体数据，用来存放 10 个学生的数据。</p>
<p>从 main() 中输入 10 个数据。</p>
<p>用 save() 函数实现向磁盘输出学生数据。</p>
<p>用 fwrite() 函数一次输出一个学生的数据</p>
<p>用fread() 函数进行数据的读取</p>
<ol>
<li>在main函数中，从终端键盘输入io个学生的数据，然后调用 save 函数，将这些数据输出到以“stu.dat”命名的磁盘文件中。fwrite函数的作用是将一个长度为36节的数据块送到 ex046_stud.dat 文件中（一个struct student_type类型结构体变量的长度为它的成员长度之和，即10 + 4 + 4 + 15 = 33，实际上占36字节，是4的倍数）</li>
<li>在fopen函数中指定读写方式为“wb”，即二进制写方式。在向磁盘文件 ex046_stud.dat 写的时候，将内存中存放stud数组元素stud订的内存单元中的内容原样复制到磁盘文件，所建立的 ex046_stud.dat 文件是一个二进制文件。这个文件可以为其他程序所用。</li>
<li>在本程序中，用fopen函数打开文件时没有指定路径，只写了文件名ex046_stud.dat，系统默认其路径为当前用户所使用的子目录，在此目录下建立一个新文件ex046_stud.dat，输出的数据存放在此文件中。</li>
<li>程序运行时，屏幕上并无输出任何信息，只是将从键盘输入的数据送到磁盘文件上</li>
</ol>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：save()/read()</span></span><br><span class="line"><span class="comment">功能：用二进制方式向文件读写一组数据</span></span><br><span class="line"><span class="comment">描述：从键盘输入 10 个学生的有关数据，然后把他们转存到磁盘文件中去</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_type</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;stud[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以二进制格式进行保存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;wb&quot;</span>)) == <span class="literal">NULL</span>) &#123;        <span class="comment">// 打卡输入文件 ex046_stud.dat</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入文件打开失败！\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入成功！\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fwrite(&amp;stud[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写入失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从二进制文件中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span> ((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读取打开文件失败!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        fread(&amp;stud[i], <span class="keyword">sizeof</span>(struct Student_type), <span class="number">1</span>, fp);     <span class="comment">// 从 fp 指向的文件读入一组数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%d\t%s\n&quot;</span>, stud[i].name, stud[i].num, stud[i].age, stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入 %d 个学生的信息：\n&quot;</span>, SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;    <span class="comment">// 注意 scanf 中的地址传递</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%s&quot;</span>,stud[i].name,&amp;stud[i].num,&amp;stud[i].age,&amp;stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">    save();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n====== 读取写入的数据 =======\n&quot;</span>);</span><br><span class="line">    read();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex046.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入 10 个学生的信息：</span><br><span class="line">&quot;A&quot; 1 11 &quot;street01&quot;</span><br><span class="line">&quot;B&quot; 2 12 &quot;street02&quot;</span><br><span class="line">&quot;C&quot; 3 13 &quot;street03&quot;</span><br><span class="line">&quot;D&quot; 4 14 &quot;street04&quot;</span><br><span class="line">&quot;E&quot; 5 15 &quot;street05&quot;</span><br><span class="line">&quot;F&quot; 6 16 &quot;street06&quot;</span><br><span class="line">&quot;G&quot; 7 17 &quot;street07&quot;</span><br><span class="line">&quot;H&quot; 8 18 &quot;street08&quot;</span><br><span class="line">&quot;I&quot; 9 19 &quot;street09&quot;</span><br><span class="line">&quot;J&quot; 10 110 &quot;street010&quot;</span><br><span class="line">写入成功！</span><br><span class="line"></span><br><span class="line">====== 读取写入的数据 =======</span><br><span class="line">&quot;A&quot;    1    11    &quot;street01&quot;</span><br><span class="line">&quot;B&quot;    2    12    &quot;street02&quot;</span><br><span class="line">&quot;C&quot;    3    13    &quot;street03&quot;</span><br><span class="line">&quot;D&quot;    4    14    &quot;street04&quot;</span><br><span class="line">&quot;E&quot;    5    15    &quot;street05&quot;</span><br><span class="line">&quot;F&quot;    6    16    &quot;street06&quot;</span><br><span class="line">&quot;G&quot;    7    17    &quot;street07&quot;</span><br><span class="line">&quot;H&quot;    8    18    &quot;street08&quot;</span><br><span class="line">&quot;I&quot;    9    19    &quot;street09&quot;</span><br><span class="line">&quot;J&quot;    10    110    &quot;street010&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex47-对一个文件重复读取"><a href="#案例ex47-对一个文件重复读取" class="headerlink" title="案例ex47: 对一个文件重复读取"></a><strong>案例ex47: 对一个文件重复读取</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p><strong>功能</strong>：对一个文件重复读取（利用rewind()函数）</p>
<p><strong>描述：</strong></p>
<p>将磁盘文件的内容进行读取</p>
<p>第一次将它的内容显示在屏幕上，第二次把他复制到另外一个文件中</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<p>对文件需要进行随机读取的原因：<br>对文件进行顺序读写比较容易理解，也容易操作，但有时效率不高，例如文件中有1000个数据，若只査第1000个数据，必须先逐个读入前面999个数据，才能读入第1000个数据。如果文件中存放一个城市几百万人的资料,若按此方法查某一人的情况，等待的时间可能太长了。<br>随机访问不是按数据在文件中的物理位置次序进行读写，而是可以对任何位置上的数<br>据进行访问，显然这种方法比顺序访问效率高得多。</p>
<p><strong>rewind() 函数</strong></p>
<p>文件位置标记定位，强制使文件位置标记指向文件开头，此函数没有返回值</p>
<p><strong>3 思路</strong></p>
<p>可以利用 rewind() 函数进行操作，当第一次读取完后，文件位置标记指向了文件尾，那么使用 rewind() 函数将文件位置标记重新返回到文件头部</p>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：对一个文件重复读取</span></span><br><span class="line"><span class="comment">描述：将磁盘文件的内容进行读取，第一次将它的内容显示在屏幕上，第二次把他复制到另外一个文件中</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp1, * fp2;</span><br><span class="line">    fp1 = fopen(<span class="string">&quot;ex047_1.dat&quot;</span>, <span class="string">&quot;r&quot;</span>);     <span class="comment">// 打开输入文件</span></span><br><span class="line">    fp2 = fopen(<span class="string">&quot;ex047_2.dat&quot;</span>, <span class="string">&quot;w&quot;</span>);     <span class="comment">// 打开写入文件</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp1))&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(fgetc(fp1));             <span class="comment">// 输出到屏幕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="number">10</span>);                         <span class="comment">// 换行</span></span><br><span class="line">    rewind(fp1);                        <span class="comment">// 文件位置标记重新返回文件的开头</span></span><br><span class="line">    <span class="keyword">while</span>(!feof(fp1)) &#123;</span><br><span class="line">        fputc(fgetc(fp1), fp2);             <span class="comment">// 重头，逐个字符读取写入到ex047_2.dat</span></span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex047.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this is my first use of wind!</span><br></pre></td></tr></table></figure>
<p>ex047_2.dat 文件中内容，与ex047_1.dat一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">this is my first use of wind!</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex48-将文件中不同位置的数据打印出来"><a href="#案例ex48-将文件中不同位置的数据打印出来" class="headerlink" title="案例ex48: 将文件中不同位置的数据打印出来"></a><strong>案例ex48: 将文件中不同位置的数据打印出来</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：将文件中不同位置的数据打印出来</p>
<p>描述：</p>
<p>在磁盘上也存有10个学生的数据，要求将第 1、3、5、7、9 的学生数据输入到计算机<br>并且在屏幕中显示出来</p>
</blockquote>
<p><strong>2 知识点</strong></p>
<ul>
<li><p>fseek() 函数</p>
<p>fseek() 函数改变文件位置标记<br>fseek() 的调用形式;<br>fseek(文件类型指针, 位移量, 起始点)<br>起始点用0，1或者2来替代。0 代表文件起始位置、1代表当前位置、2代表文件末尾位置</p>
<p>“位移量”指的是一“起始点” 为基点，向前移动的字节数。位移量应是 long 型数据<br>fseek() 函数一般用于二进制文件。看以下例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fseek(fp, <span class="number">100L</span>, <span class="number">0</span>)     <span class="comment">// 将文件位置标记向前移动到离文件开头100个字节处</span></span><br><span class="line">fseek(fp, <span class="number">50L</span>, <span class="number">1</span>)     <span class="comment">// 将文件位置标记向前移动到离当前位置50个字节处</span></span><br><span class="line">fseek(fp, <span class="number">-10L</span>, <span class="number">2</span>)     <span class="comment">// 将文件位置标记向前移动到离文件末尾10个字节处</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>ftell() 函数<br>测定文件位置标记的当前位置<br>ftell() 的作用是得到流式文件中文件位置标记的当前位置<br>由于文件中的文件位置标记经常移动，人们往往不容易知道其当前的位置，所以常用 ftell() 函数得到当前位置，<strong>用相对于文件开头的位移量来表示</strong>。<br>如果调用函数时出错（例如不存在 fp 指向的文件）， ftell() 返回 -1L。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i = ftell(fp);     <span class="comment">// i 存放文件当前的位置</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">-1L</span>) &#123;</span><br><span class="line">    print(<span class="string">&quot;error!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3 思路</strong></p>
<ol>
<li>按照2进制只读的方式打开指定文件，准备从文件中读取学生的成绩</li>
<li>将文件位置标记指向文件的开头，然后从磁盘文件读取一个学生的信息，并把它显示在屏幕上</li>
<li>再将文件位置标记指向第 1、3、5、7、9 的学生的数据区的开头，从磁盘中读取相应的学生的信息，显示在屏幕上</li>
<li>关闭文件</li>
</ol>
<p><strong>注意：将【ex046.c 用二进制方式向文件读写一组数据】按照二进制形式写入的学生信息进行读取</strong></p>
<p><strong>4 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：将文件中不同位置的数据打印出来</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">在磁盘上也存有10个学生的数据，要求将第 3、5、7、9 的学生数据输入到计算机</span></span><br><span class="line"><span class="comment">并且在屏幕中显示出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student_type</span> &#123;</span>     <span class="comment">// 学生数据信息</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;stud[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(<span class="string">&quot;ex046_stud.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开文件失败！\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        fseek(fp, i*<span class="keyword">sizeof</span>(struct student_type), <span class="number">0</span>);             <span class="comment">// 移动文件位置标记</span></span><br><span class="line">        fread(&amp;stud[i], <span class="keyword">sizeof</span>(struct student_type), <span class="number">1</span>, fp);    <span class="comment">// 读取一个数据块到结构体变量</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %4d %d %s \n&quot;</span>, stud[i].name, stud[i].num, stud[i].age, stud[i].addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源文件中的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;    1    11    &quot;street01&quot;</span><br><span class="line">&quot;B&quot;    2    12    &quot;street02&quot;</span><br><span class="line">&quot;C&quot;    3    13    &quot;street03&quot;</span><br><span class="line">&quot;D&quot;    4    14    &quot;street04&quot;</span><br><span class="line">&quot;E&quot;    5    15    &quot;street05&quot;</span><br><span class="line">&quot;F&quot;    6    16    &quot;street06&quot;</span><br><span class="line">&quot;G&quot;    7    17    &quot;street07&quot;</span><br><span class="line">&quot;H&quot;    8    18    &quot;street08&quot;</span><br><span class="line">&quot;I&quot;    9    19    &quot;street09&quot;</span><br><span class="line">&quot;J&quot;    10    110    &quot;street010&quot;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;A&quot;    1 11 &quot;street01&quot;</span><br><span class="line">&quot;C&quot;    3 13 &quot;street03&quot;</span><br><span class="line">&quot;E&quot;    5 15 &quot;street05&quot;</span><br><span class="line">&quot;G&quot;    7 17 &quot;street07&quot;</span><br><span class="line">&quot;I&quot;    9 19 &quot;street09&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex49-文件加密"><a href="#案例ex49-文件加密" class="headerlink" title="案例ex49: 文件加密"></a><strong>案例ex49: 文件加密</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>函数：encrypt()<br>功能：文件加密<br>描述：C语言实现文件加密，执行参数有<br>【原文件路径及名称 密码 加密后文件路径及名称】</p>
</blockquote>
<p><strong>2 思路</strong></p>
<blockquote>
<p>register 关键字</p>
</blockquote>
<p>C语言中的关键字register代表寄存器存储类型<br>register修饰符暗示编译程序相应dao的变量zhuan将被频繁地使用，如shu果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中而不是通过内存寻址访问以提高效率</p>
<blockquote>
<p>加密</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ch = ch ^ *(pwd + i);</span><br></pre></td></tr></table></figure>
<p>采用异或方法进行加密，当然不同的情况可以采用不同的方式进行加密</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：文件加密</span></span><br><span class="line"><span class="comment">描述：C语言实现文件加密，执行参数有</span></span><br><span class="line"><span class="comment">【原文件路径及名称 密码 加密后文件路径及名称】</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">char</span> *s_file, <span class="keyword">char</span> *pwd, <span class="keyword">char</span> *c_file)</span></span>;                     <span class="comment">// 文件加密函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">char</span> *s_file, <span class="keyword">char</span> *pwd, <span class="keyword">char</span> *c_file)</span> </span>&#123;                      <span class="comment">// 自定义函数encrypt用于加密</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    FILE *fp1,  *fp2;                                                     <span class="comment">// 定义fp1和fp2是指向结构体变量的指针</span></span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> ch;</span><br><span class="line">    fp1 = fopen(s_file, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开原文件.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                                         <span class="comment">// 如果不能打开要加密的文件,便退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    fp2 = fopen(c_file, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开被加密的文件.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                                         <span class="comment">// 如果不能建立加密后的文件,便退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    ch = fgetc(fp1);</span><br><span class="line">    <span class="keyword">while</span> (!feof(fp1))    &#123;                                                 <span class="comment">// 测试文件是否结束</span></span><br><span class="line"></span><br><span class="line">        ch = ch ^ *(pwd + i);                                            <span class="comment">// 采用异或方法进行加密，也可以采用其他方式方法就行加密</span></span><br><span class="line">        i++;</span><br><span class="line">        fputc(ch, fp2);                                                    <span class="comment">// 异或后写入fp2文件</span></span><br><span class="line">        ch = fgetc(fp1);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">9</span>)</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sourcefile[<span class="number">50</span>];                                                 <span class="comment">// 被加密的文件名称</span></span><br><span class="line">    <span class="keyword">char</span> codefile[<span class="number">50</span>];                         <span class="comment">// 加密后的文件名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">10</span>];                                                         <span class="comment">// 密码存储</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;                                                    <span class="comment">// 容错处理，不满足参数格式，需要自行输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入原文件名称:\n&quot;</span>);</span><br><span class="line">        gets(sourcefile);                                                 <span class="comment">// 得到要加密的文件名</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入密码:\n&quot;</span>);</span><br><span class="line">        gets(pwd);                                                         <span class="comment">// 得到密码</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入加密后文件名称:\n&quot;</span>);</span><br><span class="line">        gets(codefile);                                                 <span class="comment">// 得到加密后你要的文件名</span></span><br><span class="line">        encrypt(sourcefile, pwd, codefile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(sourcefile, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">strcpy</span>(pwd, argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">strcpy</span>(codefile, argv[<span class="number">3</span>]);</span><br><span class="line">        encrypt(sourcefile, pwd, codefile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex049.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入原文件名称:</span><br><span class="line">s_file.txt</span><br><span class="line">请输入密码:</span><br><span class="line">johngo_py</span><br><span class="line">请输入加密后文件名称:</span><br><span class="line">c_file.txt</span><br></pre></td></tr></table></figure>
<p>最后就可以发现有加密后的文件产出</p>
<hr>
<h3 id="案例ex50-使用共用体存放学生和老师的信息"><a href="#案例ex50-使用共用体存放学生和老师的信息" class="headerlink" title="案例ex50: 使用共用体存放学生和老师的信息"></a><strong>案例ex50: 使用共用体存放学生和老师的信息</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用共用体存放学生和老师的信息<br>描述：根据输入职业的标识，区分出是老师还是学生<br>    然后根据输入的标识将对应的信息输出。<br>    如果是学生，则输出班级信息<br>    如果是老师，则输出职位信息</p>
</blockquote>
<p><strong>2 思路</strong></p>
<blockquote>
<p>共用体有时也被称为联合或者联合体</p>
<p>这也是 Union 这个单词的本意</p>
</blockquote>
<p><strong>结构体和共用体的区别：</strong></p>
<p>结构体的各个成员会占用不同的内存，互相之间没有影响；</p>
<p>共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。</p>
<p>结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<p>共用体也是一种自定义类型，可以通过它来创建变量，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>
<p>上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>
<p>如果不再定义新的变量，也可以将共用体的名字省略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">union&#123;</span><br><span class="line">    int n;        </span><br><span class="line">    char ch;</span><br><span class="line">    double f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>
<p>另外，看看下面代码中对共用体的使用方法，可以在后面编程中参考使用</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用共用体存放学生和老师的信息</span></span><br><span class="line"><span class="comment">描述：根据输入职业的标识，区分出是老师还是学生</span></span><br><span class="line"><span class="comment">然后根据输入的标识将对应的信息输出。</span></span><br><span class="line"><span class="comment">如果是学生，则输出班级信息</span></span><br><span class="line"><span class="comment">如果是老师，则输出职位信息</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> tp;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>                                    <span class="comment">//共用体类型</span></span><br><span class="line">        <span class="keyword">int</span> inclass;</span><br><span class="line">        <span class="keyword">char</span> position[<span class="number">10</span>];</span><br><span class="line">    &#125;job;                                      <span class="comment">//共用体变量</span></span><br><span class="line">&#125;person[N];                                    <span class="comment">//结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入 %d 个人信息(编号 姓名 类型(s/t) 班级/职位)：\n&quot;</span>, N);</span><br><span class="line">    <span class="comment">// 信息填写</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;第%d个人\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %s %c&quot;</span>, &amp;person[i].num, person[i].name, &amp;person[i].tp);        <span class="comment">/*输入信息*/</span></span><br><span class="line">        <span class="keyword">if</span>(person[i].tp==<span class="string">&#x27;s&#x27;</span>)                                        <span class="comment">/*根据类型值判断是老师还是学生*/</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;person[i].job.inclass);                    <span class="comment">/*输入工作类型*/</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(person[i].tp==<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, person[i].job.position);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n编号    姓名    类型    班级/职位\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信息输出</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(person[i].tp == <span class="string">&#x27;s&#x27;</span>)                                        <span class="comment">/*根据工作类型输出结果*/</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t%s\t%c\t%d&quot;</span>, person[i].num, person[i].name, person[i].tp, person[i].job.inclass);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(person[i].tp == <span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t%s\t%c\t%s&quot;</span>, person[i].num, person[i].name, person[i].tp, person[i].job.position);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex050.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入 2 个人信息(编号 姓名 类型(s/t) 班级/职位)：</span><br><span class="line">第1个人</span><br><span class="line">1 Johngo1 s 1</span><br><span class="line">第2个人</span><br><span class="line">2 Johngo2 t 数学</span><br><span class="line"></span><br><span class="line">编号    姓名    类型    班级/职位</span><br><span class="line">1    Johngo    s    1</span><br><span class="line">2    Johngo2    t    数学</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex51-使用共用体处理任意类型数据"><a href="#案例ex51-使用共用体处理任意类型数据" class="headerlink" title="案例ex51: 使用共用体处理任意类型数据"></a><strong>案例ex51: 使用共用体处理任意类型数据</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：使用共用体处理任意类型数据<br>描述：设计一个共用体类型，使其成员包含多种数据类型，根据不同的类型，输出不同的数据</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>首先设定了各种数据类型的变量，由于这些变量不是全部一次性处理的，所以就采用了共用体类型<br>在下面例子中，通过 TypeFlag 来识别在共用体重的存储类型，执行程序的时候就会按照不同的存储方式进行存储到 union_demo 变量中</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：fun()</span></span><br><span class="line"><span class="comment">功能：使用共用体处理任意类型数据</span></span><br><span class="line"><span class="comment">描述：设计一个共用体类型，使其成员包含多种数据类型，根据不同的类型，输出不同的数据</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span>                                        <span class="comment">// 定义共用体</span></span><br><span class="line">    <span class="keyword">int</span> i;                                    <span class="comment">// 共用体成员</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;union_demo;                                        <span class="comment">// 声明共用体类型的变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> TypeFlag;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入成员类型:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;TypeFlag);                                <span class="comment">// 输入类型符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入数字:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span>(TypeFlag) &#123;                                    <span class="comment">// 多分支选择语句判断输入</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;union_demo.i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;union_demo.c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>,&amp;union_demo.f); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;union_demo.d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(TypeFlag) &#123;                                      <span class="comment">// 多分支选择语句判断输出</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,union_demo.i); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,union_demo.c); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>,union_demo.f); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>,union_demo.d);</span><br><span class="line">    &#125;                            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex051.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入成员类型:</span><br><span class="line">i</span><br><span class="line">输入数字:</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex52-输出今天星期几"><a href="#案例ex52-输出今天星期几" class="headerlink" title="案例ex52: 输出今天星期几"></a><strong>案例ex52: 输出今天星期几</strong></h3><p><strong>1 题目</strong></p>
<p>&gt;</p>
<p><strong>2 思路</strong></p>
<p>举语法定义格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>
<p>举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Monday          1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tuesday          2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Wednesday      3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Thursday      4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Friday          5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Saturday      6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Sunday          7</span></span><br></pre></td></tr></table></figure><br>这个看起来代码量就比较多，接下来我们看看使用枚举的方式：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span>Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday&#125; ;</span><br></pre></td></tr></table></figure></p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">函数：week()</span></span><br><span class="line"><span class="comment">功能：输出今天星期几</span></span><br><span class="line"><span class="comment">描述：枚举类型的使用，利用枚举类型表示一周的每一天，然后通过数据来输出对应周几</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span>Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday&#125; ; <span class="comment">//定义枚举结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> day;                                            <span class="comment">//定义整型变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入星期数(0-6):&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;day);                                    <span class="comment">//输入0-6的值</span></span><br><span class="line">    <span class="keyword">switch</span>(day) &#123;                                        <span class="comment">//根据数值进行判断</span></span><br><span class="line">        <span class="keyword">case</span> Sunday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期天&quot;</span>); <span class="keyword">break</span>;            <span class="comment">//根据枚举类型进行判断</span></span><br><span class="line">        <span class="keyword">case</span> Monday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期一&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tuesday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期二&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Wednesday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期三&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Thursday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期天四&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Friday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期五&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Saturday: <span class="built_in">printf</span>(<span class="string">&quot;今天是星期六&quot;</span>); <span class="keyword">break</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex052.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入星期数(0-6):5</span><br><span class="line">今天是星期五</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex53-任意次方后的最后三位"><a href="#案例ex53-任意次方后的最后三位" class="headerlink" title="案例ex53: 任意次方后的最后三位"></a><strong>案例ex53: 任意次方后的最后三位</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：任意次方后的最后三位<br>描述：<br>求一个整数任意次方后的最后三位数，即求 x^y 的最后三位<br>x 和 y 的值由键盘输入</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>注意点：</strong></p>
<p>为了防止计算越界，本例中不能使用直接计算一个数的任意次方。那么如何去计算并且有效防止计算越界，而且不会产生误差。</p>
<p>这里采用了一种方式就是在每次进行次方相乘后，取其后三位，这样就不会出现越界的现象产生。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：任意次方后的最后三位</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">求一个整数任意次方后的最后三位数，即求 x^y 的最后三位</span></span><br><span class="line"><span class="comment">x 和 y 的值由键盘输入</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x, y, z = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个数，x和y(x^y):\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);                                     <span class="comment">// 输入底数和幂数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= y; i++)</span><br><span class="line">        z = z * x % <span class="number">1000</span>;                                    <span class="comment">// 计算一个数任意次方的后三位</span></span><br><span class="line">    <span class="keyword">if</span>(z&gt;=<span class="number">100</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d^%d的最后三位是:%d\n&quot;</span>, x, y, z);             <span class="comment">// 输出最终结果*/</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d^%d的最后三位是:0%d\n&quot;</span>, x, y, z);            <span class="comment">// 输出最终结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex053.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">1 1</span><br><span class="line">1^1的最后三位是:001</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">2 4</span><br><span class="line">2^4的最后三位是:016</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个数，x和y(x^y):</span><br><span class="line">5 9</span><br><span class="line">5^9的最后三位是:125</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex54-计算某日是该年的第几天"><a href="#案例ex54-计算某日是该年的第几天" class="headerlink" title="案例ex54: 计算某日是该年的第几天"></a><strong>案例ex54: 计算某日是该年的第几天</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：计算某日是该年的第几天<br>描述：计算天数的代码，从键盘输入年、月、日，在屏幕输出此日期是改年的第几天</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>判断年份是闰年还是平年，两点：要么可以直接被 400 整除，要么能被 4 整除，但是不能被 100 整除<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; a % <span class="number">100</span> != <span class="number">0</span> || a % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;                                </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br></pre></td></tr></table></figure><br>判断该天是改年的第几天，那么需要知道每个月有多少天。另外，2 月份需要首先判断是平年还是闰年，再来进行后续的计算</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：计算某日是该年的第几天</span></span><br><span class="line"><span class="comment">描述：计算天数的代码，从键盘输入年、月、日，在屏幕输出此日期是改年的第几天</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leap</span><span class="params">(<span class="keyword">int</span> a)</span>    </span>&#123;                                         <span class="comment">// 判断是否为闰年</span></span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; a % <span class="number">100</span> != <span class="number">0</span> || a % <span class="number">400</span> == <span class="number">0</span>)        <span class="comment">// 闰年判定条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                                        <span class="comment">// 是闰年返回1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                        <span class="comment">// 不是闰年返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span> </span>&#123;                    <span class="comment">// 参数 年 月 日，计算是该年的第几天</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, i;</span><br><span class="line">    <span class="comment">// 平年每月的天数</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">// 闰年每月的天数</span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">12</span>] = &#123;<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leap(year) == <span class="number">1</span>)                                <span class="comment">// 判断是否为闰年</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            sum += b[i];                                <span class="comment">// 是闰年，累加数组b前m-1个月份天数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">            sum += a[i];                                <span class="comment">// 不是闰年，累加数组a钱m-1个月份天数</span></span><br><span class="line">    sum += d;                                                        <span class="comment">// 将前面累加的结果加上日期，求出总天数</span></span><br><span class="line">    <span class="keyword">return</span> sum;                                                    <span class="comment">// 将计算的天数返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> year, month, day, n;                                        <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入年月日\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;year, &amp;month, &amp;day);                <span class="comment">// 输入年月日</span></span><br><span class="line">    n = number(year, month, day);                                <span class="comment">// 调用函数number</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d.%d.%d 是 %d 年的第 %d 天\n&quot;</span>, year, month, day, year, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex054.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入年月日</span><br><span class="line">2020 12 31</span><br><span class="line">2020.12.31 是 2020 年的第 366 天</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex55-婚礼上的谎言"><a href="#案例ex55-婚礼上的谎言" class="headerlink" title="案例ex55: 婚礼上的谎言"></a><strong>案例ex55: 婚礼上的谎言</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：婚礼上的谎言</p>
<p>描述：</p>
<p>3 对儿情侣参加婚礼，3 个新浪为A、B、C，3 个新娘为 X、Y、Z</p>
<p>有人想知道究竟谁与谁结婚，X 说他的未婚夫为C，C 说他将和 Z 结婚。这人们时候都知道他们在开玩笑，说全是假的。</p>
<p>那么，究竟谁与谁结婚呢？</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用穷举法进行计算</p>
<p>然后再利用题目中的谎话进行逻辑判断</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：婚礼上的谎言</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">3 对儿情侣参加婚礼，3 个新浪为A、B、C，3 个新娘为 X、Y、Z</span></span><br><span class="line"><span class="comment">有人想知道究竟谁与谁结婚，X 说他的未婚夫为C，C 说他将和 Z 结婚。这人们时候都知道他们在开玩笑，说全是假的。</span></span><br><span class="line"><span class="comment">那么，究竟谁与谁结婚呢？</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (a = <span class="number">1</span>; a &lt;= <span class="number">3</span>; a++)                                <span class="comment">// 穷举a的所有可能</span></span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">1</span>; b &lt;= <span class="number">3</span>; b++)                            <span class="comment">// 穷举b的所有可能</span></span><br><span class="line">            <span class="keyword">for</span> (c = <span class="number">1</span>; c &lt;= <span class="number">3</span>; c++)                        <span class="comment">// 穷举c的所有可能</span></span><br><span class="line">                <span class="keyword">if</span> (a != <span class="number">1</span> &amp;&amp; c != <span class="number">1</span> &amp;&amp; c != <span class="number">3</span> &amp;&amp; a != b &amp;&amp; a != c &amp;&amp; b != c) &#123;</span><br><span class="line">                                                <span class="comment">// 如果表达式为真，则输出结果，否则继续下次循环</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 A\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + a - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 B\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + b - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c 将嫁给 C\n&quot;</span>, <span class="string">&#x27;X&#x27;</span> + c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex055.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">Z 将嫁给 A</span><br><span class="line">X 将嫁给 B</span><br><span class="line">Y 将嫁给 C</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex56-百元买百鸡"><a href="#案例ex56-百元买百鸡" class="headerlink" title="案例ex56: 百元买百鸡"></a><strong>案例ex56: 百元买百鸡</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：百元买百鸡</p>
<p>描述：</p>
<p>中国占代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡闷题”</p>
<p>鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>要点</strong><br>所买的 3 种鸡的钱数总和是 100<br>所买的 3 种鸡的数量总和是 100<br>所买的小鸡的数量必须是 3 的倍数</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：百元买百鸡</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">中国占代数学家张丘建在他的《算经》中提出了一个著名的“百钱买百鸡闷题”</span></span><br><span class="line"><span class="comment">鸡翁一，值钱五，鸡母一，值钱三，鸡雏三，值钱一，百钱买百鸡，问翁、母、雏各几何？</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cock, hen, chick;                                        <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    <span class="keyword">for</span> (cock = <span class="number">0</span>; cock &lt;= <span class="number">20</span>; cock++)                                <span class="comment">// 公鸡范围在0到20之间</span></span><br><span class="line">        <span class="keyword">for</span> (hen = <span class="number">0</span>; hen &lt;= <span class="number">33</span>; hen++)                            <span class="comment">// 母鸡范围在0到33之间</span></span><br><span class="line">            <span class="keyword">for</span> (chick = <span class="number">3</span>; chick &lt;= <span class="number">99</span>; chick++)                        <span class="comment">// 小鸡范围在3到99之间</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">5</span> *cock + <span class="number">3</span> * hen + chick / <span class="number">3</span> == <span class="number">100</span>)                 <span class="comment">// 判断钱数是否等于100</span></span><br><span class="line">                    <span class="keyword">if</span> (cock + hen + chick == <span class="number">100</span>)                 <span class="comment">// 判断购买的鸡数是否等于100</span></span><br><span class="line">                        <span class="keyword">if</span> (chick % <span class="number">3</span> == <span class="number">0</span>)                         <span class="comment">// 判断小鸡数是否能被3整除</span></span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;公鸡:%d 母鸡:%d 小鸡:%d\n&quot;</span>, cock, hen,chick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex056.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">公鸡:0 母鸡:25 小鸡:75</span><br><span class="line">公鸡:4 母鸡:18 小鸡:78</span><br><span class="line">公鸡:8 母鸡:11 小鸡:81</span><br><span class="line">公鸡:12 母鸡:4 小鸡:84</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex57-判断三角形的类型"><a href="#案例ex57-判断三角形的类型" class="headerlink" title="案例ex57: 判断三角形的类型"></a><strong>案例ex57: 判断三角形的类型</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：判断三角形的类型<br>描述：根据给定的三条边判断是否能构成三角形，并且输出它对应的面积和三角形类型</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>从键盘中输入三条边后，只需判断这三条边中任意两边之和是否大于第三边</p>
<p>如果满足条件，可以构成三角形</p>
<p>再做进一步判断确定该三角形是什么三角形</p>
<p>若两边相等-则是等腰三角形；若三边相等，则是等边三角形；若三边满足勾股定理，则是直角三角形</p>
<p>另外，注意 &amp;&amp; 和 || 的使用，以及 &amp; 与 &amp;&amp; 的区别和  | 与 || 的区别</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：判断三角形的类型</span></span><br><span class="line"><span class="comment">描述：根据给定的三条边判断是否能构成三角形，并且输出它对应的面积和三角形类型</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a, b, c;</span><br><span class="line">    <span class="keyword">float</span> s, area;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入三角形的三条边长（以空格分隔）：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>, &amp;a, &amp;b, &amp;c); <span class="comment">// 输入三条边</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %f\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = %f\n&quot;</span>, c);</span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c &amp;&amp; b + c &gt; a &amp;&amp; a + c &gt; b) &#123;                    <span class="comment">// 判断两边之和是否大于第三边</span></span><br><span class="line">        s = (a + b + c) / <span class="number">2</span>;</span><br><span class="line">        area = (<span class="keyword">float</span>)<span class="built_in">sqrt</span>(s *(s - a)*(s - b)*(s - c));         <span class="comment">// 计算三角形的面积</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;面积是:%f\n&quot;</span>, area);                             <span class="comment">// 输出三角形的面积</span></span><br><span class="line">        <span class="keyword">if</span> (a == b &amp;&amp; a == c)                                    <span class="comment">// 判断三条边是否相等</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 等边三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出等边三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == b || a == c || b == c)</span><br><span class="line">            <span class="comment">// 判断三角形中是否有两边相等</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 等腰三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出等腰三角形</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((a * a + b * b == c * c) || (a * a + c * c == b * b) || (b * b + c * c == a *a))</span><br><span class="line">            <span class="comment">// 判断是否有两边的平方和大于第三边的平方</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 直角三角形\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 输出直角三角形</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;三条边组成的三角形是: 普通三角形&quot;</span>);</span><br><span class="line">            <span class="comment">// 普通三角形</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果两边之和小于第三边不能组成三角形</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该三条边不能构成三角形\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex057.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入三角形的三条边长（以空格分隔）：3 4 5</span><br><span class="line">a = 3.000000</span><br><span class="line">b = 4.000000</span><br><span class="line">c = 5.000000</span><br><span class="line">面积是:6.000000</span><br><span class="line">三条边组成的三角形是: 直角三角形</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex58-直接插入排序"><a href="#案例ex58-直接插入排序" class="headerlink" title="案例ex58: 直接插入排序"></a><strong>案例ex58: 直接插入排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：直接插入排序<br>描述：利用直接插入排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>原始顺序: 34, 12, 45, 3, 8, 23, 89, 52, 24, 10</p>
<p>在代码中将数组 a[0] 置为监视哨</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">趟数</th>
<th style="text-align:center">监视哨</th>
<th style="text-align:center">排序结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">34</td>
<td style="text-align:center">(12,) 34, 45, 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">12</td>
<td style="text-align:center">(12, 34,) 45, 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">45</td>
<td style="text-align:center">(12, 34, 45,) 3, 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
<td style="text-align:center">(3, 12, 34, 45,) 8, 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">(3, 8, 12, 34, 45,) 23, 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">23</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45,) 89, 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">89</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45, 89,) 52, 24, 10</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">52</td>
<td style="text-align:center">(3, 8, 12, 23, 34, 45, 52, 89,) 24, 10</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">24</td>
<td style="text-align:center">(3, 8, 12, 23, 24, 34, 45, 52, 89,) 10</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">(3, 8, 10, 12, 23, 24, 34, 45, 52, 89,)</td>
</tr>
</tbody>
</table>
</div>
<p>以上是整个的插入排序算法的过程</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：直接插入排序</span></span><br><span class="line"><span class="comment">描述：利用直接插入排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span>    </span>&#123;                    <span class="comment">// 自定义函数isort</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;                    <span class="comment">// 数组下标从2开始，0 位置做监视哨，1位置一个数据无可比性</span></span><br><span class="line">        s[<span class="number">0</span>] = s[i];                            <span class="comment">// 给监视哨赋值</span></span><br><span class="line">        j = i - <span class="number">1</span>;                                <span class="comment">// 确定要进行比较的元素的最右边位置</span></span><br><span class="line">        <span class="keyword">while</span> (s[<span class="number">0</span>] &lt; s[j]) &#123;</span><br><span class="line">            s[j + <span class="number">1</span>] = s[j];                    <span class="comment">// 数据右移</span></span><br><span class="line">            j--;                                <span class="comment">// 移向左边一个未比较的数</span></span><br><span class="line">        &#125;</span><br><span class="line">        s[j + <span class="number">1</span>] = s[<span class="number">0</span>];                        <span class="comment">// 在确定的位置插入s[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                    <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数据:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                            <span class="comment">// 接收从键盘中输入的10个数据到数组a中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;原始顺序:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, a[i]);                        <span class="comment">// 将未排序前的顺序输出</span></span><br><span class="line">    insort(a, <span class="number">10</span>);                                    <span class="comment">// 调用自定义函数isort()</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n插入数据排序后顺序:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, a[i]);                        <span class="comment">// 将排序后的数组输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex058.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数据:</span><br><span class="line">34</span><br><span class="line">12</span><br><span class="line">45</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">23</span><br><span class="line">89</span><br><span class="line">52</span><br><span class="line">24</span><br><span class="line">10</span><br><span class="line">原始顺序:</span><br><span class="line"> 34 12 45  3  8 23 89 52 24 10</span><br><span class="line">插入数据排序后顺序:</span><br><span class="line">  3  8 10 12 23 24 34 45 52 89</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex59-希尔排序"><a href="#案例ex59-希尔排序" class="headerlink" title="案例ex59: 希尔排序"></a><strong>案例ex59: 希尔排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：希尔排序<br>描述：利用希尔排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>希尔排序是在直接插入排序的基础上做的改进，将要排序的序列按固定增量分成若干组，等距离者在同一组中，然后再程纽内进行直接插入排序。</p>
<p>这里面的固定增量从n/2开始，以后每次缩小到原来的一半.</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：希尔排序</span></span><br><span class="line"><span class="comment">描述：利用希尔排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shsort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> n)</span>    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, d;</span><br><span class="line">    d = n / <span class="number">2</span>;                                                    <span class="comment">// 确定固定增量值</span></span><br><span class="line">    <span class="keyword">while</span> (d &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = d + <span class="number">1</span>; i &lt;= n; i++) &#123;                            <span class="comment">// 数组下标从d+1开始进行直接插入排序</span></span><br><span class="line">            s[<span class="number">0</span>] = s[i];                                        <span class="comment">// 设置监视哨</span></span><br><span class="line">            j = i - d;                                            <span class="comment">// 确定要进行比较的元素的最右边位置</span></span><br><span class="line">            <span class="keyword">while</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (s[<span class="number">0</span>] &lt; s[j])) &#123;</span><br><span class="line">                s[j + d] = s[j];                                <span class="comment">// 数据右移</span></span><br><span class="line">                j = j - d;                                        <span class="comment">// 向左移d个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            s[j + d] = s[<span class="number">0</span>];                                    <span class="comment">// 在确定的位置插入s[i]</span></span><br><span class="line">        &#125;</span><br><span class="line">        d = d / <span class="number">2</span>;                                                <span class="comment">// 增量变为原来的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                                <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数据:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                        <span class="comment">// 从键盘中输入10个数据</span></span><br><span class="line">    shsort(a, <span class="number">10</span>);                                                <span class="comment">// 调用shsort()函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                                    <span class="comment">// 将排好序的数组输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex059.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数据:</span><br><span class="line">34</span><br><span class="line">15</span><br><span class="line">56</span><br><span class="line">12</span><br><span class="line">90</span><br><span class="line">43</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">93</span><br><span class="line">100</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    7    9   12   15   34   43   56   90   93  100</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex60-冒泡排序"><a href="#案例ex60-冒泡排序" class="headerlink" title="案例ex60: 冒泡排序"></a><strong>案例ex60: 冒泡排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：冒泡排序<br>描述：利用冒泡排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>冒泡法的基本思路是</p>
<p>如果要对 n 个数进行冒泡排序，那么要进行 n-1 趟比较，在第1趟比较中要进行 n-1 次两两比较，在第 j 趟比较中要进行 n-j 次两两比较</p>
<p>从这个基本思路中就会发现，趟数决定了两两比较的次数，这样就很容易将两个 for 循环联系起来了</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：冒泡排序</span></span><br><span class="line"><span class="comment">描述：利用冒泡排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, t, a[<span class="number">11</span>];                            <span class="comment">// 定义变量及数组为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                        <span class="comment">// 从键盘中输入10个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)                    <span class="comment">// 变量i代表比较的趟数</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">11</span>-i; j++)                <span class="comment">// 变量j代表每趟两两比较的次数</span></span><br><span class="line">    <span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        t = a[j];                                <span class="comment">// 利用中间变量实现俩值互换</span></span><br><span class="line">        a[j] = a[j + <span class="number">1</span>];    </span><br><span class="line">        a[j + <span class="number">1</span>] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                    <span class="comment">// 将冒泡排序后的顺序输出</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex060.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">16</span><br><span class="line">87</span><br><span class="line">134</span><br><span class="line">14</span><br><span class="line">1</span><br><span class="line">84</span><br><span class="line">55</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    1   14   16   34   55   56   84   87   90  134</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex61-快速排序"><a href="#案例ex61-快速排序" class="headerlink" title="案例ex61: 快速排序"></a><strong>案例ex61: 快速排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：快速排序<br>描述：利用快速排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>在待排序的n个数据中取第 1 个数据作为基准值，将所有记录分为 3 组<br>使笫一组中各数据值均小于或等于基准值，第二组做基准值的数据，第三组中各数据值均人于或等于基准值，这便实现了第一趟分割，然后再对第一组和第三组分别重复上述方法。<br>依次类推；直到每组中只有一个记录为止</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：快速排序</span></span><br><span class="line"><span class="comment">描述：利用快速排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qusort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;                    <span class="comment">// 自定义函数qusort()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;                                                <span class="comment">// 定义变量为基本整型</span></span><br><span class="line">    i = start;                                                <span class="comment">// 将每组首个元素赋给i</span></span><br><span class="line">    j = end;                                                <span class="comment">// 将每组末尾元素赋给j</span></span><br><span class="line">    s[<span class="number">0</span>] = s[start];                                        <span class="comment">// 设置基准值</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[<span class="number">0</span>] &lt; s[j])</span><br><span class="line">            j--;                                            <span class="comment">// 位置左移</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            s[i] = s[j];                                    <span class="comment">// 将s[j]放到s[i]的位置上</span></span><br><span class="line">            i++;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt;= s[<span class="number">0</span>])</span><br><span class="line">            i++;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)&#123;</span><br><span class="line">            s[j] = s[i];                                    <span class="comment">// 将大于基准值的s[j]放到s[i]位置</span></span><br><span class="line">            j--;                                            <span class="comment">// 位置右移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s[i] = s[<span class="number">0</span>];                                                <span class="comment">// 将基准值放入指定位置</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; i)</span><br><span class="line">        qusort(s, start, j - <span class="number">1</span>);                                <span class="comment">// 对分割出的部分递归调用函数qusort()</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; end)</span><br><span class="line">        qusort(s, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>], i;                                                <span class="comment">// 定义数组及变量为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                        <span class="comment">// 从键盘中输入10个要进行排序的数</span></span><br><span class="line">    qusort(a, <span class="number">1</span>, <span class="number">10</span>);                                            <span class="comment">// 调用qusort()函数进行排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                                        <span class="comment">// 输出排好序的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex061.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">45</span><br><span class="line">12</span><br><span class="line">76</span><br><span class="line">2</span><br><span class="line">45</span><br><span class="line">16</span><br><span class="line">34</span><br><span class="line">61</span><br><span class="line">24</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    2   12   16   24   34   45   45   61   76   90</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex62-选择排序"><a href="#案例ex62-选择排序" class="headerlink" title="案例ex62: 选择排序"></a><strong>案例ex62: 选择排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：选择排序<br>描述：利用选择排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>选择排序的基本算法是从待排序的区间中经过选择和交换后选出最小的数值存放到a[0]中，再从剩余的未排序区间中经过选择和交换后选出最小的数值存放到a[1]中，a[1]中的数字仅大于a[0],依此类推，即可实现排序</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：选择排序</span></span><br><span class="line"><span class="comment">描述：利用选择排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, t, a[<span class="number">11</span>];                        <span class="comment">//定义变量及数组为基本整型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">11</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                    <span class="comment">//从键盘中输入要排序的10个数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;            <span class="comment">//如果后一个数比前一个数大则利用中间变量t实现俩值互换</span></span><br><span class="line">                t = a[i];</span><br><span class="line">                a[i] = a[j];</span><br><span class="line">                a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);                <span class="comment">//将排好序的数组输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex062.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">23</span><br><span class="line">51</span><br><span class="line">34</span><br><span class="line">15</span><br><span class="line">45</span><br><span class="line">72</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">33</span><br><span class="line">90</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    2    5   15   23   33   34   45   51   72   90</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex63-归并排序"><a href="#案例ex63-归并排序" class="headerlink" title="案例ex63: 归并排序"></a><strong>案例ex63: 归并排序</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：归并排序<br>描述：利用归并排序进行将数组序列从小到大排序</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>归并排序两个或多个有序记录序列合并成一个有序序列<br>一次对两个有序记录序的归并称为二路归并排序，也有三路归并排序及多路归并排序<br>下面代码给出的是二路归并排序，基本方法<br>        (1)将n个记录看成是n介长度为1的有序子表<br>        (2)将两两相邻的有序壬莓4行归并<br>        (3)垂复轨行步骤(2)<br>直至归并成一个长度为 L 的有序表</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：归并排序</span></span><br><span class="line"><span class="comment">描述：利用归并排序进行将数组序列从小到大排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> s[], <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3)</span> </span>&#123; <span class="comment">// 实现一次归并排序函数</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    i = x1;                                         <span class="comment">// 第一部分的开始位置</span></span><br><span class="line">    j = x2 + <span class="number">1</span>;                                         <span class="comment">// 第二部分的开始位置</span></span><br><span class="line">    k = x1;</span><br><span class="line">    <span class="keyword">while</span> ((i &lt;= x2) &amp;&amp; (j &lt;= x3))                <span class="comment">// 当i和j都在两个要合并的部分中</span></span><br><span class="line">        <span class="keyword">if</span> (r[i] &lt;= r[j])&#123;                        <span class="comment">// 筛选两部分中较小的元素放到数组s中</span></span><br><span class="line">        s[k] = r[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s[k] = r[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= x2)                                <span class="comment">// 将x1~x2范围内的未比较的数顺次加到数组r中</span></span><br><span class="line">        s[k++] = r[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= x3)                                <span class="comment">// 将x2+1~x3范围内的未比较的数顺次加到数组r中</span></span><br><span class="line">        s[k++] = r[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> s[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">if</span> (m == n)</span><br><span class="line">        s[m] = r[m];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = (m + n) / <span class="number">2</span>;</span><br><span class="line">        merge_sort(r, t, m, p);</span><br><span class="line">                                                <span class="comment">// 递归调用merge_sort函数将r[m]~r[p]归并成有序的t[m]~t[p]</span></span><br><span class="line">        merge_sort(r, t, p + <span class="number">1</span>, n);                <span class="comment">// 递归调用merge_sort函数将r[n+1]~r[n]归并成有序的t[p+1]~t[n]*/</span></span><br><span class="line">        merge(t, s, m, p, n);                     <span class="comment">// 调用函数将前两部分归并到s[m]~s[n]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入10个数:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    merge_sort(a, a, <span class="number">1</span>, <span class="number">10</span>);                     <span class="comment">// 调用merge_sort函数进行归并排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的顺序是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex063.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入10个数:</span><br><span class="line">34</span><br><span class="line">12</span><br><span class="line">64</span><br><span class="line">23</span><br><span class="line">98</span><br><span class="line">45</span><br><span class="line">18</span><br><span class="line">52</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">排序后的顺序是:</span><br><span class="line">    1    7   12   18   23   34   45   52   64   98</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex64-二分查找"><a href="#案例ex64-二分查找" class="headerlink" title="案例ex64: 二分查找"></a><strong>案例ex64: 二分查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：二分查找<br>描述：<br>    使用二分查找特定关键字元素<br>    用户输入有序数组的关键字后，给定要查找的关键字，看是否存在于有序数组中</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>二分査找就是折半查找<br>其基本思想：首先选取表中间位置的记录，将其关键字与给定关键字key进行比较，若相等，则査找成功；<br>若key值比该关键字值大，则要找的元素一定在右子表中，则继续对右子表进行折半査找;<br>若key值比该关键字值小，则要找的元素一定在左子表中，继续对左子表进行折半査找;<br>按照上述递推，直到查找成功或查找失败。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：二分查找</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    使用二分查找特定关键字元素</span></span><br><span class="line"><span class="comment">    用户输入有序数组的关键字后，给定要查找的关键字，看是否存在于有序数组中</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 自定义函数binary_search</span></span><br><span class="line">    <span class="keyword">int</span> low, high, mid, count = <span class="number">0</span>, count1 = <span class="number">0</span>;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;                            <span class="comment">// 当查找范围不为0时执行循环体语句</span></span><br><span class="line"></span><br><span class="line">        count++;                                <span class="comment">// count记录查找次数</span></span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;                        <span class="comment">// 求出中间位置</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid])                            <span class="comment">// 当key小于中间值</span></span><br><span class="line">            high = mid - <span class="number">1</span>;                        <span class="comment">// 确定左子表范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])                        <span class="comment">// 当key大于中间值</span></span><br><span class="line">            low = mid + <span class="number">1</span>;                            <span class="comment">// 确定右子表范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key == a[mid]) &#123;                    <span class="comment">// 当key等于中间值证明查找成功</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找成功!\n查找 %d 次!a[%d]=%d&quot;</span>, count, mid, key);</span><br><span class="line">                                            <span class="comment">// 输出查找次数及所查找元素在数组中的位置</span></span><br><span class="line">            count1++;                            <span class="comment">// count1记录查找成功次数</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">0</span>)                                <span class="comment">// 判断是否查找失败</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                            <span class="comment">// 查找失败输出no found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, key, a[<span class="number">100</span>], n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的长度:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                <span class="comment">// 输入数组元素个数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                            <span class="comment">// 输入有序数列到数组a中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);                                <span class="comment">// 输入要查找的关键字</span></span><br><span class="line">    binary_search(key, a, n);                        <span class="comment">// 调用自定义函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex064.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入数组的长度:</span><br><span class="line">10</span><br><span class="line">请输入数组元素:</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">46</span><br><span class="line">78</span><br><span class="line">90</span><br><span class="line">102</span><br><span class="line">122</span><br><span class="line">请输入你想查找的元素:</span><br><span class="line">102</span><br><span class="line">查找成功!</span><br><span class="line">查找 3 次!a[8]=102</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex65-分块查找"><a href="#案例ex65-分块查找" class="headerlink" title="案例ex65: 分块查找"></a><strong>案例ex65: 分块查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：分块查找<br>描述：利用分块查找的思想，将指定的数据项查找出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>分块查找是折半查找和顺序查找的一种改进方法, 分块查找由于只要求索引表是有序的, 对块内节点没有排序要求, 因此特别适合于节点动态变化的情况。</p>
<p>要求将待査的元素均匀地分成块, 块间按大小排序, 块内不排序, 所以要建立一个块的最大（或最小）关键字表, 称为索引表。</p>
<p>本例子中将给出的15个数按关键字大小分成了3块, 这15个数的排列是一个有序序列, 也可以给出无序序列, 但必须满足分在第一块中的任意数都小于第二块中的所有数, 第二块中的所有数都小于第三块中的所有数。</p>
<p>当要査找关键字为key的元素时, 先用顺序查找在已建好的索引表中査出key所在的块中, 再在对应的块中顺序查找key, 若key存在, 则输出其相应位置, 否则输出提示信息。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：分块查找</span></span><br><span class="line"><span class="comment">描述：利用分块查找的思想，将指定的数据项查找出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span> &#123;</span>                                            <span class="comment">// 定义块的结构</span></span><br><span class="line">    <span class="keyword">int</span> key;                                                <span class="comment">// 存放块内最大值</span></span><br><span class="line">    <span class="keyword">int</span> start;                                            <span class="comment">// 存放块内起始值</span></span><br><span class="line">    <span class="keyword">int</span> end;                                                <span class="comment">// 存放块内结束值</span></span><br><span class="line">&#125; index_table[<span class="number">4</span>];                                     <span class="comment">// 结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">block_search</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> a[])</span> </span>&#123;                     <span class="comment">// 自定义分块查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= <span class="number">3</span> &amp;&amp; key &gt; index_table[i].key)            <span class="comment">// 确定在那个块中</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>)                                                                <span class="comment">// 大于分得的块数, 则返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    j = index_table[i].start;                                 <span class="comment">// j等于块范围的起始值</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= index_table[i].end &amp;&amp; a[j] != key)        <span class="comment">// 在确定的块内进行查找</span></span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; index_table[i].end)                                    <span class="comment">// 如果大于块范围的结束值, 则说明没有要查找的数,j置0</span></span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>, k, key, a[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入15个数:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 输入由小到大的15个数，由于是测试数据，那么必须要保证在块之间是整体有序的，块内无序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);                                </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        index_table[i].start = j + <span class="number">1</span>;                     <span class="comment">// 确定每个块范围的起始值</span></span><br><span class="line">        j = j + <span class="number">1</span>;</span><br><span class="line">        index_table[i].end = j + <span class="number">4</span>;                     <span class="comment">// 确定每个块范围的结束值</span></span><br><span class="line">        j = j + <span class="number">4</span>;</span><br><span class="line">        index_table[i].key = a[j];                         <span class="comment">// 确定每个块范围中元素的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;key);                                     <span class="comment">// 输入要查询的数值</span></span><br><span class="line">    k = block_search(key, a);                             <span class="comment">// 调用函数进行查找</span></span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>)    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找成功, 其位置是:%d\n&quot;</span>, k);                <span class="comment">// 如果找到该数, 则输出其位置</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                                <span class="comment">// 若未找到则输出提示信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex065.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入15个数:</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br><span class="line">14</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">21</span><br><span class="line">25</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">34</span><br><span class="line">40</span><br><span class="line">请输入你想查找的元素:</span><br><span class="line">29</span><br><span class="line">查找成功, 其位置是:11</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex66-哈希查找"><a href="#案例ex66-哈希查找" class="headerlink" title="案例ex66: 哈希查找"></a><strong>案例ex66: 哈希查找</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：哈希查找<br>描述：<br>    哈希表长度 11<br>    哈希函数 (key)=key%11<br>    采用线性探测再散列的方法处理冲突</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>哈希函数简要介绍</strong></p>
<p><strong>哈希函数的构造方法</strong></p>
<p>哈希函数的构造方法常用的有5种，分别是数字分析法、平方取中法、分段叠加、伪随机数法和余数法，其中余数法比较常用。<br>例子中已给出哈希函数，按照给出的哈希函数进行了构造</p>
<p><strong>避免哈希冲突的方法</strong></p>
<p>分别有开放定址法（包括线性探测再散列和二次探测再散列入、链地址法、再哈希法和建立公共溢出区<br>开放定址法中的线性探测再散列比较常用，该方法的特点是在冲突发生时，顺序查看表中的下一单元，直到找出一个空单元或査遍全表。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：哈希查找</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    哈希表长度 11</span></span><br><span class="line"><span class="comment">    哈希函数 (key)=key%11</span></span><br><span class="line"><span class="comment">    采用线性探测再散列的方法处理冲突</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hashtable[Max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % Max;                             <span class="comment">// 哈希函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;                                 <span class="comment">// 自定义函数实现哈希查询</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos, t;</span><br><span class="line">    pos = func(key);                                 <span class="comment">// 哈希函数确定出的位置</span></span><br><span class="line">    t = pos;                                        <span class="comment">// t存放确定出的位置</span></span><br><span class="line">    <span class="keyword">while</span> (hashtable[t] != key &amp;&amp; hashtable[t] !=  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该位置上不等于要查找的关键字且不为空</span></span><br><span class="line">        t = (t + <span class="number">1</span>) % Max;                             <span class="comment">// 利用线性探测求出下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (pos == t)</span><br><span class="line">            <span class="comment">// 如果经多次探测又回到原来用哈希函数求出的位置则说明要查找的数不存在</span></span><br><span class="line">            <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hashtable[t] ==  - <span class="number">1</span>)                        <span class="comment">// 如果探测的位置是-1则说明要查找的数不存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creathash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;                            <span class="comment">// 自定义函数创建哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos, t;</span><br><span class="line">    pos = func(key);                                <span class="comment">// 哈希函数确定元素的位置</span></span><br><span class="line">    t = pos;</span><br><span class="line">    <span class="keyword">while</span> (hashtable[t] !=  - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该位置有元素存在则进行线性探测再散列</span></span><br><span class="line">        t = (t + <span class="number">1</span>) % Max;</span><br><span class="line">        <span class="keyword">if</span> (pos == t) &#123;</span><br><span class="line">            <span class="comment">// 如果冲突处理后确定的位置与原位置相同则说明哈希表已满</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;哈希表已满\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hashtable[t] = key;                                <span class="comment">// 将元素放入确定的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, t;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++)</span><br><span class="line">        hashtable[i] =  - <span class="number">1</span>;                <span class="comment">// 哈希表中初始位置全置-1</span></span><br><span class="line">                                             </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">                                             <span class="comment">// 50以内所有数未产生时均标志为0</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span> <span class="keyword">long</span>)time(<span class="number">0</span>));             <span class="comment">// 利用系统时间做种子产生随机数</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;建立 Hash 表： \n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (i != N) &#123;</span><br><span class="line">        t = rand() % <span class="number">50</span>;                     <span class="comment">// 产生一个50以内的随机数赋给t</span></span><br><span class="line">        <span class="keyword">if</span> (flag[t] == <span class="number">0</span>) &#123;                        <span class="comment">// 查看t是否产生过</span></span><br><span class="line">            creathash(t);                        <span class="comment">// 调用函数创建哈希表</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%2d:&quot;</span>, t);                     <span class="comment">// 将该元素输出</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; Max; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;(%2d) &quot;</span>, hashtable[j]);</span><br><span class="line">                                                 <span class="comment">// 输出哈希表中内容</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            flag[t] = <span class="number">1</span>;                         <span class="comment">// 将产生的这个数标志为1</span></span><br><span class="line">            i++;                                <span class="comment">// i自加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入你想查找的元素:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);                             <span class="comment">// 输入要查找的元素</span></span><br><span class="line">    <span class="keyword">if</span> (t &gt; <span class="number">0</span> &amp;&amp; t &lt; <span class="number">50</span>) &#123;</span><br><span class="line">        i = search(t);                            <span class="comment">// 调用search进行哈希查找</span></span><br><span class="line">        <span class="keyword">if</span> (i !=  - <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找成功！其位置是:%d\n&quot;</span>, i);    <span class="comment">// 若查找到该元素则输出其位置</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找失败!&quot;</span>);                    <span class="comment">// 未找到输出提示信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入有误!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex066.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">建立 Hash 表：</span><br><span class="line"> 7:(-1) (-1) (-1) (-1) (-1) (-1) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">22:(22) (-1) (-1) (-1) (-1) (-1) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">16:(22) (-1) (-1) (-1) (-1) (16) (-1) ( 7) (-1) (-1) (-1)</span><br><span class="line">29:(22) (-1) (-1) (-1) (-1) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line">44:(22) (44) (-1) (-1) (-1) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line">37:(22) (44) (-1) (-1) (37) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line"> 3:(22) (44) (-1) ( 3) (37) (16) (-1) ( 7) (29) (-1) (-1)</span><br><span class="line"> 9:(22) (44) (-1) ( 3) (37) (16) (-1) ( 7) (29) ( 9) (-1)</span><br><span class="line">请输入你想查找的元素:9</span><br><span class="line">查找成功！其位置是:9</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex67-斐波那契数列"><a href="#案例ex67-斐波那契数列" class="headerlink" title="案例ex67: 斐波那契数列"></a><strong>案例ex67: 斐波那契数列</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：斐波那契数列<br>描述：实现一个斐波那契数列，并且打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>斐波那契数列（Fibonacci sequence），又称黄金分割数列<br>斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）<br>即这样的一个序列：这样一个数列：0、1、1、2、3、5、8、13、21、34</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：斐波那契数列</span></span><br><span class="line"><span class="comment">描述：实现一个斐波那契数列，并且打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;                                                <span class="comment">// 定义整型变量i</span></span><br><span class="line">    <span class="keyword">long</span> f[<span class="number">51</span>];                                            <span class="comment">// 意义数组为长整形</span></span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>, f[<span class="number">2</span>] = <span class="number">1</span>;                                    <span class="comment">// 数组中的f[1]、f[2]赋初值为1</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; <span class="number">51</span>; i++)</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];                        <span class="comment">// 数列中从第3项开始每一项等于前两项之和</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%12ld&quot;</span>, f[i]);                            <span class="comment">// 输出数组中的 30 个元素</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                                <span class="comment">// 每 5 个元素进行一次换行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex067.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">           1           1           2           3           5</span><br><span class="line">           8          13          21          34          55</span><br><span class="line">          89         144         233         377         610</span><br><span class="line">         987        1597        2584        4181        6765</span><br><span class="line">       10946       17711       28657       46368       75025</span><br><span class="line">      121393      196418      317811      514229      832040</span><br><span class="line">     1346269     2178309     3524578     5702887     9227465</span><br><span class="line">    14930352    24157817    39088169    63245986   102334155</span><br><span class="line">   165580141   267914296   433494437   701408733  1134903170</span><br><span class="line">  1836311903  2971215073  4807526976  7778742049 12586269025</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex68-哥德巴赫猜想"><a href="#案例ex68-哥德巴赫猜想" class="headerlink" title="案例ex68: 哥德巴赫猜想"></a><strong>案例ex68: 哥德巴赫猜想</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：哥德巴赫猜想<br>描述：<br>    任一大于2的整数都可写成两个质数之和<br>    验证从 3 到 50 之间所有数都是否可以写成两个素数之和</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>创建判断是否为素数的函数</li>
<li>从 3 到 50 循环判断是否可以有 2 个素数加和</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：哥德巴赫猜想</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    任一大于2的整数都可写成两个质数之和</span></span><br><span class="line"><span class="comment">    验证从 3 到 50 之间所有数都是否可以写成两个素数之和</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ss</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;                                                     <span class="comment">// 素数的判断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">1</span>)                                                 <span class="comment">// 小于1的数不是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>)                                                 <span class="comment">// 2是素数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; i; j++)    &#123;                        <span class="comment">// 对大于2的数进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != j + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k, flag1, flag2, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= <span class="number">50</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">2</span>; k &lt;= i / <span class="number">2</span>; k++) &#123;</span><br><span class="line">            j = i - k;</span><br><span class="line">            flag1 = ss(k);                                        <span class="comment">// 判断拆分出的数是否是素数</span></span><br><span class="line">            <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line">                flag2 = ss(j);</span><br><span class="line">                <span class="keyword">if</span> (flag2) &#123;                                     <span class="comment">// 如果拆分出的两个数均是素数则输出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d = %d+%d,\t&quot;</span>, i, k, j);</span><br><span class="line">                    n++;</span><br><span class="line">                    <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex068.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">4 = 2+2,    5 = 2+3,    6 = 3+3,    7 = 2+5,    8 = 3+5,</span><br><span class="line">9 = 2+7,    10 = 3+7,    10 = 5+5,    12 = 5+7,    13 = 2+11,</span><br><span class="line">14 = 3+11,    14 = 7+7,    15 = 2+13,    16 = 3+13,    16 = 5+11,</span><br><span class="line">18 = 5+13,    18 = 7+11,    19 = 2+17,    20 = 3+17,    20 = 7+13,</span><br><span class="line">21 = 2+19,    22 = 3+19,    22 = 5+17,    22 = 11+11,    24 = 5+19,</span><br><span class="line">24 = 7+17,    24 = 11+13,    25 = 2+23,    26 = 3+23,    26 = 7+19,</span><br><span class="line">26 = 13+13,    28 = 5+23,    28 = 11+17,    30 = 7+23,    30 = 11+19,</span><br><span class="line">30 = 13+17,    31 = 2+29,    32 = 3+29,    32 = 13+19,    33 = 2+31,</span><br><span class="line">34 = 3+31,    34 = 5+29,    34 = 11+23,    34 = 17+17,    36 = 5+31,</span><br><span class="line">36 = 7+29,    36 = 13+23,    36 = 17+19,    38 = 7+31,    38 = 19+19,</span><br><span class="line">39 = 2+37,    40 = 3+37,    40 = 11+29,    40 = 17+23,    42 = 5+37,</span><br><span class="line">42 = 11+31,    42 = 13+29,    42 = 19+23,    43 = 2+41,    44 = 3+41,</span><br><span class="line">44 = 7+37,    44 = 13+31,    45 = 2+43,    46 = 3+43,    46 = 5+41,</span><br><span class="line">46 = 17+29,    46 = 23+23,    48 = 5+43,    48 = 7+41,    48 = 11+37,</span><br><span class="line">48 = 17+31,    48 = 19+29,    49 = 2+47,    50 = 3+47,    50 = 7+43,</span><br><span class="line">50 = 13+37,    50 = 19+31,</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex69-尼科彻斯定理"><a href="#案例ex69-尼科彻斯定理" class="headerlink" title="案例ex69: 尼科彻斯定理"></a><strong>案例ex69: 尼科彻斯定理</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：尼科彻斯定理</p>
<p>描述：<br>    验证尼科彻斯定理。即：任何一个整数 m 的立方都可以写成 m 个连续奇数之和。m属于[1,100]，超出范围则报错。<br>    例如：<br>    1^3=1<br>    2^3=3+5<br>    3^3=7+9+11<br>    4^3=13+15+17+19</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>循环判断实现尼科彻斯定理</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：尼科彻斯定理</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    验证尼科彻斯定理。即：任何一个整数 m 的立方都可以写成 m 个连续奇数之和。m属于[1,100]，超出范围则报错。</span></span><br><span class="line"><span class="comment">    例如：</span></span><br><span class="line"><span class="comment">    1^3=1</span></span><br><span class="line"><span class="comment">    2^3=3+5</span></span><br><span class="line"><span class="comment">    3^3=7+9+11</span></span><br><span class="line"><span class="comment">    4^3=13+15+17+19</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l, n, m, sum, flag=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                    <span class="comment">// 从键盘中任意输入一个数</span></span><br><span class="line">    m = n * n * n;                                        <span class="comment">// 计算出该数的立方</span></span><br><span class="line">    i = m / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)                                        <span class="comment">// 当i为偶数时i值加1</span></span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span> &amp;&amp; i &gt;= <span class="number">1</span>) &#123;                        <span class="comment">// 当i大于等于1且flag=1时执行循环体语句</span></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            sum += (i - <span class="number">2</span> * k);                            <span class="comment">// 奇数累加求和</span></span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;                                    <span class="comment">// 如果sum与m相等，则输出累加过程</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d*%d*%d=%d=&quot;</span>, n, n, n, m);</span><br><span class="line">                <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; k - <span class="number">1</span>; l++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d+&quot;</span>, i - l * <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - (k - <span class="number">1</span>) *<span class="number">2</span>);             <span class="comment">// 输出累加求和的最后一个数</span></span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i -= <span class="number">2</span>;                                            <span class="comment">// i等于下一个奇数继续上面过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex069.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入一个数:</span><br><span class="line">12</span><br><span class="line">12*12*12=1728=865+863</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex70-创建单向链表"><a href="#案例ex70-创建单向链表" class="headerlink" title="案例ex70: 创建单向链表"></a><strong>案例ex70: 创建单向链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建单向链表</p>
<p>描述：创建Node结构体，构造一个单链表</p>
</blockquote>
<p><strong>2 思路</strong></p>
<ol>
<li>创建结点的结构体，分布由结点值和指针组成</li>
<li>循环创建每个结点，使得上一个结点指向下一个结点</li>
</ol>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建单向链表</span></span><br><span class="line"><span class="comment">描述：创建Node结构体，构造一个单链表</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct LNode *<span class="title">create_listnode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">head</span>, *<span class="title">p1</span>, *<span class="title">p2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入结点内容:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        p1 = (struct LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LNode)); <span class="comment">// 分配空间</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a); <span class="comment">// 输入数据</span></span><br><span class="line">        p1-&gt;data = a; <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123; <span class="comment">// 指定头结点</span></span><br><span class="line">            head = p1;</span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1; <span class="comment">// 指定后继指针</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">lnode</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要创建单链表的结点个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); <span class="comment">// 输入链表结点个数</span></span><br><span class="line">    lnode = create_listnode(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是:\nhead-&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (lnode) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, lnode-&gt;data); <span class="comment">// 输出链表</span></span><br><span class="line">        lnode = lnode-&gt;next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入要创建单链表的结点个数:5</span><br><span class="line">输入结点内容:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">结果是:</span><br><span class="line"><span class="meta">head-&gt;</span><span class="bash">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex71-创建双向链表"><a href="#案例ex71-创建双向链表" class="headerlink" title="案例ex71: 创建双向链表"></a><strong>案例ex71: 创建双向链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建双向链表<br>描述：<br>    a. 创建一个双链表，实现输入链表中的数据，并且可以将链表中的数据进行输出<br>    b. 输入一个结点内容，把这个结点从链表中删除，随后输出链表内容</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>单链表</strong>，存储形式只有一个指向直接后继的指针域，所以只能是从头结点顺着指针域指向的下一个结点进行不断的查找<br><strong>双向链表</strong>，一个结点既可以指向前驱也可以指向后继，对于数据查找来说更加的便捷</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建双向链表</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    a. 创建一个双链表，实现输入链表中的数据，并且可以将链表中的数据进行输出</span></span><br><span class="line"><span class="comment">    b. 输入一个结点内容，把这个结点从链表中删除，随后输出链表内容</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">prior</span>,  *<span class="title">next</span>;</span></span><br><span class="line">&#125; stud;                                 <span class="comment">// 双链表的结构定义</span></span><br><span class="line"></span><br><span class="line"><span class="function">stud *<span class="title">creat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    stud *p,  *h,  *s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    h = (stud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stud));    <span class="comment">// 申请结点空间</span></span><br><span class="line">    h-&gt;name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    h-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    h-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = h;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s = (stud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stud));</span><br><span class="line">        p-&gt;next = s;                    <span class="comment">// 指定后继结点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入第%d个学生的姓名: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s-&gt;name);</span><br><span class="line">        s-&gt;prior = p;                    <span class="comment">// 指定前驱结点</span></span><br><span class="line">        s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> (h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function">stud *<span class="title">search</span><span class="params">(stud *h, <span class="keyword">char</span> *x)</span> </span>&#123;</span><br><span class="line">    stud *p;                            <span class="comment">// 指向结构体类型的指针</span></span><br><span class="line">    <span class="keyword">char</span> *y;</span><br><span class="line">    p = h-&gt;next;        </span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        y = p-&gt;name;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(y, x) == <span class="number">0</span>)            <span class="comment">// 如果是要删除的节点，则返回地址</span></span><br><span class="line">            <span class="keyword">return</span> (p);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有找到数据!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(stud *p)</span> </span>&#123;</span><br><span class="line">    p-&gt;next-&gt;prior = p-&gt;prior;            <span class="comment">// p的下一个结点的前驱指针指向p的前驱结点</span></span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;            <span class="comment">// p的前驱结点的后继指针指向p的后继结点</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> sname[<span class="number">20</span>];</span><br><span class="line">    stud *head,  *sp;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;请输入链表的大小:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number);                <span class="comment">// 输入链表结点数</span></span><br><span class="line">    head = creat(number);                <span class="comment">// 创建链表</span></span><br><span class="line">    sp = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n现在这个双链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (sp) &#123;                        <span class="comment">// 输出链表中数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, &amp;*(sp-&gt;name));</span><br><span class="line">        sp = sp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n请输入你想查找的姓名:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, sname);</span><br><span class="line">    sp = search(head, sname);            <span class="comment">// 查找指定结点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你想查找的姓名是:%s\n&quot;</span>,  * &amp;sp-&gt;name);</span><br><span class="line">    del(sp);                            <span class="comment">// 删除结点</span></span><br><span class="line">    sp = head-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n现在这个双链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (sp) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, &amp;*(sp-&gt;name));    <span class="comment">// 输出当前链表中数据</span></span><br><span class="line">        sp = sp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex071.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表的大小:</span><br><span class="line">5</span><br><span class="line">输入第1个学生的姓名: a</span><br><span class="line">输入第2个学生的姓名: b</span><br><span class="line">输入第3个学生的姓名: c</span><br><span class="line">输入第4个学生的姓名: d</span><br><span class="line">输入第5个学生的姓名: e</span><br><span class="line"></span><br><span class="line">现在这个双链表是:</span><br><span class="line">a b c d e</span><br><span class="line">请输入你想查找的姓名:</span><br><span class="line">d</span><br><span class="line">你想查找的姓名是:d</span><br><span class="line"></span><br><span class="line">现在这个双链表是:</span><br><span class="line">a b c e</span><br><span class="line"></span><br><span class="line"> 按任意键退出...</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex72-创建一个单循环链表"><a href="#案例ex72-创建一个单循环链表" class="headerlink" title="案例ex72: 创建一个单循环链表"></a><strong>案例ex72: 创建一个单循环链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建一个单循环链表<br>描述：输入链表中各个结点中的值，然后进行进行整合成单循环链表进行输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>一个循环链表是从简单的链表中发展而来，简单链表带来的弊端是，必须要保存头结点才能不断的遍历链表，否则当遍历到<br>结点尾部的时候，便没办法进行后续的工作。<br>简单循环链表带来的优势是，当遍历到链表尾部的时候，由于尾部的next指针指向头部，所以是要比简单的单链表灵活一些的</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建一个单循环链表</span></span><br><span class="line"><span class="comment">描述：输入链表中各个结点中的值，然后进行进行整合成单循环链表进行输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1,  *p2;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));     <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                 <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = head;                 <span class="comment">// 尾节点指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1, head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入循环链表:(以 # 结束)\n&quot;</span>);</span><br><span class="line">    L1 = create();                    <span class="comment">// 创建循环链表</span></span><br><span class="line">    head = L1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;形成的循环链表是:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, L1-&gt;num);</span><br><span class="line">    L1 = L1-&gt;next;                    <span class="comment">// 指向下一个结点</span></span><br><span class="line">    <span class="keyword">while</span> (L1 != head) &#123;             <span class="comment">// 判断条件为循环到头结点结束</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c -&gt; &quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex072.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入循环链表:(以 # 结束)</span><br><span class="line"><span class="meta">apple#</span></span><br><span class="line"><span class="bash">形成的循环链表是:</span></span><br><span class="line">a -&gt; p -&gt; p -&gt; l -&gt; e -&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex73-头插入法建立单链表"><a href="#案例ex73-头插入法建立单链表" class="headerlink" title="案例ex73: 头插入法建立单链表"></a><strong>案例ex73: 头插入法建立单链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：头插入法建立单链表<br>描述：输入链表中各个结点中的值，然后利用头插入法整合成单循环链表进行输出</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>头插法的基本思路是：<br>  a. 首先创将一个空的单链表<br>  b. 生成新的结点插入到头部，然后一直循环直到所有的元素结点都插入到链表中<br>最后，由于是循环向头部插入，那么导致的一个现象就是，从头部开始遍历的时候，一定与形成时元素结点相反</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：头插入法建立单链表</span></span><br><span class="line"><span class="comment">描述：输入链表中各个结点中的值，然后利用头插入法整合成单循环链表进行输出</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,  *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表元素(字符采集，不需要分隔符):\n&quot;</span>);</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));         <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                                 <span class="comment">// 数据域赋值</span></span><br><span class="line">        p1-&gt;next = head;</span><br><span class="line">        head = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;                                    <span class="comment">// 返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1;</span><br><span class="line">    L1 = create();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这个链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (L1) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表元素(字符采集，不需要分隔符):</span><br><span class="line">apple</span><br><span class="line">这个链表是:</span><br><span class="line">e l p p a</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex74-约瑟夫环"><a href="#案例ex74-约瑟夫环" class="headerlink" title="案例ex74: 约瑟夫环"></a><strong>案例ex74: 约瑟夫环</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：约瑟夫环<br>描述：使用循环链表实现约瑟夫环，给定一组结点数据 {1,2,3,4,5,6,7,8,9,10}，然后从报数开始，进行打印</p>
</blockquote>
<p><strong>2 科普-什么是约瑟夫环</strong></p>
<p><strong>约瑟夫环 </strong></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719?fromtitle=%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF&amp;fromid=348830&amp;fr=aladdin">百度百科 - 约瑟夫环</a></p>
<p>约瑟夫问题是个有名的问题：N个人围成一圈，从第一个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉。例如N=6，M=5，被杀掉的顺序是：5，4，6，2，3。</p>
<p>具体例子：</p>
<p>比如说有一个圈中的数字为 {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}，第 3 个被杀掉，即从头开始数到 3 的被杀掉</p>
<p>第 1 轮 3 被杀掉，剩余 {1, 2, 【3】, 4, 5, 6, 7, 8, 9, 10}</p>
<p>第 2 轮 6 被杀掉，剩余 {1, 2, 【3】, 4, 5, 【6】, 7, 8, 9, 10}</p>
<p>第 3 轮 9 被杀掉，剩余 {1, 2, 【3】, 4, 5, 【6】, 7, 8, 【9】, 10}</p>
<p>第 4 轮 2 被杀掉，剩余 {1, 【2】, 【3】, 4, 5, 【6】, 7, 8, 【9】, 10}</p>
<p>第 5 轮 7 被杀掉，剩余 {1, 【2】, 【3】, 4, 5, 【6】, 【7】, 8, 【9】, 10}</p>
<p>第 6 轮 1 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 5, 【6】, 【7】, 8, 【9】, 10}</p>
<p>第 7 轮 8 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 5, 【6】, 【7】, 【8】, 【9】, 10}</p>
<p>第 8 轮 5 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 【5】, 【6】, 【7】, 【8】, 【9】, 10}</p>
<p>第 9 轮 10 被杀掉，剩余 {【1】, 【2】, 【3】, 4, 【5】, 【6】, 【7】, 【8】, 【9】, 【10】}</p>
<p>第 10 轮 4 被杀掉，剩余 {【1】, 【2】, 【3】, 【4】, 【5】, 【6】, 【7】, 【8】, 【9】, 【10】}</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 10</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> OVERFLOW 0</span></span><br><span class="line"><span class="keyword">int</span> KeyW[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：约瑟夫环</span></span><br><span class="line"><span class="comment">描述：使用循环链表实现约瑟夫环，给定一组结点数据 &#123;1,2,3,4,5,6,7,8,9,10&#125;，然后从报数开始，进行打印</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> keyword;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Joseph</span><span class="params">(LinkList p,<span class="keyword">int</span> m,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    LinkList q;                                            <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    q = p;</span><br><span class="line">    m%= x;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) m = x;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= m; i++)&#123;                                <span class="comment">// 找到下一个结点</span></span><br><span class="line">        p = q;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    i = q-&gt;keyword;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n出队元素: %d \t&quot;</span>,q-&gt;keyword);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;剩余元素: &quot;</span>);</span><br><span class="line">    LinkList tmp =  p;</span><br><span class="line">    <span class="keyword">int</span> tmp_x = x;</span><br><span class="line">    <span class="keyword">while</span>(tmp &amp;&amp; tmp_x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, tmp-&gt;keyword);</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        tmp_x--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    Joseph(p, i, x<span class="number">-1</span>);                                    <span class="comment">// 递归调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i,m;</span><br><span class="line">    LinkList Lhead,p,q;</span><br><span class="line">    Lhead = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));            <span class="comment">// 申请结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(!Lhead) <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    Lhead-&gt;keyword = KeyW[<span class="number">0</span>];                            <span class="comment">// 数据域赋值</span></span><br><span class="line">    Lhead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = Lhead;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;                                <span class="comment">// 创建循环链表</span></span><br><span class="line">        <span class="keyword">if</span>(!(q = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode))))<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">        q-&gt;keyword = KeyW[i];</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = Lhead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入第一次计数值m: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n输出的队列结点是:\n&quot;</span>);</span><br><span class="line">    Joseph(p, m, N);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex074.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入第一次计数值m:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输出的队列结点是:</span><br><span class="line"></span><br><span class="line">出队元素: 3     剩余元素: 2 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt;</span><br><span class="line">出队元素: 6     剩余元素: 5 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt; 2 -&gt; 4 -&gt;</span><br><span class="line">出队元素: 2     剩余元素: 1 -&gt; 4 -&gt; 5 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt;</span><br><span class="line">出队元素: 5     剩余元素: 4 -&gt; 7 -&gt; 8 -&gt; 9 -&gt; 10 -&gt; 1 -&gt;</span><br><span class="line">出队元素: 1     剩余元素: 10 -&gt; 4 -&gt; 7 -&gt; 8 -&gt; 9 -&gt;</span><br><span class="line">出队元素: 4     剩余元素: 10 -&gt; 7 -&gt; 8 -&gt; 9 -&gt;</span><br><span class="line">出队元素: 10     剩余元素: 9 -&gt; 7 -&gt; 8 -&gt;</span><br><span class="line">出队元素: 7     剩余元素: 9 -&gt; 8 -&gt;</span><br><span class="line">出队元素: 8     剩余元素: 9 -&gt;</span><br><span class="line">出队元素: 9     剩余元素:</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex75-创建顺序表并插入元素"><a href="#案例ex75-创建顺序表并插入元素" class="headerlink" title="案例ex75: 创建顺序表并插入元素"></a><strong>案例ex75: 创建顺序表并插入元素</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：创建顺序表并插入元素<br>描述：创建一个顺序表，插入元素，并且打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>创建一个链表的结构体，规定了元素最大长度，循环将要插入的元素进行往链表中插入</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Listsize 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：创建顺序表并插入元素</span></span><br><span class="line"><span class="comment">描述：创建一个顺序表，插入元素，并且打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sqlist</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[Listsize];</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(struct sqlist *l, <span class="keyword">int</span> t, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; l-&gt;length) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;位置错误&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l-&gt;length &gt;= Listsize) &#123;                        <span class="comment">// 如果超出顺序表范围，则溢出</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;溢出&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = l-&gt;length - <span class="number">1</span>; j &gt;= i; j--)                <span class="comment">// 插入元素</span></span><br><span class="line">        l-&gt;data[j + <span class="number">1</span>] = l-&gt;data[j];</span><br><span class="line">    l-&gt;data[i] = t;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sqlist</span> *<span class="title">sq</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i, n, t;</span><br><span class="line">    sq = (struct sqlist*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct sqlist));    <span class="comment">// 分配空间</span></span><br><span class="line">    sq-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表大小:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入链表的元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        InsertList(sq, t, i);                            <span class="comment">// 插入元素</span></span><br><span class="line">    &#125; <span class="built_in">printf</span>(<span class="string">&quot;这个链表现在是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sq-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sq-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex075.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入链表大小:10</span><br><span class="line">请输入链表的元素:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">这个链表现在是:</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 %</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex76-合并两个链表"><a href="#案例ex76-合并两个链表" class="headerlink" title="案例ex76: 合并两个链表"></a><strong>案例ex76: 合并两个链表</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：合并两个链表<br>描述：两个链表进行合并，将第二个单链表连接在第一个单链表的尾部</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>通过不断的遍历第一个链表，知道链表尾部，即 L1-&gt;next = NULL，之后将 L1-&gt;next 指向 L2 的头结点</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：合并两个链表</span></span><br><span class="line"><span class="comment">描述：两个链表进行合并，将第二个单链表连接在第一个单链表的尾部</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkList head;</span><br><span class="line">    LNode *p1,  *p2;</span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    a = getchar();</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">        p1 = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));    <span class="comment">// 分配空间</span></span><br><span class="line">        p1-&gt;num = a;                        <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">            head = p1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2-&gt;next = p1;</span><br><span class="line">        p2 = p1;</span><br><span class="line">        a = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkList <span class="title">coalition</span><span class="params">(LinkList L1, LinkList L2)</span> </span>&#123;</span><br><span class="line">    LNode *temp;</span><br><span class="line">    <span class="keyword">if</span> (L1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> L2;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (L2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (temp = L1; temp-&gt;next != <span class="literal">NULL</span>; temp = temp-&gt;next);</span><br><span class="line">            temp-&gt;next = L2;                 <span class="comment">// 遍历L1中节点直到尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkList L1, L2, L3;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入两个链表:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第一个链表是:\n&quot;</span>);</span><br><span class="line">    L1 = create();                            <span class="comment">// 创建一个链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第二个链表是:\n&quot;</span>);</span><br><span class="line">    L2 = create();                            <span class="comment">// 创建第二个链表</span></span><br><span class="line">    coalition(L1, L2);                        <span class="comment">// 连接两个链表</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;合并后的链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (L1)&#123;                                <span class="comment">// 输出合并后的链表*</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, L1-&gt;num);</span><br><span class="line">        L1 = L1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex076.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">请输入两个链表:</span><br><span class="line">第一个链表是:</span><br><span class="line">apple and</span><br><span class="line">第二个链表是:</span><br><span class="line">orage</span><br><span class="line">合并后的链表是:</span><br><span class="line">apple and orage</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex77-单链表节点逆置"><a href="#案例ex77-单链表节点逆置" class="headerlink" title="案例ex77: 单链表节点逆置"></a><strong>案例ex77: 单链表节点逆置</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：单链表节点逆置<br>描述：创建一个单链表，实现将创建好的单链表进行逆置</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>创建两个指向结点的临时指针，一个指向 NULL，另外一个执行头结点，然后不断向后遍历，进行原地链表反转</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：单链表节点逆置</span></span><br><span class="line"><span class="comment">描述：创建一个单链表，实现将创建好的单链表进行逆置</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node *<span class="title">create</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span>,  *<span class="title">p1</span>,  *<span class="title">p2</span>;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表元素:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        p1 = (struct Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));     <span class="comment">// 分配空间</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        p1-&gt;num = a;                                        <span class="comment">// 数据域赋值</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = p1;</span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2-&gt;next = p1;                                     <span class="comment">// 指定后继指针</span></span><br><span class="line">            p2 = p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;                                            <span class="comment">// 返回头结点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct Node *<span class="title">reverse</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span>,  *<span class="title">r</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;next) &#123;</span><br><span class="line">        p = head;                                <span class="comment">// 获取头结点地址</span></span><br><span class="line">        r = p-&gt;next;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (r) &#123;</span><br><span class="line">            p = r;</span><br><span class="line">            r = r-&gt;next;</span><br><span class="line">            p-&gt;next = head;</span><br><span class="line">            head = p;</span><br><span class="line">        &#125; <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;                                <span class="comment">// 返回头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">q</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入你想创建的结点个数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    q = create(n);                                <span class="comment">// 创建单链表</span></span><br><span class="line">    q = reverse(q);                                <span class="comment">// 单链表逆置</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;逆置后的单链表是:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;                                    <span class="comment">// 输出逆置后的单链表</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q-&gt;num);</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex077.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">输入你想创建的结点个数:5</span><br><span class="line">链表元素:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">逆置后的单链表是:</span><br><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex78-明码序列号保护"><a href="#案例ex78-明码序列号保护" class="headerlink" title="案例ex78: 明码序列号保护"></a><strong>案例ex78: 明码序列号保护</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：明码序列号保护<br>描述：使用明码序列号保护</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>采用明码序列号保护是通过使用序列号对应用程序进行保护的最初级的方法<br>通过使用序列号对程序进行注册，获取使用程序某些功能的权限<br>采用明码序列号保护的方式是通过对用户输入的序列号与程序自动生成的合法序列号或内置序列号进行比较，采用这种方式并不是很安全，容易被截获到合法的序列号。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：明码序列号保护</span></span><br><span class="line"><span class="comment">描述：使用明码序列号保护</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ysn;                                                    <span class="comment">// 声明字符指针</span></span><br><span class="line">    <span class="keyword">char</span> *sn;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input the serial number：\n&quot;</span>);            <span class="comment">// 指定合法序列号</span></span><br><span class="line">    sn=<span class="string">&quot;1001-1618-2903&quot;</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ysn);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(ysn,sn))                                <span class="comment">// 进行序列号比较</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;register succeed&quot;</span>);            <span class="comment">// 注册成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;register lose&quot;</span>);                 <span class="comment">// 注册失败</span></span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex078.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">Please input the serial number：</span><br><span class="line">123</span><br><span class="line">register lose</span><br><span class="line"></span><br><span class="line">Please input the serial number：</span><br><span class="line">1001-1618-2903</span><br><span class="line">register succeed</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex79-非明码序列号保护"><a href="#案例ex79-非明码序列号保护" class="headerlink" title="案例ex79: 非明码序列号保护"></a><strong>案例ex79: 非明码序列号保护</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：非明码序列号保护<br>描述：<br>    本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>采用菲明码序列号保护的方式验证序列号比采用明码序列号保护的方式安全。因为，非明码序列号保护是通过将输入的序列号进行算法验证实现的，而明码序列号保护是通过将输入的序列号与计算生成的合法序列号进行字符串比较实现的。采用明码序列号保护的程序在注册时会生成合法的序列号，该序列号可以通过内存设断的方式获取。一而采用非明码序列号保护的方式无法通过内在设断的方式获取。</p>
<p>本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：非明码序列号保护</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    本实例的验证算法是将序列号分为 4 段，每段 5 个字符，每段之间以字符“-”分隔。计算每段所有 ASCI 码的和，如果第一段 ASC 码的和模 6 的值为 1, 第二段 ASC 码的和模 8 的值为 1, 第三段 ASC 码的和模 9 的值为 2, 第四段 ASCⅡ码的和模 3 的值为 0, 那么该序列号视为合法，否则非法。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn1</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn2</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">6</span>;i&lt;<span class="number">11</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn3</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">12</span>;i&lt;<span class="number">17</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsn4</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">18</span>;i&lt;<span class="number">23</span>;i++) &#123;</span><br><span class="line">        sum=sum+toascii(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum%<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">23</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nplease input the serial number:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str)==<span class="number">23</span> &amp;&amp; str[<span class="number">5</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; str[<span class="number">11</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; str[<span class="number">17</span>]==<span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(getsn1(str)%<span class="number">6</span>==<span class="number">1</span> &amp;&amp; getsn2(str)%<span class="number">8</span>==<span class="number">1</span> &amp;&amp; getsn3(str)%<span class="number">9</span>==<span class="number">2</span> &amp;&amp; getsn4(str)%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register succeed&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register Lose&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;register Lose&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex070.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">please input the serial number:</span><br><span class="line">11113-22221-33332-11112</span><br><span class="line">register succeed</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line">please input the serial number:</span><br><span class="line">11113-22221-33332-11111</span><br><span class="line"></span><br><span class="line">register Lose</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex80-恺撒加密"><a href="#案例ex80-恺撒加密" class="headerlink" title="案例ex80: 恺撒加密"></a><strong>案例ex80: 恺撒加密</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：恺撒加密<br>描述：利用凯撒密码进行加密</p>
</blockquote>
<p><strong>2 凯撒密码</strong></p>
<p>维基百科对凯撒密码的解释：<a href="https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC">https://zh.wikipedia.org/wiki/%E5%87%B1%E6%92%92%E5%AF%86%E7%A2%BC</a></p>
<p>凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推</p>
<p>例如，当偏移量是左移3的时候（解密时的密钥就是3）：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：恺撒加密</span></span><br><span class="line"><span class="comment">描述：利用凯撒密码进行加密</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (c + n % <span class="number">26</span> &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(c + n % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + ((n - (<span class="string">&#x27;z&#x27;</span> - c) - <span class="number">1</span>) % <span class="number">26</span>));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (c + n % <span class="number">26</span> &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(c + n % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span> + ((n - (<span class="string">&#x27;Z&#x27;</span> - c) - <span class="number">1</span>) % <span class="number">26</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        c = str[i];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (c - n % <span class="number">26</span> &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(c - n % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;z&#x27;</span> - (n - (c - <span class="string">&#x27;a&#x27;</span>) - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> (c - n % <span class="number">26</span> &gt;= <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(c - n % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;Z&#x27;</span> - (n - (c - <span class="string">&#x27;A&#x27;</span>) - <span class="number">1</span>) % <span class="number">26</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    str[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nout:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span> str[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">//char str[]=&quot;abcdef&quot;;</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, n = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input strings:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n1:Encryption&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n2:Decryption&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n3:Violent Crack&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nPlease choose:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;\n%d&quot;</span>, &amp;n);</span><br><span class="line">        encode(str, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input number:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        decode(str, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            decode(str, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex080.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">Please input strings:python</span><br><span class="line"></span><br><span class="line">1:Encryption</span><br><span class="line">2:Decryption</span><br><span class="line">3:Violent Crack</span><br><span class="line">Please choose:1</span><br><span class="line"></span><br><span class="line">Please input number:1</span><br><span class="line"></span><br><span class="line">out:qzuipo</span><br></pre></td></tr></table></figure>
<p>该例子中有以下三种选择，结合上述对于凯撒密码的原理，试着进行理解</p>
<ul>
<li>Encryption</li>
<li>Decryption</li>
<li>Violent Crack</li>
</ul>
<hr>
<h3 id="案例ex81-编写循环移位函数"><a href="#案例ex81-编写循环移位函数" class="headerlink" title="案例ex81: 编写循环移位函数"></a><strong>案例ex81: 编写循环移位函数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：编写循环移位函数<br>描述：编写个移位函数，使移位函数既能循环左移又能循环右移。参数 n 大于 0 时表示左移，参数 n 小于 0 时表示右移。例如 n=-4, 表示要右移四位</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>利用 &lt;&lt; 或者 &gt;&gt; 进行移位计算</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：编写循环移位函数</span></span><br><span class="line"><span class="comment">描述：编写个移位函数，使移位函数既能循环左移又能循环右移。参数 n 大于 0 时表示左移，参数 n 小于 0 时表示右移。例如 n=-4, 表示要右移四位</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">move</span><span class="params">(<span class="keyword">unsigned</span> value, <span class="keyword">int</span> n)</span>    </span>&#123;                                <span class="comment">// 自定义移位函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> z;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        z = (value &gt;&gt; (<span class="number">32</span>-n)) | (value &lt;&lt; n);                <span class="comment">// 循环左移的实现过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        n=-n;</span><br><span class="line">        z = (value &lt;&lt; (<span class="number">32</span>-n)) | (value &gt;&gt; n);                <span class="comment">// 循环右移的实现过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%o&quot;</span>, &amp;a);                                                                <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要移位的位数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);                                                                    <span class="comment">// 输入要移位的位数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;移位后的结果是:%o\n&quot;</span>, move(a, n));                        <span class="comment">// 将移位后的结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入一个八进制数:</span><br><span class="line">12</span><br><span class="line">请输入要移位的位数:</span><br><span class="line">1</span><br><span class="line">移位后的结果是:24</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex82-取出给定-16-位二进制数的奇数位"><a href="#案例ex82-取出给定-16-位二进制数的奇数位" class="headerlink" title="案例ex82: 取出给定 16 位二进制数的奇数位"></a><strong>案例ex82: 取出给定 16 位二进制数的奇数位</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：取出给定 16 位二进制数的奇数位<br>描述：取出给定的 16 位二进制数的奇数位，计算后打印出来</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>本例的解题关键在于如何将给定的 16 位二进制数的奇数位取出。首先定义个可以借助的中间变量 m，为其赋值，使箕成为最高位是1、其余 15 位为 0 的 16 位进制数</p>
<p>将给定的数 a 的值左移一位，让其原来值的第 15 位成为最高位，将 a 和 m 进行与运算进行判断，若运算结果是 1, 则将此位取出转换为对应的十进制数：若运算结果是 0, 则将 a 的值左移两位，使其原来值的第 13 位成为最高位，再进行判断，直到将 8 位奇数位全部取出</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：取出给定 16 位二进制数的奇数位</span></span><br><span class="line"><span class="comment">描述：取出给定的 16 位二进制数的奇数位，计算后打印出来</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> a,s=<span class="number">0</span>,q;</span><br><span class="line">    <span class="keyword">int</span> i,j,n=<span class="number">7</span>,m;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ho&quot;</span>, &amp;a);                                <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    m=<span class="number">1</span>&lt;&lt;<span class="number">15</span>;                                        <span class="comment">// m 的最高位为 1，其他位为 0</span></span><br><span class="line">    a&lt;&lt;=<span class="number">1</span>;                                            <span class="comment">// 左移一位，使第15位成为最高位</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++) &#123;                                <span class="comment">// 得到 8 位数</span></span><br><span class="line">        </span><br><span class="line">        q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &amp; a) &#123;                                    <span class="comment">// 如果本位上值为1则进行计算</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                q*=<span class="number">2</span>;                                <span class="comment">// 得到权值</span></span><br><span class="line">            s+=q;                                    <span class="comment">// 累加</span></span><br><span class="line">        &#125;</span><br><span class="line">        a&lt;&lt;=<span class="number">2</span>;                                        <span class="comment">// 向左移位</span></span><br><span class="line">        n--;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是:%o\n&quot;</span>, s);                        <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex082.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入一个八进制数:</span><br><span class="line">013</span><br><span class="line">结果是:1</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex83-求一个数的补码"><a href="#案例ex83-求一个数的补码" class="headerlink" title="案例ex83: 求一个数的补码"></a><strong>案例ex83: 求一个数的补码</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：求一个数的补码<br>描述：输入一个八进制数，然后输出它的补码</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>一个正数的补码等于该数原码，一个负数的补码等于该数的反码加 1。<br>本例的关键是如何判断一个数是正数还是负数。当最高位为 1 时，则该数是负数；当最高位为 0 时，则该数是正数。<br>因此，数据 a 和八进制数据 010000 进行与运算，保留最高位得到数据的正负</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：求一个数的补码</span></span><br><span class="line"><span class="comment">描述：输入一个八进制数，然后输出它的补码</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span>  a,z;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入一个八进制数:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ho&quot;</span>, &amp;a);                            <span class="comment">// 输入一个八进制数</span></span><br><span class="line">    z=a &amp; <span class="number">0100000</span>;                                    <span class="comment">// 0100000的二进制形式为最高位为1，其余为0</span></span><br><span class="line">    <span class="keyword">if</span>(z==<span class="number">0100000</span>)                                    <span class="comment">// 如果a小于0</span></span><br><span class="line">        z=~a+<span class="number">1</span>;                                                <span class="comment">// 取反加1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        z=a;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果是: %o\n&quot;</span>, z);            <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex083.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入一个八进制数:</span><br><span class="line">115333</span><br><span class="line">结果是: 62445</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex84-普通的位运算"><a href="#案例ex84-普通的位运算" class="headerlink" title="案例ex84: 普通的位运算"></a><strong>案例ex84: 普通的位运算</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：普通的位运算<br>描述：<br>    求下面各个位运算的值<br>    a&amp;c<br>    b|d<br>    a^d<br>    ~a</p>
</blockquote>
<p><strong>2 思路</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>位AND</td>
<td>x&amp;y</td>
<td>如果x和y都为1，则得到1；如果x或y任何一个为0，或都为0，则得到0</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>位OR</td>
<td>x\</td>
<td>y</td>
<td>如果x或y为1，或都为1，则得到1；如果x和y都为0，则得到0</td>
</tr>
<tr>
<td>^</td>
<td>位XOR</td>
<td>x^y</td>
<td>如果x或y的值不同，则得到1；如果两个值相同，则得到0</td>
</tr>
<tr>
<td>~</td>
<td>位NOT（I的补码）</td>
<td>~x</td>
<td>如果x为0，则得到1，如果x是1，则得到0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：普通的位运算</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">    求下面各个位运算的值</span></span><br><span class="line"><span class="comment">    a&amp;c</span></span><br><span class="line"><span class="comment">    b|d</span></span><br><span class="line"><span class="comment">    a^d</span></span><br><span class="line"><span class="comment">    ~a</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> result;</span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">    c = <span class="number">6</span>;</span><br><span class="line">    d = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d,c=%d,d=%d&quot;</span>, a, b, c, d);                <span class="comment">// 输出变量a、b、c、d四个数的值</span></span><br><span class="line">    result = a &amp;c;                                            <span class="comment">// a与c的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\na&amp;c=%u\n&quot;</span>, result);                            <span class="comment">// 将结果输出</span></span><br><span class="line">    result = b | d;                                         <span class="comment">// b|d的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b|d=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">    result = a ^ d;                                            <span class="comment">// a^d的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a^d=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">    result = ~a;                                            <span class="comment">// ~a的结果赋给result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;~a=%u\n&quot;</span>, result);                                <span class="comment">// 将结果输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex084.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">a=2,b=4,c=6,d=8</span><br><span class="line">a&amp;c=2</span><br><span class="line">b|d=12</span><br><span class="line">a^d=10</span><br><span class="line">~a=4294967293</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex85-整数与-0-异或"><a href="#案例ex85-整数与-0-异或" class="headerlink" title="案例ex85: 整数与 0 异或"></a><strong>案例ex85: 整数与 0 异或</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：整数与 0 异或</p>
<p>描述：计算输入整数与 0 异或</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>异或：相同为 1，不同为 0</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>示例</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>位 XOR</td>
<td>x^y</td>
<td>如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：整数与 0 异或</span></span><br><span class="line"><span class="comment">描述：计算输入整数与 0 异或</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> result;                                 <span class="comment">// 定义无符号数</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入a:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">    b=<span class="number">0</span>;                                            <span class="comment">// 与0异或</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d&quot;</span>, a, b);</span><br><span class="line">    result = a^b;                                     <span class="comment">// 求整数与0异或的结果</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\na^b=%u\n&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex085.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">请输入a:10</span><br><span class="line">a=10,b=0</span><br><span class="line">a^b=10</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex86-打印杨辉三角"><a href="#案例ex86-打印杨辉三角" class="headerlink" title="案例ex86: 打印杨辉三角"></a><strong>案例ex86: 打印杨辉三角</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：打印杨辉三角</p>
<p>描述：打印给定行数的杨辉三角</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>杨辉三角形</strong></p>
<p>又称帕斯卡三角形、贾宪三角形、海亚姆三角形、巴斯卡三角形，是二项式系数的一种写法，形似三角形，在中国首现于南宋杨辉的《详解九章算法》得名，书中杨辉说明是引自贾宪的《释锁算书》，故又名贾宪三角形。</p>
<p><strong>最基本的几个性质</strong><br>每个数等于它上方两数之和<br>每行数字左右对称，由1开始逐渐变大<br>第n行的数字有n项<br>前n行共[(1+n)n]/2 个数</p>
<p><strong>举例</strong></p>
<p>打印出前 9 行的数字</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">                        1</span><br><span class="line">                     1     1</span><br><span class="line">                  1     2     1</span><br><span class="line">               1     3     3     1</span><br><span class="line">            1     4     6     4     1</span><br><span class="line">         1     5    10    10     5     1</span><br><span class="line">      1     6    15    20    15     6     1</span><br><span class="line">   1     7    21    35    35    21     7     1</span><br><span class="line">1     8    28    56    70    56    28     8     1</span><br></pre></td></tr></table></figure>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：打印杨辉三角</span></span><br><span class="line"><span class="comment">描述：打印给定行数的杨辉三角</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, j, k, n, a[N][N];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要打印的行数[范围在1~15之间]：&quot;</span>); <span class="comment">// 控制在 15 行之内</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">1</span> &amp;&amp; n&lt;=<span class="number">15</span>)&#123;                  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;输入的行数不在规定范围内！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d行杨辉三角打印如下：\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        a[i][<span class="number">1</span>] = a[i][i] = <span class="number">1</span>;               </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>; j&lt;=i<span class="number">-1</span>; j++)</span><br><span class="line">            a[i][j]=a[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=n-i; k++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;   &quot;</span>);                   </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=i; j++)                  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%6d&quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);                       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">请输入要打印的行数[范围在1~15之间]：20</span><br><span class="line">输入的行数不在规定范围内！</span><br><span class="line">请输入要打印的行数[范围在1~15之间]：30</span><br><span class="line">输入的行数不在规定范围内！</span><br><span class="line">请输入要打印的行数[范围在1~15之间]：10</span><br><span class="line">10行杨辉三角打印如下：</span><br><span class="line">                                1</span><br><span class="line">                             1     1</span><br><span class="line">                          1     2     1</span><br><span class="line">                       1     3     3     1</span><br><span class="line">                    1     4     6     4     1</span><br><span class="line">                 1     5    10    10     5     1</span><br><span class="line">              1     6    15    20    15     6     1</span><br><span class="line">           1     7    21    35    35    21     7     1</span><br><span class="line">        1     8    28    56    70    56    28     8     1</span><br><span class="line">     1     9    36    84   126   126    84    36     9     1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex87-循环显示随机数"><a href="#案例ex87-循环显示随机数" class="headerlink" title="案例ex87: 循环显示随机数"></a><strong>案例ex87: 循环显示随机数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：循环显示随机数<br>描述：随机产出 10 个随机数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p>在产出随机数的时候，需要将设置随机发生的种子 srand(n);<br>随后才能进行产出不同的随机数</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：循环显示随机数</span></span><br><span class="line"><span class="comment">描述：随机产出 10 个随机数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> rd; <span class="comment">// 随机发生数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 随机发生数的种子</span></span><br><span class="line">        srand(i+<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 产出随机发生数</span></span><br><span class="line">        rd = rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;种子 %d 产出的随机数为%d\n&quot;</span>, i+<span class="number">5</span>, rd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex087.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">种子 5 产出的随机数为84035</span><br><span class="line">种子 6 产出的随机数为100842</span><br><span class="line">种子 7 产出的随机数为117649</span><br><span class="line">种子 8 产出的随机数为134456</span><br><span class="line">种子 9 产出的随机数为151263</span><br><span class="line">种子 10 产出的随机数为168070</span><br><span class="line">种子 11 产出的随机数为184877</span><br><span class="line">种子 12 产出的随机数为201684</span><br><span class="line">种子 13 产出的随机数为218491</span><br><span class="line">种子 14 产出的随机数为235298</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="案例ex88-阿姆斯特朗数"><a href="#案例ex88-阿姆斯特朗数" class="headerlink" title="案例ex88: 阿姆斯特朗数"></a><strong>案例ex88: 阿姆斯特朗数</strong></h3><p><strong>1 题目</strong></p>
<blockquote>
<p>功能：阿姆斯特朗数</p>
<p>描述：打印从100到999之间所有的阿姆斯特朗数</p>
</blockquote>
<p><strong>2 思路</strong></p>
<p><strong>阿姆斯特朗数</strong></p>
<p>如果一个n位正整数等于其各位数字的n次方之和,则称该数为阿姆斯特朗数。<br>例如1^3 + 5^3 + 3^3 = 153</p>
<p><strong>水仙花数</strong></p>
<p>当n=3时，又称水仙花数，特指一种三位数，其各个数之立方和等于该数。<br>水仙花数共有4个，分别为：153、370、371、407</p>
<p><strong>3 代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">功能：阿姆斯特朗数</span></span><br><span class="line"><span class="comment">描述：打印从1到10000之间所有的阿姆斯特朗数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) &#123; <span class="comment">// 遍历从 1 到 10000 的阿姆斯特朗数</span></span><br><span class="line"></span><br><span class="line">        j = i % <span class="number">10</span>;                 <span class="comment">// 分离出个位上的数</span></span><br><span class="line">        k = i / <span class="number">10</span> % <span class="number">10</span>;             <span class="comment">// 分离出十位上的数</span></span><br><span class="line">        n = i / <span class="number">100</span>;                 <span class="comment">// 分离出百位上的数</span></span><br><span class="line">        <span class="keyword">if</span> (j *j * j + k * k * k + n * n * n == i)     <span class="comment">// 进行判断各位上的立方和是否等于遍历数本身</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ex088.c -o demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./demo</span></span><br><span class="line"></span><br><span class="line">1^3 + 5^3 + 3^3 = 153</span><br><span class="line">3^3 + 7^3 + 0^3 = 370</span><br><span class="line">3^3 + 7^3 + 1^3 = 371</span><br><span class="line">4^3 + 0^3 + 7^3 = 407</span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在这里给大家准备了几百本的互联网技术类书籍，需要的来下载吧！<a href="https://mp.weixin.qq.com/s/KAYLiHFc5HTPiFD74JYeKQ">点击获取</a><br>有任何问题，欢迎随时交流!!!</p>
]]></content>
      <categories>
        <category>C经典88案例</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas系列 | 2.Series基本功能</title>
    <url>/posts/d81231da/</url>
    <content><![CDATA[<p><img src="/images/8.jpg" width="90%" height="90%"></p>
<h2 id="系列基本功能"><a href="#系列基本功能" class="headerlink" title="系列基本功能"></a>系列基本功能</h2><div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>axes</td>
<td>返回行轴标签列表</td>
</tr>
<tr>
<td>2</td>
<td>dtype</td>
<td>返回对象的数据类型(dtype)</td>
</tr>
<tr>
<td>3</td>
<td>empty</td>
<td>如果系列为空，则返回True</td>
</tr>
<tr>
<td>4</td>
<td>ndim</td>
<td>返回底层数据的维数，默认定义：1</td>
</tr>
<tr>
<td>5</td>
<td>size</td>
<td>返回基础数据中的元素数</td>
</tr>
<tr>
<td>6</td>
<td>values</td>
<td>将系列作为ndarray返回</td>
</tr>
<tr>
<td>7</td>
<td>head()</td>
<td>返回前n行</td>
</tr>
<tr>
<td>8</td>
<td>tail()</td>
<td>返回最后n行</td>
</tr>
</tbody>
</table>
</div>
<p>axes示例：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a series with 100 random numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = pd.Series(np.random.randn(<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.axes  <span class="comment">## 返回行轴标签列表</span></span><br><span class="line">[RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.dtype     <span class="comment">## 返回对象的数据类型(dtype)</span></span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.empty    <span class="comment">## 如果系列为空，则返回True    </span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.ndim    <span class="comment">## 返回底层数据的维数，默认定义：1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.size    <span class="comment">## 返回基础数据中的元素数</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.values    <span class="comment">## 将系列作为ndarray返回</span></span><br><span class="line">array([-<span class="number">0.56295907</span>,  <span class="number">1.54666615</span>, -<span class="number">0.95013554</span>, -<span class="number">0.06782656</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.head()    <span class="comment">## 返回前n行</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.tail()    <span class="comment">## 返回最后n行</span></span><br><span class="line"><span class="number">0</span>   -<span class="number">0.562959</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1.546666</span></span><br><span class="line"><span class="number">2</span>   -<span class="number">0.950136</span></span><br><span class="line"><span class="number">3</span>   -<span class="number">0.067827</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure></p>
<h2 id="DataFrame基本功能"><a href="#DataFrame基本功能" class="headerlink" title="DataFrame基本功能"></a>DataFrame基本功能</h2><p>列出比较重要的一些方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>T/tranpose()</td>
<td>转置行和列</td>
</tr>
<tr>
<td>2</td>
<td>axes</td>
<td>返回一个列，行轴标签和列轴标签作为唯一的成员</td>
</tr>
<tr>
<td>3</td>
<td>dtypes</td>
<td>返回此对象中的数据类型(dtypes)</td>
</tr>
<tr>
<td>4</td>
<td>empty</td>
<td>如果NDFrame完全为空[无项目]，则返回为True; 如果任何轴的长度为0</td>
</tr>
<tr>
<td>5</td>
<td>ndim</td>
<td>轴/数组维度大小</td>
</tr>
<tr>
<td>6</td>
<td>shape</td>
<td>返回表示DataFrame的维度的元组</td>
</tr>
<tr>
<td>7</td>
<td>size</td>
<td>NDFrame中的元素数</td>
</tr>
<tr>
<td>8</td>
<td>values</td>
<td>NDFrame的Numpy表示</td>
</tr>
<tr>
<td>9</td>
<td>head()</td>
<td>返回开头前n行</td>
</tr>
<tr>
<td>10</td>
<td>tail()</td>
<td>返回最后n行</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>数据分析专题</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas系列 | 1.基本数据结构</title>
    <url>/posts/411b6060/</url>
    <content><![CDATA[<p><img src="/images/5.jpg" width="90%" height="90%"></p>
<blockquote>
<p>系列(Series)是能够保存任何类型的数据(整数，字符串，浮点数，Python对象等)的一维标记数组。轴标签统称为索引</p>
</blockquote>
<h2 id="一、pandas-Series"><a href="#一、pandas-Series" class="headerlink" title="一、pandas.Series"></a>一、pandas.Series</h2><p>构造函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Series(data, index, dtype, copy)</span><br></pre></td></tr></table></figure><br>| 编号 | 参数  | 描述                                                         |<br>| —— | ——- | —————————————————————————————— |<br>| 1    | data  | 数据采取各种形式，如：ndarray，list，constants               |<br>| 2    | index | 索引值必须是唯一的和散列的，与数据的长度相同  默认np.arange(n)如果没有索引被传递 |<br>| 3    | dtype | dtype用于数据类型 如果没有，将推断数据类型                   |<br>| 4    | copy  | 复制数据，默认为false                                        |</p>
<p>构成一个Series的输入有:</p>
<ul>
<li>数组</li>
<li>字典</li>
<li>标量值</li>
<li>常数</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.array([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">s = pd.Series(data,index=[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100  a</span><br><span class="line">101  b</span><br><span class="line">102  c</span><br><span class="line">103  d</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">0.</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">1.</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">2.</span>&#125;</span><br><span class="line">s = pd.Series(data,index=[<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 1.0</span><br><span class="line">c 2.0</span><br><span class="line">d NaN</span><br><span class="line">a 0.0</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<h3 id="标量值-or-常数"><a href="#标量值-or-常数" class="headerlink" title="标量值 or 常数"></a>标量值 or 常数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import the pandas library and aliasing as pd</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">s = pd.Series(<span class="number">5</span>, index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  5</span><br><span class="line">1  5</span><br><span class="line">2  5</span><br><span class="line">3  5</span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二、pandas-DataFrame"><a href="#二、pandas-DataFrame" class="headerlink" title="二、pandas.DataFrame"></a>二、pandas.DataFrame</h2><blockquote>
<p>数据帧(DataFrame)是二维数据结构，即数据以行和列的表格方式排列</p>
</blockquote>
<p>数据帧(DataFrame)的功能特点：</p>
<ul>
<li>潜在的列是不同的类型</li>
<li>大小可变</li>
<li>标记轴(行和列)</li>
<li>可以对行和列执行算术运算</li>
</ul>
<p>构造函数：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame(data, index, columns, dtype, copy)</span><br></pre></td></tr></table></figure><br>| 编号 | 参数    | 描述                                                         |<br>| —— | ———- | —————————————————————————————— |<br>| 1    | data    | 数据采取各种形式，如:ndarray，series，map，lists，dict，constant和另一个DataFrame。 |<br>| 2    | index   | 对于行标签，要用于结果帧的索引是可选缺省值np.arrange(n)，如果没有传递索引值。 |<br>| 3    | columns | 对于列标签，可选的默认语法是 - np.arange(n)。 这只有在没有索引传递的情况下才是这样。 |<br>| 4    | dtype   | 每列的数据类型。                                             |<br>| 5    | copy    | 如果默认值为False，则此命令(或任何它)用于复制数据。          |</p>
<h3 id="创建DataFrame"><a href="#创建DataFrame" class="headerlink" title="创建DataFrame"></a>创建DataFrame</h3><p>Pandas数据帧(DataFrame)可以使用各种输入创建 </p>
<ul>
<li>列表</li>
<li>字典</li>
<li>系列（Series）</li>
<li>Numpy ndarrays</li>
<li>另一个数据帧(DataFrame)</li>
</ul>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     0</span><br><span class="line">0    1</span><br><span class="line">1    2</span><br><span class="line">2    3</span><br><span class="line">3    4</span><br><span class="line">4    5</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = [&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure><br>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    a    b      c</span><br><span class="line">0   1   2     NaN</span><br><span class="line">1   5   10   20.0</span><br></pre></td></tr></table></figure></p>
<h4 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>:[<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Steve&#x27;</span>, <span class="string">&#x27;Ricky&#x27;</span>],<span class="string">&#x27;Age&#x27;</span>:[<span class="number">28</span>,<span class="number">34</span>,<span class="number">29</span>,<span class="number">42</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data, index=[<span class="string">&#x27;rank1&#x27;</span>,<span class="string">&#x27;rank2&#x27;</span>,<span class="string">&#x27;rank3&#x27;</span>,<span class="string">&#x27;rank4&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">         Age    Name</span><br><span class="line">rank1    28      Tom</span><br><span class="line">rank2    34     Jack</span><br><span class="line">rank3    29    Steve</span><br><span class="line">rank4    42    Ricky</span><br></pre></td></tr></table></figure></p>
<h4 id="系列（Series）"><a href="#系列（Series）" class="headerlink" title="系列（Series）"></a>系列（Series）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      one    two</span><br><span class="line">a     1.0    1</span><br><span class="line">b     2.0    2</span><br><span class="line">c     3.0    3</span><br><span class="line">d     NaN    4</span><br></pre></td></tr></table></figure></p>
<h3 id="列选择"><a href="#列选择" class="headerlink" title="列选择"></a>列选择</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df [<span class="string">&#x27;one&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h3 id="列添加"><a href="#列添加" class="headerlink" title="列添加"></a>列添加</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">      <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding a new column to an existing DataFrame object with column label by passing new series</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Adding a new column by passing as Series:&quot;</span>)</span><br><span class="line">df[<span class="string">&#x27;three&#x27;</span>]=pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Adding a new column using the existing columns in DataFrame:&quot;</span>)</span><br><span class="line">df[<span class="string">&#x27;four&#x27;</span>]=df[<span class="string">&#x27;one&#x27;</span>]+df[<span class="string">&#x27;three&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<h3 id="列删除-pop-del"><a href="#列删除-pop-del" class="headerlink" title="列删除 pop/del"></a>列删除 pop/del</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Using the previous DataFrame, we will delete a column</span></span><br><span class="line"><span class="comment"># using del function</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;three&#x27;</span> : pd.Series([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], index=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Our dataframe is:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># using del function</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Deleting the first column using DEL function:&quot;</span>)</span><br><span class="line"><span class="keyword">del</span> df[<span class="string">&#x27;one&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> df</span><br><span class="line"></span><br><span class="line"><span class="comment"># using pop function</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Deleting another column using POP function:&quot;</span>)</span><br><span class="line">df.pop(<span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure>
<h3 id="行选择，添加和删除"><a href="#行选择，添加和删除" class="headerlink" title="行选择，添加和删除"></a>行选择，添加和删除</h3><h4 id="标签选择-loc"><a href="#标签选择-loc" class="headerlink" title="标签选择 loc"></a>标签选择 loc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]), </span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df.loc[<span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h4 id="按整数位置选择-iloc"><a href="#按整数位置选择-iloc" class="headerlink" title="按整数位置选择 iloc"></a>按整数位置选择 iloc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;one&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]),</span><br><span class="line">     <span class="string">&#x27;two&#x27;</span> : pd.Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(d)</span><br><span class="line"><span class="built_in">print</span> df.iloc[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="行切片"><a href="#行切片" class="headerlink" title="行切片"></a>行切片</h3><h4 id="附加行-append"><a href="#附加行-append" class="headerlink" title="附加行 append"></a>附加行 append</h4><p>使用append()函数将新行添加到DataFrame<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure></p>
<h4 id="删除行-drop"><a href="#删除行-drop" class="headerlink" title="删除行 drop"></a>删除行 drop</h4><p>使用索引标签从DataFrame中删除或删除行。 如果标签重复，则会删除多行。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]], columns = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"></span><br><span class="line">df = df.append(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Drop rows with label 0</span></span><br><span class="line">df = df.drop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> df</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="三、pandas-Panel"><a href="#三、pandas-Panel" class="headerlink" title="三、pandas.Panel()"></a>三、pandas.Panel()</h2><blockquote>
<p>面板(Panel)是3D容器的数据</p>
</blockquote>
<p>3轴(axis)这个名称旨在给出描述涉及面板数据的操作的一些语义</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>轴</th>
<th>detail</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td>axis 0，每个项目对应于内部包含的数据帧(DataFrame)</td>
</tr>
<tr>
<td>major_axis</td>
<td>axis 1，它是每个数据帧(DataFrame)的索引(行)</td>
</tr>
<tr>
<td>minor_axis</td>
<td>axis 2，它是每个数据帧(DataFrame)的列</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)</span><br></pre></td></tr></table></figure>
<p>构造函数的参数如下:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>数据采取各种形式，如：ndarray，series，map，lists，dict，constant和另一个数据帧(DataFrame)</td>
</tr>
<tr>
<td>items</td>
<td>axis=0</td>
</tr>
<tr>
<td>major_axis</td>
<td>axis=1</td>
</tr>
<tr>
<td>minor_axis</td>
<td>axis=2</td>
</tr>
<tr>
<td>dtype</td>
<td>每列的数据类型</td>
</tr>
<tr>
<td>copy</td>
<td>复制数据，默认 - false</td>
</tr>
</tbody>
</table>
</div>
<h3 id="创建面板"><a href="#创建面板" class="headerlink" title="创建面板"></a>创建面板</h3><p>可以使用多种方式创建面板</p>
<ul>
<li>从ndarrays创建</li>
<li>从DataFrames的dict创建</li>
</ul>
<h4 id="从3D-ndarray创建"><a href="#从3D-ndarray创建" class="headerlink" title="从3D ndarray创建"></a>从3D ndarray创建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print data</span><br><span class="line">[[[0.79346549 0.22729079 0.94261176 0.67379434 0.18751374]</span><br><span class="line">  [0.14514546 0.50550601 0.32767807 0.45882726 0.04787695]</span><br><span class="line">  [0.64748544 0.2019516  0.38334503 0.61874107 0.68800838]</span><br><span class="line">  [0.39880845 0.41415895 0.69383131 0.71159435 0.06160828]]</span><br><span class="line"></span><br><span class="line"> [[0.97102379 0.69454937 0.54629548 0.83072134 0.53068539]</span><br><span class="line">  [0.82441684 0.5882186  0.69936055 0.0924247  0.12300041]</span><br><span class="line">  [0.30401452 0.12971053 0.90511636 0.17855185 0.05474733]</span><br><span class="line">  [0.04730471 0.03639553 0.74632198 0.85193736 0.64864719]]]</span><br><span class="line">&gt;&gt;&gt; print p</span><br><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)</span><br><span class="line">Items axis: 0 to 1</span><br><span class="line">Major_axis axis: 0 to 3</span><br><span class="line">Minor_axis axis: 0 to 4</span><br></pre></td></tr></table></figure></p>
<h4 id="从DataFrame对象的dict创建面板"><a href="#从DataFrame对象的dict创建面板" class="headerlink" title="从DataFrame对象的dict创建面板"></a>从DataFrame对象的dict创建面板</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Item1&#x27;</span> : pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>)), </span><br><span class="line">        <span class="string">&#x27;Item2&#x27;</span> : pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">2</span>))&#125;</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#39;Item2&#39;:           </span><br><span class="line">          0         1</span><br><span class="line">0  0.009730  2.263936</span><br><span class="line">1 -1.008878  1.083319</span><br><span class="line">2  0.288527  0.234344</span><br><span class="line">3 -0.426486  0.286741, </span><br><span class="line">&#39;Item1&#39;:           </span><br><span class="line">      0         1         2</span><br><span class="line">0 -2.149956  1.696135 -0.256530</span><br><span class="line">1 -1.063944 -1.033069  0.653613</span><br><span class="line">2 -0.645782 -0.097129  1.034462</span><br><span class="line">3 -0.041070  0.104719  0.577797&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print p</span><br><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 2 (items) x 4 (major_axis) x 3 (minor_axis)</span><br><span class="line">Items axis: Item1 to Item2</span><br><span class="line">Major_axis axis: 0 to 3</span><br><span class="line">Minor_axis axis: 0 to 2</span><br></pre></td></tr></table></figure></p>
<h4 id="创建一个空面板"><a href="#创建一个空面板" class="headerlink" title="创建一个空面板"></a>创建一个空面板</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating an empty panel</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">p = pd.Panel()</span><br><span class="line"><span class="built_in">print</span> p</span><br></pre></td></tr></table></figure>
<p>res:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;pandas.core.panel.Panel&#39;&gt;</span><br><span class="line">Dimensions: 0 (items) x 0 (major_axis) x 0 (minor_axis)</span><br><span class="line">Items axis: None</span><br><span class="line">Major_axis axis: None</span><br><span class="line">Minor_axis axis: None</span><br></pre></td></tr></table></figure></p>
<h3 id="从面板中选择数据"><a href="#从面板中选择数据" class="headerlink" title="从面板中选择数据"></a>从面板中选择数据</h3><p>要从面板中选择数据，可以使用以下方式</p>
<ul>
<li>Items</li>
<li>Major_axis</li>
<li>Minor_axis</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = &#123;<span class="string">&#x27;Item1&#x27;</span> : pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>, <span class="number">3</span>)), </span><br><span class="line">        <span class="string">&#x27;Item2&#x27;</span> : pd.DataFrame(np.arange(<span class="number">8</span>).reshape(<span class="number">4</span>, <span class="number">2</span>))&#125;</span><br><span class="line">p = pd.Panel(data)</span><br><span class="line"><span class="built_in">print</span> data</span><br><span class="line"><span class="comment"># 使用Item</span></span><br><span class="line"><span class="built_in">print</span> p[<span class="string">&#x27;Item1&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用Major_axis</span></span><br><span class="line"><span class="built_in">print</span> p.major_xs(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 使用Minor_axis</span></span><br><span class="line"><span class="built_in">print</span> p.minor_xs(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data:</span><br><span class="line">&#123;<span class="string">&#x27;Item2&#x27;</span>:    </span><br><span class="line">   <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>, </span><br><span class="line"><span class="string">&#x27;Item1&#x27;</span>:    </span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Item</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p[<span class="string">&#x27;Item1&#x27;</span>]</span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">1</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Major_axis</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p.major_xs(<span class="number">1</span>)</span><br><span class="line">   Item1  Item2</span><br><span class="line"><span class="number">0</span>      <span class="number">3</span>    <span class="number">2.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">5</span>    NaN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用Minor_axis</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span> p.minor_xs(<span class="number">1</span>)</span><br><span class="line">   Item1  Item2</span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>    <span class="number">1.0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">4</span>    <span class="number">3.0</span></span><br><span class="line"><span class="number">2</span>      <span class="number">7</span>    <span class="number">5.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">10</span>    <span class="number">7.0</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="最后福利"><a href="#最后福利" class="headerlink" title="最后福利"></a>最后福利</h2><p>最后，在这里准备了几百本PDF技术类书籍，<a href="https://www.keketec.club/posts/77172009/">点击来领取吧!!!</a></p>
]]></content>
      <categories>
        <category>数据分析专题</category>
      </categories>
  </entry>
  <entry>
    <title>自己写代码实现邮件发送，再也不用可视化那么麻烦了！</title>
    <url>/posts/a6c96c4e/</url>
    <content><![CDATA[<blockquote>
<p>学而知不足，长按关注，精彩不错过</p>
</blockquote>
<p>Python自动批量发送邮件是一种什么体验？</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b1.jpg" width="100%" height="100%"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多时候，我们在发送一些邮件信息的时候，在可视化的界面巴拉巴拉操作一顿，其实就是一些很简单的信息，然后可能发送的收信者比较多，带来很多的麻烦，主要是浪费了我们的时间！</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>很重要重要重要的准备工作，带你进入代码发送邮件的氛围！</p>
<blockquote>
<p>看着前面小哥哥把每个订单号都粘贴到邮件里，然后再给一个收件人的联系邮箱，如此熟练的操作，整整做了一个上午，因为需要给每个收件人单独发送，我心里有种说不出来的感觉 …</p>
<p>这就像刚刚工作那会儿看着旁边跟我一样的实习生在重复插入sql一样，他居然不知道列编辑，然而要一行一行一个字一个字的敲进去一样的感受。</p>
<p><em>如果有不知道的同学也可以私信我，几分钟的事情可能对于不知道这个技巧的同学需要几个小时才能完成</em></p>
</blockquote>
<p><strong>进行正题！！！！！</strong></p>
<p>自动化发邮件之前，首先需要用到的两个重要的 Python 模块：smtplib 和 email</p>
<blockquote>
<p>smtplib模块主要用来建立服务器链接、服务器断开的工作； </p>
<p>email模块主要负责邮件的构建，比如收件人、邮件标题、邮件内容等</p>
</blockquote>
<p>我用的是python2.7版本，所以安装这两个库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip2.7 install secure-smtplib</span><br><span class="line">pip2.7 install email</span><br></pre></td></tr></table></figure>
<p>安装准备好需要的包，下面就开始发送邮件的操作，实例化操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br></pre></td></tr></table></figure>
<p>MIMEText 类是 MIMENonMultipart 类的子类，一般用于用于封装文本类型的邮件</p>
<p>实例化邮件服务器信息，可以进行相应的配置，邮件的标题、邮件的收发邮件信息、当然还可以进行抄送</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;First Message&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;MyTestTitle&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br></pre></td></tr></table></figure>
<p>在完成了以上的操作之后，然后配置自己的信息就可以进行操作发送了。</p>
<p>当然在我给到的代码中，都是以变量给出的，首先咱们需要初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送者邮箱（改为自己的）</span></span><br><span class="line">sender = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line"><span class="comment"># 接受者邮箱（改为自己的）</span></span><br><span class="line">receiver = <span class="string">&quot;xxx@qq.com&quot;</span></span><br><span class="line"><span class="comment"># 服务器地址</span></span><br><span class="line">smtp_addr = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line"><span class="comment"># 邮件服务器账号和密码，自己的163邮箱的登录账号和密码</span></span><br><span class="line">login_user = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">login_passwd = <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后，关键一步，可以发送了，但是记得要关闭连接哦！</p>
<p><strong>参数格式：</strong><code>sendmail(self, from_addr, to_addrs, msg, mail_options=[], rcpt_options=[])</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功 ^_^ &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>哈哈，看看我的界面，已经收到了哈！</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b2.jpg" width="50%" height="50%"></p>
<p>跟着试了的同学以及攻城狮们，成功了没有</p>
<p>需要我发送代码的，给我留言哈，可以公号后台私信我吆！！</p>
<p>也可以自取哈！地址: <a href="https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw">https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw</a>  密码: s8ew</p>
<h2 id="发送其他格式的邮件"><a href="#发送其他格式的邮件" class="headerlink" title="发送其他格式的邮件"></a>发送其他格式的邮件</h2><p>上述展示了普通格式的邮件发送格式，下面咱们再看看想要发送一些HTML格式的，还有带附件的邮件形式。</p>
<p>再然后就可以自行发挥发送任何格式和组合的邮件了！</p>
<h3 id="1-发送-HTML-格式的邮件"><a href="#1-发送-HTML-格式的邮件" class="headerlink" title="1. 发送 HTML 格式的邮件"></a>1. 发送 HTML 格式的邮件</h3><p>在创建 MIMEText 时，将 _subtype 设置为 “html”，则可发送 html 格式的邮件</p>
<p>其他步骤和发送纯文本邮件配置和代码格式都一致</p>
<p>跟上面文本格式邮件对比下哈，会有很清晰的思路：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通文本格式</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># html 格式</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>贴出详细代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Python&lt;/th&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;编程爱好者&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;需要代码的同学&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;加我微信&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;Johngo106X&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;双手奉上！&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEText(words, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;测试发送HTML信息&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>一些自定义的变量可以自己设置哈，全量代码可以在网盘中自取！！！</p>
<p>哈， 再看看 Johngo 的结果：</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b3.jpg" width="50%" height="50%"></p>
<p>下面再看看重要的附件，是怎么操作的</p>
<h3 id="2-发送带有附件的邮件"><a href="#2-发送带有附件的邮件" class="headerlink" title="2. 发送带有附件的邮件"></a>2. 发送带有附件的邮件</h3><p>类似的操作方法，不同的操作是实例化发送信息的这块稍有区别</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEMultipart()</span><br></pre></td></tr></table></figure>
<p>同样的我先把代码附上，需要详细代码的请自取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">words = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;table border=&quot;1&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;Python&lt;/th&gt;</span></span><br><span class="line"><span class="string">            &lt;th&gt;编程爱好者&lt;/th&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;需要代码的同学&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;加我微信&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;Johngo106X&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;双手奉上！&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        &lt;tr&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;原文链接&lt;/td&gt;</span></span><br><span class="line"><span class="string">            &lt;td&gt;xxx&lt;/td&gt;</span></span><br><span class="line"><span class="string">        &lt;/tr&gt;</span></span><br><span class="line"><span class="string">    &lt;/table&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 配置发送内容msg</span></span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line"><span class="comment"># 邮件正文</span></span><br><span class="line">msg.attach(payload=MIMEText(words, _subtype=<span class="string">&quot;html&quot;</span>, _charset=<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&quot;附件邮件发送测试&quot;</span>,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 发信人地址</span></span><br><span class="line">msg[<span class="string">&#x27;from&#x27;</span>] = sender</span><br><span class="line"><span class="comment"># 收信人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;to&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"><span class="comment"># 抄送人地址（支持群发）</span></span><br><span class="line">msg[<span class="string">&#x27;Cc&#x27;</span>] = <span class="string">&#x27;;&#x27;</span>.join([receiver])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file_path <span class="keyword">in</span> &#123;<span class="string">&quot;test1.xlsx&quot;</span>, <span class="string">&quot;test2.xlsx&quot;</span>&#125;:</span><br><span class="line">    attachment = MIMEText(_text=<span class="built_in">open</span>(file_path, <span class="string">&quot;rb&quot;</span>).read(), _subtype=<span class="string">&quot;base64&quot;</span>, _charset=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    attachment[<span class="string">&quot;Content-Type&quot;</span>] = <span class="string">&quot;application/octet-stream&quot;</span></span><br><span class="line">    attachment[<span class="string">&quot;Content-Disposition&quot;</span>] = <span class="string">&quot;attachment; filename=%s&quot;</span> % file_path</span><br><span class="line">    msg.attach(payload=attachment)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化SMTP</span></span><br><span class="line">smtp = smtplib.SMTP()</span><br><span class="line"><span class="comment"># 链接邮件服务器</span></span><br><span class="line">smtp.connect(smtp_addr)</span><br><span class="line"><span class="comment"># 配置发送邮箱的用户名和密码</span></span><br><span class="line">smtp.login(login_user, login_passwd)</span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">smtp.sendmail(sender, receiver, msg.as_string())</span><br><span class="line">smtp.quit()</span><br><span class="line">print(<span class="string">&quot;邮件发送成功!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>同样的，咱们看看附件过来了没有</p>
<p><img src="/images/c40bdbf83b4b177ba6c010e0aa84ba4b4.jpg" width="50%" height="50%"></p>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>比较简单的几行代码，在某些时候就可以将事情事半功倍，适用于定时发邮件、快速自定义的发送相同文件内容的场景</p>
<p>代码先放到网盘，就暂且不往github上传了，地址链接: <a href="https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw">https://pan.baidu.com/s/1At5rsu59QZ0BLQ6ETpPEvw</a>  密码: s8ew，自取哈！！</p>
<p>另外，我给到的是最基本的 Python 自定义发送邮件的操作，拿到手的同学和攻城狮们可以进行再次封装，更加好用一些。同时也可以分享出来</p>
<p>好了，今天就是有关自定义发送邮件小工具的全部分享内容了，如果感觉对你有些许帮助，还请轻轻点击转发，让更多的人看到，对 Johngo 来说，有莫大的帮助！</p>
<p>文中有任何错误的地方，烦请不吝赐教。非常感谢!</p>
]]></content>
      <categories>
        <category>编程轨迹</category>
      </categories>
  </entry>
  <entry>
    <title>利用Python进行数据分析 PDF</title>
    <url>/posts/558dd557/</url>
    <content><![CDATA[<h4 id="《利用Python进行数据分析》"><a href="#《利用Python进行数据分析》" class="headerlink" title="《利用Python进行数据分析》"></a>《利用Python进行数据分析》</h4><p>这本书几乎是数据分析入门必读书了</p>
<p>主要介绍了python 3个库numpy（数组），pandas（数据分析）和matplotlib（绘图）的学习<br><a id="more"></a></p>
<p>阅读本书可以获得一份关于在Python下操作、处理、清洗、规整数据集的完整说明。本书第二版针对Python 3.6进行了更新，并增加实际案例向你展示如何高效地解决一系列数据分析问题。你将在阅读过程中学习到新版本的pandas、NumPy、IPython和Jupyter。</p>
<p>本书由Wes McKinney创作，他是Python pandas项目的创始人。本书是对Python数据科学工具的实操化、现代化的介绍，非常适合刚学Python的数据分析师或刚学数据科学以及科学计算的Python编程者。数据文件和相关的材料可以在GitHub上找到：</p>
<p>l 使用IPython shell和Jupyter notebook进行探索性计算</p>
<p>l 学习NumPy(Numerical Python)的基础和高级特性</p>
<p>l 入门pandas库中的数据分析工具</p>
<p>l 使用灵活工具对数据进行载入、清洗、变换、合并和重塑</p>
<p>l 使用matplotlib创建富含信息的可视化</p>
<p>l 将pandas的groupby功能应用于对数据集的切片、分块和汇总</p>
<p>l 分析并操作规则和不规则的时间序列数据</p>
<p>利用完整的、详细的示例学习如何解决现实中数据分析问题</p>
<h4 id="获取链接-https-pan-baidu-com-s-1GPAeBzRfm-q9k6Git-Xc5g-密码-qune"><a href="#获取链接-https-pan-baidu-com-s-1GPAeBzRfm-q9k6Git-Xc5g-密码-qune" class="headerlink" title="获取链接: https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g 密码: qune"></a>获取链接: <a href="https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g">https://pan.baidu.com/s/1GPAeBzRfm_q9k6Git_Xc5g</a> 密码: qune</h4><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p><img src="/images/6dc7268c125782b470a111351071ec9a1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言1</span><br><span class="line"></span><br><span class="line">第1章 准备工作7</span><br><span class="line"></span><br><span class="line">1.1 本书内容7</span><br><span class="line"></span><br><span class="line">1.1.1 什么类型的数据7</span><br><span class="line"></span><br><span class="line">1.2 为何利用Python进行数据分析8</span><br><span class="line"></span><br><span class="line">1.2.1 Python作为胶水8</span><br><span class="line"></span><br><span class="line">1.2.2 解决“双语言”难题8</span><br><span class="line"></span><br><span class="line">1.2.3 为何不使用Python9</span><br><span class="line"></span><br><span class="line">1.3 重要的Python库9</span><br><span class="line"></span><br><span class="line">1.3.1 NumPy9</span><br><span class="line"></span><br><span class="line">1.3.2 pandas10</span><br><span class="line"></span><br><span class="line">1.3.3 matplotlib11</span><br><span class="line"></span><br><span class="line">1.3.4 IPython与Jupyter11</span><br><span class="line"></span><br><span class="line">1.3.5 SciPy12</span><br><span class="line"></span><br><span class="line">1.3.6 scikit-learn12</span><br><span class="line"></span><br><span class="line">1.3.7 statsmodels13</span><br><span class="line"></span><br><span class="line">1.4 安装与设置13</span><br><span class="line"></span><br><span class="line">1.4.1 Windows14</span><br><span class="line"></span><br><span class="line">1.4.2 Apple（OS X和macOS）14</span><br><span class="line"></span><br><span class="line">1.4.3 GNU&#x2F;Linux14</span><br><span class="line"></span><br><span class="line">1.4.4 安装及更新Python包15</span><br><span class="line"></span><br><span class="line">1.4.5 Python 2和Python 316</span><br><span class="line"></span><br><span class="line">1.4.6 集成开发环境和文本编辑器16</span><br><span class="line"></span><br><span class="line">1.5 社区和会议17</span><br><span class="line"></span><br><span class="line">1.6 快速浏览本书17</span><br><span class="line"></span><br><span class="line">1.6.1 代码示例18</span><br><span class="line"></span><br><span class="line">1.6.2 示例数据18</span><br><span class="line"></span><br><span class="line">1.6.3导入约定18</span><br><span class="line"></span><br><span class="line">1.6.4术语19</span><br><span class="line"></span><br><span class="line">第2章 Python语言基础、IPython及Jupyter notebook20</span><br><span class="line"></span><br><span class="line">2.1 Python解释器21</span><br><span class="line"></span><br><span class="line">2.2 IPython基础22</span><br><span class="line"></span><br><span class="line">2.2.1 运行IPython命令行22</span><br><span class="line"></span><br><span class="line">2.2.2 运行 Jupyter notebook23</span><br><span class="line"></span><br><span class="line">2.2.3 Tab补全25</span><br><span class="line"></span><br><span class="line">2.2.4 内省27</span><br><span class="line"></span><br><span class="line">2.2.5 %run命令28</span><br><span class="line"></span><br><span class="line">2.2.6 执行剪贴板中的程序30</span><br><span class="line"></span><br><span class="line">2.2.7 终端快捷键30</span><br><span class="line"></span><br><span class="line">2.2.8 关于魔术命令31</span><br><span class="line"></span><br><span class="line">2.2.9　matplotlib集成33</span><br><span class="line"></span><br><span class="line">2.3 Python语言基础34</span><br><span class="line"></span><br><span class="line">2.3.1 语言语义34</span><br><span class="line"></span><br><span class="line">2.3.2 标量类型42</span><br><span class="line"></span><br><span class="line">2.3.3 控制流49</span><br><span class="line"></span><br><span class="line">第3章 内建数据结构、函数及文件54</span><br><span class="line"></span><br><span class="line">3.1 数据结构和序列54</span><br><span class="line"></span><br><span class="line">3.1.1 元组54</span><br><span class="line"></span><br><span class="line">3.1.2 列表57</span><br><span class="line"></span><br><span class="line">3.1.3 内建序列函数61</span><br><span class="line"></span><br><span class="line">3.1.4 字典64</span><br><span class="line"></span><br><span class="line">3.1.5集合67</span><br><span class="line"></span><br><span class="line">3.1.6 列表、集合和字典的推导式69</span><br><span class="line"></span><br><span class="line">3.2 函数72</span><br><span class="line"></span><br><span class="line">3.2.1 命名空间、作用域和本地函数72</span><br><span class="line"></span><br><span class="line">3.2.2 返回多个值73</span><br><span class="line"></span><br><span class="line">3.2.3 函数是对象74</span><br><span class="line"></span><br><span class="line">3.2.4 匿名（Lambda）函数75</span><br><span class="line"></span><br><span class="line">3.2.5 柯里化：部分参数应用76</span><br><span class="line"></span><br><span class="line">3.2.6 生成器77</span><br><span class="line"></span><br><span class="line">3.2.7 错误和异常处理79</span><br><span class="line"></span><br><span class="line">3.3 文件与操作系统82</span><br><span class="line"></span><br><span class="line">3.3.1 字节与Unicode文件85</span><br><span class="line"></span><br><span class="line">3.4 本章小结86</span><br><span class="line"></span><br><span class="line">第4章 NumPy基础：数组与向量化计算87</span><br><span class="line"></span><br><span class="line">4.1 NumPy ndarray：多维数组对象89</span><br><span class="line"></span><br><span class="line">4.1.1 生成ndarray90</span><br><span class="line"></span><br><span class="line">4.1.2 ndarray的数据类型92</span><br><span class="line"></span><br><span class="line">4.1.3 NumPy数组算术94</span><br><span class="line"></span><br><span class="line">4.1.4 基础索引与切片95</span><br><span class="line"></span><br><span class="line">4.1.5 布尔索引100</span><br><span class="line"></span><br><span class="line">4.1.6 神奇索引103</span><br><span class="line"></span><br><span class="line">4.1.7 数组转置和换轴104</span><br><span class="line"></span><br><span class="line">4.2 通用函数：快速的逐元素数组函数106</span><br><span class="line"></span><br><span class="line">4.3 使用数组进行面向数组编程109</span><br><span class="line"></span><br><span class="line">4.3.1 将条件逻辑作为数组操作110</span><br><span class="line"></span><br><span class="line">4.3.2 数学和统计方法111</span><br><span class="line"></span><br><span class="line">4.3.3 布尔值数组的方法113</span><br><span class="line"></span><br><span class="line">4.3.4 排序114</span><br><span class="line"></span><br><span class="line">4.3.5 唯一值与其他集合逻辑115</span><br><span class="line"></span><br><span class="line">4.4 使用数组进行文件输入和输出115</span><br><span class="line"></span><br><span class="line">4.5 线性代数116</span><br><span class="line"></span><br><span class="line">4.6 伪随机数生成118</span><br><span class="line"></span><br><span class="line">4.7 示例：随机漫步120</span><br><span class="line"></span><br><span class="line">4.7.1 一次性模拟多次随机漫步121</span><br><span class="line"></span><br><span class="line">4.8 本章小结122</span><br><span class="line"></span><br><span class="line">第5章 pandas入门123</span><br><span class="line"></span><br><span class="line">5.1 pandas数据结构介绍123</span><br><span class="line"></span><br><span class="line">5.1.1 Series123</span><br><span class="line"></span><br><span class="line">5.1.2 DataFrame128</span><br><span class="line"></span><br><span class="line">5.1.3 索引对象134</span><br><span class="line"></span><br><span class="line">5.2 基本功能135</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>百面机器学习 PDF</title>
    <url>/posts/bcee7062/</url>
    <content><![CDATA[<h4 id="《百面机器学习》"><a href="#《百面机器学习》" class="headerlink" title="《百面机器学习》"></a>《百面机器学习》</h4><h6 id="链接-https-pan-baidu-com-s-1fZgli2Lkd00XcStqm-36xQ"><a href="#链接-https-pan-baidu-com-s-1fZgli2Lkd00XcStqm-36xQ" class="headerlink" title="链接:https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ"></a>链接:<a href="https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ">https://pan.baidu.com/s/1fZgli2Lkd00XcStqm_36xQ</a></h6><p>《百面机器学习 算法工程师带你去面试》<br><a id="more"></a></p>
<p>人工智能领域正在以超乎人们想象的速度发展，本书赶在人工智能彻底占领世界之前完成编写，实属万幸。</p>
<p>书中收录了超过100道机器学习算法工程师的面试题目和解答，其中大部分源于Hulu算法研究岗位的真实场景。本书从日常工作、生活中各种有趣的现象出发，不仅囊括了机器学习的基本知识，而且还包含了成为出众算法工程师的相关技能，更重要的是凝聚了笔者对人工智能领域的一颗热忱之心，旨在培养读者发现问题、解决问题、扩展问题的能力，建立对机器学习的热爱，共绘人工智能世界的宏伟蓝图。</p>
<p>“不积跬步，无以至千里”，本书将从特征工程、模型评估、降维等经典机器学习领域出发，构建一个算法工程师必-备的知识体系；见神经网络、强化学习、生成对抗网络等新科研进展之微，知深度学习领域胜败兴衰之著；“博观而约取，厚积而薄发”，在末一章为读者展示生活中各种引领时代的人工智能应用。</p>
<h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《百面机器学习　算法工程师带你去面试》</span><br><span class="line"></span><br><span class="line">推荐序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">机器学习算法工程师的自我修养</span><br><span class="line"></span><br><span class="line">第 1章 特征工程</span><br><span class="line"></span><br><span class="line">第 1节 特征归一化</span><br><span class="line"></span><br><span class="line">第 2节 类别型特征</span><br><span class="line"></span><br><span class="line">第3节 高维组合特征的处理</span><br><span class="line"></span><br><span class="line">第4节 组合特征</span><br><span class="line"></span><br><span class="line">第5节 文本表示模型</span><br><span class="line"></span><br><span class="line">第6节 Word2Vec</span><br><span class="line"></span><br><span class="line">第7节 图像数据不足时的处理方法</span><br><span class="line"></span><br><span class="line">第 2章 模型评估</span><br><span class="line"></span><br><span class="line">第 1节 评估指标的局限性</span><br><span class="line"></span><br><span class="line">第 2节 ROC 曲线</span><br><span class="line"></span><br><span class="line">第3节 余弦距离的应用</span><br><span class="line"></span><br><span class="line">第4节 A&#x2F;B 测试的陷阱</span><br><span class="line"></span><br><span class="line">第5节 模型评估的方法</span><br><span class="line"></span><br><span class="line">第6节 超参数调优</span><br><span class="line"></span><br><span class="line">第7节 过拟合与欠拟合</span><br><span class="line"></span><br><span class="line">第3章 经典算法</span><br><span class="line"></span><br><span class="line">第 1节 支持向量机</span><br><span class="line"></span><br><span class="line">第 2节 逻辑回归</span><br><span class="line"></span><br><span class="line">第3节 决策树</span><br><span class="line"></span><br><span class="line">第4章 降维</span><br><span class="line"></span><br><span class="line">第 1节 PCA 最大方差理论</span><br><span class="line"></span><br><span class="line">第 2节 PCA 最小平方误差理论</span><br><span class="line"></span><br><span class="line">第3节 线性判别分析</span><br><span class="line"></span><br><span class="line">第4节 线性判别分析与主成分分析</span><br><span class="line"></span><br><span class="line">第5章 非监督学习</span><br><span class="line"></span><br><span class="line">第 1节 K 均值聚类</span><br><span class="line"></span><br><span class="line">第 2节 高斯混合模型</span><br><span class="line"></span><br><span class="line">第3节 自组织映射神经网络</span><br><span class="line"></span><br><span class="line">第4节 非监督学习算法的评估</span><br><span class="line"></span><br><span class="line">第6章 概率图模型</span><br><span class="line"></span><br><span class="line">第 1节 概率图模型的联合概率分布</span><br><span class="line"></span><br><span class="line">第 2节 概率图表示</span><br><span class="line"></span><br><span class="line">第3节 生成式模型与判别式模型</span><br><span class="line"></span><br><span class="line">第4节 马尔可夫模型</span><br><span class="line"></span><br><span class="line">第5节 主题模型</span><br><span class="line"></span><br><span class="line">第7章 优化算法</span><br><span class="line"></span><br><span class="line">第 1节 有监督学习的损失函数</span><br><span class="line"></span><br><span class="line">第 2节 机器学习中的优化问题</span><br><span class="line"></span><br><span class="line">第3节 经典优化算法</span><br><span class="line"></span><br><span class="line">第4节 梯度验证</span><br><span class="line"></span><br><span class="line">第5节 随机梯度下降法</span><br><span class="line"></span><br><span class="line">第6节 随机梯度下降法的加速</span><br><span class="line"></span><br><span class="line">第7节 L1 正则化与稀疏性</span><br><span class="line"></span><br><span class="line">第8章 采样</span><br><span class="line"></span><br><span class="line">第 1节 采样的作用</span><br><span class="line"></span><br><span class="line">第 2节 均匀分布随机数</span><br><span class="line"></span><br><span class="line">第3节 常见的采样方法</span><br><span class="line"></span><br><span class="line">第4节 高斯分布的采样</span><br><span class="line"></span><br><span class="line">第5节 马尔科夫蒙特卡洛采样法</span><br><span class="line"></span><br><span class="line">第6节 贝叶斯网络的采样</span><br><span class="line"></span><br><span class="line">第7节 不均衡样本集的重采样</span><br><span class="line"></span><br><span class="line">第9章 前向神经网络</span><br><span class="line"></span><br><span class="line">第 1节 多层感知机与布尔函数</span><br><span class="line"></span><br><span class="line">第 2节 深度神经网络中的激活函数</span><br><span class="line"></span><br><span class="line">第3节 多层感知机的反向传播算法</span><br><span class="line"></span><br><span class="line">第4节 神经网络训练技巧</span><br><span class="line"></span><br><span class="line">第5节 深度卷积神经网络</span><br><span class="line"></span><br><span class="line">第6节 深度残差网络</span><br><span class="line"></span><br><span class="line">第 10章 循环神经网络</span><br><span class="line"></span><br><span class="line">第 1节 循环神经网络和卷积神经网络</span><br><span class="line"></span><br><span class="line">第 2节 循环神经网络的梯度消失问题</span><br><span class="line"></span><br><span class="line">第3节 循环神经网络中的激活函数</span><br><span class="line"></span><br><span class="line">第4节 长短期记忆网络</span><br><span class="line"></span><br><span class="line">第5节 Seq2Seq 模型</span><br><span class="line"></span><br><span class="line">第6节 注意力机制</span><br><span class="line"></span><br><span class="line">第 11章 强化学习</span><br><span class="line"></span><br><span class="line">第 1节　强化学习基础</span><br><span class="line"></span><br><span class="line">第 2节 视频游戏里的强化学习</span><br><span class="line"></span><br><span class="line">第3节 策略梯度</span><br><span class="line"></span><br><span class="line">第4节 探索与利用</span><br><span class="line"></span><br><span class="line">第 12章 集成学习</span><br><span class="line"></span><br><span class="line">第 1节 集成学习的种类</span><br><span class="line"></span><br><span class="line">第 2节 集成学习的步骤和例子</span><br><span class="line"></span><br><span class="line">第3节 基分类器</span><br><span class="line"></span><br><span class="line">第4节 偏差与方差</span><br><span class="line"></span><br><span class="line">第5节 梯度提升决策树的基本原理</span><br><span class="line"></span><br><span class="line">第6节 XGBoost 与GBDT 的联系和区别</span><br><span class="line"></span><br><span class="line">第 13章 生成式对抗网络</span><br><span class="line"></span><br><span class="line">第 1节 初识GANs 的秘密</span><br><span class="line"></span><br><span class="line">第 2节 WGAN：抓住低维的幽灵</span><br><span class="line"></span><br><span class="line">第3节 DCGAN：当GANs 遇上卷积</span><br><span class="line"></span><br><span class="line">第4节 ALI：包揽推断业务</span><br><span class="line"></span><br><span class="line">第5节 IRGAN：生成离散样本</span><br><span class="line"></span><br><span class="line">第6节 SeqGAN：生成文本序列</span><br><span class="line"></span><br><span class="line">第 14章 人工智能的热门应用</span><br><span class="line"></span><br><span class="line">第 1节 计算广告</span><br><span class="line"></span><br><span class="line">第 2节 游戏中的人工智能</span><br><span class="line"></span><br><span class="line">第3节 AI 在自动驾驶中的应用</span><br><span class="line"></span><br><span class="line">第4节 机器翻译</span><br><span class="line"></span><br><span class="line">第5节 人机交互中的智能计算</span><br><span class="line"></span><br><span class="line">后记</span><br><span class="line"></span><br><span class="line">作者随笔</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">《百面深度学习 算法工程师带你去面试》</span><br><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">第 一部分 算法和模型</span><br><span class="line"></span><br><span class="line">第 1章 卷积神经网络</span><br><span class="line"></span><br><span class="line">01 卷积基础知识</span><br><span class="line"></span><br><span class="line">02 卷积的变种</span><br><span class="line"></span><br><span class="line">03 卷积神经网络的整体结构</span><br><span class="line"></span><br><span class="line">04 卷积神经网络的基础模块</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 2章 循环神经网络</span><br><span class="line"></span><br><span class="line">01 循环神经网络与序列建模</span><br><span class="line"></span><br><span class="line">02 循环神经网络中的Dropout</span><br><span class="line"></span><br><span class="line">03 循环神经网络中的长期依赖问题</span><br><span class="line"></span><br><span class="line">04 长短期记忆网络</span><br><span class="line"></span><br><span class="line">05 Seq2Seq 架构</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第3章 图神经网络</span><br><span class="line"></span><br><span class="line">01 图神经网络的基本结构</span><br><span class="line"></span><br><span class="line">02 图神经网络在推荐系统中的应用</span><br><span class="line"></span><br><span class="line">03 图神经网络的推理能力</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第4章 生成模型</span><br><span class="line"></span><br><span class="line">01 深度信念网络与深度波尔兹曼机</span><br><span class="line"></span><br><span class="line">02 变分自编码器基础知识</span><br><span class="line"></span><br><span class="line">03 变分自编码器的改进</span><br><span class="line"></span><br><span class="line">04 生成式矩匹配网络与深度自回归网络</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第5章 生成式对抗网络</span><br><span class="line"></span><br><span class="line">01 生成式对抗网络的基本原理</span><br><span class="line"></span><br><span class="line">02 生成式对抗网络的改进</span><br><span class="line"></span><br><span class="line">03 生成式对抗网络的效果评估</span><br><span class="line"></span><br><span class="line">04 生成式对抗网络的应用</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第6章 强化学习</span><br><span class="line"></span><br><span class="line">01 强化学习基础知识</span><br><span class="line"></span><br><span class="line">02 强化学习算法</span><br><span class="line"></span><br><span class="line">03 深度强化学习</span><br><span class="line"></span><br><span class="line">04 强化学习的应用</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第7章 元学习</span><br><span class="line"></span><br><span class="line">01 元学习的主要概念</span><br><span class="line"></span><br><span class="line">02 元学习的主要方法</span><br><span class="line"></span><br><span class="line">03 元学习的数据集准备</span><br><span class="line"></span><br><span class="line">04 元学习的两个简单模型</span><br><span class="line"></span><br><span class="line">05 基于度量学习的元学习模型</span><br><span class="line"></span><br><span class="line">06 基于神经图灵机的元学习模型</span><br><span class="line"></span><br><span class="line">07 基于学习优化器的元学习模型</span><br><span class="line"></span><br><span class="line">08 基于学习初始点的元学习模型</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第8章 自动化机器学习</span><br><span class="line"></span><br><span class="line">01 自动化机器学习的基本概念</span><br><span class="line"></span><br><span class="line">02 模型和超参数自动化调优</span><br><span class="line"></span><br><span class="line">03 神经网络架构搜索</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第二部分 应用</span><br><span class="line"></span><br><span class="line">第9章 计算机视觉</span><br><span class="line"></span><br><span class="line">01 物体检测</span><br><span class="line"></span><br><span class="line">02 图像分割</span><br><span class="line"></span><br><span class="line">03 光学字符识别</span><br><span class="line"></span><br><span class="line">04 图像标注</span><br><span class="line"></span><br><span class="line">05 人体姿态识别</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 10章 自然语言处理</span><br><span class="line"></span><br><span class="line">01 语言的特征表示</span><br><span class="line"></span><br><span class="line">02 机器翻译</span><br><span class="line"></span><br><span class="line">03 问答系统</span><br><span class="line"></span><br><span class="line">04 对话系统</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第 11章　推荐系统</span><br><span class="line"></span><br><span class="line">01　推荐系统基础</span><br><span class="line"></span><br><span class="line">02　推荐系统设计与算法</span><br><span class="line"></span><br><span class="line">03　推荐系统评估</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　12章 计算广告</span><br><span class="line"></span><br><span class="line">01　点击率预估</span><br><span class="line"></span><br><span class="line">02　广告召回</span><br><span class="line"></span><br><span class="line">03　广告投放策略</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　13章 视频处理</span><br><span class="line"></span><br><span class="line">01　视频编解码</span><br><span class="line"></span><br><span class="line">02　视频监控</span><br><span class="line"></span><br><span class="line">03　图像质量评价</span><br><span class="line"></span><br><span class="line">04　超分辨率重建</span><br><span class="line"></span><br><span class="line">05　网络通信</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　14章 计算机听觉</span><br><span class="line"></span><br><span class="line">01　音频信号的特征提取</span><br><span class="line"></span><br><span class="line">02　自动语音识别</span><br><span class="line"></span><br><span class="line">03　音频事件识别</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">第　15章 自动驾驶</span><br><span class="line"></span><br><span class="line">01　自动驾驶的基本概念</span><br><span class="line"></span><br><span class="line">02　端到端的自动驾驶模型</span><br><span class="line"></span><br><span class="line">03　自动驾驶的决策系统</span><br><span class="line"></span><br><span class="line">参考文献</span><br><span class="line"></span><br><span class="line">作者随笔</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术 卷1 基础知识 原书第9版 PDF</title>
    <url>/posts/3b91d480/</url>
    <content><![CDATA[<h4 id="《Java核心技术-卷1-基础知识-原书第9版》"><a href="#《Java核心技术-卷1-基础知识-原书第9版》" class="headerlink" title="《Java核心技术 卷1 基础知识 原书第9版》"></a>《Java核心技术 卷1 基础知识 原书第9版》</h4><h6 id="链接-https-pan-baidu-com-s-1L97jTawydJ6Yf5Sf0JfyAw-密码-x1x3"><a href="#链接-https-pan-baidu-com-s-1L97jTawydJ6Yf5Sf0JfyAw-密码-x1x3" class="headerlink" title="链接:https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw 密码:x1x3"></a>链接:<a href="https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw">https://pan.baidu.com/s/1L97jTawydJ6Yf5Sf0JfyAw</a> 密码:x1x3</h6><p>Cay S.Horstmann，圣何塞州立大学计算机科学系教授、Java语言的倡导者，也是《Scala for theImpatient》一书（Addison-Wesley，2012）的作者和《Core JavaServer·Faces，3rd》一书（Prentice Hall, 2010）的合著者。他还经常在计算机会议上发表演讲。CrayCornell，已经教授程序设计专业课程20多年，并撰写了多部专著。他是Apress的创始人之一，他写的程序设计专业书籍非常畅销，曾荣获Jolt震撼大奖，并获得VisualBasic Magazine的读者最喜爱作品大奖。<br><a id="more"></a></p>
<p>编辑推荐</p>
<p>Java领域最有影响力和价值的著作之一，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评；</p>
<p>根据Java SE 7全面更新，系统全面讲解Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强</p>
<p><img src="/images/c52379bffbc0809e0ebb5e9dc2a1d3231.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 Java程序设计概述</span><br><span class="line"></span><br><span class="line">1.1 Java程序设计平台</span><br><span class="line"></span><br><span class="line">1.2 Java“白皮书”的关键术语</span><br><span class="line"></span><br><span class="line">1.2.1 简单性</span><br><span class="line"></span><br><span class="line">1.2.2 面向对象</span><br><span class="line"></span><br><span class="line">1.2.3 网络技能</span><br><span class="line"></span><br><span class="line">1.2.4 健壮性</span><br><span class="line"></span><br><span class="line">1.2.5 安全性</span><br><span class="line"></span><br><span class="line">1.2.6 体系结构中立</span><br><span class="line"></span><br><span class="line">1.2.7 可移植性</span><br><span class="line"></span><br><span class="line">1.2.8 解释型</span><br><span class="line"></span><br><span class="line">1.2.9 高性能</span><br><span class="line"></span><br><span class="line">1.2.10 多线程</span><br><span class="line"></span><br><span class="line">1.2.11 动态性</span><br><span class="line"></span><br><span class="line">1.3 Java applet与Internet</span><br><span class="line"></span><br><span class="line">1.4 Java发展简史</span><br><span class="line"></span><br><span class="line">1.5 关于Java的常见误解</span><br><span class="line"></span><br><span class="line">第2章 Java程序设计环境</span><br><span class="line"></span><br><span class="line">2.1 安装Java开发工具箱</span><br><span class="line"></span><br><span class="line">2.1.1 下载JDK</span><br><span class="line"></span><br><span class="line">2.1.2 设置执行路径</span><br><span class="line"></span><br><span class="line">2.1.3 安装库源文件和文档</span><br><span class="line"></span><br><span class="line">2.1.4 安装本书中的示例</span><br><span class="line"></span><br><span class="line">2.1.5 导航Java目录</span><br><span class="line"></span><br><span class="line">2.2 选择开发环境</span><br><span class="line"></span><br><span class="line">2.3 使用命令行工具</span><br><span class="line"></span><br><span class="line">2.4 使用集成开发环境</span><br><span class="line"></span><br><span class="line">2.5 运行图形化应用程序</span><br><span class="line"></span><br><span class="line">2.6 建立并运行applet</span><br><span class="line"></span><br><span class="line">第3章 Java的基本程序设计结构</span><br><span class="line"></span><br><span class="line">3.1 一个简单的Java应用程序</span><br><span class="line"></span><br><span class="line">3.2 注释</span><br><span class="line"></span><br><span class="line">3.3 数据类型</span><br><span class="line"></span><br><span class="line">3.3.1 整型</span><br><span class="line"></span><br><span class="line">3.3.2 浮点类型</span><br><span class="line"></span><br><span class="line">3.3.3 char类型</span><br><span class="line"></span><br><span class="line">3.3.4 boolean类型</span><br><span class="line"></span><br><span class="line">3.4 变量</span><br><span class="line"></span><br><span class="line">3.4.1 变量初始化</span><br><span class="line"></span><br><span class="line">3.4.2 常量</span><br><span class="line"></span><br><span class="line">3.5 运算符</span><br><span class="line"></span><br><span class="line">3.5.1 自增运算符与自减运算符</span><br><span class="line"></span><br><span class="line">3.5.2 关系运算符与boolean运算符</span><br><span class="line"></span><br><span class="line">3.5.3 位运算符</span><br><span class="line"></span><br><span class="line">3.5.4 数学函数与常量</span><br><span class="line"></span><br><span class="line">3.5.5 数值类型之间的转换</span><br><span class="line"></span><br><span class="line">3.5.6 强制类型转换</span><br><span class="line"></span><br><span class="line">3.5.7 括号与运算符级别</span><br><span class="line"></span><br><span class="line">3.5.8 枚举类型</span><br><span class="line"></span><br><span class="line">3.6 字符串</span><br><span class="line"></span><br><span class="line">3.6.1 子串</span><br><span class="line"></span><br><span class="line">3.6.2 拼接</span><br><span class="line"></span><br><span class="line">3.6.3 不可变字符串</span><br><span class="line"></span><br><span class="line">3.6.4 检测字符串是否相等</span><br><span class="line"></span><br><span class="line">3.6.5 空串与Null串</span><br><span class="line"></span><br><span class="line">3.6.6 代码点与代码单元</span><br><span class="line"></span><br><span class="line">3.6.7 字符串API</span><br><span class="line"></span><br><span class="line">3.6.8 阅读联机API文档</span><br><span class="line"></span><br><span class="line">3.6.9 构建字符串</span><br><span class="line"></span><br><span class="line">3.7 输入输出</span><br><span class="line"></span><br><span class="line">3.7.1 读取输入</span><br><span class="line"></span><br><span class="line">3.7.2 格式化输出</span><br><span class="line"></span><br><span class="line">3.7.3 文件输入与输出</span><br><span class="line"></span><br><span class="line">3.8 控制流程</span><br><span class="line"></span><br><span class="line">3.8.1 块作用域</span><br><span class="line"></span><br><span class="line">3.8.2 条件语句</span><br><span class="line"></span><br><span class="line">3.8.3 循环</span><br><span class="line"></span><br><span class="line">3.8.4 确定循环</span><br><span class="line"></span><br><span class="line">3.8.5 多重选择：switch语句</span><br><span class="line"></span><br><span class="line">3.8.6 中断控制流程语句</span><br><span class="line"></span><br><span class="line">3.9 大数值</span><br><span class="line"></span><br><span class="line">3.10 数组</span><br><span class="line"></span><br><span class="line">3.10.1 for each循环</span><br><span class="line"></span><br><span class="line">3.10.2 数组初始化以及匿名数组</span><br><span class="line"></span><br><span class="line">3.10.3 数组拷贝</span><br><span class="line"></span><br><span class="line">3.10.4 命令行参数</span><br><span class="line"></span><br><span class="line">3.10.5 数组排序</span><br><span class="line"></span><br><span class="line">3.10.6 多维数组</span><br><span class="line"></span><br><span class="line">3.10.7 不规则数组</span><br><span class="line"></span><br><span class="line">第4章 对象与类</span><br><span class="line"></span><br><span class="line">4.1 面向对象程序设计概述</span><br><span class="line"></span><br><span class="line">4.1.1 类</span><br><span class="line"></span><br><span class="line">4.1.2 对象</span><br><span class="line"></span><br><span class="line">4.1.3 识别类</span><br><span class="line"></span><br><span class="line">4.1.4 类之间的关系</span><br><span class="line"></span><br><span class="line">4.2 使用预定义类</span><br><span class="line"></span><br><span class="line">4.2.1 对象与对象变量</span><br><span class="line"></span><br><span class="line">4.2.2 Java类库中的Gregorian-Calendar类</span><br><span class="line"></span><br><span class="line">4.2.3 更改器方法与访问器方法</span><br><span class="line"></span><br><span class="line">4.3 用户自定义类</span><br><span class="line"></span><br><span class="line">4.3.1 Employee类</span><br><span class="line"></span><br><span class="line">4.3.2 多个源文件的使用</span><br><span class="line"></span><br><span class="line">4.3.3 剖析Employee类</span><br><span class="line"></span><br><span class="line">4.3.4 从构造器开始</span><br><span class="line"></span><br><span class="line">4.3.5 隐式参数与显式参数</span><br><span class="line"></span><br><span class="line">4.3.6 封装的优点</span><br><span class="line"></span><br><span class="line">4.3.7 基于类的访问权限</span><br><span class="line"></span><br><span class="line">4.3.8 私有方法</span><br><span class="line"></span><br><span class="line">4.3.9 final实例域</span><br><span class="line"></span><br><span class="line">4.4 静态域与静态方法</span><br><span class="line"></span><br><span class="line">4.4.1 静态域</span><br><span class="line"></span><br><span class="line">4.4.2 静态常量</span><br><span class="line"></span><br><span class="line">4.4.3 静态方法</span><br><span class="line"></span><br><span class="line">4.4.4 工厂方法</span><br><span class="line"></span><br><span class="line">4.4.5 main方法</span><br><span class="line"></span><br><span class="line">4.5 方法参数</span><br><span class="line"></span><br><span class="line">4.6 对象构造</span><br><span class="line"></span><br><span class="line">4.6.1 重载</span><br><span class="line"></span><br><span class="line">4.6.2 默认域初始化</span><br><span class="line"></span><br><span class="line">4.6.3 无参数的构造器</span><br><span class="line"></span><br><span class="line">4.6.4 显式域初始化</span><br><span class="line"></span><br><span class="line">4.6.5 参数名</span><br><span class="line"></span><br><span class="line">4.6.6 调用另一个构造器</span><br><span class="line"></span><br><span class="line">4.6.7 初始化块</span><br><span class="line"></span><br><span class="line">4.6.8 对象析构与finalize方法</span><br><span class="line"></span><br><span class="line">4.7 包</span><br><span class="line"></span><br><span class="line">4.7.1 类的导入</span><br><span class="line"></span><br><span class="line">4.7.2 静态导入</span><br><span class="line"></span><br><span class="line">4.7.3 将类放入包中</span><br><span class="line"></span><br><span class="line">4.7.4 包作用域</span><br><span class="line"></span><br><span class="line">4.8 类路径</span><br><span class="line"></span><br><span class="line">4.9 文档注释</span><br><span class="line"></span><br><span class="line">4.9.1 注释的插入</span><br><span class="line"></span><br><span class="line">4.9.2 类注释</span><br><span class="line"></span><br><span class="line">4.9.3 方法注释</span><br><span class="line"></span><br><span class="line">4.9.4 域注释</span><br><span class="line"></span><br><span class="line">4.9.5 通用注释</span><br><span class="line"></span><br><span class="line">4.9.6 包与概述注释</span><br><span class="line"></span><br><span class="line">4.9.7 注释的抽取</span><br><span class="line"></span><br><span class="line">4.10 类设计技巧</span><br><span class="line"></span><br><span class="line">第5章 继承</span><br><span class="line"></span><br><span class="line">5.1 类、超类和子类</span><br><span class="line"></span><br><span class="line">5.1.1 继承层次</span><br><span class="line"></span><br><span class="line">5.1.2 多态</span><br><span class="line"></span><br><span class="line">5.1.3 动态绑定</span><br><span class="line"></span><br><span class="line">5.1.4 阻止继承：final类和方法</span><br><span class="line"></span><br><span class="line">5.1.5 强制类型转换</span><br><span class="line"></span><br><span class="line">5.1.6 抽象类</span><br><span class="line"></span><br><span class="line">5.1.7 受保护访问</span><br><span class="line"></span><br><span class="line">5.2 Object：所有类的超类</span><br><span class="line"></span><br><span class="line">5.2.1 equals方法</span><br><span class="line"></span><br><span class="line">5.2.2 相等测试与继承</span><br><span class="line"></span><br><span class="line">5.2.3 hashCode方法</span><br><span class="line"></span><br><span class="line">5.2.4 toString方法</span><br><span class="line"></span><br><span class="line">5.3 泛型数组列表</span><br><span class="line"></span><br><span class="line">5.3.1 访问数组列表元素</span><br><span class="line"></span><br><span class="line">5.3.2 类型化与原始数组列表的兼容性</span><br><span class="line"></span><br><span class="line">5.4 对象包装器与自动装箱</span><br><span class="line"></span><br><span class="line">5.5 参数数量可变的方法</span><br><span class="line"></span><br><span class="line">5.6 枚举类</span><br><span class="line"></span><br><span class="line">5.7 反射</span><br><span class="line"></span><br><span class="line">5.7.1 Class类</span><br><span class="line"></span><br><span class="line">5.7.2 捕获异常</span><br><span class="line"></span><br><span class="line">5.7.3 利用反射分析类的能力</span><br><span class="line"></span><br><span class="line">5.7.4 在运行时使用反射分析对象</span><br><span class="line"></span><br><span class="line">5.7.5 使用反射编写泛型数组代码</span><br><span class="line"></span><br><span class="line">5.7.6 调用任意方法</span><br><span class="line"></span><br><span class="line">5.8 继承设计的技巧</span><br><span class="line"></span><br><span class="line">第6章 接口与内部类</span><br><span class="line"></span><br><span class="line">6.1 接口</span><br><span class="line"></span><br><span class="line">6.1.1 接口的特性</span><br><span class="line"></span><br><span class="line">6.1.2 接口与抽象类</span><br><span class="line"></span><br><span class="line">6.2 对象克隆</span><br><span class="line"></span><br><span class="line">6.3 接口与回调</span><br><span class="line"></span><br><span class="line">6.4 内部类</span><br><span class="line"></span><br><span class="line">6.4.1 使用内部类访问对象状态</span><br><span class="line"></span><br><span class="line">6.4.2 内部类的特殊语法规则</span><br><span class="line"></span><br><span class="line">6.4.3 内部类是否有用、必要和安全</span><br><span class="line"></span><br><span class="line">6.4.4 局部内部类</span><br><span class="line"></span><br><span class="line">6.4.5 由外部方法访问final变量</span><br><span class="line"></span><br><span class="line">6.4.6 匿名内部类</span><br><span class="line"></span><br><span class="line">6.4.7 静态内部类</span><br><span class="line"></span><br><span class="line">6.5 代理</span><br><span class="line"></span><br><span class="line">第7章 图形程序设计</span><br><span class="line"></span><br><span class="line">7.1 Swing概述</span><br><span class="line"></span><br><span class="line">7.2 创建框架</span><br><span class="line"></span><br><span class="line">7.3 框架定位</span><br><span class="line"></span><br><span class="line">7.3.1 框架属性</span><br><span class="line"></span><br><span class="line">7.3.2 确定合适的框架大小</span><br><span class="line"></span><br><span class="line">7.4 在组件中显示信息</span><br><span class="line"></span><br><span class="line">7.5 处理2D图形</span><br><span class="line"></span><br><span class="line">7.6 使用颜色</span><br><span class="line"></span><br><span class="line">7.7 文本使用特殊字体</span><br><span class="line"></span><br><span class="line">7.8 显示图像</span><br><span class="line"></span><br><span class="line">第8章 事件处理</span><br><span class="line"></span><br><span class="line">8.1 事件处理基础</span><br><span class="line"></span><br><span class="line">8.1.1 实例：处理按钮点击事件</span><br><span class="line"></span><br><span class="line">8.1.2 建议使用内部类</span><br><span class="line"></span><br><span class="line">8.1.3 创建包含一个方法调用的监听器</span><br><span class="line"></span><br><span class="line">8.1.4 实例：改变观感</span><br><span class="line"></span><br><span class="line">8.1.5 适配器类</span><br><span class="line"></span><br><span class="line">8.2 动作</span><br><span class="line"></span><br><span class="line">8.3 鼠标事件</span><br><span class="line"></span><br><span class="line">8.4 AWT事件继承层次</span><br><span class="line"></span><br><span class="line">第9章 Swing用户界面组件</span><br><span class="line"></span><br><span class="line">9.1 Swing和模型-视图-控制器设计模式</span><br><span class="line"></span><br><span class="line">9.1.1 设计模式</span><br><span class="line"></span><br><span class="line">9.1.2 模型-视图-控制器模式</span><br><span class="line"></span><br><span class="line">9.1.3 Swing按钮的模型-视图-控制器分析</span><br><span class="line"></span><br><span class="line">9.2 布局管理概述</span><br><span class="line"></span><br><span class="line">9.2.1 边框布局</span><br><span class="line"></span><br><span class="line">9.2.2 网格布局</span><br><span class="line"></span><br><span class="line">9.3 文本输入</span><br><span class="line"></span><br><span class="line">9.3.1 文本域</span><br><span class="line"></span><br><span class="line">9.3.2 标签和标签组件</span><br><span class="line"></span><br><span class="line">9.3.3 密码域</span><br><span class="line"></span><br><span class="line">9.3.4 文本区</span><br><span class="line"></span><br><span class="line">9.3.5 滚动窗格</span><br><span class="line"></span><br><span class="line">9.4 选择组件</span><br><span class="line"></span><br><span class="line">9.4.1 复选框</span><br><span class="line"></span><br><span class="line">9.4.2 单选按钮</span><br><span class="line"></span><br><span class="line">9.4.3 边框</span><br><span class="line"></span><br><span class="line">9.4.4 组合框</span><br><span class="line"></span><br><span class="line">9.4.5 滑动条</span><br><span class="line"></span><br><span class="line">9.5 菜单</span><br><span class="line"></span><br><span class="line">9.5.1 菜单创建</span><br><span class="line"></span><br><span class="line">9.5.2 菜单项中的图标</span><br><span class="line"></span><br><span class="line">9.5.3 复选框和单选按钮菜单项</span><br><span class="line"></span><br><span class="line">9.5.4 弹出菜单</span><br><span class="line"></span><br><span class="line">9.5.5 快捷键和加速器</span><br><span class="line"></span><br><span class="line">9.5.6 启用和禁用菜单项</span><br><span class="line"></span><br><span class="line">9.5.7 工具栏</span><br><span class="line"></span><br><span class="line">9.5.8 工具提示</span><br><span class="line"></span><br><span class="line">9.6 复杂的布局管理</span><br><span class="line"></span><br><span class="line">9.6.1 网格组布局</span><br><span class="line"></span><br><span class="line">9.6.2 组布局</span><br><span class="line"></span><br><span class="line">9.6.3 不使用布局管理器</span><br><span class="line"></span><br><span class="line">9.6.4 定制布局管理器</span><br><span class="line"></span><br><span class="line">9.6.5 遍历顺序</span><br><span class="line"></span><br><span class="line">9.7 对话框</span><br><span class="line"></span><br><span class="line">9.7.1 选项对话框</span><br><span class="line"></span><br><span class="line">9.7.2 创建对话框</span><br><span class="line"></span><br><span class="line">9.7.3 数据交换</span><br><span class="line"></span><br><span class="line">9.7.4 文件对话框</span><br><span class="line"></span><br><span class="line">9.7.5 颜色选择器</span><br><span class="line"></span><br><span class="line">第10章 部署应用程序和applet</span><br><span class="line"></span><br><span class="line">10.1 JAR文件</span><br><span class="line"></span><br><span class="line">10.1.1 清单文件</span><br><span class="line"></span><br><span class="line">10.1.2 可运行JAR文件</span><br><span class="line"></span><br><span class="line">10.1.3 资源</span><br><span class="line"></span><br><span class="line">10.1.4 密封</span><br><span class="line"></span><br><span class="line">10.2 Java Web Start</span><br><span class="line"></span><br><span class="line">10.2.1 沙箱</span><br><span class="line"></span><br><span class="line">10.2.2 签名代码</span><br><span class="line"></span><br><span class="line">10.2.3 JNLP API</span><br><span class="line"></span><br><span class="line">10.3 applet</span><br><span class="line"></span><br><span class="line">10.3.1 一个简单的applet</span><br><span class="line"></span><br><span class="line">10.3.2 applet的HTML标记和属性</span><br><span class="line"></span><br><span class="line">10.3.3 object标记</span><br><span class="line"></span><br><span class="line">10.3.4 使用参数向applet传递信息</span><br><span class="line"></span><br><span class="line">10.3.5 访问图像和音频文件</span><br><span class="line"></span><br><span class="line">10.3.6 applet上下文</span><br><span class="line"></span><br><span class="line">10.4.1 属性映射</span><br><span class="line"></span><br><span class="line">10.4.2 Preferences API</span><br><span class="line"></span><br><span class="line">第11章 异常、断言、日志和调试</span><br><span class="line"></span><br><span class="line">11.1 处理错误</span><br><span class="line"></span><br><span class="line">11.1.1 异常分类</span><br><span class="line"></span><br><span class="line">11.1.2 声明已检查异常</span><br><span class="line"></span><br><span class="line">11.1.3 如何抛出异常</span><br><span class="line"></span><br><span class="line">11.1.4 创建异常类</span><br><span class="line"></span><br><span class="line">11.2 捕获异常</span><br><span class="line"></span><br><span class="line">11.2.1 捕获多个异常</span><br><span class="line"></span><br><span class="line">11.2.2 再次抛出异常与异常链</span><br><span class="line"></span><br><span class="line">11.2.3 finally子句</span><br><span class="line"></span><br><span class="line">11.2.4 带资源的try语句</span><br><span class="line"></span><br><span class="line">11.2.5 分析堆栈跟踪元素</span><br><span class="line"></span><br><span class="line">11.3 使用异常机制的技巧</span><br><span class="line"></span><br><span class="line">11.4 使用断言</span><br><span class="line"></span><br><span class="line">11.4.1 启用和禁用断言</span><br><span class="line"></span><br><span class="line">11.4.2 使用断言完成参数检查</span><br><span class="line"></span><br><span class="line">11.4.3 为文档假设使用断言</span><br><span class="line"></span><br><span class="line">11.5 记录日志</span><br><span class="line"></span><br><span class="line">11.5.1 基本日志</span><br><span class="line"></span><br><span class="line">11.5.2 高级日志</span><br><span class="line"></span><br><span class="line">11.5.3 修改日志管理器配置</span><br><span class="line"></span><br><span class="line">11.5.4 本地化</span><br><span class="line"></span><br><span class="line">11.5.5 处理器</span><br><span class="line"></span><br><span class="line">11.5.6 过滤器</span><br><span class="line"></span><br><span class="line">11.5.7 格式化器</span><br><span class="line"></span><br><span class="line">11.5.8 日志记录说明</span><br><span class="line"></span><br><span class="line">11.6 调试技巧</span><br><span class="line"></span><br><span class="line">11.7 GUI程序排错技巧</span><br><span class="line"></span><br><span class="line">11.8 使用调试器</span><br><span class="line"></span><br><span class="line">第12章 泛型程序设计</span><br><span class="line"></span><br><span class="line">12.1 为什么要使用泛型程序设计</span><br><span class="line"></span><br><span class="line">12.2 定义简单泛型类</span><br><span class="line"></span><br><span class="line">12.3 泛型方法</span><br><span class="line"></span><br><span class="line">12.4 类型变量的限定</span><br><span class="line"></span><br><span class="line">12.5 泛型代码和虚拟机</span><br><span class="line"></span><br><span class="line">12.5.1 翻译泛型表达式</span><br><span class="line"></span><br><span class="line">12.5.2 翻译泛型方法</span><br><span class="line"></span><br><span class="line">12.5.3 调用遗留代码</span><br><span class="line"></span><br><span class="line">12.6 约束与局限性</span><br><span class="line"></span><br><span class="line">12.6.1 不能用基本类型实例化类型参数</span><br><span class="line"></span><br><span class="line">12.6.2 运行时类型查询只适用于原始类型</span><br><span class="line"></span><br><span class="line">12.6.3 不能创建参数化类型的数组</span><br><span class="line"></span><br><span class="line">12.6.4 Varargs警告</span><br><span class="line"></span><br><span class="line">12.6.5 不能实例化类型变量</span><br><span class="line"></span><br><span class="line">12.6.6 泛型类的静态上下文中类型变量无效</span><br><span class="line"></span><br><span class="line">12.6.7 不能抛出或捕获泛型类的实例</span><br><span class="line"></span><br><span class="line">12.6.8 注意擦除后的冲突</span><br><span class="line"></span><br><span class="line">12.7 泛型类型的继承规则</span><br><span class="line"></span><br><span class="line">12.8 通配符类型</span><br><span class="line"></span><br><span class="line">12.8.1 通配符的超类型限定</span><br><span class="line"></span><br><span class="line">12.8.2 无限定通配符</span><br><span class="line"></span><br><span class="line">12.8.3 通配符捕获</span><br><span class="line"></span><br><span class="line">12.9 反射和泛型</span><br><span class="line"></span><br><span class="line">12.9.1 使用Class参数进行类型匹配</span><br><span class="line"></span><br><span class="line">12.9.2 虚拟机中的泛型类型信息</span><br><span class="line"></span><br><span class="line">第13章 集合</span><br><span class="line"></span><br><span class="line">13.1 集合接口</span><br><span class="line"></span><br><span class="line">13.1.1 将集合的接口与实现分离</span><br><span class="line"></span><br><span class="line">13.1.2 Java类库中的集合接口和迭代器接口</span><br><span class="line"></span><br><span class="line">13.2 具体的集合</span><br><span class="line"></span><br><span class="line">13.2.1 链表</span><br><span class="line"></span><br><span class="line">13.2.2 数组列表</span><br><span class="line"></span><br><span class="line">13.2.3 散列集</span><br><span class="line"></span><br><span class="line">13.2.4 树集</span><br><span class="line"></span><br><span class="line">13.2.5 对象的比较</span><br><span class="line"></span><br><span class="line">13.2.6 队列与双端队列</span><br><span class="line"></span><br><span class="line">13.2.7 优先级队列</span><br><span class="line"></span><br><span class="line">13.2.8 映射表</span><br><span class="line"></span><br><span class="line">13.2.9 专用集与映射表类</span><br><span class="line"></span><br><span class="line">13.3 集合框架</span><br><span class="line"></span><br><span class="line">13.3.1 视图与包装器</span><br><span class="line"></span><br><span class="line">13.3.2 批操作</span><br><span class="line"></span><br><span class="line">13.3.3 集合与数组之间的转换</span><br><span class="line"></span><br><span class="line">13.4 算法</span><br><span class="line"></span><br><span class="line">13.4.1 排序与混排</span><br><span class="line"></span><br><span class="line">13.4.2 二分查找</span><br><span class="line"></span><br><span class="line">13.4.3 简单算法</span><br><span class="line"></span><br><span class="line">13.4.4 编写自己的算法</span><br><span class="line"></span><br><span class="line">13.5 遗留的集合</span><br><span class="line"></span><br><span class="line">13.5.1 Hashtable类</span><br><span class="line"></span><br><span class="line">13.5.2 枚举</span><br><span class="line"></span><br><span class="line">13.5.3 属性映射表</span><br><span class="line"></span><br><span class="line">13.5.4 栈</span><br><span class="line"></span><br><span class="line">13.5.5 位集</span><br><span class="line"></span><br><span class="line">第14章 多线程</span><br><span class="line"></span><br><span class="line">14.1 什么是线程</span><br><span class="line"></span><br><span class="line">14.2 中断线程</span><br><span class="line"></span><br><span class="line">14.3 线程状态</span><br><span class="line"></span><br><span class="line">14.3.1 新创建线程</span><br><span class="line"></span><br><span class="line">14.3.2 可运行线程</span><br><span class="line"></span><br><span class="line">14.3.3 被阻塞线程和等待线程</span><br><span class="line"></span><br><span class="line">14.3.4 被终止的线程</span><br><span class="line"></span><br><span class="line">14.4 线程属性</span><br><span class="line"></span><br><span class="line">14.4.1 线程优先级</span><br><span class="line"></span><br><span class="line">14.4.2 守护线程</span><br><span class="line"></span><br><span class="line">14.4.3 未捕获异常处理器</span><br><span class="line"></span><br><span class="line">14.5 同步</span><br><span class="line"></span><br><span class="line">14.5.1 竞争条件的一个例子</span><br><span class="line"></span><br><span class="line">14.5.2 竞争条件详解</span><br><span class="line"></span><br><span class="line">14.5.3 锁对象</span><br><span class="line"></span><br><span class="line">14.5.4 条件对象</span><br><span class="line"></span><br><span class="line">14.5.5 synchronized关键字</span><br><span class="line"></span><br><span class="line">14.5.6 同步阻塞</span><br><span class="line"></span><br><span class="line">14.5.7 监视器概念</span><br><span class="line"></span><br><span class="line">14.5.8 Volatile域</span><br><span class="line"></span><br><span class="line">14.5.9 final变量</span><br><span class="line"></span><br><span class="line">14.5.10 原子性</span><br><span class="line"></span><br><span class="line">14.5.11 死锁</span><br><span class="line"></span><br><span class="line">14.5.12 线程局部变量</span><br><span class="line"></span><br><span class="line">14.5.13 锁测试与超时</span><br><span class="line"></span><br><span class="line">14.5.14 读&#x2F;写锁</span><br><span class="line"></span><br><span class="line">14.5.15 为什么弃用stop和suspend方法</span><br><span class="line"></span><br><span class="line">14.6 阻塞队列</span><br><span class="line"></span><br><span class="line">14.7 线程安全的集合</span><br><span class="line"></span><br><span class="line">14.7.1 高效的映射表、集合和队列</span><br><span class="line"></span><br><span class="line">14.7.2 写数组的拷贝</span><br><span class="line"></span><br><span class="line">14.7.3 较早的线程安全集合</span><br><span class="line"></span><br><span class="line">14.8 Callable与Future</span><br><span class="line"></span><br><span class="line">14.9 执行器</span><br><span class="line"></span><br><span class="line">14.9.1 线程池</span><br><span class="line"></span><br><span class="line">14.9.2 预定执行</span><br><span class="line"></span><br><span class="line">14.9.3 控制任务组</span><br><span class="line"></span><br><span class="line">14.9.4 Fork-Join框架</span><br><span class="line"></span><br><span class="line">14.10 同步器</span><br><span class="line"></span><br><span class="line">14.10.1 信号量</span><br><span class="line"></span><br><span class="line">14.10.2 倒计时门栓</span><br><span class="line"></span><br><span class="line">14.10.3 障栅</span><br><span class="line"></span><br><span class="line">14.10.4 交换器</span><br><span class="line"></span><br><span class="line">14.10.5 同步队列</span><br><span class="line"></span><br><span class="line">14.11 线程与Swing</span><br><span class="line"></span><br><span class="line">14.11.1 运行耗时的任务</span><br><span class="line"></span><br><span class="line">14.11.2 使用Swing工作线程</span><br><span class="line"></span><br><span class="line">14.11.3 单一线程规则</span><br><span class="line"></span><br><span class="line">附录 Java关键字</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>深入剖析Tomcat PDF</title>
    <url>/posts/565bb3ed/</url>
    <content><![CDATA[<h4 id="《深入剖析Tomcat》"><a href="#《深入剖析Tomcat》" class="headerlink" title="《深入剖析Tomcat》"></a>《深入剖析Tomcat》</h4><h6 id="链接-https-pan-baidu-com-s-1wzEEDDatdPzhE6Go-I1zqg-提取码-p42w"><a href="#链接-https-pan-baidu-com-s-1wzEEDDatdPzhE6Go-I1zqg-提取码-p42w" class="headerlink" title="链接: https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg 提取码: p42w"></a>链接: <a href="https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg">https://pan.baidu.com/s/1wzEEDDatdPzhE6Go-I1zqg</a> 提取码: p42w</h6><p>《深入剖析Tomcat》深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习《深入剖析Tomcat》，你将可以自行开发Tomcat组件，或者扩展已有的组件。 Tomcat是目前比较流行的Web服务器之一。作为一个开源和小型的轻量级应用服务器，Tomcat 易于使用，便于部署，但Tomcat本身是一个非常复杂的系统，包含了很多功能模块。这些功能模块构成了Tomcat的核心结构。《深入剖析Tomcat》从基本的HTTP请求开始，直至使用JMX技术管理Tomcat中的应用程序，逐一剖析Tomcat的基本功能模块，并配以示例代码，使读者可以逐步实现自己的Web服务器。<br><a id="more"></a></p>
<p><img src="/images/31075b65d99b5b4ae18523a205b4f6601.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">《深入剖析Tomcat》</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前 言</span><br><span class="line"></span><br><span class="line">第1章 一个简单的Web服务器1</span><br><span class="line"></span><br><span class="line">1.1 HTTP1</span><br><span class="line"></span><br><span class="line">1.1.1 HTTP请求1</span><br><span class="line"></span><br><span class="line">1.1.2 HTTP响应2</span><br><span class="line"></span><br><span class="line">1.2 Socket类3</span><br><span class="line"></span><br><span class="line">1.3 应用程序5</span><br><span class="line"></span><br><span class="line">1.3.1 HttpServer类5</span><br><span class="line"></span><br><span class="line">1.3.2 Request类8</span><br><span class="line"></span><br><span class="line">1.3.3 Response类10</span><br><span class="line"></span><br><span class="line">1.3.4 运行应用程序12</span><br><span class="line"></span><br><span class="line">1.4 小结13</span><br><span class="line"></span><br><span class="line">第2章 一个简单的servlet容器14</span><br><span class="line"></span><br><span class="line">2.1 javax.servlet.Servlet接口14</span><br><span class="line"></span><br><span class="line">2.2 应用程序 116</span><br><span class="line"></span><br><span class="line">2.2.1 HttpServer1类17</span><br><span class="line"></span><br><span class="line">2.2.2 Request类19</span><br><span class="line"></span><br><span class="line">2.2.3 Response类21</span><br><span class="line"></span><br><span class="line">2.2.4 StaticResourceProcessor类23</span><br><span class="line"></span><br><span class="line">2.2.5 servletProcessor1类24</span><br><span class="line"></span><br><span class="line">2.2.6 运行应用程序27</span><br><span class="line"></span><br><span class="line">2.3 应用程序227</span><br><span class="line"></span><br><span class="line">2.4 小结30</span><br><span class="line"></span><br><span class="line">第3章 连接器31</span><br><span class="line"></span><br><span class="line">3.1 StringManager类31</span><br><span class="line"></span><br><span class="line">3.2 应用程序33</span><br><span class="line"></span><br><span class="line">3.2.1 启动应用程序35</span><br><span class="line"></span><br><span class="line">3.2.2 HttpConnector类36</span><br><span class="line"></span><br><span class="line">3.2.3 创建HttpRequest对象38</span><br><span class="line"></span><br><span class="line">3.2.4 创建HttpResponse对象49</span><br><span class="line"></span><br><span class="line">3.2.5 静态资源处理器和servlet处理器50</span><br><span class="line"></span><br><span class="line">3.2.6 运行应用程序50</span><br><span class="line"></span><br><span class="line">3.3 小结52</span><br><span class="line"></span><br><span class="line">第4章 Tomcat的默认连接器53</span><br><span class="line"></span><br><span class="line">4.1 HTTP 1.1的新特性54</span><br><span class="line"></span><br><span class="line">4.1.1 持久连接54</span><br><span class="line"></span><br><span class="line">4.1.2 块编码54</span><br><span class="line"></span><br><span class="line">4.1.3 状态码100的使用55</span><br><span class="line"></span><br><span class="line">4.2 Connector接口55</span><br><span class="line"></span><br><span class="line">4.3 HttpConnector类56</span><br><span class="line"></span><br><span class="line">4.3.1 创建服务器套接字56</span><br><span class="line"></span><br><span class="line">4.3.2 维护HttpProcessor实例56</span><br><span class="line"></span><br><span class="line">4.3.3 提供HTTP请求服务57</span><br><span class="line"></span><br><span class="line">4.4 HttpProcessor类58</span><br><span class="line"></span><br><span class="line">4.5 Request对象61</span><br><span class="line"></span><br><span class="line">4.6 Response对象62</span><br><span class="line"></span><br><span class="line">4.7 处理请求62</span><br><span class="line"></span><br><span class="line">4.7.1 解析连接65</span><br><span class="line"></span><br><span class="line">4.7.2 解析请求65</span><br><span class="line"></span><br><span class="line">4.7.3 解析请求头65</span><br><span class="line"></span><br><span class="line">4.8 简单的Container应用程序66</span><br><span class="line"></span><br><span class="line">4.9 小结70</span><br><span class="line"></span><br><span class="line">第5章 servlet容器71</span><br><span class="line"></span><br><span class="line">5.1 Container接口71</span><br><span class="line"></span><br><span class="line">5.2 管道任务73</span><br><span class="line"></span><br><span class="line">5.2.1 Pipeline接口76</span><br><span class="line"></span><br><span class="line">5.2.2 Valve接口76</span><br><span class="line"></span><br><span class="line">5.2.3 ValveContext接口76</span><br><span class="line"></span><br><span class="line">5.2.4 Contained接口77</span><br><span class="line"></span><br><span class="line">5.3 Wrapper接口77</span><br><span class="line"></span><br><span class="line">5.4 Context接口78</span><br><span class="line"></span><br><span class="line">5.5 Wrapper应用程序78</span><br><span class="line"></span><br><span class="line">5.5.1 ex05.pyrmont.core.SimpleLoader类78</span><br><span class="line"></span><br><span class="line">5.5.2 ex05.pyrmont.core.SimplePipeline类79</span><br><span class="line"></span><br><span class="line">5.5.3 ex05.pyrmont.core.SimpleWrapper类79</span><br><span class="line"></span><br><span class="line">5.5.4 ex05.pyrmont.core.SimpleWrapperValve类80</span><br><span class="line"></span><br><span class="line">5.5.5 ex05.pyrmont.valves.ClientIPLoggerValve类81</span><br><span class="line"></span><br><span class="line">5.5.6 ex05.pyrmont.valves.HeaderLoggerValve类81</span><br><span class="line"></span><br><span class="line">5.5.7 ex05.pyrmont.startup.Bootstrap182</span><br><span class="line"></span><br><span class="line">5.5.8 运行应用程序84</span><br><span class="line"></span><br><span class="line">5.6 Context应用程序84</span><br><span class="line"></span><br><span class="line">5.6.1 ex05.pyrmont.core.SimpleContextValve类87</span><br><span class="line"></span><br><span class="line">5.6.2 ex05.pyrmont.core.SimpleContextMapper类87</span><br><span class="line"></span><br><span class="line">5.6.3 ex05.pyrmont.core.SimpleContext类89</span><br><span class="line"></span><br><span class="line">5.6.4 ex05.pyrmont.startup.Bootstrap289</span><br><span class="line"></span><br><span class="line">5.6.5 运行应用程序91</span><br><span class="line"></span><br><span class="line">5.7 小结92</span><br><span class="line"></span><br><span class="line">第6章 生命周期93</span><br><span class="line"></span><br><span class="line">6.1 Lifecycle接口93</span><br><span class="line"></span><br><span class="line">6.2 LifecycleEvent类94</span><br><span class="line"></span><br><span class="line">6.3 LifecycleListener接口94</span><br><span class="line"></span><br><span class="line">6.4 LifecycleSupport类95</span><br><span class="line"></span><br><span class="line">6.5 应用程序97</span><br><span class="line"></span><br><span class="line">6.5.1 ex06.pyrmont.core.SimpleContext类97</span><br><span class="line"></span><br><span class="line">6.5.2 ex06.pyrmont.core.SimpleContextLifecycleListener类100</span><br><span class="line"></span><br><span class="line">6.5.3 ex06.pyrmont.core.SimpleLoader类101</span><br><span class="line"></span><br><span class="line">6.5.4 ex06.pyrmont.core.SimplePipeline类101</span><br><span class="line"></span><br><span class="line">6.5.5 ex06.pyrmont.core.SimpleWrapper类101</span><br><span class="line"></span><br><span class="line">6.5.6 运行应用程序103</span><br><span class="line"></span><br><span class="line">6.6 小结104</span><br><span class="line"></span><br><span class="line">第7章 日志记录器105</span><br><span class="line"></span><br><span class="line">7.1 Logger接口105</span><br><span class="line"></span><br><span class="line">7.2 Tomcat的日志记录器106</span><br><span class="line"></span><br><span class="line">7.2.1 LoggerBase类106</span><br><span class="line"></span><br><span class="line">7.2.2 SystemOutLogger类107</span><br><span class="line"></span><br><span class="line">7.2.3 SystemErrLogger类107</span><br><span class="line"></span><br><span class="line">7.2.4 FileLogger类108</span><br><span class="line"></span><br><span class="line">7.3 应用程序111</span><br><span class="line"></span><br><span class="line">7.4 小结112</span><br><span class="line"></span><br><span class="line">第8章 载入器113</span><br><span class="line"></span><br><span class="line">8.1 Java的类载入器113</span><br><span class="line"></span><br><span class="line">8.2 Loader接口114</span><br><span class="line"></span><br><span class="line">8.3 Reloader接口116</span><br><span class="line"></span><br><span class="line">8.4 WebappLoader类116</span><br><span class="line"></span><br><span class="line">8.4.1 创建类载入器117</span><br><span class="line"></span><br><span class="line">8.4.2 设置仓库118</span><br><span class="line"></span><br><span class="line">8.4.3 设置类路径118</span><br><span class="line"></span><br><span class="line">8.4.4 设置访问权限118</span><br><span class="line"></span><br><span class="line">8.4.5 开启新线程执行类的重新载入118</span><br><span class="line"></span><br><span class="line">8.5 WebappClassLoader类120</span><br><span class="line"></span><br><span class="line">8.5.1 类缓存120</span><br><span class="line"></span><br><span class="line">8.5.2 载入类121</span><br><span class="line"></span><br><span class="line">8.5.3 应用程序121</span><br><span class="line"></span><br><span class="line">8.6 运行应用程序124</span><br><span class="line"></span><br><span class="line">8.7 小结124</span><br><span class="line"></span><br><span class="line">第9章 Session管理125</span><br><span class="line"></span><br><span class="line">9.1 Session对象126</span><br><span class="line"></span><br><span class="line">9.1.1 Session接口126</span><br><span class="line"></span><br><span class="line">9.1.2 StandardSession类127</span><br><span class="line"></span><br><span class="line">9.1.3 StandardSessionFacade类129</span><br><span class="line"></span><br><span class="line">9.2 Manager130</span><br><span class="line"></span><br><span class="line">9.2.1 Manager接口130</span><br><span class="line"></span><br><span class="line">9.2.2 ManagerBase类131</span><br><span class="line"></span><br><span class="line">9.2.3 StandardManager类132</span><br><span class="line"></span><br><span class="line">9.2.4 PersistentManagerBase类133</span><br><span class="line"></span><br><span class="line">9.2.5 PersistentManager类135</span><br><span class="line"></span><br><span class="line">9.2.6 DistributedManager类135</span><br><span class="line"></span><br><span class="line">9.3 存储器136</span><br><span class="line"></span><br><span class="line">9.3.1 StoreBase类137</span><br><span class="line"></span><br><span class="line">9.3.2 FileStore类138</span><br><span class="line"></span><br><span class="line">9.3.3 JDBCStore类139</span><br><span class="line"></span><br><span class="line">9.4 应用程序139</span><br><span class="line"></span><br><span class="line">9.4.1 Bootstrap类139</span><br><span class="line"></span><br><span class="line">9.4.2 SimpleWrapperValve类140</span><br><span class="line"></span><br><span class="line">9.4.3 运行应用程序141</span><br><span class="line"></span><br><span class="line">9.5 小结142</span><br><span class="line"></span><br><span class="line">第10章 安全性143</span><br><span class="line"></span><br><span class="line">10.1 领域143</span><br><span class="line"></span><br><span class="line">10.2 GenericPrincipal类144</span><br><span class="line"></span><br><span class="line">10.3 LoginConfig类145</span><br><span class="line"></span><br><span class="line">10.4 Authenticator接口145</span><br><span class="line"></span><br><span class="line">10.5 安装验证器阀146</span><br><span class="line"></span><br><span class="line">10.6 应用程序147</span><br><span class="line"></span><br><span class="line">10.6.1 ex10.pyrmont.core.SimpleContextConfig类147</span><br><span class="line"></span><br><span class="line">10.6.2 ex10.pyrmont.realm.SimpleRealm类149</span><br><span class="line"></span><br><span class="line">10.6.3 ex10.pyrmont.realm.SimpleUserDatabaseRealm152</span><br><span class="line"></span><br><span class="line">10.6.4 ex10.pyrmont.startup.Bootstrap1类154</span><br><span class="line"></span><br><span class="line">10.6.5 ex10.pyrmont.startup.Bootstrap2类156</span><br><span class="line"></span><br><span class="line">10.6.6 运行应用程序158</span><br><span class="line"></span><br><span class="line">10.7 小结158</span><br><span class="line"></span><br><span class="line">第11章 StandardWrapper159</span><br><span class="line"></span><br><span class="line">11.1 方法调用序列159</span><br><span class="line"></span><br><span class="line">11.2 SingleThreadModel160</span><br><span class="line"></span><br><span class="line">11.3 StandardWrapper161</span><br><span class="line"></span><br><span class="line">11.3.1 分配servlet实例162</span><br><span class="line"></span><br><span class="line">11.3.2 载入servlet类164</span><br><span class="line"></span><br><span class="line">11.3.3 ServletConfig对象167</span><br><span class="line"></span><br><span class="line">11.3.4 servlet容器的父子关系169</span><br><span class="line"></span><br><span class="line">11.4 StandardWrapperFacade类170</span><br><span class="line"></span><br><span class="line">11.5 StandardWrapperValve类171</span><br><span class="line"></span><br><span class="line">11.6 FilterDef类172</span><br><span class="line"></span><br><span class="line">11.7 ApplicationFilterConfig类174</span><br><span class="line"></span><br><span class="line">11.8 ApplicationFilterChain类175</span><br><span class="line"></span><br><span class="line">11.9 应用程序175</span><br><span class="line"></span><br><span class="line">11.10 小结177</span><br><span class="line"></span><br><span class="line">第12章 StandardContext类178</span><br><span class="line"></span><br><span class="line">12.1 StandardContext的配置178</span><br><span class="line"></span><br><span class="line">12.1.1 StandardContext类的构造函数179</span><br><span class="line"></span><br><span class="line">12.1.2 启动StandardContext实例179</span><br><span class="line"></span><br><span class="line">12.1.3 invoke()方法183</span><br><span class="line"></span><br><span class="line">12.2 StandardContextMapper类184</span><br><span class="line"></span><br><span class="line">12.3 对重载的支持187</span><br><span class="line"></span><br><span class="line">12.4 backgroundProcess()方法188</span><br><span class="line"></span><br><span class="line">12.5 小结190</span><br><span class="line"></span><br><span class="line">第13章 Host和Engine191</span><br><span class="line"></span><br><span class="line">13.1 Host接口191</span><br><span class="line"></span><br><span class="line">13.2 StandardHost类193</span><br><span class="line"></span><br><span class="line">13.3 StandardHostMapper类195</span><br><span class="line"></span><br><span class="line">13.4 StandardHostValve类196</span><br><span class="line"></span><br><span class="line">13.5 为什么必须要有一个Host容器197</span><br><span class="line"></span><br><span class="line">13.6 应用程序1198</span><br><span class="line"></span><br><span class="line">13.7 Engine接口199</span><br><span class="line"></span><br><span class="line">13.8 StandardEngine类201</span><br><span class="line"></span><br><span class="line">13.9 StandardEngineValve类201</span><br><span class="line"></span><br><span class="line">13.10 应用程序2202</span><br><span class="line"></span><br><span class="line">13.11 小结203</span><br><span class="line"></span><br><span class="line">第14章 服务器组件和服务组件204</span><br><span class="line"></span><br><span class="line">14.1 服务器组件204</span><br><span class="line"></span><br><span class="line">14.2 StandardServer类206</span><br><span class="line"></span><br><span class="line">14.2.1 initialize()方法206</span><br><span class="line"></span><br><span class="line">14.2.2 start()方法207</span><br><span class="line"></span><br><span class="line">14.2.3 stop()方法207</span><br><span class="line"></span><br><span class="line">14.2.4 await()方法208</span><br><span class="line"></span><br><span class="line">14.3 Service接口209</span><br><span class="line"></span><br><span class="line">14.4 StandardService类211</span><br><span class="line"></span><br><span class="line">14.4.1 connector和container211</span><br><span class="line"></span><br><span class="line">14.4.2 与生命周期有关的方法213</span><br><span class="line"></span><br><span class="line">14.5 应用程序215</span><br><span class="line"></span><br><span class="line">14.5.1 Bootstrap类215</span><br><span class="line"></span><br><span class="line">14.5.2 Stopper类217</span><br><span class="line"></span><br><span class="line">14.5.3 运行应用程序218</span><br><span class="line"></span><br><span class="line">14.6 小结219</span><br><span class="line"></span><br><span class="line">第15章 Digester库220</span><br><span class="line"></span><br><span class="line">15.1 Digester库221</span><br><span class="line"></span><br><span class="line">15.1.1 Digester类221</span><br><span class="line"></span><br><span class="line">15.1.2 Digester库示例1225</span><br><span class="line"></span><br><span class="line">15.1.3 Digester库示例2227</span><br><span class="line"></span><br><span class="line">15.1.4 Rule类230</span><br><span class="line"></span><br><span class="line">15.1.5 Digester库示例3：使用RuleSet232</span><br><span class="line"></span><br><span class="line">15.2 ContextConfig类234</span><br><span class="line"></span><br><span class="line">15.2.1 defaultConfig(...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术卷1第8版 PDF</title>
    <url>/posts/dcdeafe8/</url>
    <content><![CDATA[<h4 id="《Java核心技术卷1第8版》"><a href="#《Java核心技术卷1第8版》" class="headerlink" title="《Java核心技术卷1第8版》"></a>《Java核心技术卷1第8版》</h4><h6 id="链接-https-pan-baidu-com-s-1bvbULlJcLOgrjOfbaajuyA-提取码-9i6e"><a href="#链接-https-pan-baidu-com-s-1bvbULlJcLOgrjOfbaajuyA-提取码-9i6e" class="headerlink" title="链接: https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA 提取码: 9i6e"></a>链接: <a href="https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA">https://pan.baidu.com/s/1bvbULlJcLOgrjOfbaajuyA</a> 提取码: 9i6e</h6><p>Java领域*有影响力和价值的著作之一，由拥有20多年教学与研究经验的资深Java技术专家撰写(获Jolt大奖)，与《Java编程思想》齐名，10余年全球畅销不衰，广受好评。第10版根据Java SE 8全面更新，同时修正了第9版中的不足，系统全面讲解了Java语言的核心概念、语法、重要特性和开发方法，包含大量案例，实践性强。<br><a id="more"></a></p>
<p>本书共14章。第1章概述Java语言与其他程序设计语言不同的性能；第2章讲解如何下载和安装JDK及本书的程序示例；第3章介绍变量、循环和简单的函数；第4章讲解类和封装；第5章介绍继承；第6章解释接口和内部类；第7章讨论异常处理，并给出大量实用的调试技巧；第8章概要介绍泛型程序设计；第9章讨论Java平台的集合框架；第10章介绍GUI程序设计，讨论如何建立窗口、如何在窗口中绘图、如何利用几何图形绘图、如何采用多种字体格式化文本，以及如何显示图像；第11章详细讨论抽象窗口工具包的事件模型；第12章详细讨论Swing GUI工具包；第13章介绍如何将程序部署为应用或applet；第14章讨论并发。本书*后还有一个附录，其中列出了Java语言的保留字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">致谢</span><br><span class="line"></span><br><span class="line">第1章 Java程序设计概述 1</span><br><span class="line"></span><br><span class="line">1.1 Java程序设计平台 1</span><br><span class="line"></span><br><span class="line">1.2 Java“白皮书”的关键术语 2</span><br><span class="line"></span><br><span class="line">1.2.1 简单性 2</span><br><span class="line"></span><br><span class="line">1.2.2 面向对象 2</span><br><span class="line"></span><br><span class="line">1.2.3 分布式 3</span><br><span class="line"></span><br><span class="line">1.2.4 健壮性 3</span><br><span class="line"></span><br><span class="line">1.2.5 安全性 3</span><br><span class="line"></span><br><span class="line">1.2.6 体系结构中立 4</span><br><span class="line"></span><br><span class="line">1.2.7 可移植性 4</span><br><span class="line"></span><br><span class="line">1.2.8 解释型 5</span><br><span class="line"></span><br><span class="line">1.2.9 高性能 5</span><br><span class="line"></span><br><span class="line">1.2.10 多线程 5</span><br><span class="line"></span><br><span class="line">1.2.11 动态性 5</span><br><span class="line"></span><br><span class="line">1.3 Java applet与Internet 6</span><br><span class="line"></span><br><span class="line">1.4 Java发展简史 7</span><br><span class="line"></span><br><span class="line">1.5 关于Java的常见误解 9</span><br><span class="line"></span><br><span class="line">第2章 Java程序设计环境 12</span><br><span class="line"></span><br><span class="line">2.1 安装Java开发工具包 12</span><br><span class="line"></span><br><span class="line">2.1.1 下载JDK 12</span><br><span class="line"></span><br><span class="line">2.1.2 设置JDK 13</span><br><span class="line"></span><br><span class="line">2.1.3 安装库源文件和文档 15</span><br><span class="line"></span><br><span class="line">2.2 使用命令行工具 16</span><br><span class="line"></span><br><span class="line">2.3 使用集成开发环境 18</span><br><span class="line"></span><br><span class="line">2.4 运行图形化应用程序 21</span><br><span class="line"></span><br><span class="line">2.5 构建并运行applet 23</span><br><span class="line"></span><br><span class="line">第3章 Java的基本程序设计结构 28</span><br><span class="line"></span><br><span class="line">3.1 一个简单的Java应用程序 28</span><br><span class="line"></span><br><span class="line">3.2 注释 31</span><br><span class="line"></span><br><span class="line">3.3 数据类型 32</span><br><span class="line"></span><br><span class="line">3.3.1 整型 32</span><br><span class="line"></span><br><span class="line">3.3.2 浮点类型 33</span><br><span class="line"></span><br><span class="line">3.3.3 char类型 34</span><br><span class="line"></span><br><span class="line">3.3.4 Unicode和char类型 35</span><br><span class="line"></span><br><span class="line">3.3.5 boolean类型 35</span><br><span class="line"></span><br><span class="line">3.4 变量 36</span><br><span class="line"></span><br><span class="line">3.4.1 变量初始化 37</span><br><span class="line"></span><br><span class="line">3.4.2 常量 37</span><br><span class="line"></span><br><span class="line">3.5 运算符 38</span><br><span class="line"></span><br><span class="line">3.5.1 数学函数与常量 39</span><br><span class="line"></span><br><span class="line">3.5.2 数值类型之间的转换 40</span><br><span class="line"></span><br><span class="line">3.5.3 强制类型转换 41</span><br><span class="line"></span><br><span class="line">3.5.4 结合赋值和运算符 42</span><br><span class="line"></span><br><span class="line">3.5.5 自增与自减运算符 42</span><br><span class="line"></span><br><span class="line">3.5.6 关系和boolean运算符 42</span><br><span class="line"></span><br><span class="line">3.5.7 位运算符 43</span><br><span class="line"></span><br><span class="line">3.5.8 括号与运算符级别 44</span><br><span class="line"></span><br><span class="line">3.5.9 枚举类型 45</span><br><span class="line"></span><br><span class="line">3.6 字符串 45</span><br><span class="line"></span><br><span class="line">3.6.1 子串 45</span><br><span class="line"></span><br><span class="line">3.6.2 拼接 46</span><br><span class="line"></span><br><span class="line">3.6.3 不可变字符串 46</span><br><span class="line"></span><br><span class="line">3.6.4 检测字符串是否相等 47</span><br><span class="line"></span><br><span class="line">3.6.5 空串与Null串 48</span><br><span class="line"></span><br><span class="line">3.6.6 码点与代码单元 49</span><br><span class="line"></span><br><span class="line">3.6.7 String API 50</span><br><span class="line"></span><br><span class="line">3.6.8 阅读联机API文档 52</span><br><span class="line"></span><br><span class="line">3.6.9 构建字符串 54</span><br><span class="line"></span><br><span class="line">3.7 输入输出 55</span><br><span class="line"></span><br><span class="line">3.7.1 读取输入 55</span><br><span class="line"></span><br><span class="line">3.7.2 格式化输出 58</span><br><span class="line"></span><br><span class="line">3.7.3 文件输入与输出 61</span><br><span class="line"></span><br><span class="line">3.8 控制流程 63</span><br><span class="line"></span><br><span class="line">3.8.1 块作用域 63</span><br><span class="line"></span><br><span class="line">3.8.2 条件语句 63</span><br><span class="line"></span><br><span class="line">3.8.3 循环 66</span><br><span class="line"></span><br><span class="line">3.8.4 确定循环 69</span><br><span class="line"></span><br><span class="line">3.8.5 多重选择：switch语句 72</span><br><span class="line"></span><br><span class="line">3.8.6 中断控制流程语句 74</span><br><span class="line"></span><br><span class="line">3.9 大数值 76</span><br><span class="line"></span><br><span class="line">3.10 数组 78</span><br><span class="line"></span><br><span class="line">3.10.1 for each循环 79</span><br><span class="line"></span><br><span class="line">3.10.2 数组初始化以及匿名数组 80</span><br><span class="line"></span><br><span class="line">3.10.3 数组拷贝 81</span><br><span class="line"></span><br><span class="line">3.10.4 命令行参数 81</span><br><span class="line"></span><br><span class="line">3.10.5 数组排序 82</span><br><span class="line"></span><br><span class="line">3.10.6 多维数组 85</span><br><span class="line"></span><br><span class="line">3.10.7 不规则数组 88</span><br><span class="line"></span><br><span class="line">第4章 对象与类 91</span><br><span class="line"></span><br><span class="line">4.1 面向对象程序设计概述 91</span><br><span class="line"></span><br><span class="line">4.1.1 类 92</span><br><span class="line"></span><br><span class="line">4.1.2 对象 93</span><br><span class="line"></span><br><span class="line">4.1.3 识别类 93</span><br><span class="line"></span><br><span class="line">4.1.4 类之间的关系 94</span><br><span class="line"></span><br><span class="line">4.2 使用预定义类 95</span><br><span class="line"></span><br><span class="line">4.2.1 对象与对象变量 95</span><br><span class="line"></span><br><span class="line">4.2.2 Java类库中的LocalDate类 98</span><br><span class="line"></span><br><span class="line">4.2.3 更改器方法与访问器方法 100</span><br><span class="line"></span><br><span class="line">4.3 用户自定义类 103</span><br><span class="line"></span><br><span class="line">4.3.1 Employee类 103</span><br><span class="line"></span><br><span class="line">4.3.2 多个源文件的使用 105</span><br><span class="line"></span><br><span class="line">4.3.3 剖析Employee类 106</span><br><span class="line"></span><br><span class="line">4.3.4 从构造器开始 106</span><br><span class="line"></span><br><span class="line">4.3.5 隐式参数与显式参数 108</span><br><span class="line"></span><br><span class="line">4.3.6 封装的优点 109</span><br><span class="line"></span><br><span class="line">4.3.7 基于类的访问权限 111</span><br><span class="line"></span><br><span class="line">4.3.8 私有方法 111</span><br><span class="line"></span><br><span class="line">4.3.9 final实例域 112</span><br><span class="line"></span><br><span class="line">4.4 静态域与静态方法 112</span><br><span class="line"></span><br><span class="line">4.4.1 静态域 112</span><br><span class="line"></span><br><span class="line">4.4.2 静态常量 113</span><br><span class="line"></span><br><span class="line">4.4.3 静态方法 114</span><br><span class="line"></span><br><span class="line">4.4.4 工厂方法 115</span><br><span class="line"></span><br><span class="line">4.4.5 main方法 115</span><br><span class="line"></span><br><span class="line">4.5 方法参数 118</span><br><span class="line"></span><br><span class="line">4.6 对象构造 123</span><br><span class="line"></span><br><span class="line">4.6.1 重载 123</span><br><span class="line"></span><br><span class="line">4.6.2 默认域初始化 123</span><br><span class="line"></span><br><span class="line">4.6.3 无参数的构造器 124</span><br><span class="line"></span><br><span class="line">4.6.4 显式域初始化 125</span><br><span class="line"></span><br><span class="line">4.6.5 参数名 125</span><br><span class="line"></span><br><span class="line">4.6.6 调用另一个构造器 126</span><br><span class="line"></span><br><span class="line">4.6.7 初始化块 127</span><br><span class="line"></span><br><span class="line">4.6.8 对象析构与finalize方法 130</span><br><span class="line"></span><br><span class="line">4.7 包 131</span><br><span class="line"></span><br><span class="line">4.7.1 类的导入 131</span><br><span class="line"></span><br><span class="line">4.7.2 静态导入 133</span><br><span class="line"></span><br><span class="line">4.7.3 将类放入包中 133</span><br><span class="line"></span><br><span class="line">4.7.4 包作用域 136</span><br><span class="line"></span><br><span class="line">4.8 类路径 137</span><br><span class="line"></span><br><span class="line">4.8.1 设置类路径 139</span><br><span class="line"></span><br><span class="line">4.9 文档注释 140</span><br><span class="line"></span><br><span class="line">4.9.1 注释的插入 140</span><br><span class="line"></span><br><span class="line">4.9.2 类注释 140</span><br><span class="line"></span><br><span class="line">4.9.3 方法注释 141</span><br><span class="line"></span><br><span class="line">4.9.4 域注释 142</span><br><span class="line"></span><br><span class="line">4.9.5 通用注释 142</span><br><span class="line"></span><br><span class="line">4.9.6 包与概述注释 143</span><br><span class="line"></span><br><span class="line">4.9.7 注释的抽取 143</span><br><span class="line"></span><br><span class="line">4.10 类设计技巧 144</span><br><span class="line"></span><br><span class="line">第5章 继承 147</span><br><span class="line"></span><br><span class="line">5.1 类、超类和子类 147</span><br><span class="line"></span><br><span class="line">5.1.1 定义子类 147</span><br><span class="line"></span><br><span class="line">5.1.2 覆盖方法 149</span><br><span class="line"></span><br><span class="line">5.1.3 子类构造器 150</span><br><span class="line"></span><br><span class="line">5.1.4 继承层次 153</span><br><span class="line"></span><br><span class="line">5.1.5 多态 154</span><br><span class="line"></span><br><span class="line">5.1.6 理解方法调用 155</span><br><span class="line"></span><br><span class="line">5.1.7 阻止继承：final类和方法 157</span><br><span class="line"></span><br><span class="line">5.1.8 强制类型转换 158</span><br><span class="line"></span><br><span class="line">5.1.9 抽象类 160</span><br><span class="line"></span><br><span class="line">5.1.10 受保护访问 165</span><br><span class="line"></span><br><span class="line">5.2 Object：所有类的超类 166</span><br><span class="line"></span><br><span class="line">5.2.1 equals方法 166</span><br><span class="line"></span><br><span class="line">5.2.2 相等测试与继承 167</span><br><span class="line"></span><br><span class="line">5.2.3 hashCode方法 170</span><br><span class="line"></span><br><span class="line">5.2.4 toString方法 172</span><br><span class="line"></span><br><span class="line">5.3 泛型数组列表 178</span><br><span class="line"></span><br><span class="line">5.3.1 访问数组列表元素 180</span><br><span class="line"></span><br><span class="line">5.3.2 类型化与原始数组列表的兼容性 183</span><br><span class="line"></span><br><span class="line">5.4 对象包装器与自动装箱 184</span><br><span class="line"></span><br><span class="line">5.5 参数数量可变的方法 187</span><br><span class="line"></span><br><span class="line">5.6 枚举类 188</span><br><span class="line"></span><br><span class="line">5.7 反射 190</span><br><span class="line"></span><br><span class="line">5.7.1 Class类 190</span><br><span class="line"></span><br><span class="line">5.7.2 捕获异常 192</span><br><span class="line"></span><br><span class="line">5.7.3 利用反射分析类的能力 194</span><br><span class="line"></span><br><span class="line">5.7.4 在运行时使用反射分析对象 198</span><br><span class="line"></span><br><span class="line">5.7.5 使用反射编写泛型数组代码 202</span><br><span class="line"></span><br><span class="line">5.7.6 调用任意方法 205</span><br><span class="line"></span><br><span class="line">5.8 继承的设计技巧 208</span><br><span class="line"></span><br><span class="line">第6章 接口、lambda表达式与内部类 211</span><br><span class="line"></span><br><span class="line">6.1 接口 211</span><br><span class="line"></span><br><span class="line">6.1.1 接口概念 211</span><br><span class="line"></span><br><span class="line">6.1.2 接口的特性 217</span><br><span class="line"></span><br><span class="line">6.1.3 接口与抽象类 218</span><br><span class="line"></span><br><span class="line">6.1.4 静态方法 218</span><br><span class="line"></span><br><span class="line">6.1.5 默认方法 219</span><br><span class="line"></span><br><span class="line">6.1.6 解决默认方法冲突 220</span><br><span class="line"></span><br><span class="line">6.2 接口示例 222</span><br><span class="line"></span><br><span class="line">6.2.1 接口与回调 222</span><br><span class="line"></span><br><span class="line">6.2.2 Comparator接口 224</span><br><span class="line"></span><br><span class="line">6.2.3 对象克隆 225</span><br><span class="line"></span><br><span class="line">6.3 lambda表达式 231</span><br><span class="line"></span><br><span class="line">6.3.1 为什么引入lambda表达式 231</span><br><span class="line"></span><br><span class="line">6.3.2 lambda表达式的语法 232</span><br><span class="line"></span><br><span class="line">6.3.3 函数式接口 234</span><br><span class="line"></span><br><span class="line">6.3.4 方法引用 235</span><br><span class="line"></span><br><span class="line">6.3.5 构造器引用 237</span><br><span class="line"></span><br><span class="line">6.3.6 变量作用域 237</span><br><span class="line"></span><br><span class="line">6.3.7 处理lambda表达式 239</span><br><span class="line"></span><br><span class="line">6.3.8 再谈Comparator 242</span><br><span class="line"></span><br><span class="line">6.4 内部类 242</span><br><span class="line"></span><br><span class="line">6.4.1 使用内部类访问对象状态 244</span><br><span class="line"></span><br><span class="line">6.4.2 内部类的特殊语法规则 247</span><br><span class="line"></span><br><span class="line">6.4.3 内部类是否有用、必要和安全 248</span><br><span class="line"></span><br><span class="line">6.4.4 局部内部类 250</span><br><span class="line"></span><br><span class="line">6.4.5 由外部方法访问变量 250</span><br><span class="line"></span><br><span class="line">6.4.6 匿名内部类 252</span><br><span class="line"></span><br><span class="line">6.4.7 静态内部类 255</span><br><span class="line"></span><br><span class="line">6.5 代理 258</span><br><span class="line"></span><br><span class="line">6.5.1 何时使用代理 259</span><br><span class="line"></span><br><span class="line">6.5.2 创建代理对象 259</span><br><span class="line"></span><br><span class="line">6.5.3 代理类的特性 262</span><br><span class="line"></span><br><span class="line">第7章 异常、断言和日志 264</span><br><span class="line"></span><br><span class="line">7.1 处理错误 264</span><br><span class="line"></span><br><span class="line">7.1.1 异常分类 265</span><br><span class="line"></span><br><span class="line">7.1.2 声明受查异常 267</span><br><span class="line"></span><br><span class="line">7.1.3 如何抛出异常 269</span><br><span class="line"></span><br><span class="line">7.1.4 创建异常类 270</span><br><span class="line"></span><br><span class="line">7.2 捕获异常 271</span><br><span class="line"></span><br><span class="line">7.2.1 捕获异常 271</span><br><span class="line"></span><br><span class="line">7.2.2 捕获多个异常 273</span><br><span class="line"></span><br><span class="line">7.2.3 再次抛出异常与异常链 274</span><br><span class="line"></span><br><span class="line">7.2.4 finally子句 275</span><br><span class="line"></span><br><span class="line">7.2.5 带资源的try语句 278</span><br><span class="line"></span><br><span class="line">7.2.6 分析堆栈轨迹元素 280</span><br><span class="line"></span><br><span class="line">7.3 使用异常机制的技巧 282</span><br><span class="line"></span><br><span class="line">7.4 使用断言 285</span><br><span class="line"></span><br><span class="line">7.4.1 断言的概念 285</span><br><span class="line"></span><br><span class="line">7.4.2 启用和禁用断言 286</span><br><span class="line"></span><br><span class="line">7.4.3 使用断言完成参数检查 287</span><br><span class="line"></span><br><span class="line">7.4.4 为文档假设使用断言 288</span><br><span class="line"></span><br><span class="line">7.5 记录日志 289</span><br><span class="line"></span><br><span class="line">7.5.1 基本日志 289</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Java核心技术卷2第8版 PDF</title>
    <url>/posts/45d7fe52/</url>
    <content><![CDATA[<h4 id="《Java核心技术卷2第8版》"><a href="#《Java核心技术卷2第8版》" class="headerlink" title="《Java核心技术卷2第8版》"></a>《Java核心技术卷2第8版》</h4><h6 id="链接-https-pan-baidu-com-s-1hwW2u-FhrUaZGxSgLEtGlg-提取码-x58i"><a href="#链接-https-pan-baidu-com-s-1hwW2u-FhrUaZGxSgLEtGlg-提取码-x58i" class="headerlink" title="链接: https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg 提取码: x58i"></a>链接: <a href="https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg">https://pan.baidu.com/s/1hwW2u_FhrUaZGxSgLEtGlg</a> 提取码: x58i</h6><p><img src="/images/245331e9bd0ded1bdc349955247dc2e21.jpg" width="50%" height="50%"><br><a id="more"></a></p>
<p>本书是Java[令页]域有影响力和价值的著作之一，由拥有20多年教[0学0]与研究[纟巠]验的Java技术专家撰写（获Jolt[0大0]奖），与《Java编程思想》齐[0名0]，10余年全球[0畅0]销不衰，广受[女子][0评0]。[0第0]10版根据JavaSE8全[mian]更[亲斤]，同时修正了[0第0]9版中的不足，系统全[mian]讲解了Java语言的核心概念、语[0法0]、重要特性和开发方[0法0]，包含[0大0]量案例，实践性强。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">译者序</span><br><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">[0第0]1章　Java SE 8的流库 1</span><br><span class="line"></span><br><span class="line">1.1　从迭代到流的操作 1</span><br><span class="line"></span><br><span class="line">1.2　流的创建 3</span><br><span class="line"></span><br><span class="line">1.3　filter、map和flatMap方[0法0] 6</span><br><span class="line"></span><br><span class="line">1.4　抽取子流和连接流 8</span><br><span class="line"></span><br><span class="line">1.5　其他的流转换 8</span><br><span class="line"></span><br><span class="line">1.6　简单约简 9</span><br><span class="line"></span><br><span class="line">1.7　Optional类型 11</span><br><span class="line"></span><br><span class="line">1.7.1　如何使用Optional值 11</span><br><span class="line"></span><br><span class="line">1.7.2　不适合使用Optional值的方式 12</span><br><span class="line"></span><br><span class="line">1.7.3　创建Optional值 13</span><br><span class="line"></span><br><span class="line">1.7.4　用flatMap来构建Optional值的函数 13</span><br><span class="line"></span><br><span class="line">1.8　收集结果 15</span><br><span class="line"></span><br><span class="line">1.9　收集到映[身寸]表中 19</span><br><span class="line"></span><br><span class="line">1.10　群组和分区 23</span><br><span class="line"></span><br><span class="line">1.11　下游收集器 24</span><br><span class="line"></span><br><span class="line">1.12　约简操作 28</span><br><span class="line"></span><br><span class="line">1.13　基本类型流 29</span><br><span class="line"></span><br><span class="line">1.14　并行流 34</span><br><span class="line"></span><br><span class="line">[0第0]2章　输入与输出 39</span><br><span class="line"></span><br><span class="line">2.1　输入&#x2F;输出流 39</span><br><span class="line"></span><br><span class="line">2.1.1　读写字节 39</span><br><span class="line"></span><br><span class="line">2.1.2　完整的流家族 42</span><br><span class="line"></span><br><span class="line">2.1.3　组合输入&#x2F;输出流过滤器 45</span><br><span class="line"></span><br><span class="line">2.2　文本输入与输出 48</span><br><span class="line"></span><br><span class="line">2.2.1　如何写出文本输出 49</span><br><span class="line"></span><br><span class="line">2.2.2　如何读入文本输入 51</span><br><span class="line"></span><br><span class="line">2.2.3　以文本格式存储对象 52</span><br><span class="line"></span><br><span class="line">2.2.4　字符编码方式 55</span><br><span class="line"></span><br><span class="line">2.3　读写二进制数据 57</span><br><span class="line"></span><br><span class="line">2.3.1　DataInput和DataOutput接口 57</span><br><span class="line"></span><br><span class="line">2.3.2　随[1机1]访问文[亻牛] 59</span><br><span class="line"></span><br><span class="line">2.3.3　ZIP文档 63</span><br><span class="line"></span><br><span class="line">2.4　对象输入&#x2F;输出流与序列化 66</span><br><span class="line"></span><br><span class="line">2.4.1　保存和加载序列化对象 66</span><br><span class="line"></span><br><span class="line">2.4.2　理解对象序列化的文[亻牛]格式 70</span><br><span class="line"></span><br><span class="line">2.4.3　修改默认的序列化[1机1]制 75</span><br><span class="line"></span><br><span class="line">2.4.4　序列化单例和类型安全的枚举 77</span><br><span class="line"></span><br><span class="line">2.4.5　版本管理 78</span><br><span class="line"></span><br><span class="line">2.4.6　为克隆使用序列化 80</span><br><span class="line"></span><br><span class="line">2.5　操作文[亻牛] 83</span><br><span class="line"></span><br><span class="line">2.5.1　Path 83</span><br><span class="line"></span><br><span class="line">2.5.2　读写文[亻牛] 85</span><br><span class="line"></span><br><span class="line">2.5.3　创建文[亻牛]和目录 87</span><br><span class="line"></span><br><span class="line">2.5.4　复制、移动和删除文[亻牛] 88</span><br><span class="line"></span><br><span class="line">2.5.5　获取文[亻牛]信息 89</span><br><span class="line"></span><br><span class="line">2.5.6　访问目录中的项 91</span><br><span class="line"></span><br><span class="line">2.5.7　使用目录流 92</span><br><span class="line"></span><br><span class="line">2.5.8　ZIP文[亻牛]系统 95</span><br><span class="line"></span><br><span class="line">2.6　内存映[身寸]文[亻牛] 96</span><br><span class="line"></span><br><span class="line">2.6.1　内存映[身寸]文[亻牛]的性能 96</span><br><span class="line"></span><br><span class="line">2.6.2　缓冲区数据结构 103</span><br><span class="line"></span><br><span class="line">2.6.3　文[亻牛]加锁[1机1]制 105</span><br><span class="line"></span><br><span class="line">2.7　正则表达式 106</span><br><span class="line"></span><br><span class="line">[0第0]3章　XML 117</span><br><span class="line"></span><br><span class="line">3.1　XML概述 117</span><br><span class="line"></span><br><span class="line">3.1.1　XML文档的结构 119</span><br><span class="line"></span><br><span class="line">3.2　解析XML文档 122</span><br><span class="line"></span><br><span class="line">3.3　验证XML文档 132</span><br><span class="line"></span><br><span class="line">3.3.1　文档类型定义 133</span><br><span class="line"></span><br><span class="line">3.3.2　XML Schema 139</span><br><span class="line"></span><br><span class="line">3.3.3　实用示例 142</span><br><span class="line"></span><br><span class="line">3.4　使用XPath来定位信息 154</span><br><span class="line"></span><br><span class="line">3.5　使用命[0名0]空间 159</span><br><span class="line"></span><br><span class="line">3.6　流[1机1]制解析器 162</span><br><span class="line"></span><br><span class="line">3.6.1　使用SAX解析器 162</span><br><span class="line"></span><br><span class="line">3.6.2　使用StAX解析器 166</span><br><span class="line"></span><br><span class="line">3.7　生成XML文档 170</span><br><span class="line"></span><br><span class="line">3.7.1　不带命[0名0]空间的文档 170</span><br><span class="line"></span><br><span class="line">3.7.2　带命[0名0]空间的文档 170</span><br><span class="line"></span><br><span class="line">3.7.3　写出文档 171</span><br><span class="line"></span><br><span class="line">3.7.4　示例：生成SVG文[亻牛] 172</span><br><span class="line"></span><br><span class="line">3.7.5　使用StAX写出XML文档 174</span><br><span class="line"></span><br><span class="line">3.8　XSL转换 181</span><br><span class="line"></span><br><span class="line">[0第0]4章　网络 191</span><br><span class="line"></span><br><span class="line">4.1　连接到服务器 191</span><br><span class="line"></span><br><span class="line">4.1.1　使用telnet 191</span><br><span class="line"></span><br><span class="line">4.1.2　用Java连接到服务器 193</span><br><span class="line"></span><br><span class="line">4.1.3　套接字[0超0]时 195</span><br><span class="line"></span><br><span class="line">4.1.4　因特网地址 196</span><br><span class="line"></span><br><span class="line">4.2　实现服务器 198</span><br><span class="line"></span><br><span class="line">4.2.1　服务器套接字 198</span><br><span class="line"></span><br><span class="line">4.2.2　为多个客户端服务 201</span><br><span class="line"></span><br><span class="line">4.2.3　半关闭 204</span><br><span class="line"></span><br><span class="line">4.3　可中断套接字 205</span><br><span class="line"></span><br><span class="line">4.4　获取Web数 211</span><br><span class="line"></span><br><span class="line">4.4.1　URL和URI 211</span><br><span class="line"></span><br><span class="line">4.4.2　使用URLConnection获取信息 213</span><br><span class="line"></span><br><span class="line">4.4.3　[扌是]交表单数据 220</span><br><span class="line"></span><br><span class="line">4.5　发送E-mail 228</span><br><span class="line"></span><br><span class="line">[0第0]5章　数据库编程 232</span><br><span class="line"></span><br><span class="line">5.1　JDBC的设计 232</span><br><span class="line"></span><br><span class="line">5.1.1　JDBC驱动程序类型 233</span><br><span class="line"></span><br><span class="line">5.1.2　JDBC的典型用[0法0] 234</span><br><span class="line"></span><br><span class="line">5.2　结构化查询语言 234</span><br><span class="line"></span><br><span class="line">5.3　JDBC配置 239</span><br><span class="line"></span><br><span class="line">5.3.1　数据库URL 240</span><br><span class="line"></span><br><span class="line">5.3.2　驱动程序JAR文[亻牛] 240</span><br><span class="line"></span><br><span class="line">5.3.3　启动数据库 240</span><br><span class="line"></span><br><span class="line">5.3.4　注册驱动器类 241</span><br><span class="line"></span><br><span class="line">5.3.5　连接到数据库 242</span><br><span class="line"></span><br><span class="line">5.4　使用JDBC语句 244</span><br><span class="line"></span><br><span class="line">5.4.1　执行SQL语句 244</span><br><span class="line"></span><br><span class="line">5.4.2　管理连接、语句和结果集 247</span><br><span class="line"></span><br><span class="line">5.4.3　分析SQL异常 248</span><br><span class="line"></span><br><span class="line">5.4.4　组装数据库 250</span><br><span class="line"></span><br><span class="line">5.5　执行查询操作 254</span><br><span class="line"></span><br><span class="line">5.5.1　预备语句 254</span><br><span class="line"></span><br><span class="line">5.5.2　读写LOB 259</span><br><span class="line"></span><br><span class="line">5.5.3　SQL转义 261</span><br><span class="line"></span><br><span class="line">5.5.4　多结果集 262</span><br><span class="line"></span><br><span class="line">5.5.5　获取自动生成的键 263</span><br><span class="line"></span><br><span class="line">5.6　可滚动和可更[亲斤]的结果集 263</span><br><span class="line"></span><br><span class="line">5.6.1　可滚动的结果集 264</span><br><span class="line"></span><br><span class="line">5.6.2　可更[亲斤]的结果集 266</span><br><span class="line"></span><br><span class="line">5.7　行集 269</span><br><span class="line"></span><br><span class="line">5.7.1　构建行集 270</span><br><span class="line"></span><br><span class="line">5.7.2　被缓存的行集 270</span><br><span class="line"></span><br><span class="line">5.8　元数据 273</span><br><span class="line"></span><br><span class="line">5.9　事务 282</span><br><span class="line"></span><br><span class="line">5.9.1　用JDBC对事务编程 282</span><br><span class="line"></span><br><span class="line">5.9.2　保存点 283</span><br><span class="line"></span><br><span class="line">5.9.3　批量更[亲斤] 283</span><br><span class="line"></span><br><span class="line">5.10　高级SQL类型 285</span><br><span class="line"></span><br><span class="line">5.11　Web与企业应用中的连接管理 286</span><br><span class="line"></span><br><span class="line">[0第0]6章　日期和时间API 288</span><br><span class="line"></span><br><span class="line">6.1　时间线 288</span><br><span class="line"></span><br><span class="line">6.2　本地时间 291</span><br><span class="line"></span><br><span class="line">6.3　日期调整器 294</span><br><span class="line"></span><br><span class="line">6.4　本地时间 295</span><br><span class="line"></span><br><span class="line">6.5　时区时间 296</span><br><span class="line"></span><br><span class="line">6.6　格式化和解析 299</span><br><span class="line"></span><br><span class="line">6.7　与遗留代码的互操作 302</span><br><span class="line"></span><br><span class="line">[0第0]7章　[0国0]际化 304</span><br><span class="line"></span><br><span class="line">7.1　Locale对象 304</span><br><span class="line"></span><br><span class="line">7.2　数字格式 309</span><br><span class="line"></span><br><span class="line">7.3　货币 314</span><br><span class="line"></span><br><span class="line">7.4　日期和时间 315</span><br><span class="line"></span><br><span class="line">7.5　排序和范化 321</span><br><span class="line"></span><br><span class="line">7.6　消息格式化 327</span><br><span class="line"></span><br><span class="line">7.6.1　格式化数字和日期 327</span><br><span class="line"></span><br><span class="line">7.6.2　选择格式 329</span><br><span class="line"></span><br><span class="line">7.7　文本文[亻牛]和字符集 331</span><br><span class="line"></span><br><span class="line">7.7.1　文本文[亻牛] 331</span><br><span class="line"></span><br><span class="line">7.7.2　行结束符 331</span><br><span class="line"></span><br><span class="line">7.7.3　控制台 331</span><br><span class="line"></span><br><span class="line">7.7.4　日志文[亻牛] 332</span><br><span class="line"></span><br><span class="line">7.7.5　UTF-8字节顺序标志 332</span><br><span class="line"></span><br><span class="line">7.7.6　源文[亻牛]的字符编码 333</span><br><span class="line"></span><br><span class="line">7.8　资源包 333</span><br><span class="line"></span><br><span class="line">7.8.1　定位资源包 334</span><br><span class="line"></span><br><span class="line">7.8.2　属性文[亻牛] 335</span><br><span class="line"></span><br><span class="line">7.8.3　包类 335</span><br><span class="line"></span><br><span class="line">7.9　一个完整的例子 337</span><br><span class="line"></span><br><span class="line">[0第0]8章　脚本、编译与注解处理 352</span><br><span class="line"></span><br><span class="line">8.1　Java平台的脚本 352</span><br><span class="line"></span><br><span class="line">8.1.1　获取脚本引擎 352</span><br><span class="line"></span><br><span class="line">8.1.2　脚本赋值与绑定 353</span><br><span class="line"></span><br><span class="line">8.1.3　重定向输入和输出 355</span><br><span class="line"></span><br><span class="line">8.1.4　调用脚本的函数和方[0法0] 356</span><br><span class="line"></span><br><span class="line">8.1.5　编译脚本 357</span><br><span class="line"></span><br><span class="line">8.1.6　一个示例：用脚本处理GUI事[亻牛] 358</span><br><span class="line"></span><br><span class="line">8.2　编译器API 363</span><br><span class="line"></span><br><span class="line">8.2.1　编译便捷之[0法0] 363</span><br><span class="line"></span><br><span class="line">8.2.2　使用编译工具 363</span><br><span class="line"></span><br><span class="line">8.2.3　一个示例：动态Java代码生成 368</span><br><span class="line"></span><br><span class="line">8.3　使用注解 373</span><br><span class="line"></span><br><span class="line">8.3.1　注解简介 373</span><br><span class="line"></span><br><span class="line">8.3.2　一个示例：注解事[亻牛]处理器 374</span><br><span class="line"></span><br><span class="line">8.4　注解语[0法0] 379</span><br><span class="line"></span><br><span class="line">8.4.1　注解接口 379</span><br><span class="line"></span><br><span class="line">8.4.2　注解 380</span><br><span class="line"></span><br><span class="line">8.4.3　注解各类声明 382</span><br><span class="line"></span><br><span class="line">8.4.4　注解类型用[0法0] 383</span><br><span class="line"></span><br><span class="line">8.4.5　注解this 384</span><br><span class="line"></span><br><span class="line">8.5　标准注解 385</span><br><span class="line"></span><br><span class="line">8.5.1　用于编译的注解 386</span><br><span class="line"></span><br><span class="line">8.5.2　用于管理资源的注解 386</span><br><span class="line"></span><br><span class="line">8.5.3　元注解 387</span><br><span class="line"></span><br><span class="line">8.6　源码级注解处理 389</span><br><span class="line"></span><br><span class="line">8.6.1　注解处理 389</span><br><span class="line"></span><br><span class="line">8.6.2　语言模型API 390</span><br><span class="line"></span><br><span class="line">8.6.3　使用注解来生成源码 390</span><br><span class="line"></span><br><span class="line">8.7　字节码工程 393</span><br><span class="line"></span><br><span class="line">8.7.1　修改类文[亻牛] 393</span><br><span class="line"></span><br><span class="line">8.7.2　在加载时修改字节码 398</span><br><span class="line"></span><br><span class="line">[0第0]9章　安全 401</span><br><span class="line"></span><br><span class="line">9.1　类加载器 401</span><br><span class="line"></span><br><span class="line">9.1.1　类加载过程 402</span><br><span class="line"></span><br><span class="line">9.1.2　类加载器的层次结构 403</span><br><span class="line"></span><br><span class="line">9.1.3　将类加载器作为命[0名0]空间 404</span><br><span class="line"></span><br><span class="line">9.1.4　编写你自己的类加载器 405</span><br><span class="line"></span><br><span class="line">9.1.5　字节码校验 410</span><br><span class="line"></span><br><span class="line">9.2　安全管理器与访问[0权0]限 414</span><br><span class="line"></span><br><span class="line">9.2.1　[0权0]限检查 414</span><br><span class="line"></span><br><span class="line">9.2.2　Java平台安全性 415</span><br><span class="line"></span><br><span class="line">9.2.3　安全策略文[亻牛] 418</span><br><span class="line"></span><br><span class="line">9.2.4　定制[0权0]限 424</span><br><span class="line"></span><br><span class="line">9.2.5　实现[0权0]限类 426</span><br><span class="line"></span><br><span class="line">9.3　用户认证 431</span><br><span class="line"></span><br><span class="line">9.3.1　JAAS框架 431</span><br><span class="line"></span><br><span class="line">9.3.2　JAAS登录模块 437</span><br><span class="line"></span><br><span class="line">9.4　数字签[0名0] 445</span><br><span class="line"></span><br><span class="line">9.4.1　消息摘要 445</span><br><span class="line"></span><br><span class="line">9.4.2　消息签[0名0] 448</span><br><span class="line"></span><br><span class="line">9.4.3　校验签[0名0] 449</span><br><span class="line"></span><br><span class="line">9.4.4　认证问题 452</span><br><span class="line"></span><br><span class="line">9.4.5　证书签[0名0] 454</span><br><span class="line"></span><br><span class="line">9.4.6　证书请求 454</span><br><span class="line"></span><br><span class="line">9.4.7　代码签[0名0] 455</span><br><span class="line"></span><br><span class="line">9.5　加密 460</span><br><span class="line"></span><br><span class="line">9.5.1　对称密码 461</span><br><span class="line"></span><br><span class="line">9.5.2　密钥生成 462</span><br><span class="line"></span><br><span class="line">9.5.3　密码流 466</span><br><span class="line"></span><br><span class="line">9.5.4　公共密钥密码 467</span><br><span class="line"></span><br><span class="line">[0第0]10章　高级Swing 472</span><br><span class="line"></span><br><span class="line">10.1　列表 472</span><br><span class="line"></span><br><span class="line">10.1.1　JList构[亻牛] 472</span><br><span class="line"></span><br><span class="line">10.1.2　列表模式 477</span><br><span class="line"></span><br><span class="line">10.1.3　插入和移除值 481</span><br><span class="line"></span><br><span class="line">10.1.4　值的绘制 482</span><br><span class="line"></span><br><span class="line">10.2　表格 486</span><br><span class="line"></span><br><span class="line">10.2.1　简单表格 486</span><br><span class="line"></span><br><span class="line">10.2.2　表格模型 489</span><br><span class="line"></span><br><span class="line">10.2.3　对行和列的操作 493</span><br><span class="line"></span><br><span class="line">10.2.4　单元格的绘制和编辑 506</span><br><span class="line"></span><br><span class="line">10.3　树 517</span><br><span class="line"></span><br><span class="line">10.3.1　简单的树 518</span><br><span class="line"></span><br><span class="line">10.3.2　编辑树和树的路径 524</span><br><span class="line"></span><br><span class="line">10.3.3　节点枚举 530</span><br><span class="line"></span><br><span class="line">10.3.4　绘制节点 532</span><br><span class="line"></span><br><span class="line">10.3.5　监听树事[亻牛] 534</span><br><span class="line"></span><br><span class="line">10.3.6　定制树模型 541</span><br><span class="line"></span><br><span class="line">10.4　文本构[亻牛] 548</span><br><span class="line"></span><br><span class="line">10.4.1　文本构[亻牛]中的修改跟踪 549</span><br><span class="line"></span><br><span class="line">10.4.2　格式化的输入框 552</span><br><span class="line"></span><br><span class="line">10.4.3　JSpinner构[亻牛] 567</span><br><span class="line"></span><br><span class="line">10.4.4　用JEditorPane显示HTML 574</span><br><span class="line"></span><br><span class="line">10.5　进度指示器 579</span><br><span class="line"></span><br><span class="line">10.5.1　进度条 580</span><br><span class="line"></span><br><span class="line">10.5.2　进度监视器 582</span><br><span class="line"></span><br><span class="line">10.5.3　监视输入流的进度 585</span><br><span class="line"></span><br><span class="line">10.6　构[亻牛]组织器和装饰器 590</span><br><span class="line"></span><br><span class="line">10.6.1　分割[mian]板 590</span><br><span class="line"></span><br><span class="line">10.6.2　选项卡[mian]板 592</span><br><span class="line"></span><br><span class="line">10.6.3　桌[mian][mian]板和内部框体 597</span><br><span class="line"></span><br><span class="line">10.6.4　层 613</span><br><span class="line"></span><br><span class="line">[0第0]11章　高级AWT 618</span><br><span class="line"></span><br><span class="line">11.1　绘图操作流程 618</span><br><span class="line"></span><br><span class="line">11.2　形状 620</span><br><span class="line"></span><br><span class="line">11.2.1　形状类层次结构 621</span><br><span class="line"></span><br><span class="line">11.2.2　使用形状类 623</span><br><span class="line"></span><br><span class="line">11.3　区域 634</span><br><span class="line"></span><br><span class="line">11.4　笔划 635</span><br><span class="line"></span><br><span class="line">11.5　着色 642</span><br><span class="line"></span><br><span class="line">11.6　坐标变换 644</span><br><span class="line"></span><br><span class="line">11.7　剪切 648</span><br><span class="line"></span><br><span class="line">11.8　透明与组合 650</span><br><span class="line"></span><br><span class="line">11.9　绘图[扌是]示 657</span><br><span class="line"></span><br><span class="line">11.10　图像的读取器和写入器 663</span><br><span class="line"></span><br><span class="line">11.10.1　获得适合图像文[亻牛]类型的读取器和写入器 663</span><br><span class="line"></span><br><span class="line">11.10.2　读取和写入带有多个图像的文[亻牛] 664</span><br><span class="line"></span><br><span class="line">11.11　图像处理 671</span><br><span class="line"></span><br><span class="line">11.11.1　构建[1光1]栅图像 672</span><br><span class="line"></span><br><span class="line">11.11.2　图像过滤 678</span><br><span class="line"></span><br><span class="line">11.12　打印 685</span><br><span class="line"></span><br><span class="line">11.12.1　图形打印 685</span><br><span class="line"></span><br><span class="line">11.12.2　打印多页文[亻牛] 693</span><br><span class="line"></span><br><span class="line">11.12.3　打印预览 694</span><br><span class="line"></span><br><span class="line">11.12.4　打印服务程序 702</span><br><span class="line"></span><br><span class="line">11.12.5　流打印服务程序 706</span><br><span class="line"></span><br><span class="line">11.12.6　打印属性 707</span><br><span class="line"></span><br><span class="line">11.13　剪贴板 712</span><br><span class="line"></span><br><span class="line">11.13.1　用于数据传递的类和接口 713</span><br><span class="line"></span><br><span class="line">11.13.2　传递文本 714</span><br><span class="line"></span><br><span class="line">11.13.3　Transferable接口和数据风格 717</span><br><span class="line"></span><br><span class="line">11.13.4　构建一个可传递的图像 718</span><br><span class="line"></span><br><span class="line">11.13.5　通过系统剪贴板传递Java对象 722</span><br><span class="line"></span><br><span class="line">11.13.6　使用本地剪贴板来传递对象引用 725</span><br><span class="line"></span><br><span class="line">11.14　拖放操作 725</span><br><span class="line"></span><br><span class="line">11.14.1　Swing对数据传递的支持 726</span><br><span class="line"></span><br><span class="line">11.14.2　拖曳源 730</span><br><span class="line"></span><br><span class="line">11.14.3　放置目标 732</span><br><span class="line"></span><br><span class="line">11.15　平台集成 739</span><br><span class="line"></span><br><span class="line">11.15.1　闪屏 739</span><br><span class="line"></span><br><span class="line">11.15.2　启动桌[mian]应用程序 743</span><br><span class="line"></span><br><span class="line">11.15.3　系统托盘 748</span><br><span class="line"></span><br><span class="line">[0第0]12章　本地方[0法0] 752</span><br><span class="line"></span><br><span class="line">12.1　从Java程序中调用C函数 752</span><br><span class="line"></span><br><span class="line">12.2　数值参数与返回值 757</span><br><span class="line"></span><br><span class="line">12.3　字符串参数 759</span><br><span class="line"></span><br><span class="line">12.4　访问域 764</span><br><span class="line"></span><br><span class="line">12.4.1　访问实例域 765</span><br><span class="line"></span><br><span class="line">12.4.2　访问静态域 768</span><br><span class="line"></span><br><span class="line">12.5　编码签[0名0] 769</span><br><span class="line"></span><br><span class="line">12.6　调用Java方[0法0] 770</span><br><span class="line"></span><br><span class="line">12.6.1　实例方[0法0] 771</span><br><span class="line"></span><br><span class="line">12.6.2　静态方[0法0] 774</span><br><span class="line"></span><br><span class="line">12.6.3　构造器 775</span><br><span class="line"></span><br><span class="line">12.6.4　另一种方[0法0]调用 775</span><br><span class="line"></span><br><span class="line">12.7　访问数组元素 777</span><br><span class="line"></span><br><span class="line">12.8　错误处理 780</span><br><span class="line"></span><br><span class="line">12.9　使用调用API 785</span><br><span class="line"></span><br><span class="line">12.10　完整的示例：访问Windows注册表 789</span><br><span class="line"></span><br><span class="line">12.10.1　Windows注册表概述 789</span><br><span class="line"></span><br><span class="line">12.10.2　访问注册表的Java平台接口 791</span><br><span class="line"></span><br><span class="line">12.10.3　以本地方[0法0]方式实现注册表访问函数 791</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="另外，动态规划万字总结，一步步拨开动态规划的面纱"><a href="#另外，动态规划万字总结，一步步拨开动态规划的面纱" class="headerlink" title="另外，动态规划万字总结，一步步拨开动态规划的面纱"></a>另外，动态规划万字总结，一步步拨开动态规划的面纱</h4><h6 id="链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1"><a href="#链接-https-pan-baidu-com-s-18-2SoCibWB15JTO8EB0LfA-密码-uto1" class="headerlink" title="链接:https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA 密码:uto1"></a>链接:<a href="https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA">https://pan.baidu.com/s/18-2SoCibWB15JTO8EB0LfA</a> 密码:uto1</h6><h4 id="有问题拿不到直接联系作者哦！"><a href="#有问题拿不到直接联系作者哦！" class="headerlink" title="有问题拿不到直接联系作者哦！"></a>有问题拿不到直接联系作者哦！</h4><p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>MongoDB权威指南 PDF</title>
    <url>/posts/6efaad91/</url>
    <content><![CDATA[<h4 id="《MongoDB权威指南》"><a href="#《MongoDB权威指南》" class="headerlink" title="《MongoDB权威指南》"></a>《MongoDB权威指南》</h4><h6 id="链接-https-pan-baidu-com-s-181Mk5vRIzAJ6ZeJq2qrMqQ-提取码-sj6a"><a href="#链接-https-pan-baidu-com-s-181Mk5vRIzAJ6ZeJq2qrMqQ-提取码-sj6a" class="headerlink" title="链接: https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ 提取码: sj6a"></a>链接: <a href="https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ">https://pan.baidu.com/s/181Mk5vRIzAJ6ZeJq2qrMqQ</a> 提取码: sj6a</h6><p>与传统的关系型数据库不同，MongoDB是一种面向文档的数据库。《MongoDB指南(第2版)》这一版共分为六部分，涵盖开发、管理以及部署的各个方面。分展示MongoDB基础知识、核心概念。第二部分介绍使用MongoDB进行开发，包括索引的概念以及各种特殊索引和集合的用法等。第三部分讲述复制，包括副本集的相关概念、创建方法，与应用程序的交互等。第四部讨论分片，包括分片的配置，片键的选择，集群的管理。第五部分阐述创建索引、移动和压缩数据等管理任务，以及MongoDB的持久数据存储。后一部分集中说明服务器管理。<br><a id="more"></a></p>
<p><img src="/images/c367d4220bb379b54821542cff7710871.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">前言</span><br><span class="line"></span><br><span class="line">部分 MongoDB介绍</span><br><span class="line"></span><br><span class="line">章 MongoDB简介 3</span><br><span class="line"></span><br><span class="line">1.1 易于使用 3</span><br><span class="line"></span><br><span class="line">1.2 易于扩展 4</span><br><span class="line"></span><br><span class="line">1.3 丰富的功能 4</span><br><span class="line"></span><br><span class="line">1.4 卓越的性能 5</span><br><span class="line"></span><br><span class="line">1.5 小结 5</span><br><span class="line"></span><br><span class="line">第2章 MongoDB基础知识 7</span><br><span class="line"></span><br><span class="line">2.1 文档 7</span><br><span class="line"></span><br><span class="line">2.2 集合 8</span><br><span class="line"></span><br><span class="line">2.2.1 动态模式 8</span><br><span class="line"></span><br><span class="line">2.2.2 命名 9</span><br><span class="line"></span><br><span class="line">2.3 数据库 10</span><br><span class="line"></span><br><span class="line">2.4 启动MongoDB 11</span><br><span class="line"></span><br><span class="line">2.5 MongoDBshell简介 12</span><br><span class="line"></span><br><span class="line">2.5.1 运行shell 12</span><br><span class="line"></span><br><span class="line">2.5.2 MongoDB客户端 13</span><br><span class="line"></span><br><span class="line">2.5.3 shell中的基本操作 14</span><br><span class="line"></span><br><span class="line">2.6 数据类型 16</span><br><span class="line"></span><br><span class="line">2.6.1 基本数据类型 16</span><br><span class="line"></span><br><span class="line">2.6.2 日期 18</span><br><span class="line"></span><br><span class="line">2.6.3 数组 18</span><br><span class="line"></span><br><span class="line">2. 内嵌文档 19</span><br><span class="line"></span><br><span class="line">2.6.5 _id和ObjectId 20</span><br><span class="line"></span><br><span class="line">2.7 使用MongoDBshell 21</span><br><span class="line"></span><br><span class="line">2.7.1 shell小贴士 22</span><br><span class="line"></span><br><span class="line">2.7.2 使用shell执行脚本 23</span><br><span class="line"></span><br><span class="line">2.7.3 创建mongorc.js文件 25</span><br><span class="line"></span><br><span class="line">2.7.4 定制shell提示 26</span><br><span class="line"></span><br><span class="line">2.7.5 编辑复合变量 26</span><br><span class="line"></span><br><span class="line">2.7.6 集合命名注意事项 27</span><br><span class="line"></span><br><span class="line">第3章 创建、更新和删除文档 29</span><br><span class="line"></span><br><span class="line">3.1 插入并保存文档 29</span><br><span class="line"></span><br><span class="line">3.1.1 批量插入 29</span><br><span class="line"></span><br><span class="line">3.1.2 插入校验 30</span><br><span class="line"></span><br><span class="line">3.2 删除文档 31</span><br><span class="line"></span><br><span class="line">3.3 更新文档 32</span><br><span class="line"></span><br><span class="line">3.3.1 文档替换 32</span><br><span class="line"></span><br><span class="line">3.3.2 使用修改器 34</span><br><span class="line"></span><br><span class="line">3.3.3 upsert 45</span><br><span class="line"></span><br><span class="line">3.3.4 更新多个文档 47</span><br><span class="line"></span><br><span class="line">3.3.5 返回被更新的文档 48</span><br><span class="line"></span><br><span class="line">3.4 写入安全机制 50</span><br><span class="line"></span><br><span class="line">第4章 查询 53</span><br><span class="line"></span><br><span class="line">4.1 find简介 53</span><br><span class="line"></span><br><span class="line">4.1.1 指定需要返回的键 54</span><br><span class="line"></span><br><span class="line">4.1.2 55</span><br><span class="line"></span><br><span class="line">4.2 查询条件 55</span><br><span class="line"></span><br><span class="line">4.2.1 查询条件 55</span><br><span class="line"></span><br><span class="line">4.2.2 OR查询 56</span><br><span class="line"></span><br><span class="line">4.2.3 $not 57</span><br><span class="line"></span><br><span class="line">4.2.4 条件语义 57</span><br><span class="line"></span><br><span class="line">4.3 特定类型的查询 58</span><br><span class="line"></span><br><span class="line">4.3.1 null 58</span><br><span class="line"></span><br><span class="line">4.3.2 正则表达式 59</span><br><span class="line"></span><br><span class="line">4.3.3 查询数组 59</span><br><span class="line"></span><br><span class="line">4.3.4 查询内嵌文档</span><br><span class="line"></span><br><span class="line">4.4 $where查询 65</span><br><span class="line"></span><br><span class="line">4.5 游标 67</span><br><span class="line"></span><br><span class="line">4.5.1 limit、skip和sort 69</span><br><span class="line"></span><br><span class="line">4.5.2 避免使用skip略过大量结果 70</span><br><span class="line"></span><br><span class="line">4.5.3 不错查询选项 72</span><br><span class="line"></span><br><span class="line">4.5.4 获取一致结果 73</span><br><span class="line"></span><br><span class="line">4.5.5 游标生命周期 75</span><br><span class="line"></span><br><span class="line">4.6 数据库命令 75</span><br><span class="line"></span><br><span class="line">第二部分 设计应用</span><br><span class="line"></span><br><span class="line">第5章 索引 81</span><br><span class="line"></span><br><span class="line">5.1 索引简介 81</span><br><span class="line"></span><br><span class="line">5.1.1 复合索引简介 84</span><br><span class="line"></span><br><span class="line">5.1.2 使用复合索引 90</span><br><span class="line"></span><br><span class="line">5.1.3 $操作符如何使用索引 91</span><br><span class="line"></span><br><span class="line">5.1.4 索引对象和数组 96</span><br><span class="line"></span><br><span class="line">5.1.5 索引基数 98</span><br><span class="line"></span><br><span class="line">5.2 使用explain（）和hint（） 98</span><br><span class="line"></span><br><span class="line">5.3 何时不应该使用索引 103</span><br><span class="line"></span><br><span class="line">5.4 索引类型 104</span><br><span class="line"></span><br><span class="line">5.4.1 索引 104</span><br><span class="line"></span><br><span class="line">5.4.2 稀疏索引 106</span><br><span class="line"></span><br><span class="line">5.5 索引管理 107</span><br><span class="line"></span><br><span class="line">5.5.1 标识索引 108</span><br><span class="line"></span><br><span class="line">5.5.2 修改索引 108</span><br><span class="line"></span><br><span class="line">第6章 特殊的索引和集合 111</span><br><span class="line"></span><br><span class="line">6.1 固定集合 111</span><br><span class="line"></span><br><span class="line">6.1.1 创建固定集合 113</span><br><span class="line"></span><br><span class="line">6.1.2 自然排序 113</span><br><span class="line"></span><br><span class="line">6.1.3 循环游标 115</span><br><span class="line"></span><br><span class="line">6.1.4 没有_id索引的集合 115</span><br><span class="line"></span><br><span class="line">6.2 TTL索引 116</span><br><span class="line"></span><br><span class="line">6.3 全文本索引 116</span><br><span class="line"></span><br><span class="line">6.3.1 搜索语法 119</span><br><span class="line"></span><br><span class="line">6.3.2 优化全文本搜索 120</span><br><span class="line"></span><br><span class="line">6.3.3 在其他语言中搜索 121</span><br><span class="line"></span><br><span class="line">地理空间索引 121</span><br><span class="line"></span><br><span class="line">.1 地理空间查询的类型 122</span><br><span class="line"></span><br><span class="line">.2 复合地理空间索引 123</span><br><span class="line"></span><br><span class="line">.3 2d索引 123</span><br><span class="line"></span><br><span class="line">6.5 使用GridFS存储文件 125</span><br><span class="line"></span><br><span class="line">6.5.1 GridFS入门 126</span><br><span class="line"></span><br><span class="line">6.5.2 在MongoDB驱动程序中使用GridFS 126</span><br><span class="line"></span><br><span class="line">6.5.3 揭开GridFS的面纱 127</span><br><span class="line"></span><br><span class="line">第7章 聚合 129</span><br><span class="line"></span><br><span class="line">7.1 聚合框架 129</span><br><span class="line"></span><br><span class="line">7.2 管道操作符 131</span><br><span class="line"></span><br><span class="line">7.2.1 $match 132</span><br><span class="line"></span><br><span class="line">7.2.2 $project 132</span><br><span class="line"></span><br><span class="line">7.2.3 $group 137</span><br><span class="line"></span><br><span class="line">7.2.4 $unwind 140</span><br><span class="line"></span><br><span class="line">7.2.5 $sort 141</span><br><span class="line"></span><br><span class="line">7.2.6 $limit 142</span><br><span class="line"></span><br><span class="line">7.2.7 $skip 142</span><br><span class="line"></span><br><span class="line">7.2.8 使用管道 142</span><br><span class="line"></span><br><span class="line">7.3 MapReduce 143</span><br><span class="line"></span><br><span class="line">7.3.1 示例1：找出集合中的所有键 143</span><br><span class="line"></span><br><span class="line">7.3.2 示例2：网页分类 145</span><br><span class="line"></span><br><span class="line">7.3.3 MongoDB和MapReduce 146</span><br><span class="line"></span><br><span class="line">7.4 聚合命令 148</span><br><span class="line"></span><br><span class="line">7.4.1 count 149</span><br><span class="line"></span><br><span class="line">7.4.2 distinct 149</span><br><span class="line"></span><br><span class="line">7.4.3 group 150</span><br><span class="line"></span><br><span class="line">第8章 应用程序设计 155</span><br><span class="line"></span><br><span class="line">8.1 范式化与反范式化 155</span><br><span class="line"></span><br><span class="line">8.1.1 数据表示的例子 156</span><br><span class="line"></span><br><span class="line">8.1.2 基数 159</span><br><span class="line"></span><br><span class="line">8.1.3 好友、粉丝，以及其他的麻烦事项 160</span><br><span class="line"></span><br><span class="line">8.2 优化数据操作 162</span><br><span class="line"></span><br><span class="line">8.2.1 优化文档增长 162</span><br><span class="line"></span><br><span class="line">8.2.2 删除旧数据 1</span><br><span class="line"></span><br><span class="line">8.3 数据库和集合的设计 1</span><br><span class="line"></span><br><span class="line">8.4 一致性管理 165</span><br><span class="line"></span><br><span class="line">8.5 模式迁移 166</span><br><span class="line"></span><br><span class="line">8.6 不适合使用MongoDB的场景 167</span><br><span class="line"></span><br><span class="line">第三部分 复制</span><br><span class="line"></span><br><span class="line">第9章 创建副本集 171</span><br><span class="line"></span><br><span class="line">9.1 复制简介 171</span><br><span class="line"></span><br><span class="line">9.2 建立副本集 172</span><br><span class="line"></span><br><span class="line">9.3 配置副本集 176</span><br><span class="line"></span><br><span class="line">9.3.1 rs辅助函数 178</span><br><span class="line"></span><br><span class="line">9.3.2 网络注意事项 178</span><br><span class="line"></span><br><span class="line">9.4 修改副本集配置 178</span><br><span class="line"></span><br><span class="line">9.5 设计副本集 180</span><br><span class="line"></span><br><span class="line">9.6 成员配置选项 184</span><br><span class="line"></span><br><span class="line">9.6.1 选举仲裁者 184</span><br><span class="line"></span><br><span class="line">9.6.2 优先级 185</span><br><span class="line"></span><br><span class="line">9.6.3 隐藏成员 186</span><br><span class="line"></span><br><span class="line">9. 延迟备份节点 187</span><br><span class="line"></span><br><span class="line">9.6.5 创建索引 187</span><br><span class="line"></span><br><span class="line">0章 副本集的组成 189</span><br><span class="line"></span><br><span class="line">10.1 同步 189</span><br><span class="line"></span><br><span class="line">10.1.1 初始化同步 190</span><br><span class="line"></span><br><span class="line">10.1.2 处理陈旧数据 193</span><br><span class="line"></span><br><span class="line">10.2 心跳 193</span><br><span class="line"></span><br><span class="line">10.3 选举 195</span><br><span class="line"></span><br><span class="line">10.4 回滚 195</span><br><span class="line"></span><br><span class="line">1章 从应用程序连接副本集 201</span><br><span class="line"></span><br><span class="line">11.1 客户端到副本集的连接 201</span><br><span class="line"></span><br><span class="line">11.2 等待写入复制 202</span><br><span class="line"></span><br><span class="line">11.2.1 可能导致错误的原因 203</span><br><span class="line"></span><br><span class="line">11.2.2 其他值 204</span><br><span class="line"></span><br><span class="line">11.3 自定义复制保证规则 204</span><br><span class="line"></span><br><span class="line">11.3.1 保证复制到每个数据中心的一台服务器上 204</span><br><span class="line"></span><br><span class="line">11.3.2 保证写操作被复制到可见节点中的“大多数” 206</span><br><span class="line"></span><br><span class="line">11.3.3 创建其他规则 206</span><br><span class="line"></span><br><span class="line">11.4 将读请求发送到备份节点 207</span><br><span class="line"></span><br><span class="line">11.4.1 出于一致性考虑 207</span><br><span class="line"></span><br><span class="line">11.4.2 出于负载的考虑 208</span><br><span class="line"></span><br><span class="line">11.4.3 何时可以从备份节点读取数据 208</span><br><span class="line"></span><br><span class="line">2章 管理 211</span><br><span class="line"></span><br><span class="line">12.1 以单机模式启动成员 211</span><br><span class="line"></span><br><span class="line">12.2 副本集配置 212</span><br><span class="line"></span><br><span class="line">12.2.1 创建副本集 212</span><br><span class="line"></span><br><span class="line">12.2.2 修改副本集成员 213</span><br><span class="line"></span><br><span class="line">12.2.3 创建比较大的副本集 213</span><br><span class="line"></span><br><span class="line">12.2.4 强制重新配置 214</span><br><span class="line"></span><br><span class="line">12.3 修改成员状态 215</span><br><span class="line"></span><br><span class="line">12.3.1 把主节点变为备份节点 215</span><br><span class="line"></span><br><span class="line">12.3.2 阻止选举 215</span><br><span class="line"></span><br><span class="line">12.3.3 使用维护模式 215</span><br><span class="line"></span><br><span class="line">12.4 监控复制 216</span><br><span class="line"></span><br><span class="line">12.4.1 获取状态 216</span><br><span class="line"></span><br><span class="line">12.4.2 复制图谱 218</span><br><span class="line"></span><br><span class="line">12.4.3 复制循环 220</span><br><span class="line"></span><br><span class="line">12.4.4 禁用复制链 220</span><br><span class="line"></span><br><span class="line">12.4.5 计算延迟 221</span><br><span class="line"></span><br><span class="line">12.4.6 调整oplog大小 222</span><br><span class="line"></span><br><span class="line">12.4.7 从延迟备份节点中恢复 223</span><br><span class="line"></span><br><span class="line">12.4.8 创建索引 224</span><br><span class="line"></span><br><span class="line">12.4.9 在预算有限的情况下进行复制 225</span><br><span class="line"></span><br><span class="line">12.4.10 主节点如何跟踪延迟 226</span><br><span class="line"></span><br><span class="line">12.5 主从模式 227</span><br><span class="line"></span><br><span class="line">12.5.1 从主从模式切换到副本集模式 228</span><br><span class="line"></span><br><span class="line">12.5.2 让副本集模仿主从模式的行为 228</span><br><span class="line"></span><br><span class="line">第四部分 分片</span><br><span class="line"></span><br><span class="line">3章 分片 233</span><br><span class="line"></span><br><span class="line">13.1 分片简介 233</span><br><span class="line"></span><br><span class="line">13.2 理解集群的组件 234</span><br><span class="line"></span><br><span class="line">13.3 快速建立一个简单的集群 235</span><br><span class="line"></span><br><span class="line">4章 配置分片 243</span><br><span class="line"></span><br><span class="line">14.1 何时分片 243</span><br><span class="line"></span><br><span class="line">14.2 启动服务器 244</span><br><span class="line"></span><br><span class="line">14.2.1 配置服务器 244</span><br><span class="line"></span><br><span class="line">14.2.2 mongos进程 245</span><br><span class="line"></span><br><span class="line">14.2.3 将副本集转换为分片 245</span><br><span class="line"></span><br><span class="line">14.2.4 增加集群容量 247</span><br><span class="line"></span><br><span class="line">14.2.5 数据分片 247</span><br><span class="line"></span><br><span class="line">14.3 MongoDB如何追踪集群数据 248</span><br><span class="line"></span><br><span class="line">14.3.1 块范围 249</span><br><span class="line"></span><br><span class="line">14.3.2 拆分块 250</span><br><span class="line"></span><br><span class="line">14.4 均衡器 254</span><br><span class="line"></span><br><span class="line">5章 选择片键 257</span><br><span class="line"></span><br><span class="line">15.1 检查使用情况 257</span><br><span class="line"></span><br><span class="line">15.2 数据分发 258</span><br><span class="line"></span><br><span class="line">15.2.1 升序片键 258</span><br><span class="line"></span><br><span class="line">15.2.2 随机分发的片键 261</span><br><span class="line"></span><br><span class="line">15.2.3 基于位置的片键 262</span><br><span class="line"></span><br><span class="line">15.3 片键策略 263</span><br><span class="line"></span><br><span class="line">15.3.1 散列片键 2</span><br><span class="line"></span><br><span class="line">15.3.2 GridFS的散列片键 265</span><br><span class="line"></span><br><span class="line">15.3.3 流水策略 266</span><br><span class="line"></span><br><span class="line">15.3.4 多热点 267</span><br><span class="line"></span><br><span class="line">15.4 片键规则和指导方针 270</span><br><span class="line"></span><br><span class="line">15.4.1 片键 270</span><br><span class="line"></span><br><span class="line">15.4.2 片键的势 270</span><br><span class="line"></span><br><span class="line">15.5 控制数据分发 270</span><br><span class="line"></span><br><span class="line">15.5.1 对多个数据库和集合使用一个集群 270</span><br><span class="line"></span><br><span class="line">15.5.2 手动分片 272</span><br><span class="line"></span><br><span class="line">6章 分片管理 275</span><br><span class="line"></span><br><span class="line">16.1 检查集群状态 275</span><br><span class="line"></span><br><span class="line">16.1.1 使用sh.status查看集群摘要信息 275</span><br><span class="line"></span><br><span class="line">16.1.2 检查配置信息 277</span><br><span class="line"></span><br><span class="line">16.2 查看网络连接 282</span><br><span class="line"></span><br><span class="line">16.2.1 查看连接统计 283</span><br><span class="line"></span><br><span class="line">16.2.2 连接数量 283</span><br><span class="line"></span><br><span class="line">16.3 服务器管理 285</span><br><span class="line"></span><br><span class="line">16.3.1 添加服务器 285</span><br><span class="line"></span><br><span class="line">16.3.2 修改分片的服务器 285</span><br><span class="line"></span><br><span class="line">16.3.3 删除分片 286</span><br><span class="line"></span><br><span class="line">16.3.4 修改配置服务器 288</span><br><span class="line"></span><br><span class="line">1 数据均衡 289</span><br><span class="line"></span><br><span class="line">1.1 均衡器 289</span><br><span class="line"></span><br><span class="line">1.2 修改块大小 290</span><br><span class="line"></span><br><span class="line">1.3 移动块 290</span><br><span class="line"></span><br><span class="line">1.4 特大块 292</span><br><span class="line"></span><br><span class="line">1.5 刷新配置 295</span><br><span class="line"></span><br><span class="line">第五部分 应用管理</span><br><span class="line"></span><br><span class="line">7章 了解应用的动态 299</span><br><span class="line"></span><br><span class="line">17.1 了解正在进行的操作 299</span><br><span class="line"></span><br><span class="line">17.1.1 寻找有问题的操作 301</span><br><span class="line"></span><br><span class="line">17.1.2 终止操作的执行 301</span><br><span class="line"></span><br><span class="line">17.1.3 假象 302</span><br><span class="line"></span><br><span class="line">17.1.4 避免幽灵操作 302</span><br><span class="line"></span><br><span class="line">17.2 使用系统分析器 303</span><br><span class="line"></span><br><span class="line">17.3 计算空间消耗 305</span><br><span class="line"></span><br><span class="line">17.3.1 文档 305</span><br><span class="line"></span><br><span class="line">17.3.2 集合 305</span><br><span class="line"></span><br><span class="line">17.3.3 数据库 306</span><br><span class="line"></span><br><span class="line">17.4 使用mongotop和monogostat 307</span><br><span class="line"></span><br><span class="line">8章 数据管理 311</span><br><span class="line"></span><br><span class="line">18.1 配置身份验证 311</span><br><span class="line"></span><br><span class="line">18.1.1 身份验证基本原理 312</span><br><span class="line"></span><br><span class="line">18.1.2 配置身份验证 313</span><br><span class="line"></span><br><span class="line">18.1.3 身份验证的工作原理 314</span><br><span class="line"></span><br><span class="line">18.2 建立和删除索引 315</span><br><span class="line"></span><br><span class="line">18.2.1 在独立的服务器上建立索引 315</span><br><span class="line"></span><br><span class="line">18.2.2 在副本集上建立索引 315</span><br><span class="line"></span><br><span class="line">18.2.3 在分片集群上建立索引 316</span><br><span class="line"></span><br><span class="line">18.2.4 删除索引 316</span><br><span class="line"></span><br><span class="line">18.2.5 注意内存溢出杀手 316</span><br><span class="line"></span><br><span class="line">18.3 预热数据 317</span><br><span class="line"></span><br><span class="line">18.3.1 将数据库移至内存 317</span><br><span class="line"></span><br><span class="line">18.3.2 将集合移至内存 318</span><br><span class="line"></span><br><span class="line">18.3.3 自定义预热 318</span><br><span class="line"></span><br><span class="line">18.4 压缩数据 320</span><br><span class="line"></span><br><span class="line">18.5 移动集合 321</span><br><span class="line"></span><br><span class="line">18.6 预分配数据文件 322</span><br><span class="line"></span><br><span class="line">9章 持久性 323</span><br><span class="line"></span><br><span class="line">19.1 日记系统的用途 323</span><br><span class="line"></span><br><span class="line">19.1.1 批量提交写入操作 324</span><br><span class="line"></span><br><span class="line">19.1.2 设定提交时间间隔 325</span><br><span class="line"></span><br><span class="line">19.2 关闭日记系统 325</span><br><span class="line"></span><br><span class="line">19.2.1 替换数据文件 325</span><br><span class="line"></span><br><span class="line">19.2.2 修复数据文件 326</span><br><span class="line"></span><br><span class="line">19.2.3 关于mongod.lock文件 326</span><br><span class="line"></span><br><span class="line">19.2.4 隐蔽的异常退出 327</span><br><span class="line"></span><br><span class="line">19.3 MongoDB无法保证的事项 327</span><br><span class="line"></span><br><span class="line">19.4 检验数据损坏 327</span><br><span class="line"></span><br><span class="line">19.5 副本集中的持久性 329</span><br><span class="line"></span><br><span class="line">第六部分 服务器管理</span><br><span class="line"></span><br><span class="line">第20章 启动和停止MongoDB 333</span><br><span class="line"></span><br><span class="line">20.1 从命令行启动 333</span><br><span class="line"></span><br><span class="line">20.2 停止MongoDB 336</span><br><span class="line"></span><br><span class="line">20.3 安全性 337</span><br><span class="line"></span><br><span class="line">20.3.1 数据加密 338</span><br><span class="line"></span><br><span class="line">20.3.2 SSL安全连接 338</span><br><span class="line"></span><br><span class="line">20.4 日志 338</span><br><span class="line"></span><br><span class="line">第21章 监控MongoDB 341</span><br><span class="line"></span><br><span class="line">21.1 监控内存使用状况 341</span><br><span class="line"></span><br><span class="line">21.1.1 有关电脑内存的介绍 341</span><br><span class="line"></span><br><span class="line">21.1.2 跟踪监测内存使用状况 342</span><br><span class="line"></span><br><span class="line">21.1.3 跟踪监测缺页中断 343</span><br><span class="line"></span><br><span class="line">21.1.4 减少索引树的脱靶次数 345</span><br><span class="line"></span><br><span class="line">21.1.5 IO延迟 345</span><br><span class="line"></span><br><span class="line">21.1.6 跟踪监测后台刷新平均时间 346</span><br><span class="line"></span><br><span class="line">21.2 计算工作集的大小 347</span><br><span class="line"></span><br><span class="line">21.3 跟踪监测性能状况 349</span><br><span class="line"></span><br><span class="line">21.4 监控副本集 352</span><br><span class="line"></span><br><span class="line">第22章 备份 355</span><br><span class="line"></span><br><span class="line">22.1 对服务器进行备份 355</span><br><span class="line"></span><br><span class="line">22.1.1 文件系统快照 355</span><br><span class="line"></span><br><span class="line">22.1.2 复制数据文件 356</span><br><span class="line"></span><br><span class="line">22.1.3 使用mongodump 357</span><br><span class="line"></span><br><span class="line">22.2 对副本集进行备份 359</span><br><span class="line"></span><br><span class="line">22.3 对分片集群进行备份 360</span><br><span class="line"></span><br><span class="line">22.3.1 备份和恢复整个集群 360</span><br><span class="line"></span><br><span class="line">22.3.2 备份和恢复单独的分片 360</span><br><span class="line"></span><br><span class="line">22.4 使用mongooplog进行增量备份 361</span><br><span class="line"></span><br><span class="line">第23章 部署MongoDB 363</span><br><span class="line"></span><br><span class="line">23.1 设计系统结构 363</span><br><span class="line"></span><br><span class="line">23.1.1 选择存储介质 363</span><br><span class="line"></span><br><span class="line">23.1.2 推荐的RAID配置 367</span><br><span class="line"></span><br><span class="line">23.1.3 CPU 368</span><br><span class="line"></span><br><span class="line">23.1.4 选择操作系统 368</span><br><span class="line"></span><br><span class="line">23.1.5 交换空间 369</span><br><span class="line"></span><br><span class="line">23.1.6 文件系统 369</span><br><span class="line"></span><br><span class="line">23.2 虚拟化 370</span><br><span class="line"></span><br><span class="line">23.2.1 禁止内存过度分配 370</span><br><span class="line"></span><br><span class="line">23.2.2 神秘的内存 370</span><br><span class="line"></span><br><span class="line">23.2.3 处理网络磁盘的IO问题 371</span><br><span class="line"></span><br><span class="line">23.2.4 使用非网络磁盘 372</span><br><span class="line"></span><br><span class="line">23.3 系统配置 372</span><br><span class="line"></span><br><span class="line">23.3.1 禁用NUMA 372</span><br><span class="line"></span><br><span class="line">23.3.2 更智能地预读取数据 375</span><br><span class="line"></span><br><span class="line">23.3.3 禁用大内存页面 376</span><br><span class="line"></span><br><span class="line">23.3.4 选择一种磁盘调度算法 377</span><br><span class="line"></span><br><span class="line">23.3.5 不要记录访问时间 377</span><br><span class="line"></span><br><span class="line">23.3.6 修改 378</span><br><span class="line"></span><br><span class="line">23.4 网络配置 379</span><br><span class="line"></span><br><span class="line">23.5 系统管理 381</span><br><span class="line"></span><br><span class="line">23.5.1 时钟同步 381</span><br><span class="line"></span><br><span class="line">23.5.2 OOMKiller 381</span><br><span class="line"></span><br><span class="line">23.5.3 关闭定期任务 382</span><br><span class="line"></span><br><span class="line">附录A 安装MongoDB 383</span><br><span class="line"></span><br><span class="line">附录B 深入MongoDB 387</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>Spark快速大数据分析 PDF</title>
    <url>/posts/69976988/</url>
    <content><![CDATA[<h4 id="《Spark快速大数据分析》"><a href="#《Spark快速大数据分析》" class="headerlink" title="《Spark快速大数据分析》"></a>《Spark快速大数据分析》</h4><h6 id="链接-https-pan-baidu-com-s-1Vk0DSbD-x70BqghyU2hlaA-提取码-i6av"><a href="#链接-https-pan-baidu-com-s-1Vk0DSbD-x70BqghyU2hlaA-提取码-i6av" class="headerlink" title="链接: https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA 提取码: i6av"></a>链接: <a href="https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA">https://pan.baidu.com/s/1Vk0DSbD_x70BqghyU2hlaA</a> 提取码: i6av</h6><p>《Spark快速大数据分析》由 Spark 开发者及核心成员共同打造，讲解了网络大数据时代应运而生的、能高效迅捷地分析处理数据的工具——Spark，它带领读者快速掌握用 Spark 收集、计算、简化和保存海量数据的方法，学会交互、迭代和增量式分析，解决分区、数据本地化和自定义序列化等问题。<br><a id="more"></a></p>
<p><img src="/images/154781ecd5c7691028feb106be190aac1.jpg" width="50%" height="50%"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">目录</span><br><span class="line"></span><br><span class="line">推荐序　　xi</span><br><span class="line"></span><br><span class="line">译者序　　xiv</span><br><span class="line"></span><br><span class="line">序　　xvi</span><br><span class="line"></span><br><span class="line">前言　　xvii</span><br><span class="line"></span><br><span class="line">第1章　Spark数据分析导论　　1</span><br><span class="line"></span><br><span class="line">1．1　Spark是什么　　1</span><br><span class="line"></span><br><span class="line">1．2　一个大一统的软件栈　　2</span><br><span class="line"></span><br><span class="line">1．2．1　Spark Core　　2</span><br><span class="line"></span><br><span class="line">1．2．2　Spark SQL　　3</span><br><span class="line"></span><br><span class="line">1．2．3　Spark Streaming　　3</span><br><span class="line"></span><br><span class="line">1．2．4　MLlib　　3</span><br><span class="line"></span><br><span class="line">1．2．5　GraphX　　3</span><br><span class="line"></span><br><span class="line">1．2．6　集群管理器　　4</span><br><span class="line"></span><br><span class="line">1．3　Spark的用户和用途　　4</span><br><span class="line"></span><br><span class="line">1．3．1　数据科学任务　　4</span><br><span class="line"></span><br><span class="line">1．3．2　数据处理应用　　5</span><br><span class="line"></span><br><span class="line">1．4　Spark简史　　5</span><br><span class="line"></span><br><span class="line">1．5　Spark的版本和发布　　6</span><br><span class="line"></span><br><span class="line">1．6　Spark的存储层次　　6</span><br><span class="line"></span><br><span class="line">第2章　Spark下载与入门　　7</span><br><span class="line"></span><br><span class="line">2．1　下载Spark　　7</span><br><span class="line"></span><br><span class="line">2．2　Spark中Python和Scala的shell　　9</span><br><span class="line"></span><br><span class="line">2．3　Spark 核心概念简介　　12</span><br><span class="line"></span><br><span class="line">2．4　独立应用　　14</span><br><span class="line"></span><br><span class="line">2．4．1　初始化SparkContext　　15</span><br><span class="line"></span><br><span class="line">2．4．2　构建独立应用　　16</span><br><span class="line"></span><br><span class="line">2．5　总结　　19</span><br><span class="line"></span><br><span class="line">第3章　RDD编程　　21</span><br><span class="line"></span><br><span class="line">3．1　RDD基础　　21</span><br><span class="line"></span><br><span class="line">3．2　创建RDD　　23</span><br><span class="line"></span><br><span class="line">3．3　RDD操作　　24</span><br><span class="line"></span><br><span class="line">3．3．1　转化操作　　24</span><br><span class="line"></span><br><span class="line">3．3．2　行动操作　　26</span><br><span class="line"></span><br><span class="line">3．3．3　惰性求值　　27</span><br><span class="line"></span><br><span class="line">3．4　向Spark传递函数　　27</span><br><span class="line"></span><br><span class="line">3．4．1　Python　　27</span><br><span class="line"></span><br><span class="line">3．4．2　Scala　　28</span><br><span class="line"></span><br><span class="line">3．4．3　Java　　29</span><br><span class="line"></span><br><span class="line">3．5　常见的转化操作和行动操作　　30</span><br><span class="line"></span><br><span class="line">3．5．1　基本RDD　　30</span><br><span class="line"></span><br><span class="line">3．5．2　在不同RDD类型间转换　　37</span><br><span class="line"></span><br><span class="line">3．6　持久化( 缓存)　　39</span><br><span class="line"></span><br><span class="line">3．7　总结　　40</span><br><span class="line"></span><br><span class="line">第4章　键值对操作　　41</span><br><span class="line"></span><br><span class="line">4．1　动机　　41</span><br><span class="line"></span><br><span class="line">4．2　创建Pair RDD　　42</span><br><span class="line"></span><br><span class="line">4．3　Pair RDD的转化操作　　42</span><br><span class="line"></span><br><span class="line">4．3．1　聚合操作　　45</span><br><span class="line"></span><br><span class="line">4．3．2　数据分组　　49</span><br><span class="line"></span><br><span class="line">4．3．3　连接　　50</span><br><span class="line"></span><br><span class="line">4．3．4　数据排序　　51</span><br><span class="line"></span><br><span class="line">4．4　Pair RDD的行动操作　　52</span><br><span class="line"></span><br><span class="line">4．5　数据分区（进阶）　　52</span><br><span class="line"></span><br><span class="line">4．5．1　获取RDD的分区方式　　55</span><br><span class="line"></span><br><span class="line">4．5．2　从分区中获益的操作　　56</span><br><span class="line"></span><br><span class="line">4．5．3　影响分区方式的操作　　57</span><br><span class="line"></span><br><span class="line">4．5．4　示例：PageRank　　57</span><br><span class="line"></span><br><span class="line">4．5．5　自定义分区方式　　59</span><br><span class="line"></span><br><span class="line">4．6　总结　　61</span><br><span class="line"></span><br><span class="line">第5章　数据读取与保存　　63</span><br><span class="line"></span><br><span class="line">5．1　动机　　63</span><br><span class="line"></span><br><span class="line">5．2　文件格式　　64</span><br><span class="line"></span><br><span class="line">5．2．1　文本文件　　64</span><br><span class="line"></span><br><span class="line">5．2．2　JSON　　66</span><br><span class="line"></span><br><span class="line">5．2．3　逗号分隔值与制表符分隔值　　68</span><br><span class="line"></span><br><span class="line">5．2．4　SequenceFile　　71</span><br><span class="line"></span><br><span class="line">5．2．5　对象文件　　73</span><br><span class="line"></span><br><span class="line">5．2．6　Hadoop输入输出格式　　73</span><br><span class="line"></span><br><span class="line">5．2．7　文件压缩　　77</span><br><span class="line"></span><br><span class="line">5．3　文件系统　　78</span><br><span class="line"></span><br><span class="line">5．3．1　本地&#x2F;“常规”文件系统　　78</span><br><span class="line"></span><br><span class="line">5．3．2　Amazon S3　　78</span><br><span class="line"></span><br><span class="line">5．3．3　HDFS　　79</span><br><span class="line"></span><br><span class="line">5．4　Spark SQL中的结构化数据　　79</span><br><span class="line"></span><br><span class="line">5．4．1　Apache Hive　　80</span><br><span class="line"></span><br><span class="line">5．4．2　JSON　　80</span><br><span class="line"></span><br><span class="line">5．5　数据库　　81</span><br><span class="line"></span><br><span class="line">5．5．1　Java数据库连接　　81</span><br><span class="line"></span><br><span class="line">5．5．2　Cassandra　　82</span><br><span class="line"></span><br><span class="line">5．5．3　HBase　　84</span><br><span class="line"></span><br><span class="line">5．5．4　Elasticsearch　　85</span><br><span class="line"></span><br><span class="line">5．6　总结　　86</span><br><span class="line"></span><br><span class="line">第6章　Spark编程进阶　　87</span><br><span class="line"></span><br><span class="line">6．1　简介　　87</span><br><span class="line"></span><br><span class="line">6．2　累加器　　88</span><br><span class="line"></span><br><span class="line">6．2．1　累加器与容错性　　90</span><br><span class="line"></span><br><span class="line">6．2．2　自定义累加器　　91</span><br><span class="line"></span><br><span class="line">6．3　广播变量　　91</span><br><span class="line"></span><br><span class="line">6．4　基于分区进行操作　　94</span><br><span class="line"></span><br><span class="line">6．5　与外部程序间的管道　　96</span><br><span class="line"></span><br><span class="line">6．6　数值RDD 的操作　　99</span><br><span class="line"></span><br><span class="line">6．7　总结　　100</span><br><span class="line"></span><br><span class="line">第7章　在集群上运行Spark　　101</span><br><span class="line"></span><br><span class="line">7．1　简介　　101</span><br><span class="line"></span><br><span class="line">7．2　Spark运行时架构　　101</span><br><span class="line"></span><br><span class="line">7．2．1　驱动器节点　　102</span><br><span class="line"></span><br><span class="line">7．2．2　执行器节点　　103</span><br><span class="line"></span><br><span class="line">7．2．3　集群管理器　　103</span><br><span class="line"></span><br><span class="line">7．2．4　启动一个程序　　104</span><br><span class="line"></span><br><span class="line">7．2．5　小结　　104</span><br><span class="line"></span><br><span class="line">7．3　使用spark-submit 部署应用　　105</span><br><span class="line"></span><br><span class="line">7．4　打包代码与依赖　　107</span><br><span class="line"></span><br><span class="line">7．4．1　使用Maven构建的用Java编写的Spark应用　　108</span><br><span class="line"></span><br><span class="line">7．4．2　使用sbt构建的用Scala编写的Spark应用　　109</span><br><span class="line"></span><br><span class="line">7．4．3　依赖冲突　　 111</span><br><span class="line"></span><br><span class="line">7．5　Spark应用内与应用间调度　　111</span><br><span class="line"></span><br><span class="line">7．6　集群管理器　　112</span><br><span class="line"></span><br><span class="line">7．6．1　独立集群管理器　　112</span><br><span class="line"></span><br><span class="line">7．6．2　Hadoop YARN　　115</span><br><span class="line"></span><br><span class="line">7．6．3　Apache Mesos　　116</span><br><span class="line"></span><br><span class="line">7．6．4　Amazon EC2　　117</span><br><span class="line"></span><br><span class="line">7．7　选择合适的集群管理器　　120</span><br><span class="line"></span><br><span class="line">7．8　总结　　121</span><br><span class="line"></span><br><span class="line">第8章　Spark调优与调试　　123</span><br><span class="line"></span><br><span class="line">8．1　使用SparkConf配置Spark　　123</span><br><span class="line"></span><br><span class="line">8．2　Spark执行的组成部分：作业、任务和步骤　　127</span><br><span class="line"></span><br><span class="line">8．3　查找信息　　131</span><br><span class="line"></span><br><span class="line">8．3．1　Spark网页用户界面　　131</span><br><span class="line"></span><br><span class="line">8．3．2　驱动器进程和执行器进程的日志　　134</span><br><span class="line"></span><br><span class="line">8．4　关键性能考量　　135</span><br><span class="line"></span><br><span class="line">8．4．1　并行度　　135</span><br><span class="line"></span><br><span class="line">8．4．2　序列化格式　　136</span><br><span class="line"></span><br><span class="line">8．4．3　内存管理　　137</span><br><span class="line"></span><br><span class="line">8．4．4　硬件供给　　138</span><br><span class="line"></span><br><span class="line">8．5　总结　　139</span><br><span class="line"></span><br><span class="line">第9章　Spark SQL　　141</span><br><span class="line"></span><br><span class="line">9．1　连接Spark SQL　　142</span><br><span class="line"></span><br><span class="line">9．2　在应用中使用Spark SQL　　144</span><br><span class="line"></span><br><span class="line">9．2．1　初始化Spark SQL　　144</span><br><span class="line"></span><br><span class="line">9．2．2　基本查询示例　　145</span><br><span class="line"></span><br><span class="line">9．2．3　SchemaRDD　　146</span><br><span class="line"></span><br><span class="line">9．2．4　缓存　　148</span><br><span class="line"></span><br><span class="line">9．3　读取和存储数据　　149</span><br><span class="line"></span><br><span class="line">9．3．1　Apache Hive　　149</span><br><span class="line"></span><br><span class="line">9．3．2　Parquet　　150</span><br><span class="line"></span><br><span class="line">9．3．3　JSON　　150</span><br><span class="line"></span><br><span class="line">9．3．4　基于RDD　　152</span><br><span class="line"></span><br><span class="line">9．4　JDBC&#x2F;ODBC服务器　　153</span><br><span class="line"></span><br><span class="line">9．4．1　使用Beeline　　155</span><br><span class="line"></span><br><span class="line">9．4．2　长生命周期的表与查询　　156</span><br><span class="line"></span><br><span class="line">9．5　用户自定义函数　　156</span><br><span class="line"></span><br><span class="line">9．5．1　Spark SQL UDF　　156</span><br><span class="line"></span><br><span class="line">9．5．2　Hive UDF　　157</span><br><span class="line"></span><br><span class="line">9．6　Spark SQL性能　　158</span><br><span class="line"></span><br><span class="line">9．7　总结　　159</span><br><span class="line"></span><br><span class="line">第10章　Spark Streaming　　161</span><br><span class="line"></span><br><span class="line">10．1　一个简单的例子　　162</span><br><span class="line"></span><br><span class="line">10．2　架构与抽象　　164</span><br><span class="line"></span><br><span class="line">10．3　转化操作　　167</span><br><span class="line"></span><br><span class="line">10．3．1　无状态转化操作　　167</span><br><span class="line"></span><br><span class="line">10．3．2　有状态转化操作　　169</span><br><span class="line"></span><br><span class="line">10．4　输出操作　　173</span><br><span class="line"></span><br><span class="line">10．5　输入源　　175</span><br><span class="line"></span><br><span class="line">10．5．1　核心数据源　　175</span><br><span class="line"></span><br><span class="line">10．5．2　附加数据源　　176</span><br><span class="line"></span><br><span class="line">10．5．3　多数据源与集群规模　　179</span><br><span class="line"></span><br><span class="line">10．6　24&#x2F;7不间断运行　　180</span><br><span class="line"></span><br><span class="line">10．6．1　检查点机制　　180</span><br><span class="line"></span><br><span class="line">10．6．2　驱动器程序容错　　181</span><br><span class="line"></span><br><span class="line">10．6．3　工作节点容错　　182</span><br><span class="line"></span><br><span class="line">10．6．4　接收器容错　　182</span><br><span class="line"></span><br><span class="line">10．6．5　处理保证　　183</span><br><span class="line"></span><br><span class="line">10．7　Streaming用户界面　　183</span><br><span class="line"></span><br><span class="line">10．8　性能考量　　184</span><br><span class="line"></span><br><span class="line">10．8．1　批次和窗口大小　　184</span><br><span class="line"></span><br><span class="line">10．8．2　并行度　　184</span><br><span class="line"></span><br><span class="line">10．8．3　垃圾回收和内存使用　　185</span><br><span class="line"></span><br><span class="line">10．9　总结　　185</span><br><span class="line"></span><br><span class="line">第11章　基于MLlib的机器学习　　187</span><br><span class="line"></span><br><span class="line">11．1　概述　　187</span><br><span class="line"></span><br><span class="line">11．2　系统要求　　188</span><br><span class="line"></span><br><span class="line">11．3　机器学习基础　　189</span><br><span class="line"></span><br><span class="line">11．4　数据类型　　192</span><br><span class="line"></span><br><span class="line">11．5　算法　　194</span><br><span class="line"></span><br><span class="line">11．5．1　特征提取　　194</span><br><span class="line"></span><br><span class="line">11．5．2　统计　　196</span><br><span class="line"></span><br><span class="line">11．5．3　分类与回归　　197</span><br><span class="line"></span><br><span class="line">11．5．4　聚类　　202</span><br><span class="line"></span><br><span class="line">11．5．5　协同过滤与推荐　　203</span><br><span class="line"></span><br><span class="line">11．5．6　降维　　204</span><br><span class="line"></span><br><span class="line">11．5．7　模型评估　　206</span><br><span class="line"></span><br><span class="line">11．6　一些提示与性能考量　　206</span><br><span class="line"></span><br><span class="line">11．6．1　准备特征　　206</span><br><span class="line"></span><br><span class="line">11．6．2　配置算法　　207</span><br><span class="line"></span><br><span class="line">11．6．3　缓存RDD以重复使用　　207</span><br><span class="line"></span><br><span class="line">11．6．4　识别稀疏程度　　207</span><br><span class="line"></span><br><span class="line">11．6．5　并行度　　207</span><br><span class="line"></span><br><span class="line">11．7　流水线API　　208</span><br><span class="line"></span><br><span class="line">11．8　总结　　209</span><br><span class="line"></span><br><span class="line">作者简介　　210</span><br><span class="line"></span><br><span class="line">封面介绍　　210</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>最后，这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
  <entry>
    <title>《机器学习》周志华-西瓜书PDF</title>
    <url>/posts/d92a0946/</url>
    <content><![CDATA[<h4 id="书籍名称"><a href="#书籍名称" class="headerlink" title="书籍名称"></a>书籍名称</h4><p><strong>《机器学习》周志华-西瓜书 PDF</strong></p>
<p>链接:<a href="https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA">https://pan.baidu.com/s/1oTJjTkxK0PuV2nRExq1wcA</a> 提取码:odp0</p>
<p><img src="/images/c04ff56125cfc9f61fe032af1498c7dd1.jpg" width="50%" height="50%"></p>
<a id="more"></a>
<p>机器学习是计算机科学与人工智能的重要分支领域. 本书作为该领域的入门教材，在内容上尽可能涵盖机器学习基础知识的各方面. 全书共16 章，大致分为3 个部分：第1 部分（第1～3 章）介绍机器学习的基础知识；第2 部分（第4～10 章）讨论一些经典而常用的机器学习方法（决策树、神经网络、支持向量机、贝叶斯分类器、集成学习、聚类、降维与度量学习）；第3 部分（第11～16 章）为进阶知识，内容涉及特征选择与稀疏学习、计算学习理论、半监督学习、概率图模型、规则学习以及强化学习等. 每章都附有习题并介绍了相关阅读材料，以便有兴趣的读者进一步钻研探索。</p>
<p>本书可作为高等院校计算机、自动化及相关专业的本科生或研究生教材，也可供对机器学习感兴趣的研究人员和工程技术人员阅读参考。</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">第1章 1</span><br><span class="line"></span><br><span class="line">1.1 引言 1</span><br><span class="line"></span><br><span class="line">1.2 基本术 2</span><br><span class="line"></span><br><span class="line">1.3 假设空间 4</span><br><span class="line"></span><br><span class="line">1.4 归纳偏好 6</span><br><span class="line"></span><br><span class="line">1.5 发展历程 10</span><br><span class="line"></span><br><span class="line">1.6 应用现状 13</span><br><span class="line"></span><br><span class="line">1.7 阅读材料 16</span><br><span class="line"></span><br><span class="line">习题 19</span><br><span class="line"></span><br><span class="line">参考文献 20</span><br><span class="line"></span><br><span class="line">休息一会儿 22</span><br><span class="line"></span><br><span class="line">第2章 模型评估与选择 23</span><br><span class="line"></span><br><span class="line">2.1 经验误差与过拟合 23</span><br><span class="line"></span><br><span class="line">2.2 评估方法 24</span><br><span class="line"></span><br><span class="line">2.2.1 留出法 25</span><br><span class="line"></span><br><span class="line">2.2.2 交叉验证法 26</span><br><span class="line"></span><br><span class="line">2.2.3 自助法 27</span><br><span class="line"></span><br><span class="line">2.2.4 调参与最终模型 28</span><br><span class="line"></span><br><span class="line">2.3 性能度量 28</span><br><span class="line"></span><br><span class="line">2.3.1 错误率与精度 29</span><br><span class="line"></span><br><span class="line">2.3.2 查准率、查全率与F1 30</span><br><span class="line"></span><br><span class="line">2.3.3 ROC与AUC 33</span><br><span class="line"></span><br><span class="line">2.3.4 代价敏感错误率与代价曲线 35</span><br><span class="line"></span><br><span class="line">2.4 比较检验 37</span><br><span class="line"></span><br><span class="line">2.4.1 假设检验 37</span><br><span class="line"></span><br><span class="line">2.4.2 交叉验证t检验 40</span><br><span class="line"></span><br><span class="line">2.4.3 McNemar检验 41</span><br><span class="line"></span><br><span class="line">2.4.4 Friedman检验与后续检验 42</span><br><span class="line"></span><br><span class="line">2.5 偏差与方差 44</span><br><span class="line"></span><br><span class="line">2.6 阅读材料 46</span><br><span class="line"></span><br><span class="line">习题 48</span><br><span class="line"></span><br><span class="line">参考文献 49</span><br><span class="line"></span><br><span class="line">休息一会儿 51</span><br><span class="line"></span><br><span class="line">第3章 线性模型 53</span><br><span class="line"></span><br><span class="line">3.1 基本形式 53</span><br><span class="line"></span><br><span class="line">3.2 线性回归 53</span><br><span class="line"></span><br><span class="line">3.3 对数几率回归 57</span><br><span class="line"></span><br><span class="line">3.4 线性判别分析 60</span><br><span class="line"></span><br><span class="line">3.5 多分类学习 63</span><br><span class="line"></span><br><span class="line">3.6 类别不平衡问题 66</span><br><span class="line"></span><br><span class="line">3.7 阅读材料 67</span><br><span class="line"></span><br><span class="line">习题 69</span><br><span class="line"></span><br><span class="line">参考文献 70</span><br><span class="line"></span><br><span class="line">休息一会儿 72</span><br><span class="line"></span><br><span class="line">第4章 决策树 73</span><br><span class="line"></span><br><span class="line">4.1 基本流程 73</span><br><span class="line"></span><br><span class="line">4.2 划分选择 75</span><br><span class="line"></span><br><span class="line">4.2.1 信息增益 75</span><br><span class="line"></span><br><span class="line">4.2.2 增益率 77</span><br><span class="line"></span><br><span class="line">4.2.3 基尼指数 79</span><br><span class="line"></span><br><span class="line">4.3 剪枝处理 79</span><br><span class="line"></span><br><span class="line">4.3.1 预剪枝 80</span><br><span class="line"></span><br><span class="line">4.3.2 后剪枝 82</span><br><span class="line"></span><br><span class="line">4.4 连续与缺失值 83</span><br><span class="line"></span><br><span class="line">4.4.1 连续值处理 83</span><br><span class="line"></span><br><span class="line">4.4.2 缺失值处理 85</span><br><span class="line"></span><br><span class="line">4.5 多变量决策树 88</span><br><span class="line"></span><br><span class="line">4.6 阅读材料 92</span><br><span class="line"></span><br><span class="line">习题 93</span><br><span class="line"></span><br><span class="line">参考文献 94</span><br><span class="line"></span><br><span class="line">休息一会儿 95</span><br><span class="line"></span><br><span class="line">第5章 神经网络 97</span><br><span class="line"></span><br><span class="line">5.1 神经元模型 97</span><br><span class="line"></span><br><span class="line">5.2 感知机与多层网络 98</span><br><span class="line"></span><br><span class="line">5.3 误差逆传播算法 101</span><br><span class="line"></span><br><span class="line">5.4 全局最小与局部极小 106</span><br><span class="line"></span><br><span class="line">5.5 其他常见神经网络 108</span><br><span class="line"></span><br><span class="line">5.5.1 RBF网络 108</span><br><span class="line"></span><br><span class="line">5.5.2 ART网络 108</span><br><span class="line"></span><br><span class="line">5.5.3 SOM网络 109</span><br><span class="line"></span><br><span class="line">5.5.4 级联相关网络 110</span><br><span class="line"></span><br><span class="line">5.5.5 Elman网络 111</span><br><span class="line"></span><br><span class="line">5.5.6 Boltzmann机 111</span><br><span class="line"></span><br><span class="line">5.6 深度学习 113</span><br><span class="line"></span><br><span class="line">5.7 阅读材料 115</span><br><span class="line"></span><br><span class="line">习题 116</span><br><span class="line"></span><br><span class="line">参考文献 117</span><br><span class="line"></span><br><span class="line">休息一会儿 120</span><br><span class="line"></span><br><span class="line">第6章 支持向量机 121</span><br><span class="line"></span><br><span class="line">6.1 间隔与支持向量 121</span><br><span class="line"></span><br><span class="line">6.2 对偶问题 123</span><br><span class="line"></span><br><span class="line">6.3 核函数 126</span><br><span class="line"></span><br><span class="line">6.4 软间隔与正则化 129</span><br><span class="line"></span><br><span class="line">6.5 支持向量回归 133</span><br><span class="line"></span><br><span class="line">6.6 核方法 137</span><br><span class="line"></span><br><span class="line">6.7 阅读材料 139</span><br><span class="line"></span><br><span class="line">习题 141</span><br><span class="line"></span><br><span class="line">参考文献 142</span><br><span class="line"></span><br><span class="line">休息一会儿 145</span><br><span class="line"></span><br><span class="line">第7章 贝叶斯分类器 147</span><br><span class="line"></span><br><span class="line">7.1 贝叶斯决策论 147</span><br><span class="line"></span><br><span class="line">7.2 极大似然估计 149</span><br><span class="line"></span><br><span class="line">7.3 朴素贝叶斯分类器 150</span><br><span class="line"></span><br><span class="line">7.4 半朴素贝叶斯分类器 154</span><br><span class="line"></span><br><span class="line">7.5 贝叶斯网 156</span><br><span class="line"></span><br><span class="line">7.5.1 结构 157</span><br><span class="line"></span><br><span class="line">7.5.2 学习 159</span><br><span class="line"></span><br><span class="line">7.5.3 推断 161</span><br><span class="line"></span><br><span class="line">7.6 EM算法 162</span><br><span class="line"></span><br><span class="line">7.7 阅读材料 164</span><br><span class="line"></span><br><span class="line">习题 166</span><br><span class="line"></span><br><span class="line">参考文献 167</span><br><span class="line"></span><br><span class="line">休息一会儿 169</span><br><span class="line"></span><br><span class="line">第8章 集成学习 171</span><br><span class="line"></span><br><span class="line">8.1 个体与集成 171</span><br><span class="line"></span><br><span class="line">8.2 Boosting 173</span><br><span class="line"></span><br><span class="line">8.3 Bagging与随机森林 178</span><br><span class="line"></span><br><span class="line">8.3.1 Bagging 178</span><br><span class="line"></span><br><span class="line">8.3.2 随机森林 179</span><br><span class="line"></span><br><span class="line">8.4 结合策略 181</span><br><span class="line"></span><br><span class="line">8.4.1 平均法 181</span><br><span class="line"></span><br><span class="line">8.4.2 投票法 182</span><br><span class="line"></span><br><span class="line">8.4.3 学习法 183</span><br><span class="line"></span><br><span class="line">8.5 多样性 185</span><br><span class="line"></span><br><span class="line">8.5.1 误差--分歧分解 185</span><br><span class="line"></span><br><span class="line">8.5.2 多样性度量 186</span><br><span class="line"></span><br><span class="line">8.5.3 多样性增强 188</span><br><span class="line"></span><br><span class="line">8.6 阅读材料 190</span><br><span class="line"></span><br><span class="line">习题 192</span><br><span class="line"></span><br><span class="line">参考文献 193</span><br><span class="line"></span><br><span class="line">休息一会儿 196</span><br><span class="line"></span><br><span class="line">第9章 聚类 197</span><br><span class="line"></span><br><span class="line">9.1 聚类任务 197</span><br><span class="line"></span><br><span class="line">9.2 性能度量 197</span><br><span class="line"></span><br><span class="line">9.3 距离计算 199</span><br><span class="line"></span><br><span class="line">9.4 原型聚类 202</span><br><span class="line"></span><br><span class="line">9.4.1 k均值算法 202</span><br><span class="line"></span><br><span class="line">9.4.2 学习向量量化 204</span><br><span class="line"></span><br><span class="line">9.4.3 高斯混合聚类 206</span><br><span class="line"></span><br><span class="line">9.5 密度聚类 211</span><br><span class="line"></span><br><span class="line">9.6 层次聚类 214</span><br><span class="line"></span><br><span class="line">9.7 阅读材料 217</span><br><span class="line"></span><br><span class="line">习题 220</span><br><span class="line"></span><br><span class="line">参考文献 221</span><br><span class="line"></span><br><span class="line">休息一会儿 224</span><br><span class="line"></span><br><span class="line">第10章 降维与度量学习 225</span><br><span class="line"></span><br><span class="line">10.1 k近邻学习 225</span><br><span class="line"></span><br><span class="line">10.2 低维嵌入 226</span><br><span class="line"></span><br><span class="line">10.3 主成分分析 229</span><br><span class="line"></span><br><span class="line">10.4 核化线性降维 232</span><br><span class="line"></span><br><span class="line">10.5 流形学习 234</span><br><span class="line"></span><br><span class="line">10.5.1 等度量映射 234</span><br><span class="line"></span><br><span class="line">10.5.2 局部线性嵌入 235</span><br><span class="line"></span><br><span class="line">10.6 度量学习 237</span><br><span class="line"></span><br><span class="line">10.7 阅读材料 240</span><br><span class="line"></span><br><span class="line">习题 242</span><br><span class="line"></span><br><span class="line">参考文献 243</span><br><span class="line"></span><br><span class="line">休息一会儿 246</span><br><span class="line"></span><br><span class="line">第11章 特征选择与稀疏学习 247</span><br><span class="line"></span><br><span class="line">11.1 子集搜索与评价 247</span><br><span class="line"></span><br><span class="line">11.2 过滤式选择 249</span><br><span class="line"></span><br><span class="line">11.3 包裹式选择 250</span><br><span class="line"></span><br><span class="line">11.4 嵌入式选择与L$_1$正则化 252</span><br><span class="line"></span><br><span class="line">11.5 稀疏表示与字典学习 254</span><br><span class="line"></span><br><span class="line">11.6 压缩感知 257</span><br><span class="line"></span><br><span class="line">11.7 阅读材料 260</span><br><span class="line"></span><br><span class="line">习题 262</span><br><span class="line"></span><br><span class="line">参考文献 263</span><br><span class="line"></span><br><span class="line">休息一会儿 266</span><br><span class="line"></span><br><span class="line">第12章 计算学习理论 267</span><br><span class="line"></span><br><span class="line">12.1 基础知识 267</span><br><span class="line"></span><br><span class="line">12.2 PAC学习 268</span><br><span class="line"></span><br><span class="line">12.3 有限假设空间 270</span><br><span class="line"></span><br><span class="line">12.3.1 可分情形 270</span><br><span class="line"></span><br><span class="line">12.3.2 不可分情形 272</span><br><span class="line"></span><br><span class="line">12.4 VC维 273</span><br><span class="line"></span><br><span class="line">12.5 Rademacher复杂度 279</span><br><span class="line"></span><br><span class="line">12.6 稳定性 284</span><br><span class="line"></span><br><span class="line">12.7 阅读材料 287</span><br><span class="line"></span><br><span class="line">习题 289</span><br><span class="line"></span><br><span class="line">参考文献 290</span><br><span class="line"></span><br><span class="line">休息一会儿 292</span><br><span class="line"></span><br><span class="line">第13章 半监督学习 293</span><br><span class="line"></span><br><span class="line">13.1 未标记样本 293</span><br><span class="line"></span><br><span class="line">13.2 生成式方法 295</span><br><span class="line"></span><br><span class="line">13.3 半监督SVM 298</span><br><span class="line"></span><br><span class="line">13.4 图半监督学习 300</span><br><span class="line"></span><br><span class="line">13.5 基于分歧的方法 304</span><br><span class="line"></span><br><span class="line">13.6 半监督聚类 307</span><br><span class="line"></span><br><span class="line">13.7 阅读材料 311</span><br><span class="line"></span><br><span class="line">习题 313</span><br><span class="line"></span><br><span class="line">参考文献 314</span><br><span class="line"></span><br><span class="line">休息一会儿 317</span><br><span class="line"></span><br><span class="line">第14章 概率图模型 319</span><br><span class="line"></span><br><span class="line">14.1 隐马尔可夫模型 319</span><br><span class="line"></span><br><span class="line">14.2 马尔可夫随机场 322</span><br><span class="line"></span><br><span class="line">14.3 条件随机场 325</span><br><span class="line"></span><br><span class="line">14.4 学习与推断 328</span><br><span class="line"></span><br><span class="line">14.4.1 变量消去 328</span><br><span class="line"></span><br><span class="line">14.4.2 信念传播 330</span><br><span class="line"></span><br><span class="line">14.5 近似推断 331</span><br><span class="line"></span><br><span class="line">14.5.1 MCMC采样 331</span><br><span class="line"></span><br><span class="line">14.5.2 变分推断 334</span><br><span class="line"></span><br><span class="line">14.6 话题模型 337</span><br><span class="line"></span><br><span class="line">14.7 阅读材料 339</span><br><span class="line"></span><br><span class="line">习题 341</span><br><span class="line"></span><br><span class="line">参考文献 342</span><br><span class="line"></span><br><span class="line">休息一会儿 345</span><br><span class="line"></span><br><span class="line">第15章 规则学习 347</span><br><span class="line"></span><br><span class="line">15.1 基本概念 347</span><br><span class="line"></span><br><span class="line">15.2 序贯覆盖 349</span><br><span class="line"></span><br><span class="line">15.3 剪枝优化 352</span><br><span class="line"></span><br><span class="line">15.4 一阶规则学习 354</span><br><span class="line"></span><br><span class="line">15.5 归纳逻辑程序设计 357</span><br><span class="line"></span><br><span class="line">15.5.1 最小一般泛化 358</span><br><span class="line"></span><br><span class="line">15.5.2 逆归结 359</span><br><span class="line"></span><br><span class="line">15.6 阅读材料 363</span><br><span class="line"></span><br><span class="line">习题 365</span><br><span class="line"></span><br><span class="line">参考文献 366</span><br><span class="line"></span><br><span class="line">休息一会儿 369</span><br><span class="line"></span><br><span class="line">第16章 强化学习 371</span><br><span class="line"></span><br><span class="line">16.1 任务与奖赏 371</span><br><span class="line"></span><br><span class="line">16.2 $K$-摇臂赌博机 373</span><br><span class="line"></span><br><span class="line">16.2.1 探索与利用 373</span><br><span class="line"></span><br><span class="line">16.2.2 $\epsilon $-贪心 374</span><br><span class="line"></span><br><span class="line">16.2.3 Softmax 375</span><br><span class="line"></span><br><span class="line">16.3 有模型学习 377</span><br><span class="line"></span><br><span class="line">16.3.1 策略评估 377</span><br><span class="line"></span><br><span class="line">16.3.2 策略改进 379</span><br><span class="line"></span><br><span class="line">16.3.3 策略迭代与值迭代 381</span><br><span class="line"></span><br><span class="line">16.4 免模型学习 382</span><br><span class="line"></span><br><span class="line">16.4.1 蒙特卡罗强化学习 383</span><br><span class="line"></span><br><span class="line">16.4.2 时序差分学习 386</span><br><span class="line"></span><br><span class="line">16.5 值函数近似 388</span><br><span class="line"></span><br><span class="line">16.6 模仿学习 390</span><br><span class="line"></span><br><span class="line">16.6.1 直接模仿学习 391</span><br><span class="line"></span><br><span class="line">16.6.2 逆强化学习 391</span><br><span class="line"></span><br><span class="line">16.7 阅读材料 393</span><br><span class="line"></span><br><span class="line">习题 394</span><br><span class="line"></span><br><span class="line">参考文献 395</span><br><span class="line"></span><br><span class="line">休息一会儿 397</span><br><span class="line"></span><br><span class="line">附录 399</span><br><span class="line"></span><br><span class="line">A 矩阵 399</span><br><span class="line"></span><br><span class="line">B 优化 403</span><br><span class="line"></span><br><span class="line">C 概率分布 409</span><br><span class="line"></span><br><span class="line">后记 417</span><br><span class="line"></span><br><span class="line">索引 419</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这里为大家准备了几百本的互联网电子书，有需要的过来取吧。<a href="https://mp.weixin.qq.com/s/dFqVQ2qJxvQ0YrIlPISJuw">点击获取</a></p>
<p><em>本页书籍均来自网络，如有侵权，请联系我立即删除。我的邮箱：yaojianguolq@163.com</em></p>
]]></content>
      <categories>
        <category>资源分享</category>
      </categories>
  </entry>
</search>
